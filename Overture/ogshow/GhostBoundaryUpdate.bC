// ==========================================================================
// GhostBoundaryUpdate: update for parallel ghost points and periodic points
// ==========================================================================


#include "GhostBoundaryUpdate.h"
#include "ParallelUtility.h"
#include "display.h"


// =================================================================================================
/// \brief Constructor for GhostBoundaryUpdate: update for parallel ghost points and periodic points
// =================================================================================================
GhostBoundaryUpdate::GhostBoundaryUpdate()
{
  initializeClass("gbu");

  // dbase.put<int>("debug")=0;
  // dbase.put<aString>("debugFileName");
  // dbase.get<aString>("debugFileName")="tug"; 
  // dbase.put<int>("isInitialized")=0;
  // dbase.put<int>("isEmpty")=0;              // true if there are no points on this processor
  // dbase.put<bool>("copyOnProcessor")=true;  // if true do not send messages to the same processor

}

// =================================================================================================
/// \brief Constructor for GhostBoundaryUpdate: update for parallel ghost points and periodic points
//  \param debugFileName (input) : name for the debugFile(s)
// =================================================================================================
GhostBoundaryUpdate::GhostBoundaryUpdate( const aString & debugFileName )
{
  initializeClass(debugFileName);
}

// =================================================================================================
/// \brief Initialize the class (protected)
//  \param debugFileName (input) : name for the debugFile(s)
// =================================================================================================
void GhostBoundaryUpdate::initializeClass(const aString & debugFileName)
{
  dbase.put<int>("numberOfGridDimensions")=0;

  dbase.put<int>("debug")=0;
  dbase.put<aString>("debugFileName");
  dbase.get<aString>("debugFileName")=debugFileName;
  dbase.put<int>("isInitialized")=0;
  dbase.put<int>("isEmpty")=0;       // true if there are no points on this processor
  dbase.put<bool>("copyOnProcessor")=true;  // if true do not send messages to the same processor

}




// =================================================================================================
/// \brief Destructor for GhostBoundaryUpdate: update for parallel ghost points and periodic points
// =================================================================================================
GhostBoundaryUpdate::~GhostBoundaryUpdate()
{

  if( dbase.has_key("debugFile") )
  {
    FILE * debugFile=dbase.get<FILE*>("debugFile");
    if( debugFile!=NULL )
      fclose(debugFile);
  }
  
}

// =================================================================================================
/// \brief Set the debug flag for turning on debug output. Debug info is written to files,
///  one per processor
// =================================================================================================
int GhostBoundaryUpdate::setDebug( int debug )
{
  dbase.get<int>("debug")=debug;
}

// =====================================================================================================
/// \brief Set the debug file name 
// =====================================================================================================
int GhostBoundaryUpdate::setDebugFileName( const aString & fileName )
{
  aString & debugFileName = dbase.get<aString>("debugFileName");
  debugFileName = fileName;
  
  return 0;
}


// static int sent=0, received=0; 

// void
// displayPartiData(realArray & u, const aString & name)
// {
//   const int myid = Communication_Manager::My_Process_Number;
//   const int np=max(1,Communication_Manager::Number_Of_Processors);

//   DARRAY *uDArray = u.Array_Descriptor.Array_Domain.BlockPartiArrayDomain;
//   DECOMP *uDecomp = uDArray->decomp;

//   printf(" *************** %s: DARRAY uDArray->nDims=p=%i *******************\n"
//          "  nDims=%i  : number of array dimensions\n",(const char*)name,myid,uDArray->nDims);
  
//   int i;
//   for( int i=0; i<uDArray->nDims; i++ )
//   {
//     printf(" myid=%i: dim=%i: internal-ghost-cells=%i, total-size=%i, left,central,right-size=[%i,%i,%i] \n"
//            "                  global=[%i,%i] local-size=%i\n",myid,
//         i,uDArray->ghostCells[i],uDArray->dimVecG[i],
//            uDArray->dimVecL_L[i],uDArray->dimVecL[i],uDArray->dimVecL_R[i],
//            uDArray->g_index_low[i],uDArray->g_index_hi[i],uDArray->local_size[i]);
//   }

//   printf(" *************** u: DECOMP p=%i *******************\n"
//          "  nDims=%i, nProcs=%i, baseProc=%i \n",
//       myid,uDecomp->nDims,uDecomp->nProcs,uDecomp->baseProc);

//   for( int i=0; i<uDecomp->nDims; i++ )
//   {
//     printf(" myid=%i: dim=%i: dimVec=%i (size of decomposition) \n"
//            "                  dimProc=%i (number of processors allocated to this dimension) \n",
//         myid,i,uDecomp->dimVec[i],uDecomp->dimProc[i]);
//   }
// }



// ================================================================================================
// Macro: Set bounds for the receive boxes on a part of a face defined by [d0,dir]
// 
// /param d0 (input):   d0 = -1 : "left" side
//                      d0 =  0 : "center" 
//                      d0 = +1 : "right" side
// /param dir (input) : direction, 0,1,2,3
// /param bb(0:1,0:*) (input/output) : receive box
// /param centerBox0,leftMostBox0,rightMostBox0,isPeriodicBox0 (output) : indicate properies of this box
//        centerBox0    : true if this box is in the center, i.e. d0==0
//        leftMostBox0  : true if the box hits the far left of the global array  (where there are no parallel ghost)
//        rightMostBox0 : true if the box hits the far right of the global array (where there are no parallel ghost)
// 
// This macro uses:
//  ubb(side,axis) : bounds on local array data, no parallel ghost
//  ng(axis)       : number of parallel ghost points along this axis
//  isPeriodic(0:2), gid(0:1,0;2), dim(0:1,0;2) : for periodic boundaries
// 
// Notes:
//  (1) Each face on the local-array receives and sends parallel ghost data (except at the far left and right).
//  (2) The far-left and far-right send real-ghost data for periodic boundaries.
//  (3) For a given face we build a receive-box R and a send-box S as shown in the figure.
//  (4) If ghost points in box R on a face is received from processor pr then the adjacent
//      send-box S of interior points is sent to the same processor pr.
// 
//        +.. +------------------------+...+    +...+---+---------------------
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        :   |   |   local array  |   |   :    :   |   |   local array
//        :   |   |    processor   |   |   :    :   |   |     processor 
//        : R | S |      p0        | S | R :    : R | S |        p1 
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        +.. +------------------------+...+    +---+---------------------
//            |                        |        
//          ubb(0,dir)                ubb(1,dir)
// 
//             R = receive-box of ghost points
//             S = send box of interior points 

// ===================================================================================================
#beginMacro setReceiveBoxBounds(bb,d0,dir,centerBox0,leftMostBox0,rightMostBox0,isPeriodicBox0)

  // leftMostBox0  = true if we are on the far left of the array
  // rightMostBox0 = true if we are on the far right of the array
  bool centerBox0     = d0==0;
  bool leftMostBox0   = d0==-1 && ( ubb(0,dir) == u.getBase(dir) );
  bool rightMostBox0  = d0==1  && ( ubb(1,dir) == u.getBound(dir) );
  bool isPeriodicBox0 = false;

  if( d0==-1 )
  {
    // parallel ghost points on left 
    bb(0,dir)=ubb(0,dir)-ng(dir); bb(1,dir)=ubb(0,dir)-1;
  }
  else if( d0==0 )
  {
    // center section 
    bb(0,dir)=ubb(0,dir); bb(1,dir)=ubb(1,dir);
  }
  else 
  {
    // parallel ghost points on right 
    bb(0,dir)=ubb(1,dir)+1; bb(1,dir)=ubb(1,dir)+ng(dir);
  }
  if( leftMostBox0 || rightMostBox0 )
  {
    // No parallel ghost on far left or right 
    bb(0,dir)=0;  bb(1,dir)=-1;  // empty box
  }

  if( dir<numberOfDimensions && leftMostBox0 && isPeriodic(dir)  )
  {
    // receive periodic points on left (could be empty )
    bb(0,dir)=dim(0,dir);
    bb(1,dir)=gid(0,dir)-1;

    isPeriodicBox0=true; //  bb(1,dir)>= bb(0,dir);
  }
  if( dir<numberOfDimensions && rightMostBox0 && isPeriodic(dir) )
  {
    // receive periodic points on right
    bb(0,dir)=gid(1,dir);
    bb(1,dir)=dim(1,dir);
    if( bb(0,dir)>bb(1,dir) )
    {
      ::display(dim,"dim","%3i");
      ::display(gid,"gid","%3i");
      
      OV_ABORT("error bb(0,dir)>bb(1,dir) ")
    }
    
    isPeriodicBox0=true;
  }

  if( dir<numberOfDimensions && isPeriodic(dir) && d0==0 )
  {
    // --- middle of a periodic box ---
    // adjust box size to remove ghost

    //     |  |                           |  |
    //     +--+------------------------+--+--+
    //     |  |                           |  |
    //     +--+------------------------+--+--+
    //        |<--                  -->
    //
    if( ubb(0,dir) == u.getBase(dir) )
      bb(0,dir) = gid(0,dir);
    if( ubb(1,dir) == u.getBound(dir) )
      bb(1,dir) = gid(1,dir)-1;
  }

#endMacro
    
// ==========================================================================
// Macro: Build a "send-box" on a part of a face defined by [d0,dir]
//
// Notes:
//  (1) Each face on the local-array receives and sends parallel ghost data (except at the far left and right).
//  (2) The far-left and far-right send real-ghost data for periodic boundaries.
//  (3) For a given face we build a receive-box R and a send-box S as shown in the figure.
//  (4) If ghost points in box R on a face is received from processor pr then the adjacent
//      send-box S of interior points is sent to the same processor pr.
// 
//        +.. +------------------------+...+    +...+---+---------------------
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        :   |   |   local array  |   |   :    :   |   |   local array
//        :   |   |    processor   |   |   :    :   |   |     processor 
//        : R | S |      p0        | S | R :    : R | S |        p1 
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        :   |   |                |   |   :    :   |   |
//        +.. +------------------------+...+    +---+---------------------
//            |                        |        
//          ubb(0,dir)                ubb(1,dir)
// 
//             R = receive-box of ghost points
//             S = send box of interior points 
// ==========================================================================
#beginMacro setSendBoxBounds(bb,d0,dir,centerBox0,leftMostBox0,rightMostBox0,isPeriodicBox0)
  if( d0==-1 )
  {
    bb(0,dir)=ubb(0,dir); bb(1,dir)=ubb(0,dir)+ng(dir)-1;
  }
  else if( d0==0 )
  {
    bb(0,dir)=ubb(0,dir); bb(1,dir)=ubb(1,dir);
  }
  else 
  {
    bb(0,dir)=ubb(1,dir)-ng(dir)+1; bb(1,dir)=ubb(1,dir);
  }

  if( leftMostBox0 || rightMostBox0 )
  {
    bb(0,dir)=0;  bb(1,dir)=-1;  // empty box
  }

  if( dir<numberOfDimensions && leftMostBox0 && isPeriodic(dir) )
  {
    // send periodic points on left
    bb(0,dir)=gid(0,dir);
    bb(1,dir)=gid(0,dir) + ( dim(1,dir)-gid(1,dir) );
    isPeriodicBox0=true;
  }
  if( dir<numberOfDimensions && rightMostBox0 && isPeriodic(dir) )
  {
    // send periodic points on right (could be empty )
    bb(0,dir)=gid(1,dir)-1 - ( gid(0,dir)-dim(0,dir)-1 );
    bb(1,dir)=gid(1,dir)-1;

    isPeriodicBox0=true; // bb(1,dir)>= bb(0,dir);
  }

  if( dir<numberOfDimensions && isPeriodic(dir) && d0==0 )
  {
    // --- middle of a periodic box ---
    // adjust box size to remove ghost

    //     |  |                           |  |
    //     +--+------------------------+--+--+
    //     |  |                           |  |
    //     +--+------------------------+--+--+
    //        |<--                  -->
    //
    if( ubb(0,dir) == u.getBase(dir) )
      bb(0,dir) = gid(0,dir);
    if( ubb(1,dir) == u.getBound(dir) )
      bb(1,dir) = gid(1,dir)-1;
  }

#endMacro


// =========================================================================
// Macro: Create a tag to uniquely identify the Box
// Input: d0,d1,d2,d3 : each dn takes values -1,0,1 for left, center, right 
// Output : tag       
// ========================================================================
#beginMacro encodeTag( tag,d0,d1,d2,d3)
   tag = (d0+1)+3*( (d1+1)+ 3*( (d2+1) + 3*(d3+1) ) );
#endMacro             

// ========================================================================
// Macro: Decode the tag used to uniquely identify the Box
// Input : tag        
// Output: d0,d1,d2,d3
// =======================================================================
#beginMacro decodeTag( tag,d0,d1,d2,d3)
 {
   int mytag=tag;
   d0 = (mytag %3) -1;
   mytag /=3; 
   d1 = (mytag %3) -1;
   mytag /=3; 
   d2 = (mytag %3) -1;
   mytag /=3; 
   d3 = (mytag %3) -1;

   // check: 
   encodeTag( mytag,d0,d1,d2,d3);
   if( mytag != tag )
   {
     printF("ERROR: decoding tag failed! FIX ME\n");
     OV_ABORT("ERROR");
   }
   
 }
#endMacro             


// ================================================================================================
// Macro : Convert a source box tag (face ID) into the associated target box tag (face ID)
// ================================================================================================
#beginMacro convertTag(sourceTag,destTag)
{
  int d0,d1,d2,d3;
  decodeTag(sourceTag,d0,d1,d2,d3);
  // The sourced tag specifies the location [d0,d1,d2,d3] of the box in the source domain
  // The corresponding location in the target omain has negative values : [-d0,-d1,-d2,-d3]
  encodeTag(destTag,-d0,-d1,-d2,-d3);
}
#endMacro 


// =================================================================================================
/// \brief  Initialize communication schedules for parallel ghost updates
///
/// \param numberOfGridDimensions (input) : number of "grid" (distributed) dimensions. There can
///    also be "component" dimensions (assumed here to follow the grid dimensions)
// =================================================================================================
int GhostBoundaryUpdate::initialize( realArray & u, const int numberOfGridDimensions )
{
  IntegerArray isPeriodic(6);
  isPeriodic=0;
  IntegerArray & gid = Overture::nullIntArray();
  return initialize( u,numberOfGridDimensions,gid,gid,gid,isPeriodic );
  
}

// =================================================================================================
/// \brief  Initialize communication schedules for parallel ghost updates and periodic updates (possibly on a face only)
/// \param mg (input) : provides information for periodic updates
/// \param fside,faxis : if set, only update values on this face (fside,faxis)
// =================================================================================================
int GhostBoundaryUpdate::initialize( realMappedGridFunction & u, int fside, int faxis )
{
  MappedGrid & mg = *u.getMappedGrid();
  return initialize( u, mg.numberOfDimensions(), mg.gridIndexRange(),mg.dimension(),mg.indexRange(),mg.isPeriodic(),fside,faxis );
}



// =================================================================================================
/// \brief  MAIN initialization routine for computing communication schedules
/// \param isPeriodic
///
/// \notes This routine computes the set of index boxes that define what data needs to be transferred
///  between processors to update parallel ghost points. Periodic ghjost points can also optionally
///  be updated.
// =================================================================================================
int GhostBoundaryUpdate::
initialize( realArray & u,
            const int numberOfGridDimensions,
            const IntegerArray & gid, const IntegerArray & dim,
            const IntegerArray & indexRange, const IntegerArray & isPeriodic,
            int fside /* = -1 */ , int faxis /* = -1 */ )
{

  const int myid = max(0,Communication_Manager::My_Process_Number);
  const int np=max(1,Communication_Manager::Number_Of_Processors);

  int & isInitialized = dbase.get<int>("isInitialized");
  if( isInitialized )
  {
    printF("GhostBoundaryUpdate::initialize: ERROR: initialize has already been called! \n"
           "  Currently this routine cannot be called again -- fix me Bill!\n");
    OV_ABORT("ERROR");
  }
  isInitialized=1;

  const bool & copyOnProcessor = dbase.get<bool>("copyOnProcessor");  // if true do not send messages to the same processor
  
  const int & debug = dbase.get<int>("debug");
  const aString & debugFileName = dbase.get<aString>("debugFileName");
 
  if( debug & 1 )
    printF("----- GhostBoundaryUpdate:: initialize ----\n");

  // int fside=-1, faxis=-1;  // if valid, update ghost and periodic on this face only 

  if( !dbase.has_key("debugFile") )
  {
    dbase.put<FILE*>("debugFile")=NULL;

    FILE *& debugFile=dbase.get<FILE*>("debugFile");
    if( debug !=0 && debugFile==NULL )
    {
      
      char fileName[40];
      sprintf(fileName,"%s%i.debug",(const char*)debugFileName,myid);
      debugFile= fopen(fileName,"w");
    }
  }
  FILE *debugFile=dbase.get<FILE*>("debugFile");

  if( debug !=0 )
  {
    fprintf(debugFile,"++++ GhostBoundaryUpdate::initialize updateGhostAndPeriodic np=%d, myid=%i copyOnProcessor=%d"
            " numberOfGridDimensions=%d +++++\n",
            np,myid,(int)copyOnProcessor,numberOfGridDimensions);

    // fprintf(debugFile,"++++ updateGhostAndPeriodic np=%d, myid=%i numberOfDimensions=%d, numGhost=[%d,%d] "
    //      "numParallelGhost=%d ndp=%d +++++\n",
    //      np,myid,numberOfDimensions,numGhostLeft,numGhostRight,numParallelGhost,ndp);


    fprintf(debugFile,"++++ isPeriodic=[%d,%d,%d] [fside,faxis]=[%d,%d] \n",
            isPeriodic(0),isPeriodic(1),isPeriodic(2),fside,faxis);
    fflush(debugFile);
  }


  OV_GET_SERIAL_ARRAY(real,u,uLocal);


  // const intSerialArray & uProcessorSet = u.getPartition().getProcessorSet();

  // if( false )
  // {
  //   ::display(uProcessorSet,"uProcessorSet");
  //   displayPartiData(u,"u");
  // }

  if( debug & 1 )
  {
    if( debugFileName == "tug" )
    {
      ::display(uLocal,"GBU:init: uLocal (before)",debugFile,"%4.0f ");
      ::display(u,"GBU:init: u (before)","%4.0f ");
    }
    else
    {
      ::display(uLocal,"GBU:init: uLocal (before)",debugFile,"%5.2f ");
      ::display(u,"GBU:init: u (before)","%5.2f ");
    }
  }
  
  IndexBox uBox;
  CopyArray::getLocalArrayBox( myid, u, uBox );

  if( debug & 1 )
  {
    fprintf(debugFile," myid=%i uLocal bounds=[%2i,%2i][%2i,%2i][%2i,%2i][%2i,%2i] (no parallel ghost)\n",
            myid,
            uBox.base(0),uBox.bound(0),
            uBox.base(1),uBox.bound(1),
            uBox.base(2),uBox.bound(2),
            uBox.base(3),uBox.bound(3));
  }
  
  IndexBox uBoxGhost;
  CopyArray::getLocalArrayBoxWithGhost( myid, u, uBoxGhost );

  if( debug & 1 )
  {
    fprintf(debugFile," myid=%i uLocal bounds=[%2i,%2i][%2i,%2i][%2i,%2i][%2i,%2i] (with parallel ghost)\n",
            myid,
            uBoxGhost.base(0),uBoxGhost.bound(0),
            uBoxGhost.base(1),uBoxGhost.bound(1),
            uBoxGhost.base(2),uBoxGhost.bound(2),
            uBoxGhost.base(3),uBoxGhost.bound(3));
  }
  
  int & isEmpty = dbase.get<int>("isEmpty");       // true if there are no points on this processor
  if( uBox.isEmpty() )
  {
    //  there are no points on this processor
    isEmpty=1;
    if( debug )
    {
      fprintf(debugFile,"\n >>>>> There are no points on this processor.\n\n");
    }
    
    return 0;
  }
  

  int index[4]={0,0,0,0};

  // --- Make a list of boxes to receive and send ----

  const int maxDim=MAX_DISTRIBUTED_DIMENSIONS;
  assert( maxDim==4 );
  
  // Bounding box for uLocal:
  int pubb[2*MAX_ARRAY_DIMENSION];
  #define ubb(side,axis) pubb[(side)+2*(axis)]
  for( int i=0; i<2*MAX_ARRAY_DIMENSION; i++ )
    pubb[i]=0;
  
  // num parallel ghost 
  int png[MAX_ARRAY_DIMENSION];
  #define ng(dir) png[dir]   
  for( int i=0; i<MAX_ARRAY_DIMENSION; i++ )
    ng(i)=0;

  // ------ Assign ubb(0:1,0:*) -- bounding box array for uLocal (no parallel ghost)
  //        ng(axis) = num parallel ghost 
  
  int numDim = u.numberOfDimensions();          // total number of array dimensions
  int numberOfDimensions= numberOfGridDimensions;  // number of distributed dimensions (excludes components)
  dbase.get<int>("numberOfGridDimensions")=numberOfGridDimensions;  // save 

  assert(  numberOfDimensions<=numDim );
  numDim=numberOfDimensions;              // exclude "components" when making boxes


  for( int dir=0; dir<numDim; dir++ )
  {
    ubb(0,dir) = uBox.base(dir);
    ubb(1,dir) = uBox.bound(dir);
    ng(dir) = u.getGhostBoundaryWidth(dir);

    if( dir==faxis && fside>=0 )
    {
      // --- restrict the bounding box to live on the face ---
      isPeriodic(faxis)=0;  // turn off periodicity along this axis 
      ng(faxis)=0;          // turn off parallel ghost along this axis 
      ubb(0,dir) = max(ubb(0,dir),gid(fside,faxis));
      ubb(1,dir) = min(ubb(1,dir),gid(fside,faxis));
    
    }
    
  }
  // -- Check that there are enough interior points to fill periodic ghost ---
  //  This check is needed beacuse of the way we fill in periodic ghost points using one pass.
  for( int dir=0; dir<numberOfGridDimensions; dir++ )
  {
    if( isPeriodic(dir) )
    {
      int numPoints        = gid(1,dir)-gid(0,dir);  // number of available points for periodic update 
      int numPeriodicGhost = dim(1,dir)-gid(1,dir)+1;      // number of periodic points on "right" side
      if(  numPeriodicGhost > numPoints )
      {
        printF("GhostBoundaryUpdate::initialize: ERROR: There are not enough interior points to fill periodic images.\n"
               "   dir=%d, numPeriodicGhost=%d > numPoints=%d\n",dir,numPeriodicGhost,numPoints);
        ::display(dim,"dimension");
        ::display(gid,"gridIndexRange");
        printF(" Increase the number of points in direction dir=%, or decrease the number of true ghost points\n",dir);
        OV_ABORT("ERROR");
      }
    }
  }
  

  if( debug & 2  )
  {
    fprintf(debugFile," ubb=[%i,%i][%i,%i][%i,%i][%i,%i] u=[%i,%i][%i,%i][%i,%i][%i,%i]\n",
            ubb(0,0),ubb(1,0),ubb(0,1),ubb(1,1),ubb(0,2),ubb(1,2),ubb(0,3),ubb(1,3),
            u.getBase(0),u.getBound(0),u.getBase(1),u.getBound(1),u.getBase(2),u.getBound(2),u.getBase(3),u.getBound(3));
  }
  
  // Receive bounding box 
  int pbbr[2*MAX_ARRAY_DIMENSION];
  #define bbr(side,axis) pbbr[(side)+2*(axis)]
  for( int i=0; i<2*MAX_ARRAY_DIMENSION; i++ )
    pbbr[i]=0;

  // Send bounding box 
  int pbbs[2*MAX_ARRAY_DIMENSION];
  #define bbs(side,axis) pbbs[(side)+2*(axis)]
  for( int i=0; i<2*MAX_ARRAY_DIMENSION; i++ )
    pbbs[i]=0;

  // Make a list of boxes for data we should send and receive
  if( !dbase.has_key("sendBoxes") )
  {
    dbase.put<ListOfIndexBox>("sendBoxes");       // for remote sends
    dbase.put<ListOfIndexBox>("receiveBoxes");    // for remote receives
    dbase.put<std::map<int,int> >("receiveMap");

    dbase.put<ListOfIndexBox>("copySendBoxes");     // on processor "sends" 
    dbase.put<ListOfIndexBox>("copyReceiveBoxes");  // on processor "receives"
    dbase.put<std::map<int,int> >("copyReceiveMap");

  }
  
  ListOfIndexBox & sendBoxes    = dbase.get<ListOfIndexBox>("sendBoxes");
  ListOfIndexBox & receiveBoxes = dbase.get<ListOfIndexBox>("receiveBoxes");

  ListOfIndexBox & copySendBoxes    = dbase.get<ListOfIndexBox>("copySendBoxes");
  ListOfIndexBox & copyReceiveBoxes = dbase.get<ListOfIndexBox>("copyReceiveBoxes");

  // receiveMap[tag] = m <-> IndexBox : receiveBoxes[m]
  // std::map<int,int> receiveMap;
  std::map<int,int> & receiveMap     = dbase.get<std::map<int,int> >("receiveMap");
  std::map<int,int> & copyReceiveMap = dbase.get<std::map<int,int> >("copyReceiveMap");

  // isGhostn = 1 if there are parallel ghost in direction n
  const int isGhost0 = ng(0)==0 && isPeriodic(0)==0 ? 0 : 1;
  const int isGhost1 = ng(1)==0 && isPeriodic(1)==0 ? 0 : 1;
  const int isGhost2 = ng(2)==0 && isPeriodic(2)==0 ? 0 : 1;
  const int isGhost3 = ng(3)==0                     ? 0 : 1;

  for( int d3=-isGhost3; d3<=isGhost3; d3++ )  // loop -1:1, or 0:0 if no parallel ghost 
  {
    int dir=3;
    setReceiveBoxBounds(bbr,d3,dir,centerBox3,leftMostBox3,rightMostBox3,isPeriodicBox3);
    setSendBoxBounds(bbs,d3,dir,centerBox3,leftMostBox3,rightMostBox3,isPeriodicBox3);

    for( int d2=-isGhost2; d2<=isGhost2; d2++ )  // loop -1:1, or 0:0 if no parallel ghost 
    {
      int dir=2;
      setReceiveBoxBounds(bbr,d2,dir,centerBox2,leftMostBox2,rightMostBox2,isPeriodicBox2);
      setSendBoxBounds(bbs,d2,dir,centerBox2,leftMostBox2,rightMostBox2,isPeriodicBox2);

      for( int d1=-isGhost1; d1<=isGhost1; d1++ )   // loop -1:1, or 0:0 if no parallel ghost 
      {
        int dir=1;
        setReceiveBoxBounds(bbr,d1,dir,centerBox1,leftMostBox1,rightMostBox1,isPeriodicBox1);
        setSendBoxBounds(bbs,d1,dir,centerBox1,leftMostBox1,rightMostBox1,isPeriodicBox1);
    
        for( int d0=-isGhost0; d0<=isGhost0; d0++ )  // loop -1:1, or 0:0 if no parallel ghost 
        {
          int dir=0;
          setReceiveBoxBounds(bbr,d0,dir,centerBox0,leftMostBox0,rightMostBox0,isPeriodicBox0);
          setSendBoxBounds(bbs,d0,dir,centerBox0,leftMostBox0,rightMostBox0,isPeriodicBox0);

          bool centerBox     = centerBox0     && centerBox1     && centerBox2;
          bool leftMostBox   = leftMostBox0   || leftMostBox1   || leftMostBox2;
          bool rightMostBox  = rightMostBox0  || rightMostBox1  || rightMostBox2;
          bool isPeriodicBox = isPeriodicBox0 || isPeriodicBox1 ||  isPeriodicBox2;
          // fprintf(debugFile,"d0=%d d1=%d leftMostBox0=%i rightMostBox0=%i\n",d0,d1,leftMostBox0,rightMostBox0);
          
          if( debug & 2 )
          {
            IndexBox rBox(bbr(0,0),bbr(1,0), bbr(0,1),bbr(1,1), bbr(0,2),bbr(1,2), bbr(0,3),bbr(1,3) );
            fprintf(debugFile,"d0=%2d d1=%2d rBox=[%d,%d][%d,%d][%d,%d][%d,%d], isPeriodicBox=%d isEmpty=%d\n",
                    d0,d1, bbr(0,0),bbr(1,0),bbr(0,1),bbr(1,1),bbr(0,2),bbr(1,2),bbr(0,3),bbr(1,3),(int)isPeriodicBox,
                    (int)rBox.isEmpty());
            IndexBox sBox(bbs(0,0),bbs(1,0), bbs(0,1),bbs(1,1), bbs(0,2),bbs(1,2), bbs(0,3),bbs(1,3) );
            fprintf(debugFile,"d0=%2d d1=%2d sBox=[%d,%d][%d,%d][%d,%d][%d,%d], isPeriodicBox=%d isEmpty=%d\n",
                    d0,d1,bbs(0,0),bbs(1,0),bbs(0,1),bbs(1,1),bbs(0,2),bbs(1,2),bbs(0,3),bbs(1,3),(int)isPeriodicBox,
                    (int)sBox.isEmpty());

          }

          bool boxIsOnProcessor=false;
          if( ( !centerBox && !leftMostBox && !rightMostBox) || isPeriodicBox )
          {
            // Create a receive box
            IndexBox rBox(bbr(0,0),bbr(1,0), bbr(0,1),bbr(1,1), bbr(0,2),bbr(1,2), bbr(0,3),bbr(1,3) );
            
            if( !rBox.isEmpty() )
            {
              if( debug & 2 )
                fprintf(debugFile,"    Add receive box=[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i], isPeriodicBox=%d\n",
                        bbr(0,0),bbr(1,0),bbr(0,1),bbr(1,1),bbr(0,2),bbr(1,2),bbr(0,3),bbr(1,3),(int)isPeriodicBox);

              // Find which processor holds the data we need to receive: 
              for( int axis=0; axis<4; axis++ )
              {
                // choose a point near the middle of the box: 
                index[axis]=(bbr(0,axis)+bbr(1,axis))/2;  

                // Adjust point for periodic grids 
                if( isPeriodicBox && axis<numberOfDimensions && isPeriodic(axis) )
                {
                  if( (axis==0 && leftMostBox0) || (axis==1 && leftMostBox1) || (axis==2 && leftMostBox2) )
                    index[axis] += gid(1,axis) - gid(0,axis);  // periodic image
                  else if( (axis==0 && rightMostBox0) || (axis==1 && rightMostBox1) || (axis==2 && rightMostBox2) )
                    index[axis] -= gid(1,axis) - gid(0,axis);  // periodic image
                }
                
              }  // 
              #ifdef USE_PPP
                rBox.processor= u.Array_Descriptor.findProcNum( index );  // processor for this point 
              #else
                rBox.processor=0;
              #endif 
              int tag;
              encodeTag( tag,d0,d1,d2,d3);
              rBox.tag=tag;

              if( rBox.processor != myid || !copyOnProcessor )
              {
                receiveMap[tag]= receiveBoxes.size();
                receiveBoxes.push_back(rBox);        // remote send
              }
              else
              {
                boxIsOnProcessor=true;
                copyReceiveMap[tag]= copyReceiveBoxes.size();
                copyReceiveBoxes.push_back(rBox);      // on processor 
              }
              
            }
            
            // Create a send box
            IndexBox sBox(bbs(0,0),bbs(1,0), bbs(0,1),bbs(1,1), bbs(0,2),bbs(1,2), bbs(0,3),bbs(1,3) );

            // -- check if the all the periodic images are on the source processor ---
            if( !uBox.contains(sBox) )
            {
              // We need to split the boxes and get data from the next processor.
              // As a work-around one could call the update function twice since the
              // parallel ghost will be filled in during the first call.
              printf("GhostBoundaryUpdate::initialize: ERROR!\n");
              printf("The local data box is too small for a periodic update.\n"
                     "There are likely too few points on this processor.\n");
              printf("FIX ME BILL !\n");
              OV_ABORT("ERROR");
            }
            

            if( !sBox.isEmpty() )
            {
              if( debug & 2 )
                fprintf(debugFile,"    Add    send box=[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i], isPeriodicBox=%d\n",
                        bbs(0,0),bbs(1,0),bbs(0,1),bbs(1,1),bbs(0,2),bbs(1,2),bbs(0,3),bbs(1,3),(int)isPeriodicBox);


              // for( int axis=0; axis<4; axis++ ){ index[axis]=bbs(0,axis); }  // 
              // sBox.processor= u.Array_Descriptor.findProcNum( index );  // processor for this point 

              // we send data to the same proc that we receive the ghost point from: 
              sBox.processor= rBox.processor; 

              int tag;
              encodeTag( tag,d0,d1,d2,d3);
              sBox.tag=tag;

              if( sBox.processor != myid || !copyOnProcessor)
                sendBoxes.push_back(sBox);         // remote receive
              else
              {
                assert( boxIsOnProcessor );         // receive box must also be on processor 
                copySendBoxes.push_back(sBox);      // on processor  
              }
              
            }
            
          }

        } // end for d0
      } // end for d1
    } // end for d2 
  } // end for d3
   


  if( debug!=0 )
  {
    // ----------- Debug output of send/receive boxes -------
    
    ListOfIndexBox::iterator iter; 
    int ireceive=0;
    for(iter = receiveBoxes.begin(); iter!=receiveBoxes.end(); iter++ )
    {
      IndexBox & box = *iter;
      int sourceTag = box.tag, destTag;
      convertTag(sourceTag,destTag);
      
      fprintf(debugFile,
              ">>> receive box %2i =[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i], [rTag=%d, map=%d] from processor p=%i sTag=%d\n",
              ireceive,
              box.base(0),box.bound(0),
              box.base(1),box.bound(1),
              box.base(2),box.bound(2),
              box.base(3),box.bound(3),
              box.tag, receiveMap.at(box.tag),box.processor,destTag );
      ireceive++;
      
    }

    // ListOfIndexBox::iterator iter; 
    int isend=0;
    for(iter = sendBoxes.begin(); iter!=sendBoxes.end(); iter++ )
    {
      IndexBox & box = *iter;

      int sourceTag = box.tag, destTag;
      convertTag(sourceTag,destTag);

      fprintf(debugFile,
              ">>>    send box %2i =[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i] sTag=%d, to processor p=%i for rTag=%d\n",
              isend,
              box.base(0),box.bound(0),
              box.base(1),box.bound(1),
              box.base(2),box.bound(2),
              box.base(3),box.bound(3),
              box.tag,box.processor,destTag);
      isend++;
    }
      
    ireceive=0;
    for(iter = copyReceiveBoxes.begin(); iter!=copyReceiveBoxes.end(); iter++ )
    {
      IndexBox & box = *iter;
      int sourceTag = box.tag, destTag;
      convertTag(sourceTag,destTag);
      
      fprintf(debugFile,
              ">>> receive box %2i =[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i], [rTag=%d, map=%d] from processor p=%i sTag=%d"
                  " [ON PROCESSOR]\n",
              ireceive,
              box.base(0),box.bound(0),
              box.base(1),box.bound(1),
              box.base(2),box.bound(2),
              box.base(3),box.bound(3),
              box.tag, copyReceiveMap.at(box.tag),box.processor,destTag );
      ireceive++;
      
    }

    // ListOfIndexBox::iterator iter; 
    isend=0;
    for(iter = copySendBoxes.begin(); iter!=copySendBoxes.end(); iter++ )
    {
      IndexBox & box = *iter;

      int sourceTag = box.tag, destTag;
      convertTag(sourceTag,destTag);

      fprintf(debugFile,
              ">>>    send box %2i =[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i] sTag=%d, to processor p=%i for rTag=%d"
              " [ON PROCESSOR]\n",
              isend,
              box.base(0),box.bound(0),
              box.base(1),box.bound(1),
              box.base(2),box.bound(2),
              box.base(3),box.bound(3),
              box.tag,box.processor,destTag);
      isend++;
    }
    fprintf(debugFile,"\n =============== END INITIALIZE ======\n");
    fflush(debugFile);
  }
  
  return 0;
  
} // end initialize

// =================================================================================================
/// \brief Update parallel ghost and optionally periodic ghost 
// =================================================================================================
#ifdef USE_PPP
int GhostBoundaryUpdate::
updateGhostBoundaries( realArray & u, const Range & C /* = nullRange */ )
{
  OV_GET_SERIAL_ARRAY(real,u,uLocal);
  return updateGhostBoundaries( uLocal,C );
  
}
#endif

#define FOR_BOX(i0,i1,i2,i3,box)\
      const int i0b=box.bound(0),i1b=box.bound(1),i2b=box.bound(2),i3b=box.bound(3);\
      for( int i3=box.base(3); i3<=i3b; i3++ )\
      for( int i2=box.base(2); i2<=i2b; i2++ )\
      for( int i1=box.base(1); i1<=i1b; i1++ )\
      for( int i0=box.base(0); i0<=i0b; i0++ )


#define FOR_BOX_IJ(i0,i1,i2,i3,ibox,j0,j1,j2,j3,jbox)\
      const int i0b=ibox.bound(0),i1b=ibox.bound(1),i2b=ibox.bound(2),i3b=ibox.bound(3);\
      const int j0b=jbox.bound(0),j1b=jbox.bound(1),j2b=jbox.bound(2),j3b=jbox.bound(3);\
      for( int i3=ibox.base(3),j3=jbox.base(3); i3<=i3b; i3+=1, j3+=1 )\
      for( int i2=ibox.base(2),j2=jbox.base(2); i2<=i2b; i2+=1, j2+=1 )\
      for( int i1=ibox.base(1),j1=jbox.base(1); i1<=i1b; i1+=1, j1+=1 )\
      for( int i0=ibox.base(0),j0=jbox.base(0); i0<=i0b; i0+=1, j0+=1 )


// =================================================================================================
/// \brief Update parallel ghost and optionally periodic ghost. This version assigns values in 
///   a uLocal array that may be different from the local array of u. 
// =================================================================================================
int GhostBoundaryUpdate::
updateGhostBoundaries( RealArray & uLocal, const Range & Components /* = nullRange */ )
{
  const int & debug = dbase.get<int>("debug");
  const aString & debugFileName = dbase.get<aString>("debugFileName");
  FILE *debugFile=dbase.get<FILE*>("debugFile");

  const int & isEmpty = dbase.get<int>("isEmpty");       // true if there are no points on this processor

  if( !isEmpty )
  {
    // there are some points on this processor

    const int myid = max(0,Communication_Manager::My_Process_Number);
    const int np=max(1,Communication_Manager::Number_Of_Processors);


    const int & isInitialized = dbase.get<int>("isInitialized");
    if( !isInitialized )
    {
      printF("GhostBoundaryUpdate::updateGhostBoundaries:ERROR: You should call initialize before "
             "calling updateGhostBoundaries!\n");
      OV_ABORT("ERROR");
    }

    if( debug & 1 )
      printF("----- START updateGhostBoundaries ----\n");

    const int & numberOfGridDimensions = dbase.get<int>("numberOfGridDimensions");
    // Finish me for components
    const int component=numberOfGridDimensions;
    // By default choose all components if "Components" is not given
    const Range C = Components==nullRange ? uLocal.dimension(component) : Components;
    const int numberOfComponents = C.getLength();
    // printF("UGB: component=%d C=[%d,%d] Components=[%d,%d]\n",component,C.getBase(),C.getBound(),
    //        Components.getBase(),Components.getBound());
    if( debug & 2 )
    {
      fprintf(debugFile,"UGB: component=%d C=[%d,%d] Components=[%d,%d]\n",component,C.getBase(),C.getBound(),
              Components.getBase(),Components.getBound());
    }
    

    ListOfIndexBox & sendBoxes    = dbase.get<ListOfIndexBox>("sendBoxes");
    ListOfIndexBox & receiveBoxes = dbase.get<ListOfIndexBox>("receiveBoxes");

    // receiveMap[tag] = m <-> IndexBox : receiveBoxes[m]
    std::map<int,int> & receiveMap = dbase.get<std::map<int,int> >("receiveMap");

    #ifdef USE_PPP
    // ============================== START OF MPI VERSION ====================================================


    // ************** MPI calls *****************

    if( debugFile!=NULL ) fflush(debugFile);

    const int numReceive=receiveBoxes.size();
    real **rBuff=NULL;   // buffers for receiving data
    MPI_Request *receiveRequest=NULL;
    MPI_Status *receiveStatus=NULL;
    int *receiveBoxIndex = new int [np];  // maps processor number to index in receiveBoxes
    for( int p=0; p<np; p++ ) receiveBoxIndex[p]=-1;

    if( debug & 2 )
      fprintf(debugFile,"+++ Number of boxes to receive: numReceive=%d\n",numReceive);
    

    if( numReceive>0 )
    {
      // post receives first

      receiveRequest= new MPI_Request[numReceive]; // remember to delete these
      receiveStatus= new MPI_Status[numReceive]; 

      rBuff = new real* [numReceive];
      // int sendingProc = new int [numReceive];
    
      for(int m=0; m<numReceive; m++ )
      {
        IndexBox & pReceiveBox = receiveBoxes[m];
        pReceiveBox.setBaseBound( component,C.getBase(),C.getBound());  // set component range 

        // sendingProc[m]=pReceiveBox.processor;  // this processor will be sending the data
        int bufSize=pReceiveBox.size();
        rBuff[m]= new real [bufSize];
      
        assert( pReceiveBox.processor>=0 && pReceiveBox.processor<np );
      
        receiveBoxIndex[pReceiveBox.processor]=m;  // maps processor number to index in receiveBoxes
        if( debug!=0 )
        {
          fprintf(debugFile,">>> myid=%i: post a receive for buffer of size %5i from p=%i (m=%i,numReceive=%i) \n",
                  myid,bufSize,pReceiveBox.processor,m,numReceive);
        }

        // --- Convert the tag associated with the receive box to the expected tag from the sender ---


        
        int tag = pReceiveBox.tag, rtag;  
        convertTag(tag,rtag);

        // int d0,d1,d2,d3;
        // decodeTag(tag,d0,d1,d2,d3);
        // if( debug & 2 ) 
        //   fprintf(debugFile,"Decode tag=%d : [d0,d1,d2,d3]=[%2i,%2i,%2i,%2i]\n",tag,d0,d1,d2,d3);
        // // The received tag specifies the location [d0,d1,d2,d3] of the box in the sender's domain
        // // The corresponding location in my domain has negative values : [-d0,-d1,-d2,-d3]
        // encodeTag(rtag,-d0,-d1,-d2,-d3);
        if( debug  & 2 ) 
          fprintf(debugFile,"Encode tag=%d --> rtag=%d \n",tag,rtag);

        // int MPI_Irecv(void *buf, int count, MPI_Datatype datatype, int source,
        //               int tag, MPI_Comm comm, MPI_Request *request)
        // MPI_Irecv(rBuff[m],bufSize,MPI_Real,pReceiveBox.processor,MPI_ANY_TAG,MPI_COMM_WORLD,&receiveRequest[m] );
        MPI_Irecv(rBuff[m],bufSize,MPI_Real,pReceiveBox.processor,rtag,MPI_COMM_WORLD,&receiveRequest[m] );
      
      }
    }
  
    // Now send the data
    const int numSend=sendBoxes.size();
    MPI_Request *sendRequest=NULL;
    real **sBuff=NULL;
    if( numSend>0 )
    {
      // send data

      sendRequest= new MPI_Request[numSend]; // remember to delete these
      sBuff = new real* [numSend];
    
      for(int m=0; m<numSend; m++ )
      {
        IndexBox & pSendBox = sendBoxes[m]; 
        pSendBox.setBaseBound( component,C.getBase(),C.getBound() );  // set component range 

        int bufSize=pSendBox.size();
        sBuff[m]= new real [bufSize];
//       for( int i=0; i<bufSize; i++ )
//       {
//      sBuff[m][i]=i;
//       }

        real *buff=sBuff[m];
        int i=0;
        FOR_BOX(i0,i1,i2,i3,pSendBox)
        {
          buff[i]=uLocal(i0,i1,i2,i3);  
          i++;
        }


        if( debug!=0 )
        {
          fprintf(debugFile,"<<< myid=%i: send buffer of size %5i (tag=%d) to p=%i\n",
                  myid,bufSize,pSendBox.tag,pSendBox.processor);

          fprintf(debugFile,
                  "pSendBox=[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i]\n",
                  pSendBox.base(0),pSendBox.bound(0),
                  pSendBox.base(1),pSendBox.bound(1),
                  pSendBox.base(2),pSendBox.bound(2),
                  pSendBox.base(3),pSendBox.bound(3));

          fprintf(debugFile,">>> myid=%i: SEND data: (component=%d)\n",myid,component);
          for( int j=0; j<bufSize; j++ ) fprintf(debugFile,"%5.2f ",buff[j]);
          fprintf(debugFile,"\n");
          
        }
      
        // int MPI_Isend(const void *buf, int count, MPI_Datatype datatype, int dest, int tag,
        //               MPI_Comm comm, MPI_Request * request)
        // MPI_Isend(sBuff[m],bufSize,MPI_Real,pSendBox.processor,bufSize,MPI_COMM_WORLD,&sendRequest[m] );
        MPI_Isend(sBuff[m],bufSize,MPI_Real,pSendBox.processor,pSendBox.tag,MPI_COMM_WORLD,&sendRequest[m] );
      }
    }

    if( debug )  fflush(debugFile);

    // ------ Now perform on processor copies while we wait for receives ---

    ListOfIndexBox & copySendBoxes    = dbase.get<ListOfIndexBox>("copySendBoxes");
    if( copySendBoxes.size()>0 )
    {
      ListOfIndexBox & copyReceiveBoxes  = dbase.get<ListOfIndexBox>("copyReceiveBoxes");
      std::map<int,int> & copyReceiveMap = dbase.get<std::map<int,int> >("copyReceiveMap");

      assert( copySendBoxes.size() == copyReceiveBoxes.size() );
      for( int m=0; m<copySendBoxes.size(); m++ )
      {
        IndexBox & sourceBox = copySendBoxes[m];
        sourceBox.setBaseBound( component,C.getBase(),C.getBound() );  // set component range 

        int stag=sourceBox.tag, rtag;  
        convertTag(stag,rtag);
        int myBox = copyReceiveMap.at(rtag);  // copyReceiveBoxes[myBox] corresponds to copySendBox[m]

        if( debug & 2 )
        {
          fprintf(debugFile,"copyOnProc: sourceBox.tag=%d --> rtag=%d: m=%d (source) ->  myBox=%d (target)\n",stag,rtag,m,myBox);
          fprintf(debugFile,
                  "copyOnProc:  sourceBox =[%3i,%3i][%3i,%3i][%3i,%3i][%3i,%3i]\n",
                  sourceBox.base(0),sourceBox.bound(0),
                  sourceBox.base(1),sourceBox.bound(1),
                  sourceBox.base(2),sourceBox.bound(2),
                  sourceBox.base(3),sourceBox.bound(3));
        }

        assert( myBox>=0 && myBox<copyReceiveBoxes.size() );
        IndexBox & targetBox = copyReceiveBoxes[myBox];
        targetBox.setBaseBound( component,C.getBase(),C.getBound() );  // set component range 

        assert( sourceBox.size()==targetBox.size() );
        
        FOR_BOX_IJ(i0,i1,i2,i3,sourceBox, j0,j1,j2,j3,targetBox )
        {
          uLocal(j0,j1,j2,j3) = uLocal(i0,i1,i2,i3);
        }

      }
    }
    

    if( numReceive>0 )
    {
      MPI_Waitall( numReceive, receiveRequest, receiveStatus );  // wait to receive all messages
  
      for(int m=0; m<numReceive; m++  )
      {
        // int bufSize=receiveStatus[m].MPI_TAG;
        int tag =receiveStatus[m].MPI_TAG;

        int p = receiveStatus[m].MPI_SOURCE;
        assert( p>=0 && p<np );
      
        if( receiveStatus[m].MPI_ERROR !=0  ) 
        {
          if( debug )
          {
            fprintf(debugFile," Receive: m=%d, receiveStatus[m].MPI_ERROR=%d\n",m,(int)receiveStatus[m].MPI_ERROR);
            fflush(debugFile);
          }
        }

        int rtag;  
        convertTag(tag,rtag);

        // int d0,d1,d2,d3;
        // decodeTag(tag,d0,d1,d2,d3);
        // if( debug & 2 ) 
        //   fprintf(debugFile,"Decode tag=%d : [d0,d1,d2,d3]=[%2i,%2i,%2i,%2i]\n",tag,d0,d1,d2,d3);
        // // The received tag specifies the location [d0,d1,d2,d3] of the box in the sender's domain
        // // The corresponding location in my domain has negative values : [-d0,-d1,-d2,-d3]
        // int rtag;
        // encodeTag(rtag,-d0,-d1,-d2,-d3);

        // int mybox = receiveMap[rtag];  // which receiveBox 
        int mybox = receiveMap.at(rtag);  // which receiveBox   (this version throws an exeception if rtag is not there)
        if( debug & 2  ) 
          fprintf(debugFile,"Encode tag=%d -> rtag=%d -> box number %d (from receiveMap[rtag]) \n",tag,rtag,mybox);

        if( debug & 2 )
        {
          IndexBox & rBox = receiveBoxes[mybox];
          int bufSize = rBox.size();
          fprintf(debugFile,">>> myid=%i: RECEIVED buffer tag=%i from p=%i (mybox=%i,bufSize=%d, numReceive=%i)\n",
                  myid,tag,p,mybox,bufSize,numReceive);
          for( int j=0; j<bufSize; j++ ) fprintf(debugFile,"%5.2f ",rBuff[mybox][j]);
          fprintf(debugFile,"\n");
        }

        // fill in the entries of vLocal
        // old: int n = receiveBoxIndex[p];
        int n = mybox;
        assert( n>=0 && n<numReceive );
        IndexBox & rBox = receiveBoxes[n];
        assert( rBox.processor==p );

        // assign vLocal(rBox) = rBuff[m][0...]
        const real *buff = rBuff[mybox];
      
        int i=0;
        FOR_BOX(i0,i1,i2,i3,rBox)
        {
          uLocal(i0,i1,i2,i3)=buff[i]; 
          i++;
        }
      }

    }
  
//   if( debug & 2 )
//   {
//     ListOfIndexBox::iterator iter; 
//     for(int m=0; iter = receiveBoxes.begin(); m++, iter!=receiveBoxes.end(); iter++ )
//     {
//       IndexBox & pReceiveBox = *iter;

//       int bufSize=receiveStatus[m].MPI_TAG;

//       fprintf(debugFile,"<- processor %i: received msg from processor %i, tag=%i p=%i values=",myID,
//            receiveStatus[m].MPI_SOURCE,receiveStatus[m].MPI_TAG,p);
//       for( j=0; j<nivd; j++ ) fprintf(debugFile,"%8.2e ",dbuff[p][j]);
//       fprintf(debugFile,"\n");

//       }
//     }
//   }




    // wait to send messages before deleting buffers
    if( numSend>0 )
    {
      if( debug!=0 )
      {
        fprintf(debugFile,"+++ myid=%i: wait for all messges to be sent, numSend=%i\n",myid,numSend); 
        fflush(debugFile);
      }

      MPI_Status *sendStatus = new MPI_Status[numSend]; 
      MPI_Waitall( numSend, sendRequest, sendStatus );   
      delete [] sendStatus;
    }

    if( debug!=0 )
    {
      fprintf(debugFile,"+++ myid=%i: cleanup buffers...\n",myid); 
      fflush(debugFile);
    }

  
    for (int i=0; i<numReceive; i++ )
    {
      delete [] rBuff[i];
    }
    delete [] rBuff;
    delete [] receiveStatus;
    delete [] receiveRequest;
    delete [] receiveBoxIndex;
  
    for (int i=0; i<numSend; i++ )
    {
      delete [] sBuff[i];
    }
    delete [] sBuff;
    delete [] sendRequest;
  

    if( (debug & 1) && debugFile!=NULL )
    {
      fprintf(debugFile,"**** myid=%i finished updateGhostAndPeriodic ****\n",myid);
      fflush(debugFile);
    }

    
    // ============================== END OF MPI VERSION ====================================================


    #else

    // ============================== START SERIAL VERSION ====================================================
    if( debug & 2 )
    {
      printF("\n ===== GhostBoundaryUpdate::updateGhostBoundaries =====\n");
      fprintf(debugFile,"\n ===== GhostBoundaryUpdate::updateGhostBoundaries =====\n");
    }
    
    ListOfIndexBox & copySendBoxes    = dbase.get<ListOfIndexBox>("copySendBoxes");
    if( copySendBoxes.size()>0 )
    {
      ListOfIndexBox & copyReceiveBoxes  = dbase.get<ListOfIndexBox>("copyReceiveBoxes");
      std::map<int,int> & copyReceiveMap = dbase.get<std::map<int,int> >("copyReceiveMap");

      assert( copySendBoxes.size() == copyReceiveBoxes.size() );
      for( int m=0; m<copySendBoxes.size(); m++ )
      {
        IndexBox & sourceBox = copySendBoxes[m];
        sourceBox.setBaseBound( component,C.getBase(),C.getBound() );  // set component range 

        int stag=sourceBox.tag, rtag;  
        convertTag(stag,rtag);

        // if( debug & 2 )
        // {
        //   fprintf(debugFile,"copyOnProc: sourceBox.tag=%d --> rtag=%d: m=%d (source)\n",stag,rtag,m);
        //   fflush(debugFile);
        // }

        int myBox = copyReceiveMap.at(rtag);  // copyReceiveBoxes[myBox] corresponds to copySendBox[m]

        if( debug & 2 )
          fprintf(debugFile,"copyOnProc: sourceBox.tag=%d --> rtag=%d: m=%d (source) ->  myBox=%d (target)\n",stag,rtag,m,myBox);

        assert( myBox>=0 && myBox<copyReceiveBoxes.size() );
        IndexBox & targetBox = copyReceiveBoxes[myBox];
        targetBox.setBaseBound( component,C.getBase(),C.getBound() );  // set component range 

        assert( sourceBox.size()==targetBox.size() );
        
        FOR_BOX_IJ(i0,i1,i2,i3,sourceBox, j0,j1,j2,j3,targetBox )
        {
          uLocal(j0,j1,j2,j3) = uLocal(i0,i1,i2,i3);
        }

      }
    }
  
  
  // ============================== END SERIAL VERSION ====================================================
  #endif

  }  // end if not is empty 
  
   

  if( debug )
  {
    if( debugFileName == "tug" ) // *** FIX ME --> add format as an option
    {
      ::display(uLocal,"GBU:: uLocal (after)",debugFile,"%4.0f ");
      //::display(u,"u (after)","%4.0f ");
    }
    else
    {
      ::display(uLocal,"GBU: uLocal (after)",debugFile,"%5.2f ");
      //::display(u,"u (after)","%5.2f ");
    }
  }

  return 0;

}




