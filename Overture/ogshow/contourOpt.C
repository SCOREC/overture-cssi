// This file automatically generated from contourOpt.bC with bpp.
#include "Overture.h"
#include "GL_GraphicsInterface.h"
#include "ParallelUtility.h"
#include "DataPointMapping.h"
#include "interpPoints.h"
#include "conversion.h"
#include "UnstructuredMapping.h"
#include "display.h"
#include "CompositeGrid.h"
#include "PlotIt.h"

#include <float.h>
        
// local version so that we can change it: 
static int isHiddenByRefinement=MappedGrid::IShiddenByRefinement;

#define FOR_3(i1,i2,i3,I1,I2,I3) i1Bound=I1.getBound(); i2Bound=I2.getBound(); i3Bound=I3.getBound(); for( i3=I3.getBase(); i3<=i3Bound; i3++ )  for( i2=I2.getBase(); i2<=i2Bound; i2++ )  for( i1=I1.getBase(); i1<=i1Bound; i1++ )  
#define FOR_3WithStride(i1,i2,i3,m1,m2,m3,I1,I2,I3) i1Bound=I1.getBound(); i2Bound=I2.getBound(); i3Bound=I3.getBound(); for( i3=I3.getBase(); i3<=i3Bound; i3+=m3 )  for( i2=I2.getBase(); i2<=i2Bound; i2+=m2 )  for( i1=I1.getBase(); i1<=i1Bound; i1+=m1 )  

extern int colourTable[256][3];

//-----------------------------------------------------------------------------------------------
// Get Bounds on u -- treat the general case when the component can be in any Index position of u
//
// Input 
//  u :
//  parameters (input) : holds numberOfGhostLinesToPlot
//  R0,R1,...,R4 : optional Ranges to say which components to check
// Return
//   uMin,Umax
//-----------------------------------------------------------------------------------------------
void PlotIt::
getBounds(const realGridCollectionFunction & u,
                    real & uMin, 
                    real & uMax,
                    GraphicsParameters & parameters,   
                    const Range & R0,      // check these entries of component 0
                    const Range & R1,      // check these entries of component 1
                    const Range & R2,
                    const Range & R3,
                    const Range & R4)
{
    const GridCollection & gc = *(u.gridCollection);
    const int numberOfGrids =  gc.numberOfComponentGrids();

    isHiddenByRefinement = parameters.plotHiddenRefinementPoints ? 0 : MappedGrid::IShiddenByRefinement;

    Index I[8] = {Range(0,0),Range(0,0),Range(0,0),Range(0,0),Range(0,0),Range(0,0),Range(0,0),Range(0,0)};
    Range R[] = { R0,R1,R2,R3,R4 };

    for( int component=0; component<5; component++ )
        I[u.positionOfComponent(component)]= R[component].length()>0 ? R[component]
                                      : Range(u.getComponentBase(component),u.getComponentBase(component));

    uMin=REAL_MAX;
    uMax=-uMin;
    for( int grid=0; grid<numberOfGrids; grid++ )
    {
        Index I1,I2,I3;
    // *wdh* new mask    getIndex(gc[grid].gridIndexRange(),I1,I2,I3,parameters.numberOfGhostLinesToPlot);
        if( gc[grid].getGridType()==MappedGrid::structuredGrid )
        {
            getIndex(gc[grid].indexRange(),I1,I2,I3,parameters.numberOfGhostLinesToPlot);
            I[u.positionOfCoordinate(0)]=I1;
            I[u.positionOfCoordinate(1)]=I2;
            I[u.positionOfCoordinate(2)]=I3;
        
      // check if conformable:
            if( u.positionOfComponent(0)> u.positionOfCoordinate(gc.numberOfDimensions()-1) )
            {
                #ifdef USE_PPP
        	  const RealArray & v = u[grid].getLocalArray();   // no parallel ghost 
        	  const IntegerArray & mask = gc[grid].mask().getLocalArray();
        	  const int n1a=max(v.getBase(0),I1.getBase()), n1b=min(v.getBound(0),I1.getBound());  
        	  const int n2a=max(v.getBase(1),I2.getBase()), n2b=min(v.getBound(1),I2.getBound());
        	  const int n3a=max(v.getBase(2),I3.getBase()), n3b=min(v.getBound(2),I3.getBound());
        	  if( n1a>n1b || n2a>n2b || n3a>n3b )
          	    continue;
        	  I1=Range(n1a,n1b);
        	  I2=Range(n2a,n2b);
        	  I3=Range(n3a,n3b);
        	  I[u.positionOfCoordinate(0)]=I1;
        	  I[u.positionOfCoordinate(1)]=I2;
        	  I[u.positionOfCoordinate(2)]=I3;

                #else
                	  const RealArray & v = u[grid]; 
        	  const IntegerArray & mask = gc[grid].mask(); 
                #endif
      	where( mask(I1,I2,I3) != 0 && !(mask(I1,I2,I3) & isHiddenByRefinement) )
      	{ // ** fix for more components ****
        	  uMin= grid==0 ? min(v(I[0],I[1],I[2],I[3])) : min(min(v(I[0],I[1],I[2],I[3])),uMin);
        	  uMax= grid==0 ? max(v(I[0],I[1],I[2],I[3])) : max(max(v(I[0],I[1],I[2],I[3])),uMax);
      	}
            }
            else  // ***** this will not be needed when A++ is fixed ******
            {
      	int i1,i2,i3,i1Bound,i2Bound,i3Bound;
                const intArray & mask = gc[grid].mask();
      	FOR_3(i1,i2,i3,I1,I2,I3)
      	{
        	  if( mask(i1,i2,i3) != 0 && !(mask(i1,i2,i3) & isHiddenByRefinement))
        	  {
          	    for( int c0=I[u.positionOfComponent(0)].getBase(); c0<=I[u.positionOfComponent(0)].getBase(); c0++ )
          	    {
            	      uMin= min(u[grid].sa(i1,i2,i3,c0),uMin);
            	      uMax= max(u[grid].sa(i1,i2,i3,c0),uMax);
          	    }
        	  }
      	}
            }
        }
        else
        {
      // unstructured grid 
            Range C0 = R0.getLength()>0 ? R0 : Range(u.getComponentBase(0),u.getComponentBase(0));
            const realArray & v = u[grid];
      // uMin=min(v(I1,C0));  // *wdh* 020515
      // uMax=max(v(I1,C0));
            Range all;
            uMin=min(v(all,all,all,C0));
            uMax=max(v(all,all,all,C0));
        }
    } // end for grid

    if( PlotIt::parallelPlottingOption==1 )
    {
        uMin=ParallelUtility::getMinValue(uMin);
        uMax=ParallelUtility::getMaxValue(uMax);
    }
    
}


#define ForBoundary(side,axis)   for( axis=0; axis<gc.numberOfDimensions(); axis++ ) for( side=0; side<=1; side++ )

#define COLOUR_INDEX(uVal) min(max(int((uVal-uMin)*delta255+.5),0),255)

// shade a quadrilaterl with corners (i1,i2,i3) to (i1+m1,i2+m2,i3) using the rainbow colour table

// shade a quadrilaterl with corners (i1,i2,i3) to (i1+m1,i2+m2,i3) using the current colour table



void PlotIt::
contourOpt2d(GenericGraphicsInterface &gi, 
                          const realGridCollectionFunction & uGCF, 
                          GraphicsParameters & psp,
                          real & uMin, real & uMax, real & uRaise,
                          bool & recomputeVelocityMinMax,
           	     bool & contourLevelsSpecified,
                          RealArray & xBound )
// ============================================================================================================
// Optimized version of the 2d contour plotter
// =============================================================================================================
{

    const bool showTimings=false;
    real time0=getCPU();

    const int myid=max(0,Communication_Manager::My_Process_Number);
    const int np= max(1,Communication_Manager::numberOfProcessors());
    const int graphicsProcessor = gi.getProcessorForGraphics();
    const bool plotOnThisProcessor = Communication_Manager::localProcessNumber()==gi.getProcessorForGraphics();

#ifdef USE_PPP
    if( false && PlotIt::parallelPlottingOption==1 )
    {
        printf("*** contourOpt2d: START myid=%i ***\n",myid);
        fflush(0);
        MPI_Barrier(Overture::OV_COMM);
    }
#endif


    const GridCollection & gc = *(uGCF.gridCollection);
    const int numberOfGrids =  gc.numberOfComponentGrids();
    const int numberOfDimensions =  gc.numberOfDimensions();

    bool & plotWireFrame        = psp.plotWireFrame;
    bool & plotShadedSurface    = psp.plotShadedSurface;
    int  & component            = psp.componentForContours;
    bool & plotContourLines     = psp.plotContourLines;
    bool & plotGridBoundariesOnContourPlots = psp.plotGridBoundariesOnContourPlots;

    bool & flatShading = psp.flatShading;

    IntegerArray & gridsToPlot      = psp.gridsToPlot;
    int  & numberOfContourLevels= psp.numberOfContourLevels;
    real & minimumContourSpacing = psp.minimumContourSpacing;
    const IntegerArray & minAndMaxContourLevelsSpecified  = psp.minAndMaxContourLevelsSpecified;
    RealArray & minAndMaxContourLevels = psp.minAndMaxContourLevels;
    real & contourSurfaceVerticalScaleFactor=psp.contourSurfaceVerticalScaleFactor; 
    int & numberOfGhostLinesToPlot = psp.numberOfGhostLinesToPlot;
    RealArray & contourLevels    = psp.contourLevels;

    bool unsPlotGhost = psp.numberOfGhostLinesToPlot;

    isHiddenByRefinement = psp.plotHiddenRefinementPoints ? 0 : MappedGrid::IShiddenByRefinement;

//   if( true )
//   {
//     printf(" In contourOpt2d at start\n");
//     for( int grid=0; grid<gc.numberOfComponentGrids(); grid++ )
//       gc[grid].displayComputedGeometry();
//   }

    Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];

    gi.setGlobalBound(xBound);
            
  // Get Bounds on u -- treat the general case when the component can be in any Index position of u
    if( !minAndMaxContourLevelsSpecified(component) )
    {
        if( recomputeVelocityMinMax )
        {
            recomputeVelocityMinMax=false;
            getBounds(uGCF,uMin,uMax,psp,Range(component,component));
        }
    }
    else
    {
        uMin=minAndMaxContourLevels(0,component);
        uMax=minAndMaxContourLevels(1,component);
    }

    real deltaU = uMax-uMin;
    if( deltaU==0. )
    {
        uMax+=.5;
        uMin-=.5;
    }
    else if( deltaU < minimumContourSpacing*numberOfContourLevels )
    {
        uMax+=minimumContourSpacing*numberOfContourLevels;
        uMin-=minimumContourSpacing*numberOfContourLevels;
        deltaU = uMax-uMin;
    }
            
    real uAverage=.5*(uMax+uMin);
    real deltaUInverse =  deltaU==0. ? 1. : 1./deltaU;

  // scale height of surface by this contourSurfaceVerticalScaleFactor
  // the maximum distance in the x or y direction
    real spatialBound = psp.contourSurfaceSpatialBound;
    if( spatialBound<=0 ) spatialBound=max(xBound(End,Range(0,1))-xBound(Start,Range(0,1)));

    real uScaleFactor=contourSurfaceVerticalScaleFactor*deltaUInverse*spatialBound;

    bool lineStipple=FALSE;   // true if line stipple (dashed lines) turned on)

    real time1=getCPU();
    if( showTimings ) printf("contour2d:time for setup=%8.2e\n",time1-time0);

    if( plotOnThisProcessor )
    {
        glPushName(uGCF.getGlobalID()); // assign a name for picking
            
        if( !plotWireFrame )
        {
            glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
            glShadeModel(GL_SMOOTH);     // interpolate colours between vertices
        }
      	
        glPolygonOffset(4.0,3.0*OFFSET_FACTOR);  // for contour lines on the polygons we need a big offset
        glEnable(GL_POLYGON_OFFSET_FILL);
    }
    
    bool adaptForColour = gi.gridCoarseningFactor<0; // plot at finer resolution where the colour changes
    // const int maxPlotablePoints=500000; // maximum number of points we plot at the highest resolution
    const int maxPlotablePoints=5000000; // maximum number of points we plot at the highest resolution *wdh* increased March 19, 2021
    const int maxAdaptiveColourPoints=maxPlotablePoints*2; // turn off adaptive colouring if this many cells plotted
    int numberOfCellsPlotted=0;

    #ifdef USE_PPP
  // define a partition for a distributed array that only lives on the graphicsProcessor
    Partitioning_Type partition; 
    partition.SpecifyProcessorRange(Range(graphicsProcessor,graphicsProcessor)); 
    for( int axis=0; axis<4; axis++ )
    {
        int ghost=0; // uPartition.getGhostBoundaryWidth(axis);
        if( ghost>0 )
            partition.partitionAlongAxis(axis, true , ghost);
        else
            partition.partitionAlongAxis(axis, false, 0);
    }
    #endif

    for( int grid=0; grid<numberOfGrids; grid++ )
    {
        if( !(gridsToPlot(grid)&GraphicsParameters::toggleContours) )
            continue;
    // RealArray & u = uGCF[grid];
        realMappedGridFunction & u = uGCF[grid];

    // -- use the vertex array if we are plotting with an adjustment for the "displacement"
    // const bool isRectangular=gc[grid].isRectangular();
        const bool isRectangular=gc[grid].isRectangular() && !psp.adjustGridForDisplacement && 
                             !(gc[grid]->computedGeometry & MappedGrid::THEvertex);

        if( !isRectangular )
        { // *wdh* 090522 -- make sure the center is there as well since we us it below
            MappedGrid & mg = (MappedGrid&)(gc[grid]);
            mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter );
        }
        

        if( gc[grid].getGridType()==MappedGrid::structuredGrid )
        {
            bool cellVertex = (bool) gc[grid].isAllVertexCentered();
      // The position array is the vertex or center array, these are the coordinates
      // corresponding to the solution values

      // *************** Loop over processors ******************
            for( int p=0; p<np; p++ )
            {

#ifdef USE_PPP
      	if( false && PlotIt::parallelPlottingOption==1 )
      	{
        	  printf("*** contourOpt2d: myid=%i : plot data on processor p=%i ***\n",myid,p);
        	  fflush(0);
        	  MPI_Barrier(Overture::OV_COMM);
      	}
    
#endif

	// --- Determine I1,I2,I3 for plotting ----
      	I3=gc[grid].dimension(Start,axis3);
      	for( int axis=0; axis<2; axis++ )
      	{
        	  int ia=max(gc[grid].extendedIndexRange(Start,axis)-numberOfGhostLinesToPlot,
                 		     gc[grid].dimension(Start,axis));
        	  int ib=min(gc[grid].extendedIndexRange(End,axis)+numberOfGhostLinesToPlot,
                 		     gc[grid].dimension(End,axis));

        	  if( !gc[grid].isPeriodic(axis) )
          	    ib--;

	  // Sometimes we do want to see ghost points on interpolation boundaries.
	  // There fore do NOT do the following.
	  // if( gc[grid].boundaryCondition(Start,axis)==0 )
	  //   ia=max(gc[grid].extendedIndexRange(Start,axis),ia);
	  // if( gc[grid].boundaryCondition(End,axis)==0 )
	  //   ib=min(gc[grid].extendedIndexRange(End,axis)-1,ib);
            	      
        	  Iv[axis]=Range(ia,ib);
      	}


                #ifndef USE_PPP

                  const realSerialArray & uu = u;
                  const realSerialArray & coord = isRectangular ? uu : cellVertex ? gc[grid].vertex() : gc[grid].center();
                  const intSerialArray & mask = gc[grid].mask();

                #else


                  realSerialArray uu; 
                  realSerialArray coord;
                  intSerialArray mask;  

	 // for now: create distributed arrays that just live of the graphics processor -- then copy
         // data from processor p -- we could write special MPI calls instead ---
                  realArray ud, coordd;
       	 intArray maskd;
       	 
       	 if( p==graphicsProcessor )
       	 {
         	   getLocalArrayWithGhostBoundaries(u,uu);
         	   if( !isRectangular )
           	     getLocalArrayWithGhostBoundaries(gc[grid].center(),coord);   

         	   getLocalArrayWithGhostBoundaries(gc[grid].mask(),mask); 
       	 }
         	 else
       	 {
           // finish this 

                      IndexBox pBox;
                      const int nd=4;
                      Index Jv[nd];

           // if( myid==graphicsProcessor )
	   // CopyArray::getLocalArrayBoxWithGhost( p, u, pBox ); // get local bounds of the array on processor p 
         	   CopyArray::getLocalArrayBox( p, u, pBox ); // get local bounds of the array on processor p 

         	   if( false )
         	   {
           	     printf("contourOpt2d: myid=%i, copy data [%i,%i][%i,%i] from processor p=%i to graphicsProcessor=%i\n",
                		    myid,pBox.base(0),pBox.bound(0),pBox.base(1),pBox.bound(1),p,graphicsProcessor);
           	     fflush(0);
           	     MPI_Barrier(Overture::OV_COMM);
         	   }
         	   
                      if( pBox.isEmpty() ) continue;
         	   
         	   for( int d=0; d<3; d++ )	     
         	   {
           	     int ja=pBox.base(d), jb=pBox.bound(d);
	     // copy an extra line on internal ghost boundaries to avoid a gap
	     // if( ja>gridIndexRange(0,d) ) ja--;
           	     if( jb<gc[grid].gridIndexRange(1,d) ) jb++;
           	     Jv[d]=Range(ja,jb);
         	   }

           // trouble here: 
         	   Jv[3]=Range(component,component); // only copy the component we are plotting 
	   // Jv[3]=u.dimension(3); // works
	   // Jv[3]=Range(0,component); // try this --> works 
	   // Jv[3]=Range(max(0,component-1),component); // try this 


                      ud.partition(partition);
         	   ud.redim(Jv[0],Jv[1],Jv[2],Jv[3]);
                      ParallelUtility::copy(ud,Jv,u,Jv,nd); // copy data from processor p to graphics processor
         	   getLocalArrayWithGhostBoundaries(ud,uu);
                      
	   // ::display(uu,sPrintF(" uu from processor p=%i",p));
                      
         	   if( !isRectangular )
         	   {
           	     Jv[3]=Range(0,gc.numberOfDimensions()-1);
           	     coordd.partition(partition);
           	     coordd.redim(Jv[0],Jv[1],Jv[2],Jv[3]);
                          const realArray & x = gc[grid].center();
           	     ParallelUtility::copy(coordd,Jv,x,Jv,nd); // copy data from processor p to graphics processor
           	     getLocalArrayWithGhostBoundaries(coordd,coord);
         	   }
                      
         	   Jv[3]=Range(0,0);
         	   maskd.partition(partition);
         	   maskd.redim(Jv[0],Jv[1],Jv[2],Jv[3]);
         	   ParallelUtility::copy(maskd,Jv,gc[grid].mask(),Jv,nd); // copy data from processor p to graphics processor
         	   getLocalArrayWithGhostBoundaries(maskd,mask);
       	 }
                #endif
      	
      	if( !plotOnThisProcessor ) continue;  // remaing parts of this loop are only done on the graphics processor


	// ****** parallelPlottingOption *****

	// With distributed plotting we copy the data from processor p to the graphics-processor

                #ifdef USE_PPP
// 	int includeGhost=1;
// 	bool ok = ParallelUtility::getLocalArrayBounds(u,uu,I1,I2,I3,includeGhost);
// 	if( !ok ) continue;

                bool ok=true;
      	for( int d=0; d<numberOfDimensions; d++ )
      	{
        	  int ia=max(mask.getBase(d),Iv[d].getBase()), ib=min(mask.getBound(d)-1,Iv[d].getBound());
        	  if( ia<=ib )
        	  {
                        Iv[d]=Range(ia,ib);
        	  }
        	  else
        	  {
          	    ok=false;
          	    break;
        	  }
      	}
                if( !ok ) continue;
                #endif

      	real uc[4], xc[4*2];  // for line contours.
      	real u00,u10,u01,u11;

          	    
      	real timea=getCPU();
      	int i1,i2,i3,i1Bound,i2Bound,i3Bound;

      	const bool plotRefinements = gc.numberOfRefinementLevels()>1;


      	const int *maskp = mask.Array_Descriptor.Array_View_Pointer2;
      	const int maskDim0=mask.getRawDataSize(0);
      	const int maskDim1=mask.getRawDataSize(1);
#define MASK(i0,i1,i2) maskp[i0+maskDim0*(i1+maskDim1*(i2))]

	// on refinement grids do not plot cells with ANY corner hidden by refinement
#define CMASK(i1,i2,i3) (MASK(i1,i2,i3)!=0 && MASK(i1+1,i2,i3)!=0 && 	  MASK(i1,i2+1,i3)!=0 && MASK(i1+1,i2+1,i3)!=0 && (!plotRefinements || (!(MASK(i1  ,i2  ,i3) & isHiddenByRefinement) && 	   !(MASK(i1+1,i2  ,i3) & isHiddenByRefinement) && 	   !(MASK(i1  ,i2+1,i3) & isHiddenByRefinement) && 	   !(MASK(i1+1,i2+1,i3) & isHiddenByRefinement) )))

      	if(plotShadedSurface &&  plotWireFrame )
        	  glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);  // plot lines on surface for a wireframe



      	const real *up = uu.Array_Descriptor.Array_View_Pointer3;
      	const int uDim0=uu.getRawDataSize(0);
      	const int uDim1=uu.getRawDataSize(1);
      	const int uDim2=uu.getRawDataSize(2);
#define U(i0,i1,i2,c) up[(i0)*d0+(i1)*d1+(i2)*d2+(c)*dc]
      	int d0,d1,d2,dc;
      	if( u.positionOfComponent(0)==3 )
      	{
        	  d0=1; d1=uDim0; d2=d1*uDim1; dc=d2*uDim2;
      	}
      	else if( u.positionOfComponent(0)==0 )
      	{
        	  dc=1; d0=uDim0; d1=d0*uDim1; d2=d1*uDim2; 
      	}
      	else
      	{
        	  printf("contour:ERROR: not implemented for u.positionOfComponent(0)=%i\n",u.positionOfComponent(0));
        	  throw "error";
      	}
          	    
// GRIDTYPE: curvilinear or rectangular. The rectangular version does not need the vertex array.


      	if( isRectangular )
      	{
        // 	  CONTOUR2D(rectangular);
        //         #If "rectangular" == "rectangular"
                      	real dx[3],xab[2][3];
                      	gc[grid].getRectangularGridParameters( dx, xab );
                      	const int i0a=gc[grid].gridIndexRange(0,0);
                      	const int i1a=gc[grid].gridIndexRange(0,1);
                      	const int i2a=gc[grid].gridIndexRange(0,2);
                                const real xa=xab[0][0], dx0=dx[0];
                                const real ya=xab[0][1], dy0=dx[1];
                                const real za=xab[0][2], dz0=dx[2];
                #define XSCALE(x) (psp.xScaleFactor*(x))
                #define YSCALE(y) (psp.yScaleFactor*(y))
                #define ZSCALE(z) (psp.zScaleFactor*(z))
                #define COORD0(i0,i1,i2) XSCALE((xa+dx0*(i0-i0a)))
                #define COORD1(i0,i1,i2) YSCALE((ya+dy0*(i1-i1a)))
                #define COORD2(i0,i1,i2) ZSCALE((za+dz0*(i2-i2a)))
                      	glPushName(gc[grid].getGlobalID()); // assign a name for picking
                                glLineWidth(psp.size(GraphicsParameters::lineWidth)*gi.getLineWidthScaleFactor()); // *wdh* 2014/12/27
                      	if( plotShadedSurface )
                      	{
                        	  const real delta255 = deltaUInverse*255;
                        	  int index=-2, index2=-1;
                        	  if( psp.colourTable==GraphicsParameters::rainbow )
                        	  {
                          	    if( false && gi.gridCoarseningFactor==2 )
                          	    {
                            	      const int m1=2,m2=2,m3=1;
                            	      FOR_3WithStride(i1,i2,i3,m1,m2,m3,I1,I2,I3) 
                            	      {
        		// ** watch out for ends
                            		if( CMASK(i1,i2,i3) && CMASK(i1+1,i2,i3) && CMASK(i1,i2+1,i3) && CMASK(i1+1,i2+1,i3) &&
                                		    i1<i1Bound && i2<i2Bound )
                            		{
                      // 		  shadeQuadRainbow(i1,i2,m1,m2);
                                            {
                                              u00=U(i1   ,i2   ,i3,component); 
                                              u10=U(i1+m1,i2   ,i3,component); 
                                              u01=U(i1   ,i2+m2,i3,component); 
                                              u11=U(i1+m1,i2+m2,i3,component);
                                              glBegin(GL_POLYGON);  // draw shaded filled polygons
                                              if( !flatShading )
                                              {
                                                  index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              else
                                              {
                         // flat shaded polygon using average value of verticies 
                                                  index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              glEnd();   
                                            }
                            		}
                            		else
                            		{
                              		  if( CMASK(i1,i2,i3) )
                        // 		    shadeQuadRainbow(i1,i2,1,1);
                                                {
                                                  u00=U(i1   ,i2   ,i3,component); 
                                                  u10=U(i1+1,i2   ,i3,component); 
                                                  u01=U(i1   ,i2+1,i3,component); 
                                                  u11=U(i1+1,i2+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                              		  if( CMASK(i1+1,i2,i3) && i1<i1Bound )
                        // 		    shadeQuadRainbow(i1+1,i2,1,1);
                                                {
                                                  u00=U(i1+1   ,i2   ,i3,component); 
                                                  u10=U(i1+1+1,i2   ,i3,component); 
                                                  u01=U(i1+1   ,i2+1,i3,component); 
                                                  u11=U(i1+1+1,i2+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2,i3),COORD1(i1+1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1  ,i2+1,i3),COORD1(i1+1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2,i3),COORD1(i1+1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1  ,i2+1,i3),COORD1(i1+1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                              		  if( CMASK(i1,i2+1,i3) && i2<i2Bound )
                        // 		    shadeQuadRainbow(i1,i2+1,1,1);
                                                {
                                                  u00=U(i1   ,i2+1   ,i3,component); 
                                                  u10=U(i1+1,i2+1   ,i3,component); 
                                                  u01=U(i1   ,i2+1+1,i3,component); 
                                                  u11=U(i1+1,i2+1+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2+1,i3),COORD1(i1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1+1,i3),COORD1(i1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1  ,i2+1+1,i3),COORD1(i1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2+1,i3),COORD1(i1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2+1+1,i3),COORD1(i1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1  ,i2+1+1,i3),COORD1(i1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                              		  if( CMASK(i1+1,i2+1,i3) && i1<i1Bound && i2<i2Bound )
                        // 		    shadeQuadRainbow(i1+1,i2+1,1,1);
                                                {
                                                  u00=U(i1+1   ,i2+1   ,i3,component); 
                                                  u10=U(i1+1+1,i2+1   ,i3,component); 
                                                  u01=U(i1+1   ,i2+1+1,i3,component); 
                                                  u11=U(i1+1+1,i2+1+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2+1+1,i3),COORD1(i1+1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1  ,i2+1+1,i3),COORD1(i1+1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2+1+1,i3),COORD1(i1+1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1  ,i2+1+1,i3),COORD1(i1+1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                            		}
                            	      }
                          	    }
                          	    else if( abs(gi.gridCoarseningFactor)>1 )
                          	    {
                            	      const int m1=abs(gi.gridCoarseningFactor),m2=abs(gi.gridCoarseningFactor),m3=1;
                            	      FOR_3WithStride(i1,i2,i3,m1,m2,m3,I1,I2,I3) 
                            	      {
        		// ** watch out for ends
                            		bool ok=true && (i1+m1-1)<=i1Bound && (i2+m2-1)<=i2Bound;
                            		int j1,j2,j3=i3;
                            		const int colourIndex=adaptForColour ? COLOUR_INDEX(U(i1,i2,i3,component)) : 0;
                            		for( j2=i2; j2<i2+m2 && ok ; j2++ )
                              		  for( j1=i1; j1<i1+m1; j1++ )
                              		  {
                                		    if( !CMASK(j1,j2,j3) || 
                                  			(adaptForColour && COLOUR_INDEX(U(j1,j2,j3,component))!=colourIndex) )
                                		    { // we can NOT plot the cell with lower left corner (j1,j2)
                                  		      ok=false;
                                  		      break;
                                		    }
                              		  }
                            		if( ok )
                            		{
        		  // plot large cell
                      // 		  shadeQuadRainbow(i1,i2,m1,m2);
                                            {
                                              u00=U(i1   ,i2   ,i3,component); 
                                              u10=U(i1+m1,i2   ,i3,component); 
                                              u01=U(i1   ,i2+m2,i3,component); 
                                              u11=U(i1+m1,i2+m2,i3,component);
                                              glBegin(GL_POLYGON);  // draw shaded filled polygons
                                              if( !flatShading )
                                              {
                                                  index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              else
                                              {
                         // flat shaded polygon using average value of verticies 
                                                  index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              glEnd();   
                                            }
                              		  numberOfCellsPlotted++;
                            		}
                            		else
                            		{
        		  // plot individual cells
                              		  const int i2b = min(i2+m2-1,i2Bound);
                              		  const int i1b = min(i1+m1-1,i1Bound);
                              		  for( j2=i2; j2<=i2b; j2++ )
                                		    for( j1=i1; j1<=i1b; j1++ )
                                		    {
                                  		      if( CMASK(j1,j2,j3) )
                                  		      {
                          // 			shadeQuadRainbow(j1,j2,1,1);
                                                    {
                                                      u00=U(j1   ,j2   ,i3,component); 
                                                      u10=U(j1+1,j2   ,i3,component); 
                                                      u01=U(j1   ,j2+1,i3,component); 
                                                      u11=U(j1+1,j2+1,i3,component);
                                                      glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                      if( !flatShading )
                                                      {
                                                          index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1,j2,i3),COORD1(j1,j2,i3), (u00-uAverage)*uScaleFactor );
                                                          index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1+1,j2,i3),COORD1(j1+1,j2,i3), (u10-uAverage)*uScaleFactor );
                                                          index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1+1,j2+1,i3),COORD1(j1+1,j2+1,i3), (u11-uAverage)*uScaleFactor );
                                                          index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1  ,j2+1,i3),COORD1(j1  ,j2+1,i3), (u01-uAverage)*uScaleFactor );
                                                      }
                                                      else
                                                      {
                             // flat shaded polygon using average value of verticies 
                                                          index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1,j2,i3),COORD1(j1,j2,i3), (u00-uAverage)*uScaleFactor );
                                                          glVertex3(COORD0(j1+1,j2,i3),COORD1(j1+1,j2,i3), (u10-uAverage)*uScaleFactor );
                                                          glVertex3(COORD0(j1+1,j2+1,i3),COORD1(j1+1,j2+1,i3), (u11-uAverage)*uScaleFactor );
                                                          glVertex3(COORD0(j1  ,j2+1,i3),COORD1(j1  ,j2+1,i3), (u01-uAverage)*uScaleFactor );
                                                      }
                                                      glEnd();   
                                                    }
                                  			numberOfCellsPlotted++;
                                  		      }
                                		    }
                            		}
                            		if( adaptForColour && numberOfCellsPlotted >maxAdaptiveColourPoints )
                            		{
                              		  adaptForColour=false;
                              		  printF(" contour:INFO:turning off adaptive grid for colour since too many cells are being plotted\n");
                            		}
                            	      }
                            	      if( false )
                            		printF(" contour:INFO: grid=%i, gridCoarseningFactor=%i,  total number of cells plotted=%i\n",
                                   		       grid,gi.gridCoarseningFactor,numberOfCellsPlotted);
                          	    }
                          	    else
                          	    {
                            	      FOR_3(i1,i2,i3,I1,I2,I3)
                            	      {
                            		if( CMASK(i1,i2,i3) )
                            		{
                      // 		  shadeQuadRainbow(i1,i2,1,1);
                                            {
                                              u00=U(i1   ,i2   ,i3,component); 
                                              u10=U(i1+1,i2   ,i3,component); 
                                              u01=U(i1   ,i2+1,i3,component); 
                                              u11=U(i1+1,i2+1,i3,component);
                                              glBegin(GL_POLYGON);  // draw shaded filled polygons
                                              if( !flatShading )
                                              {
                                                  index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              else
                                              {
                         // flat shaded polygon using average value of verticies 
                                                  index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              glEnd();   
                                            }
                            		}
                            	      }
                          	    }
                        	  }
                        	  else // colour table is not a rainbow
                        	  {
                          	    FOR_3(i1,i2,i3,I1,I2,I3)
                          	    {
                            	      if( CMASK(i1,i2,i3) )
                            	      {
                    // 		shadeQuadFromColourTable(i1,i2,1,1);
                                        {
                                          u00=U(i1   ,i2   ,i3,component); 
                                          u10=U(i1+1,i2   ,i3,component); 
                                          u01=U(i1   ,i2+1,i3,component); 
                                          u11=U(i1+1,i2+1,i3,component);
                                          glBegin(GL_POLYGON);  // draw shaded filled polygons
                                          if( !flatShading )
                                          {
                                              gi.setColourFromTable( (u00-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1  ,i2  ,i3),COORD1(i1  ,i2  ,i3), (u00-uAverage)*uScaleFactor );
                                              gi.setColourFromTable( (u10-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1+1,i2  ,i3),COORD1(i1+1,i2  ,i3), (u10-uAverage)*uScaleFactor );
                                              gi.setColourFromTable( (u11-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                              gi.setColourFromTable( (u01-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                          }
                                          else
                                          {
                                              gi.setColourFromTable( (.25*(u00+u10+u01+u11)-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1  ,i2  ,i3),COORD1(i1  ,i2  ,i3), (u00-uAverage)*uScaleFactor );
                                              glVertex3(COORD0(i1+1,i2  ,i3),COORD1(i1+1,i2  ,i3), (u10-uAverage)*uScaleFactor );
                                              glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                              glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                          }
                                          glEnd();   
                                        }
                            	      }
                          	    }
                        	  }
                      	}
                      	real time2a=getCPU();
                      	if( showTimings ) printf("contour2d:time for shaded=%8.2e\n",time2a-time1);
                      	if( plotContourLines && deltaU>0.)
                      	{
                        	  glLineWidth(psp.size(GraphicsParameters::majorContourWidth)*psp.size(GraphicsParameters::lineWidth)*
                                  		      gi.getLineWidthScaleFactor());  
                        	  if( !psp.colourLineContours )
                          	    gi.setColour(GenericGraphicsInterface::textColour);
                        	  FOR_3(i1,i2,i3,I1,I2,I3)
                        	  {
                          	    if( CMASK(i1,i2,i3) )
                          	    {
                            	      real u00=U(i1  ,i2  ,i3,component); 
                            	      real u10=U(i1+1,i2  ,i3,component); 
                            	      real u01=U(i1  ,i2+1,i3,component); 
                            	      real u11=U(i1+1,i2+1,i3,component);
                #define XC(i,j) xc[i+2*(j)]
                            	      uc[0]=u00; XC(0,0)=COORD0(i1  ,i2  ,i3); XC(1,0)=COORD1(i1  ,i2  ,i3); 
                            	      uc[1]=u10; XC(0,1)=COORD0(i1+1,i2  ,i3); XC(1,1)=COORD1(i1+1,i2  ,i3);
                            	      uc[2]=u11; XC(0,2)=COORD0(i1+1,i2+1,i3); XC(1,2)=COORD1(i1+1,i2+1,i3);
                            	      uc[3]=u01; XC(0,3)=COORD0(i1  ,i2+1,i3); XC(1,3)=COORD1(i1  ,i2+1,i3);
        	      // note: edges are done in a different order that before.
                            	      drawContourLinesOnAnElement(gi,uc,xc,4,deltaU,deltaUInverse,uMin,uMax,uAverage,uScaleFactor,
                                                					  uRaise,contourLevels,lineStipple,contourLevelsSpecified,psp );
                          	    }
                        	  }
                        	  glLineWidth(psp.size(GraphicsParameters::lineWidth)*gi.getLineWidthScaleFactor()); // reset
                      	}
                      	real time2b=getCPU();
                      	if( showTimings ) printf("contour2d:time for lines=%8.2e\n",time2b-time2a);
                      	if( plotWireFrame ) // to get hidden lines plot a white surface
                      	{
                        	  glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
                        	  glShadeModel(GL_SMOOTH);     // interpolate colours between vertices
                        	  gi.setColour(GenericGraphicsInterface::backGroundColour); // glColor3(1.,1.,1.);
                        	  FOR_3(i1,i2,i3,I1,I2,I3)
                        	  {
                          	    if( CMASK(i1,i2,i3) )
                          	    {
                            	      real u00=U(i1  ,i2  ,i3,component);  // the .sa function permutes the indices
                            	      real u10=U(i1+1,i2  ,i3,component);  // so that i1,i2,i3,component are in the correct
                            	      real u01=U(i1  ,i2+1,i3,component);  // positions for a general grid function
                            	      real u11=U(i1+1,i2+1,i3,component);
                            	      glBegin(GL_POLYGON); 
                            	      glVertex3(COORD0(i1  ,i2  ,i3),COORD1(i1  ,i2  ,i3), (u00-uAverage)*uScaleFactor );
                            	      glVertex3(COORD0(i1+1,i2  ,i3),COORD1(i1+1,i2  ,i3), (u10-uAverage)*uScaleFactor );
                            	      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                            	      glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                            	      glEnd();   
                          	    }
                        	  }
                      	}
                      	glPopName();
                      	real time2c=getCPU();
                      	if( showTimings ) printf("contour2d:time for wire frame=%8.2e\n",time2c-time2b);
                      	real time2=getCPU();
                      	if( showTimings ) printf("contour2d:time for shaded, lines, wireframe =%8.2e\n",time2-time1);
                #undef COORD
                #undef COORD0
                #undef COORD1
                #undef COORD2
      	}
      	else
      	{
        // 	  CONTOUR2D(curvlinear);
        //         #If "curvlinear" == "rectangular"
        //         #Else
                      	const real *coordp = coord.Array_Descriptor.Array_View_Pointer3;
                      	const int coordDim0=coord.getRawDataSize(0);
                      	const int coordDim1=coord.getRawDataSize(1);
                      	const int coordDim2=coord.getRawDataSize(2);
                #define COORD(i0,i1,i2,i3) coordp[i0+coordDim0*(i1+coordDim1*(i2+coordDim2*(i3)))]
                #define COORD0(i0,i1,i2) XSCALE(coordp[i0+coordDim0*(i1+coordDim1*(i2+coordDim2*(0)))])
                #define COORD1(i0,i1,i2) YSCALE(coordp[i0+coordDim0*(i1+coordDim1*(i2+coordDim2*(1)))])
                #define COORD2(i0,i1,i2) ZSCALE(coordp[i0+coordDim0*(i1+coordDim1*(i2+coordDim2*(2)))])
                      	glPushName(gc[grid].getGlobalID()); // assign a name for picking
                                glLineWidth(psp.size(GraphicsParameters::lineWidth)*gi.getLineWidthScaleFactor()); // *wdh* 2014/12/27
                      	if( plotShadedSurface )
                      	{
                        	  const real delta255 = deltaUInverse*255;
                        	  int index=-2, index2=-1;
                        	  if( psp.colourTable==GraphicsParameters::rainbow )
                        	  {
                          	    if( false && gi.gridCoarseningFactor==2 )
                          	    {
                            	      const int m1=2,m2=2,m3=1;
                            	      FOR_3WithStride(i1,i2,i3,m1,m2,m3,I1,I2,I3) 
                            	      {
        		// ** watch out for ends
                            		if( CMASK(i1,i2,i3) && CMASK(i1+1,i2,i3) && CMASK(i1,i2+1,i3) && CMASK(i1+1,i2+1,i3) &&
                                		    i1<i1Bound && i2<i2Bound )
                            		{
                      // 		  shadeQuadRainbow(i1,i2,m1,m2);
                                            {
                                              u00=U(i1   ,i2   ,i3,component); 
                                              u10=U(i1+m1,i2   ,i3,component); 
                                              u01=U(i1   ,i2+m2,i3,component); 
                                              u11=U(i1+m1,i2+m2,i3,component);
                                              glBegin(GL_POLYGON);  // draw shaded filled polygons
                                              if( !flatShading )
                                              {
                                                  index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              else
                                              {
                         // flat shaded polygon using average value of verticies 
                                                  index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              glEnd();   
                                            }
                            		}
                            		else
                            		{
                              		  if( CMASK(i1,i2,i3) )
                        // 		    shadeQuadRainbow(i1,i2,1,1);
                                                {
                                                  u00=U(i1   ,i2   ,i3,component); 
                                                  u10=U(i1+1,i2   ,i3,component); 
                                                  u01=U(i1   ,i2+1,i3,component); 
                                                  u11=U(i1+1,i2+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                              		  if( CMASK(i1+1,i2,i3) && i1<i1Bound )
                        // 		    shadeQuadRainbow(i1+1,i2,1,1);
                                                {
                                                  u00=U(i1+1   ,i2   ,i3,component); 
                                                  u10=U(i1+1+1,i2   ,i3,component); 
                                                  u01=U(i1+1   ,i2+1,i3,component); 
                                                  u11=U(i1+1+1,i2+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2,i3),COORD1(i1+1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1  ,i2+1,i3),COORD1(i1+1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2,i3),COORD1(i1+1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1  ,i2+1,i3),COORD1(i1+1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                              		  if( CMASK(i1,i2+1,i3) && i2<i2Bound )
                        // 		    shadeQuadRainbow(i1,i2+1,1,1);
                                                {
                                                  u00=U(i1   ,i2+1   ,i3,component); 
                                                  u10=U(i1+1,i2+1   ,i3,component); 
                                                  u01=U(i1   ,i2+1+1,i3,component); 
                                                  u11=U(i1+1,i2+1+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2+1,i3),COORD1(i1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1+1,i3),COORD1(i1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1  ,i2+1+1,i3),COORD1(i1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1,i2+1,i3),COORD1(i1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1,i2+1+1,i3),COORD1(i1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1  ,i2+1+1,i3),COORD1(i1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                              		  if( CMASK(i1+1,i2+1,i3) && i1<i1Bound && i2<i2Bound )
                        // 		    shadeQuadRainbow(i1+1,i2+1,1,1);
                                                {
                                                  u00=U(i1+1   ,i2+1   ,i3,component); 
                                                  u10=U(i1+1+1,i2+1   ,i3,component); 
                                                  u01=U(i1+1   ,i2+1+1,i3,component); 
                                                  u11=U(i1+1+1,i2+1+1,i3,component);
                                                  glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                  if( !flatShading )
                                                  {
                                                      index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1+1,i2+1+1,i3),COORD1(i1+1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1  ,i2+1+1,i3),COORD1(i1+1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  else
                                                  {
                           // flat shaded polygon using average value of verticies 
                                                      index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                      if( index2!=index )
                                                      {
                                                          index=index2;
                                                          glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                      }
                                                      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u00-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2+1,i3),COORD1(i1+1+1,i2+1,i3), (u10-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1+1,i2+1+1,i3),COORD1(i1+1+1,i2+1+1,i3), (u11-uAverage)*uScaleFactor );
                                                      glVertex3(COORD0(i1+1  ,i2+1+1,i3),COORD1(i1+1  ,i2+1+1,i3), (u01-uAverage)*uScaleFactor );
                                                  }
                                                  glEnd();   
                                                }
                            		}
                            	      }
                          	    }
                          	    else if( abs(gi.gridCoarseningFactor)>1 )
                          	    {
                            	      const int m1=abs(gi.gridCoarseningFactor),m2=abs(gi.gridCoarseningFactor),m3=1;
                            	      FOR_3WithStride(i1,i2,i3,m1,m2,m3,I1,I2,I3) 
                            	      {
        		// ** watch out for ends
                            		bool ok=true && (i1+m1-1)<=i1Bound && (i2+m2-1)<=i2Bound;
                            		int j1,j2,j3=i3;
                            		const int colourIndex=adaptForColour ? COLOUR_INDEX(U(i1,i2,i3,component)) : 0;
                            		for( j2=i2; j2<i2+m2 && ok ; j2++ )
                              		  for( j1=i1; j1<i1+m1; j1++ )
                              		  {
                                		    if( !CMASK(j1,j2,j3) || 
                                  			(adaptForColour && COLOUR_INDEX(U(j1,j2,j3,component))!=colourIndex) )
                                		    { // we can NOT plot the cell with lower left corner (j1,j2)
                                  		      ok=false;
                                  		      break;
                                		    }
                              		  }
                            		if( ok )
                            		{
        		  // plot large cell
                      // 		  shadeQuadRainbow(i1,i2,m1,m2);
                                            {
                                              u00=U(i1   ,i2   ,i3,component); 
                                              u10=U(i1+m1,i2   ,i3,component); 
                                              u01=U(i1   ,i2+m2,i3,component); 
                                              u11=U(i1+m1,i2+m2,i3,component);
                                              glBegin(GL_POLYGON);  // draw shaded filled polygons
                                              if( !flatShading )
                                              {
                                                  index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              else
                                              {
                         // flat shaded polygon using average value of verticies 
                                                  index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2,i3),COORD1(i1+m1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+m1,i2+m2,i3),COORD1(i1+m1,i2+m2,i3), (u11-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1  ,i2+m2,i3),COORD1(i1  ,i2+m2,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              glEnd();   
                                            }
                              		  numberOfCellsPlotted++;
                            		}
                            		else
                            		{
        		  // plot individual cells
                              		  const int i2b = min(i2+m2-1,i2Bound);
                              		  const int i1b = min(i1+m1-1,i1Bound);
                              		  for( j2=i2; j2<=i2b; j2++ )
                                		    for( j1=i1; j1<=i1b; j1++ )
                                		    {
                                  		      if( CMASK(j1,j2,j3) )
                                  		      {
                          // 			shadeQuadRainbow(j1,j2,1,1);
                                                    {
                                                      u00=U(j1   ,j2   ,i3,component); 
                                                      u10=U(j1+1,j2   ,i3,component); 
                                                      u01=U(j1   ,j2+1,i3,component); 
                                                      u11=U(j1+1,j2+1,i3,component);
                                                      glBegin(GL_POLYGON);  // draw shaded filled polygons
                                                      if( !flatShading )
                                                      {
                                                          index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1,j2,i3),COORD1(j1,j2,i3), (u00-uAverage)*uScaleFactor );
                                                          index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1+1,j2,i3),COORD1(j1+1,j2,i3), (u10-uAverage)*uScaleFactor );
                                                          index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1+1,j2+1,i3),COORD1(j1+1,j2+1,i3), (u11-uAverage)*uScaleFactor );
                                                          index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1  ,j2+1,i3),COORD1(j1  ,j2+1,i3), (u01-uAverage)*uScaleFactor );
                                                      }
                                                      else
                                                      {
                             // flat shaded polygon using average value of verticies 
                                                          index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                          if( index2!=index )
                                                          {
                                                              index=index2;
                                                              glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                          }
                                                          glVertex3(COORD0(j1,j2,i3),COORD1(j1,j2,i3), (u00-uAverage)*uScaleFactor );
                                                          glVertex3(COORD0(j1+1,j2,i3),COORD1(j1+1,j2,i3), (u10-uAverage)*uScaleFactor );
                                                          glVertex3(COORD0(j1+1,j2+1,i3),COORD1(j1+1,j2+1,i3), (u11-uAverage)*uScaleFactor );
                                                          glVertex3(COORD0(j1  ,j2+1,i3),COORD1(j1  ,j2+1,i3), (u01-uAverage)*uScaleFactor );
                                                      }
                                                      glEnd();   
                                                    }
                                  			numberOfCellsPlotted++;
                                  		      }
                                		    }
                            		}
                            		if( adaptForColour && numberOfCellsPlotted >maxAdaptiveColourPoints )
                            		{
                              		  adaptForColour=false;
                              		  printF(" contour:INFO:turning off adaptive grid for colour since too many cells are being plotted\n");
                            		}
                            	      }
                            	      if( false )
                            		printF(" contour:INFO: grid=%i, gridCoarseningFactor=%i,  total number of cells plotted=%i\n",
                                   		       grid,gi.gridCoarseningFactor,numberOfCellsPlotted);
                          	    }
                          	    else
                          	    {
                            	      FOR_3(i1,i2,i3,I1,I2,I3)
                            	      {
                            		if( CMASK(i1,i2,i3) )
                            		{
                      // 		  shadeQuadRainbow(i1,i2,1,1);
                                            {
                                              u00=U(i1   ,i2   ,i3,component); 
                                              u10=U(i1+1,i2   ,i3,component); 
                                              u01=U(i1   ,i2+1,i3,component); 
                                              u11=U(i1+1,i2+1,i3,component);
                                              glBegin(GL_POLYGON);  // draw shaded filled polygons
                                              if( !flatShading )
                                              {
                                                  index2 = min(max(int((u00-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u10-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u11-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                  index2 = min(max(int((u01-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              else
                                              {
                         // flat shaded polygon using average value of verticies 
                                                  index2 = min(max(int((.25*(u00+u10+u01+u11)-uMin)*delta255+.5),0),255);
                                                  if( index2!=index )
                                                  {
                                                      index=index2;
                                                      glColor3f(colourTable[index][0]/255.,colourTable[index][1]/255.,colourTable[index][2]/255.);
                                                  }
                                                  glVertex3(COORD0(i1,i2,i3),COORD1(i1,i2,i3), (u00-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+1,i2,i3),COORD1(i1+1,i2,i3), (u10-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                                  glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                              }
                                              glEnd();   
                                            }
                            		}
                            	      }
                          	    }
                        	  }
                        	  else // colour table is not a rainbow
                        	  {
                          	    FOR_3(i1,i2,i3,I1,I2,I3)
                          	    {
                            	      if( CMASK(i1,i2,i3) )
                            	      {
                    // 		shadeQuadFromColourTable(i1,i2,1,1);
                                        {
                                          u00=U(i1   ,i2   ,i3,component); 
                                          u10=U(i1+1,i2   ,i3,component); 
                                          u01=U(i1   ,i2+1,i3,component); 
                                          u11=U(i1+1,i2+1,i3,component);
                                          glBegin(GL_POLYGON);  // draw shaded filled polygons
                                          if( !flatShading )
                                          {
                                              gi.setColourFromTable( (u00-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1  ,i2  ,i3),COORD1(i1  ,i2  ,i3), (u00-uAverage)*uScaleFactor );
                                              gi.setColourFromTable( (u10-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1+1,i2  ,i3),COORD1(i1+1,i2  ,i3), (u10-uAverage)*uScaleFactor );
                                              gi.setColourFromTable( (u11-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                              gi.setColourFromTable( (u01-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                          }
                                          else
                                          {
                                              gi.setColourFromTable( (.25*(u00+u10+u01+u11)-uMin)*deltaUInverse,psp );
                                              glVertex3(COORD0(i1  ,i2  ,i3),COORD1(i1  ,i2  ,i3), (u00-uAverage)*uScaleFactor );
                                              glVertex3(COORD0(i1+1,i2  ,i3),COORD1(i1+1,i2  ,i3), (u10-uAverage)*uScaleFactor );
                                              glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                                              glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                                          }
                                          glEnd();   
                                        }
                            	      }
                          	    }
                        	  }
                      	}
                      	real time2a=getCPU();
                      	if( showTimings ) printf("contour2d:time for shaded=%8.2e\n",time2a-time1);
                      	if( plotContourLines && deltaU>0.)
                      	{
                        	  glLineWidth(psp.size(GraphicsParameters::majorContourWidth)*psp.size(GraphicsParameters::lineWidth)*
                                  		      gi.getLineWidthScaleFactor());  
                        	  if( !psp.colourLineContours )
                          	    gi.setColour(GenericGraphicsInterface::textColour);
                        	  FOR_3(i1,i2,i3,I1,I2,I3)
                        	  {
                          	    if( CMASK(i1,i2,i3) )
                          	    {
                            	      real u00=U(i1  ,i2  ,i3,component); 
                            	      real u10=U(i1+1,i2  ,i3,component); 
                            	      real u01=U(i1  ,i2+1,i3,component); 
                            	      real u11=U(i1+1,i2+1,i3,component);
                #define XC(i,j) xc[i+2*(j)]
                            	      uc[0]=u00; XC(0,0)=COORD0(i1  ,i2  ,i3); XC(1,0)=COORD1(i1  ,i2  ,i3); 
                            	      uc[1]=u10; XC(0,1)=COORD0(i1+1,i2  ,i3); XC(1,1)=COORD1(i1+1,i2  ,i3);
                            	      uc[2]=u11; XC(0,2)=COORD0(i1+1,i2+1,i3); XC(1,2)=COORD1(i1+1,i2+1,i3);
                            	      uc[3]=u01; XC(0,3)=COORD0(i1  ,i2+1,i3); XC(1,3)=COORD1(i1  ,i2+1,i3);
        	      // note: edges are done in a different order that before.
                            	      drawContourLinesOnAnElement(gi,uc,xc,4,deltaU,deltaUInverse,uMin,uMax,uAverage,uScaleFactor,
                                                					  uRaise,contourLevels,lineStipple,contourLevelsSpecified,psp );
                          	    }
                        	  }
                        	  glLineWidth(psp.size(GraphicsParameters::lineWidth)*gi.getLineWidthScaleFactor()); // reset
                      	}
                      	real time2b=getCPU();
                      	if( showTimings ) printf("contour2d:time for lines=%8.2e\n",time2b-time2a);
                      	if( plotWireFrame ) // to get hidden lines plot a white surface
                      	{
                        	  glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
                        	  glShadeModel(GL_SMOOTH);     // interpolate colours between vertices
                        	  gi.setColour(GenericGraphicsInterface::backGroundColour); // glColor3(1.,1.,1.);
                        	  FOR_3(i1,i2,i3,I1,I2,I3)
                        	  {
                          	    if( CMASK(i1,i2,i3) )
                          	    {
                            	      real u00=U(i1  ,i2  ,i3,component);  // the .sa function permutes the indices
                            	      real u10=U(i1+1,i2  ,i3,component);  // so that i1,i2,i3,component are in the correct
                            	      real u01=U(i1  ,i2+1,i3,component);  // positions for a general grid function
                            	      real u11=U(i1+1,i2+1,i3,component);
                            	      glBegin(GL_POLYGON); 
                            	      glVertex3(COORD0(i1  ,i2  ,i3),COORD1(i1  ,i2  ,i3), (u00-uAverage)*uScaleFactor );
                            	      glVertex3(COORD0(i1+1,i2  ,i3),COORD1(i1+1,i2  ,i3), (u10-uAverage)*uScaleFactor );
                            	      glVertex3(COORD0(i1+1,i2+1,i3),COORD1(i1+1,i2+1,i3), (u11-uAverage)*uScaleFactor );
                            	      glVertex3(COORD0(i1  ,i2+1,i3),COORD1(i1  ,i2+1,i3), (u01-uAverage)*uScaleFactor );
                            	      glEnd();   
                          	    }
                        	  }
                      	}
                      	glPopName();
                      	real time2c=getCPU();
                      	if( showTimings ) printf("contour2d:time for wire frame=%8.2e\n",time2c-time2b);
                      	real time2=getCPU();
                      	if( showTimings ) printf("contour2d:time for shaded, lines, wireframe =%8.2e\n",time2-time1);
                #undef COORD
                #undef COORD0
                #undef COORD1
                #undef COORD2
      	}


#undef U
            

            } // end for p ---------------

        }
        else
        {
      // === unstructured grid ====
            UnstructuredMapping & map = (UnstructuredMapping &) gc[grid].mapping().getMapping();
          	    
            const realArray & x = map.getNodes();
            const int numberOfNodes = map.getNumberOfNodes();
            const int numberOfElements = map.getNumberOfElements();
            const intArray & element = map.getElements();

            realArray uu;
            uu.reference(u);
            glPushName(gc[grid].getGlobalID()); // assign a name for picking

            if( u.getGridFunctionType(component)==GridFunctionParameters::cellCentered )
            {
        // *** this computation should be done once in the calling function ****  fix this ****

                printf(" **** contour plot unstructured: cell centred grid function found! ****\n");
      	
        // grid function is cell centered!
        // For now make a node centered values for plotting by averaging.
                uu.redim(numberOfNodes,u.getComponentDimension(0));   // this could be declared above!!
                uu=0.;
      	
                IntegerArray numElementPerNode(numberOfNodes);
                numElementPerNode=0;
      	
                int e;
      	for( e=0; e<numberOfElements; e++ )
      	{
        	  int numNodes = map.numberOfVertices( UnstructuredMapping::EntityTypeEnum(map.getDomainDimension()),e);//map.getNumberOfNodesThisElement(e);
        	  for( int n=0; n<numNodes; n++ )
        	  {
          	    int nn=element(e,n);
          	    uu(nn,component)+=u(e,0,0,component);
          	    numElementPerNode(nn)+=1;
        	  }
      	}
                for( int n=0; n<numberOfNodes; n++ )
      	{
        	  uu(n,component)/=numElementPerNode(n);
      	}
            }
            else if( u.getGridFunctionType(component)==GridFunctionParameters::faceCentered )
            {
                printf(" **** contour plot unstructured: FACE centred grid function found! ****\n");
      	
        // grid function is cell centered!
        // For now make a node centered values for plotting by averaging.
                uu.redim(numberOfNodes,u.getComponentDimension(0));   // this could be declared above!!
                uu=0.;
      	
                IntegerArray numFacePerNode(numberOfNodes);
                numFacePerNode=0;
      	
                const int numberOfFaces=map.getNumberOfFaces();
      	const intArray & faces = map.getFaces();
      	
                int f;
      	for( f=0; f<numberOfFaces; f++ )
      	{
        	  int numNodes = map.numberOfVertices( UnstructuredMapping::Edge,f);//map.getNumberOfNodesThisFace(f); // this should be 2 
                    assert( numNodes==2 );
        	  for( int n=0; n<numNodes; n++ )
        	  {
          	    int nn=faces(f,n);
          	    uu(nn,component)+=u(f,0,0,component);
          	    numFacePerNode(nn)+=1;
        	  }
      	}
                for( int n=0; n<numberOfNodes; n++ )
      	{
        	  uu(n,component)/=numFacePerNode(n);
      	}
            }
            else
            {
      	uu.reference(u);
            }
            
            const real *xp = x.Array_Descriptor.Array_View_Pointer1;
            const int xDim0=x.getRawDataSize(0);
#define X(i0,i1) xp[i0+xDim0*(i1)]
            const real *up = uu.Array_Descriptor.Array_View_Pointer1;
            const int uDim0=uu.getRawDataSize(0);
#define U(i0,i1) up[i0+uDim0*(i1)]
            const int *elementp = element.Array_Descriptor.Array_View_Pointer1;
            const int elementDim0=element.getRawDataSize(0);
#define ELEMENT(i0,i1) elementp[i0+elementDim0*(i1)]


      // int numberOfNodesPerElement=map.getNumberOfNodesPerElement();
            int i;
            if( plotShadedSurface )
            { 
      	if( plotWireFrame )
        	  glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);  // plot lines on surface for a wireframe

	// for( i=0; i<numberOfElements; i++ )
                UnstructuredMappingIterator iter;
                for( iter=map.begin(UnstructuredMapping::Face,!unsPlotGhost); iter!=map.end(UnstructuredMapping::Face,!unsPlotGhost); iter++ )
      	{
                    i=*iter;
        	  glBegin(GL_POLYGON);  // draw shaded filled polygons
                    const int numNodes=map.numberOfVertices( UnstructuredMapping::EntityTypeEnum(map.getDomainDimension()),i);//mmap.getNumberOfNodesThisElement(i);
        	  for( int n=0; n<numNodes; n++ )
        	  {
          	    int m=ELEMENT(i,n);
          	    real u00=U(m,component);
          	    gi.setColourFromTable( (u00-uMin)*deltaUInverse,psp );
          	    glVertex3(X(m,0),X(m,1),(u00-uAverage)*uScaleFactor );
            		
        	  }
        	  glEnd();   
      	}

      	if( plotWireFrame ) // to get hidden lines plot a white surface
      	{
        	  glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
        	  glShadeModel(GL_SMOOTH);     // interpolate colours between vertices
        	  gi.setColour(GenericGraphicsInterface::backGroundColour); // glColor3(1.,1.,1.);
	  // for( i=0; i<numberOfElements; i++ )
        	  UnstructuredMappingIterator iter;
                    for( iter=map.begin(UnstructuredMapping::Face,!unsPlotGhost); iter!=map.end(UnstructuredMapping::Face,!unsPlotGhost); iter++ )
        	  {
          	    i=*iter;

          	    glBegin(GL_POLYGON); 
          	    const int numNodes=map.numberOfVertices( UnstructuredMapping::EntityTypeEnum(map.getDomainDimension()),i);//mmap.getNumberOfNodesThisElement(i);
          	    for( int n=0; n<numNodes; n++ )
          	    {
            	      int m=ELEMENT(i,n);
            	      real u00=U(m,component);
            	      glVertex3(X(m,0),X(m,1),(u00-uAverage)*uScaleFactor );
          	    }
          	    glEnd();   
        	  }

      	}
            	      
            } // end if( plotShadedSurface )
            if( plotContourLines && deltaU>0.)
            {
      	real *uc= new real [map.getMaxNumberOfNodesPerElement()];
      	real *xc= new real [map.getMaxNumberOfNodesPerElement()*2]; 
            	      
      	glLineWidth(psp.size(GraphicsParameters::majorContourWidth)*psp.size(GraphicsParameters::lineWidth)*
                		    gi.getLineWidthScaleFactor());  
      	if( !psp.colourLineContours )
        	  gi.setColour(GenericGraphicsInterface::textColour);


	// for( i=0; i<numberOfElements; i++ )
      	UnstructuredMappingIterator iter;
                for( iter=map.begin(UnstructuredMapping::Face,!unsPlotGhost); 
           	     iter!=map.end(UnstructuredMapping::Face,!unsPlotGhost); iter++ )
      	{
        	  i=*iter;
        	  const int numNodes=map.numberOfVertices( UnstructuredMapping::EntityTypeEnum(map.getDomainDimension()),i);//mmap.getNumberOfNodesThisElement(i);
        	  for( int n=0; n<numNodes; n++ )
        	  {
          	    int m=ELEMENT(i,n);
          	    uc[n]=U(m,component);
          	    XC(0,n)=X(m,0);
          	    XC(1,n)=X(m,1);
        	  }

        	  drawContourLinesOnAnElement(gi,uc,xc,numNodes,
                              				      deltaU,deltaUInverse,uMin,uMax,uAverage,uScaleFactor,uRaise,
                              				      contourLevels,lineStipple,contourLevelsSpecified,psp );
              		  
      	}

      	glLineWidth(psp.size(GraphicsParameters::lineWidth)*gi.getLineWidthScaleFactor()); // reset
      	delete [] uc;
      	delete [] xc;
            }
            glPopName();

        }
        


    } // end for grid

    if( plotOnThisProcessor )
    {
        glDisable(GL_POLYGON_OFFSET_FILL);
        glPolygonOffset(1.0,0.5*OFFSET_FACTOR);  // reset to default
    }
    
#ifdef USE_PPP
    if( false && PlotIt::parallelPlottingOption==1 )
    {
        printf("*** contourOpt2d: END myid=%i ***\n",myid);
        fflush(0);
        MPI_Barrier(Overture::OV_COMM);
    }
#endif

#undef X
#undef U
#undef ELEMENT


}


int PlotIt::
drawContourLinesOnAnElement(GenericGraphicsInterface &gi,  
                                                          real *u,
                                                          real *xc,
                                                          const int numberOfVerticies,
                                                          const real deltaU,
                                                          const real deltaUInverse,
                                                          const real uMin, 
                                                          const real uMax,
                                                          const real uAverage,
                                                          const real uScaleFactor,
                                                          const real uRaise,
                                                          const RealArray & contourLevels,
                                                          bool & lineStipple,
                                                          bool contourLevelsSpecified,
                                                          GraphicsParameters & psp )
// ============================================================================================
// /Description:
//   Draw all contour lines that cross an element.
// /xc (input): x(i,0:1) -- vertices of the element in a cyclic order. The last vertex is assumed to
//   be connected to the first (not duplicated).
// /u (input): u(i) -- function values on the vertices.
// ============================================================================================
{
    

    real contourLineSpacing=deltaU/max(1,(psp.numberOfContourLevels-1));
  // draw contour lines on the surface, at intervals of contourLineSpacing

//   Range R=numberOfVerticies;  // *wdh* 001025
//   real u0 = min(u(R));
//   real u1 = max(u(R));

    real u0=u[0];
    real u1=u0;
    int i;
    for( i=1; i<numberOfVerticies; i++ )
    {
        if( u[i]<u0 )
        {
            u0=u[i];
        }
        else if( u[i]>u1 )
        {
            u1=u[i];
        }
    }
    

    int iStart=0,iEnd=-1;
    if( !contourLevelsSpecified )
    { // contour values are evenly spaced
        iStart=(int)ceil(max(u0-uMin,0.)/contourLineSpacing);  // smallest int not less than (arg)
        iEnd  =(int)floor(min(u1-uMin,uMax-uMin)/contourLineSpacing);
    }
    else
    { // this assumes that the values in contourLevels are increasing
        for( i=0; i<psp.numberOfContourLevels; i++ )
        {
            if( contourLevels(i) <u0 )
      	iStart=i;
            if( contourLevels(i) <= u1 )
      	iEnd=i;
        }
    }
            	      
    if( u0>=u1 ) iStart++;   // don't draw lines on a flat "surface"
    if( iStart>iEnd ) return 0;
    
    if( iEnd-iStart > psp.numberOfContourLevels )
    {
        printf("drawContourLinesOnAnElement:ERROR: [uMin,uMax]=[%8.3e,%8.3e] [u0,u1]=[%8.3e,%8.3e] [iStart,iEnd]=[%i,%i]\n",
         	   uMin,uMax,u0,u1,iStart,iEnd );
        iStart=0;
        iEnd=psp.numberOfContourLevels-1;
    }
    

//   // **** fix this -- 
//   glLineWidth(psp.size(GraphicsParameters::majorContourWidth)*psp.size(GraphicsParameters::lineWidth)*
// 	      gi.getLineWidthScaleFactor());  

//   if( !psp.colourLineContours )
//     gi.setColour(GenericGraphicsInterface::textColour); // glColor3(0.,0.,0.); // setColour(textColour);

  // loop over the possible contour levels than can pass through this square	
    for( i =iStart; i<=iEnd; i++ )
    {
    // check this contour level 
        real uv = contourLevelsSpecified? contourLevels(i) : i*contourLineSpacing+uMin; 
        if( psp.plotDashedLinesForNegativeContours && uv<0. )
        {
            if( !lineStipple )
            {
      	lineStipple=true;
      	glEnable(GL_LINE_STIPPLE);
	// glLineStipple(2,0xAAAA);  // dash pattern - - - - - - -
      	glLineStipple(1,0x00FF);  // dash pattern --   --   --  --
            }
        }
        else if( lineStipple )
        {
            lineStipple=false;
            glDisable(GL_LINE_STIPPLE);
        }

        glBegin(GL_LINE_STRIP);  // draw line contours
        for( int i=0; i<numberOfVerticies; i++ )
        {
            int ip1=(i+1) % numberOfVerticies;
            
            real ua=u[i];
            real ub=u[ip1];

            if( (uv-ua)*(uv-ub)<=0. )  
            { // contour level crosses this side
      	real denom = ub-ua;
      	denom = (denom==0.) ? 1 : denom;
      	real alpha = (uv-ua)/denom; 
      	alpha=max(0.,min(1.,alpha));
      	real uValue=ua*(1.-alpha)+ub*alpha;
      	if( psp.colourLineContours )
        	  gi.setColourFromTable( (uValue-uMin)*deltaUInverse,psp );
      	glVertex3(XC(axis1,i)*(1.-alpha)+XC(axis1,ip1)*alpha,
              		  XC(axis2,i)*(1.-alpha)+XC(axis2,ip1)*alpha,
              		  (uValue-uAverage)*uScaleFactor+uRaise);  // raise the contour line above the surface!
            }
        }
        glEnd();
//    glLineWidth(psp.size(GraphicsParameters::lineWidth)*gi.getLineWidthScaleFactor()); // reset
    }
    if( lineStipple )
    {
        lineStipple=FALSE;
        glDisable(GL_LINE_STIPPLE);
    }

    return 0;
}
#undef XC



#undef FOR_3


