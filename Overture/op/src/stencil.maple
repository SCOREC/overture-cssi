# restart: read "stencil.maple";
with(StringTools):

# read in the DuDx array of derivative definitions:
read "derivativesByChainRule.maple":

rName := [ r, s, t ]:
rxName:= [ rx, ry, rz, sx, sy, sz, tx, ty, tz ]:

nMax:=11:     # max stencil size
nd:=nMax-1:
md:=nd:

read "differenceWeights.maple";
# compute difference weights for derivatives to various orders of accuracy, return results in c
computeDifferenceWeights(nd,md,c):


getStencilCoefficient :=proc( dudx,i1,i2,i3, maxPartial, orderOfAccuracy,dim )
# *******************************************************************************
# dudx (input) : symbolic representation of the operator such as
#                   dudx := rx^2*urr + ...:
# i1,i2,i3 (input) : stencil position, eg. (i1,i2,i3)=(-1,0,0)
# maxPartial (input) : the largest partial derivative to be expected
# orderOfAccuracy (input) : order of accuracy (2,4,6,..)
# dim : number of space dimensions
# *******************************************************************************

local nr,ns,nt,urn,u,i,cw,idz,cd,rName,dr,ds,dt:

rName := [ r, s, t ]:
cd := dudx:

if dim=2 then idz:=0: else idz:=maxPartial: end if:

# for each parametric derivative ur, us, urr, ...
for nt from 0 to idz do:
for ns from 0 to maxPartial do:
for nr from 0 to maxPartial do:
if nr+ns+nt > 0 then

  # form the name of this parametric derivative, such as ur or urs etc.
  urn := u;
  for i from 1 to nr do urn:=cat(urn,rName[1]): end do:
  for i from 1 to ns do urn:=cat(urn,rName[2]): end do:
  for i from 1 to nt do urn:=cat(urn,rName[3]): end do:

  # Note for nr=0 : the operator is the identity: 1 for i1=0, 0 otherwise
  cw := 1:
  cw := cw*getWeight(i1,nr,orderOfAccuracy)/dr^nr:
  cw := cw*getWeight(i2,ns,orderOfAccuracy)/ds^ns: 
  if dim=3 then cw := cw*getWeight(i3,nt,orderOfAccuracy)/dt^nt: end if:

  if 0=1 then 
    printf("getStencilCoeff: nr=%d ns=%d : coeff of %s(%d,%d,%d) = %s\n",nr,ns,convert(urn,string),
           i1,i2,i3,convert(cw,string)):
  end if:
  cd := subs(urn=cw,cd):

end if:
end do:
end do:
end do:

RETURN(cd):
end:

# restart: read "stencil.maple";

# --------------------------------------------------------------------------------
  # -----------
  substituteStrings :=proc( cd )
   local m,cds,rxs:
    cds := convert(cd,string):
    cds := SubstituteAll(cds,"^","**"):
    cds := SubstituteAll(cds,"0*","0.*"):
    cds := SubstituteAll(cds,"1*","1.*"):
    cds := SubstituteAll(cds,"2*","2.*"):
    cds := SubstituteAll(cds,"3*","3.*"):
    cds := SubstituteAll(cds,"4*","4.*"):
    cds := SubstituteAll(cds,"5*","5.*"):
    cds := SubstituteAll(cds,"6*","6.*"):
    cds := SubstituteAll(cds,"7*","7.*"):
    cds := SubstituteAll(cds,"8*","8.*"):
    cds := SubstituteAll(cds,"9*","9.*"):

    cds := SubstituteAll(cds,"dr","(dr)"):
    cds := SubstituteAll(cds,"ds","(ds)"):
    cds := SubstituteAll(cds,"dt","(dt)"):

    for m from 1 to 9 do
      rxs := convert(rxName[m],string):
      cds := SubstituteAll(cds,rxs,cat("aj ## ",rxs)):
    end do:

  RETURN(cds):
  end:
  # -------------


fileName:="derivStencilCoeff.h":
file := fopen( fileName,WRITE ):

fprintf(file,"! This file was generated by Overture/op/src/stencil.maple\n"):
fprintf(file,"! Here are the coefficients of the ghost points (left side) in some stencils for derivatives.\n"):
fprintf(file,"! Use -dr, -ds or -dt to get ghost points on the right side.\n"):
fprintf(file,"\n\n"):

dim:=2:  # 2D or 3D
maxOrder:=6:
maxPartial:=6: 


ndd:=9+10:  # 9+10 # total number of derivatives that we get coefficients for 
dudxa := array(1..ndd):
dNamea := array(1..ndd):
ordera := array(1..ndd):
numDeriv := array(1..ndd):
m:=1:
dNamea[m]:="x": dudxa[m]:=DuDx[1,0,0,dim]: ordera[m]:=maxOrder: numDeriv[m]:=1: m:=m+1:
dNamea[m]:="y": dudxa[m]:=DuDx[0,1,0,dim]: ordera[m]:=maxOrder:  numDeriv[m]:=1: m:=m+1:
dNamea[m]:="lap": dudxa[m]:=DuDx[2,0,0,dim]+ DuDx[0,2,0,dim]: ordera[m]:=maxOrder: numDeriv[m]:=2: m:=m+1:
dNamea[m]:="xLap": dudxa[m]:=DuDx[3,0,0,dim]+ DuDx[1,2,0,dim]: ordera[m]:=maxOrder-2: numDeriv[m]:=3: m:=m+1:
dNamea[m]:="yLap": dudxa[m]:=DuDx[2,1,0,dim]+ DuDx[0,3,0,dim]: ordera[m]:=maxOrder-2: numDeriv[m]:=3: m:=m+1:
dNamea[m]:="lapSq": dudxa[m]:=DuDx[4,0,0,dim]+ 2*DuDx[2,2,0,dim]+ DuDx[0,4,0,dim]: 
                   ordera[m]:=maxOrder-2: numDeriv[m]:=4: m:=m+1:
dNamea[m]:="xLapSq": dudxa[m]:=DuDx[5,0,0,dim]+ 2*DuDx[3,2,0,dim]+ DuDx[1,4,0,dim]: 
                    ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="yLapSq": dudxa[m]:=DuDx[4,1,0,dim]+ 2*DuDx[2,3,0,dim]+ DuDx[0,5,0,dim]: 
                    ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="lapCubed": dudxa[m]:=DuDx[6,0,0,dim]+ 3*(DuDx[4,2,0,dim]+DuDx[2,4,0,dim])+ DuDx[0,6,0,dim]: 
                      ordera[m]:=maxOrder-4: numDeriv[m]:=6: m:=m+1:

# for fixup:
#      real c1xxy4(3),c1yyy4(3),c1xxxxy2(3),c1xxyyy2(3),c1yyyyy2(3), c1xxxyy2(3),c1xyyyy2(3)

dNamea[m]:="xxx": dudxa[m]:=DuDx[3,0,0,dim]: ordera[m]:=maxOrder-2: numDeriv[m]:=3: m:=m+1:
dNamea[m]:="xxy": dudxa[m]:=DuDx[2,1,0,dim]: ordera[m]:=maxOrder-2: numDeriv[m]:=3: m:=m+1:
dNamea[m]:="xyy": dudxa[m]:=DuDx[1,2,0,dim]: ordera[m]:=maxOrder-2: numDeriv[m]:=3: m:=m+1:
dNamea[m]:="yyy": dudxa[m]:=DuDx[0,3,0,dim]: ordera[m]:=maxOrder-2: numDeriv[m]:=3: m:=m+1:

dNamea[m]:="xxxxx": dudxa[m]:=DuDx[5,0,0,dim]: ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="xxxxy": dudxa[m]:=DuDx[4,1,0,dim]: ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="xxxyy": dudxa[m]:=DuDx[3,2,0,dim]: ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="xxyyy": dudxa[m]:=DuDx[2,3,0,dim]: ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="xyyyy": dudxa[m]:=DuDx[1,4,0,dim]: ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:
dNamea[m]:="yyyyy": dudxa[m]:=DuDx[0,5,0,dim]: ordera[m]:=maxOrder-4: numDeriv[m]:=5: m:=m+1:

for orderOfAccuracy from 2 by 2 to maxOrder do

  fprintf(file,"\n! *** orderOfAccuracy = %d \n\n",orderOfAccuracy):

for ii from 1 to ndd do
if orderOfAccuracy<=ordera[ii] then

  dudx:=dudxa[ii]:
  dName:=dNamea[ii]:
  
  halfWidth:=floor( (orderOfAccuracy+(numDeriv[ii]-1))/2 ): 

  printf("..Derivative %s, order=%d, dim=%d halfWidth=%d\n",convert(dName,string),orderOfAccuracy,dim,halfWidth):
  # printf("\n Derivative DuDx=%s\n",convert(dudx,string)):
  
  # Easier: to get opposite ghost value just set dr -> -dr 
  # dudx := subs(ur=is*ur,urrr=is*urrrr,urrrrr=is*urrrrr,urrrrrrr=is*urrrrrrr,dudx):

  # names are uxxCoeffOrder%iGhostr1s0t0 : 

  # Find the coefficient of point u(i1,i2,i3) 
  i1:=-1: 
  i2:=0: i3:=0:
  for i2 from 0 by -1 to -halfWidth do
  for i1 from 0 by -1 to -halfWidth do
    if (i2=0 and i1<0) or (i1=0 and i2<0) then
      cd := getStencilCoefficient( dudx,i1,i2,i3, maxPartial, orderOfAccuracy,dim ):
      cd:=collect(simplify(cd),{dr,ds,dt}):
      # dn:=denom(cd):
      cds:=substituteStrings(cd):
  
      # printf(" Derivative: coeff(%d,%d,%d) = %s \n",i1,i2,i3,convert(cds,string)):
  
      if dim=2 then
        fprintf(file,"#defineMacro %sCoeff%ddOrder%dGhost%d%d(aj,dr,ds) ( %s )\n\n",convert(dName,string),
                dim,orderOfAccuracy,-i1,-i2,convert(cds,string)):
      else
        fprintf(file,"#defineMacro %sCoeff%ddOrder%dGhost%d%d%d(aj,dr,ds,dt) ( %s )\n\n",convert(dName,string),
                dim,orderOfAccuracy,-i1,-i2,-i3,convert(cds,string)):
      end if:

    #  printf(" Derivative: coeff(%d,%d,%d) = %s (denom=%s)\n",i1,i2,i3,convert(cds,string),convert(dn,string)):
    #                     convert(denom(cd),string),):
    end if
  end do:
  end do:

end if:
end do: # end ii

end do: # orderOfAccuracy

fclose(file):

printf(" **** output written to file [%s] ******\n",fileName);


# restart; read "stencil.maple";