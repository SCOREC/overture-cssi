// This file automatically generated from BodyForce.bC with bpp.
#include "BodyForce.h"
#include "AnnulusMapping.h"
#include "BoxMapping.h"
#include "SquareMapping.h"
#include "GenericGraphicsInterface.h"
#include "xColours.h"
#include "UnstructuredMapping.h"

// ====================================================================================
// This class holds information about different body forces.
// It is used in setupBodyForcing and computeBodyForcing.
// ====================================================================================
BodyForce::
BodyForce()
{
    initialize();
}

BodyForce::
~BodyForce()
{
    aString & regionType = dbase.get<aString>("regionType");

    if( false )
        printF("BodyForce: destructor called for bodyForcingName=[%s]\n",
         	   (const char*)dbase.get<aString >("bodyForcingName"));

    if( regionType=="mapping" )
    {
        if( dbase.has_key("bodyForceMapping") )
        {
            printF("~BodyForce(): delete bodyForceMapping\n");
            delete dbase.get<MappingRC*>("bodyForceMapping");
        }
    }
}

// ====================================================================================
/// \brief Initialize a BodyForce.
// ====================================================================================
void BodyForce::
initialize()
{

    if( !dbase.has_key("bodyForcingName") ) dbase.put<aString>("bodyForcingName");
    dbase.get<aString >("bodyForcingName")="bodyForcingDefaultName";

  // forcingType: name of the forcing, e.g. "dragForce", "wakeModel"
    if( !dbase.has_key("forcingType") ) dbase.put<aString >("forcingType");
    dbase.get<aString >("forcingType")="unknown";

  // addForcing is true of we add this forcing to the current forcings, otherwise we set the forcing and
  // over-write current forcings.
    if( !dbase.has_key("addForcing") ) dbase.put<bool >("addForcing",true);

  // forcingIsTimeDependent : true if the forcing depends on time
    if( !dbase.has_key("forcingIsTimeDependent") ) dbase.put<bool >("forcingIsTimeDependent",true);

  // forcingHasBeenAssigned : set to true when the forcing has been assigned (for time-independent forcing)
    if( !dbase.has_key("forcingHasBeenAssigned") ) dbase.put<bool >("forcingHasBeenAssigned",false);

  // visible : true if this region should be plotted (some forcings use the same regions as others)
    if( !dbase.has_key("visible") ) dbase.put<bool >("visible",true);

  // regionType is "box", "ellipse" , ...
    if( !dbase.has_key("regionType") ) dbase.put<aString>("regionType");
    dbase.get<aString>("regionType")="none";

  // linesToPlot[3] is used when plotting regions (e.g. number of lines on a box)
    if( !dbase.has_key("linesToPlot") ) dbase.put<int[3]>("linesToPlot"); 
    int *linesToPlot= dbase.get<int[3]>("linesToPlot"); 
    linesToPlot[0]=linesToPlot[1]=linesToPlot[2]=11;
    
    if( !dbase.has_key("colour") ) dbase.put<int>("colour");
    dbase.get<int>("colour")=getXColour("DARKTURQUOISE"); // default colout


}


// ====================================================================================
/// \brief copy constructor
// ====================================================================================
BodyForce::
BodyForce( const BodyForce & bf )
{
    printF("BodyForce: copy constructor called! bf.bodyForcingName=[%s]\n",
                    (const char*)bf.dbase.get<aString >("bodyForcingName"));

    initialize();
    *this = bf;
}


// =====================================================================================
/// \brief equals operator
// =====================================================================================
BodyForce & BodyForce::
operator=( const BodyForce & bf )
{

    printF("BodyForce: operator= called! bf.bodyForcingName=[%s]\n",
                    (const char*)bf.dbase.get<aString >("bodyForcingName"));


    return *this;
}



//=================================================================================
/// \brief Get the BodyForce object from the database
//=================================================================================
int BodyForce::
get( const GenericDataBase & dir, const aString & name)
{
    GenericDataBase & subDir = *dir.virtualConstructor();
    dir.find(subDir,name,"BodyForce");

    subDir.get( dbase.get<aString>("bodyForcingName"),"bodyForcingName" );
    subDir.get( dbase.get<aString>("forcingType"),"forcingType" );            
    subDir.get( dbase.get<bool>("addForcing"),"addForcing" );            
    subDir.get( dbase.get<bool>("forcingIsTimeDependent"),"forcingIsTimeDependent" );            
    subDir.get( dbase.get<bool>("forcingHasBeenAssigned"),"forcingHasBeenAssigned" );       
    subDir.get( dbase.get<bool>("visible"),"visible" );            
    subDir.get( dbase.get<int>("colour"),"colour" );            

    aString & regionType = dbase.get<aString>("regionType");
    subDir.get( regionType,"regionType" );            
    subDir.get( dbase.get<int[3]>("linesToPlot"), "linesToPlot",3 );

    if( regionType=="box" )
    {
        if( !dbase.has_key("boxBounds") ) dbase.put<real[6]>("boxBounds");
        subDir.get( dbase.get<real[6]>("boxBounds"),"boxBounds",6 );
    }
    else if( regionType=="ellipse" )
    {
        if( !dbase.has_key("ellipse") ) dbase.put<real[6]>("ellipse");
        subDir.get( dbase.get<real[6]>("ellipse"),"ellipse",6 );
    }
    else if( regionType=="maskFromGridFunction" )
    {
    // region defined from a mask in a grid function
    // *FINISH ME*
    }  
    else if( regionType=="mapping" )
    {
        if( !dbase.has_key("bodyForceMapping") ) dbase.put<MappingRC*>("bodyForceMapping");
        MappingRC*& bodyForceMapping= dbase.get<MappingRC*>("bodyForceMapping");
        bodyForceMapping = new MappingRC();
        bodyForceMapping->get(subDir,"mapping");  // this will "make" the correct type of Mapping
    }

//   subDir.get( xa,"xa" );
//   subDir.get( ya,"ya" );
//   subDir.get( xb,"xb" );
//   subDir.get( yb,"yb" );
//   subDir.get( z ,"z" );

    delete &subDir;
    return 0; 
}

//=================================================================================
/// \brief Put the BodyForce object into the database
//=================================================================================
int BodyForce::
put( GenericDataBase & dir, const aString & name) const
{  
    GenericDataBase & subDir = *dir.virtualConstructor();      // create a derived data-base object
    dir.create(subDir,name,"BodyForce");                      // create a sub-directory 

    subDir.put( dbase.get<aString>("bodyForcingName"),"bodyForcingName" );
    subDir.put( dbase.get<aString>("forcingType"),"forcingType" );            
    subDir.put( dbase.get<bool>("addForcing"),"addForcing" );            
    subDir.put( dbase.get<bool>("forcingIsTimeDependent"),"forcingIsTimeDependent" );            
    subDir.put( dbase.get<bool>("forcingHasBeenAssigned"),"forcingHasBeenAssigned" );            
    subDir.put( dbase.get<bool>("visible"),"visible" );            
    subDir.put( dbase.get<int>("colour"),"colour" );            

  // This may not aways exist: *fix me*      
    const aString & regionType = dbase.get<aString>("regionType");
    subDir.put( regionType,"regionType" );            
    subDir.put( dbase.get<int[3]>("linesToPlot"), "linesToPlot",3 );
    
    if( regionType=="box" )
    {
        subDir.put( dbase.get<real[6]>("boxBounds"),"boxBounds",6 );
    }
    else if( regionType=="ellipse" )
    {
        subDir.put( dbase.get<real[6]>("ellipse"),"ellipse",6 );
    }
    else if( regionType=="maskFromGridFunction" )
    {
    // region defined from a mask in a grid function
    // *FINISH ME*
    }  
    else if( regionType=="mapping" )
    {
        MappingRC *pMap = dbase.get<MappingRC*>("bodyForceMapping");
        assert( pMap!=NULL );
        pMap->put(subDir,"mapping" );
    }
    
    delete &subDir;
    return 0;
}



// ==================================================================================================
// Here is the class where we keep current parameters that define the current region for a body force:
// These parameters are only used while the body force is being defined.
// ==================================================================================================
BodyForceRegionParameters::
BodyForceRegionParameters()
{
  // regionType : name of the region:
    if( !dbase.has_key("regionType") ) dbase.put<aString >("regionType");
    dbase.get<aString >("regionType")="box";


  // Default box bounds:
    real xa=0., xb=1., ya=0., yb=1., za=0., zb=1.;
    dbase.put<real[6] >("boxBounds");
    real *boxBounds =  dbase.get<real[6] >("boxBounds");
    boxBounds[0]=xa;
    boxBounds[1]=xb;
    boxBounds[2]=ya;
    boxBounds[3]=yb;
    boxBounds[4]=za;
    boxBounds[5]=zb;


  // Default ellipse: [(x-xe)/ae]^2 + [(y-ye)/be]^2 + [(z-ze)/ce]^2 = 1 
    real ae=1., be=1., ce=1., xe=0., ye=0., ze=0.;
    dbase.put<real[6] >("ellipse");
    real *ellipse =  dbase.get<real[6] >("ellipse");
    ellipse[0]=ae;
    ellipse[1]=be;
    ellipse[2]=ce;
    ellipse[3]=xe;
    ellipse[4]=ye;
    ellipse[5]=ze;

  // profile type: name of the forcing profile: uniform, parabolic, ..
    if( !dbase.has_key("profileType") ) dbase.put<aString >("profileType");
    dbase.get<aString >("profileType")="uniform";

    if( !dbase.has_key("parabolicProfileDepth") ) dbase.put<real>("parabolicProfileDepth",0.1);
    if( !dbase.has_key("tanhProfileExponent") ) dbase.put<real>("tanhProfileExponent",10.);

  // Specify number of lines to use when plotting the region:
    dbase.put<int[3] >("linesToPlot");
    int *linesToPlot =  dbase.get<int[3] >("linesToPlot");
    linesToPlot[0]=linesToPlot[1]=linesToPlot[2]=10;

}

BodyForceRegionParameters::
~BodyForceRegionParameters()
{
    if( dbase.has_key("bodyForceMapping") )
    {
        printF("~BodyForceRegionParameters(): delete bodyForceMapping\n");
        delete dbase.get<MappingRC*>("bodyForceMapping");
    }
}


// ==========================================================================================
//  This macro plots body/boundary forcing regions
// ==========================================================================================

// ======================================================================================
/// \brief Plot body/boundary forcing regions and immersed boundaries. 
/// \details We interactively check for answers if the calling program has set GI\_PLOT\_THE_OBJEC\T_AND\_EXIT to false,
/// otherwise we plot the regions and exit.
///
/// \param dbase (input) : DataBase holding the lists of body and boundary forcings.
/// \param cg (input) : the current grid.
// ======================================================================================
int BodyForce::
plotForcingRegions( GenericGraphicsInterface &gi, DataBase & dbase, CompositeGrid & cg, 
                		    GraphicsParameters & pspGlobal )
{

    if( !dbase.has_key("turnOnBodyForcing") )
            return 0;

    if( !dbase.get<bool >("turnOnBodyForcing") &&
      !dbase.get<bool>("turnOnBoundaryForcing") )
    {
    // there are no body or boundary forcings defined
        return 0;
    }

    const int numberOfDimensions = cg.numberOfDimensions();

    if( !dbase.has_key("lineWidth") )
    {// line width for 2d curves
        dbase.put<real>("lineWidth");
        dbase.get<real>("lineWidth")=3.;
    }
    real & lineWidth=dbase.get<real>("lineWidth");

  // We interactively check for answers if the calling program has set GI_PLOT_THE_OBJECT_AND_EXIT to false,
  // otherwise we plot the regions and exit.
    int plotObjectAndExit=true;
    pspGlobal.get(GI_PLOT_THE_OBJECT_AND_EXIT,plotObjectAndExit);

  // Here is a GraphicsParameters for saving properties of the body and boundary forcing
    if( !dbase.has_key("bodyForcingGraphicsParameters")) 
    {
        dbase.put<GraphicsParameters>("bodyForcingGraphicsParameters");
        GraphicsParameters & pspBody = dbase.get<GraphicsParameters>("bodyForcingGraphicsParameters");
    // set initial values
        pspBody.getBoundaryColourOption()=GraphicsParameters::defaultColour; // GraphicsParameters::colourByGrid;
        pspBody.set(GI_BLOCK_BOUNDARY_COLOUR_OPTION,GraphicsParameters::defaultColour); // means use mapping colour
        pspBody.set(GI_BOUNDARY_COLOUR_OPTION,GraphicsParameters::colourByGrid);  // for 2D

        pspBody.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,true);   // 2d grid lines: OFF?  *BUT* THIS IS ALSO FOR 2D LINES !! so ON!
        pspBody.set(GI_PLOT_LINES_ON_MAPPING_BOUNDARIES,false); // 3d lines : OFF
        pspBody.set(GI_MAPPING_COLOUR,"DARKTURQUOISE");

        pspBody.set(GI_PLOT_GRID_POINTS_ON_CURVES,false);  // grid points on curves OFF by default

    // Unstructured mappings: 
        pspBody.set(GI_PLOT_UNS_FACES,true);
        pspBody.set(GI_PLOT_UNS_EDGES,false);
        pspBody.set(GI_PLOT_UNS_BOUNDARY_EDGES,false);

    }
    GraphicsParameters & pspBody = dbase.get<GraphicsParameters>("bodyForcingGraphicsParameters");
    if( !dbase.has_key("boundaryForcingGraphicsParameters")) 
    {
        dbase.put<GraphicsParameters>("boundaryForcingGraphicsParameters");
        GraphicsParameters & pspBoundary = dbase.get<GraphicsParameters>("boundaryForcingGraphicsParameters");
    // set initial values
        pspBoundary.getBoundaryColourOption()=GraphicsParameters::defaultColour; // GraphicsParameters::colourByGrid;
        pspBoundary.set(GI_BLOCK_BOUNDARY_COLOUR_OPTION,GraphicsParameters::defaultColour); // means use mapping colour
        pspBoundary.set(GI_BOUNDARY_COLOUR_OPTION,GraphicsParameters::colourByGrid);  // for 2D

        pspBoundary.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,false);   // 2d grid lines: OFF
        pspBoundary.set(GI_PLOT_LINES_ON_MAPPING_BOUNDARIES,false); // 3d lines : OFF
        pspBoundary.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,false);   // shaded surfaces : OFF
        pspBoundary.set(GI_PLOT_NON_PHYSICAL_BOUNDARIES,false);
        pspBoundary.set(GI_MAPPING_COLOUR,"DARKORCHID");

    // Unstructured mappings: 
        pspBoundary.set(GI_PLOT_UNS_FACES,true);
        pspBoundary.set(GI_PLOT_UNS_EDGES,false);
        pspBoundary.set(GI_PLOT_UNS_BOUNDARY_EDGES,false);
    }
    GraphicsParameters & pspBoundary = dbase.get<GraphicsParameters>("boundaryForcingGraphicsParameters");

    int bodyForcePlotShaded;
    int bodyForcePlotBlockBoundaries;
    int bodyForcePlotGridLines;
    pspBody.get(GI_PLOT_SHADED_MAPPING_BOUNDARIES,bodyForcePlotShaded);
    pspBody.get(GI_PLOT_LINES_ON_MAPPING_BOUNDARIES,bodyForcePlotGridLines);
    pspBody.get(GI_PLOT_BLOCK_BOUNDARIES,bodyForcePlotBlockBoundaries);

    int boundaryForcePlotShaded;
    int boundaryForcePlotBlockBoundaries;
    int boundaryForcePlotGridLines;
    pspBoundary.get(GI_PLOT_SHADED_MAPPING_BOUNDARIES,boundaryForcePlotShaded);
    pspBoundary.get(GI_PLOT_LINES_ON_MAPPING_BOUNDARIES,boundaryForcePlotGridLines);
    pspBoundary.get(GI_PLOT_BLOCK_BOUNDARIES,boundaryForcePlotBlockBoundaries);


    enum PickingOptionEnum
    {
        pickingOff,
        pickToColourBlocks,
        pickToEditRegion,
    } pickingOption=pickingOff;

    bool pickClosest=false;  // if true only pick the closest of the chosen items, other use all
    int pickColourIndex=getXColour("aquamarine");  // index of the colour used for pick to colour grids

    GUIState dialog;
  // --- Build the sibling dialog for colour dialog ---
    DialogData & colourDialog = dialog.getDialogSibling();
    colourDialog.setWindowTitle("Pick colour");
    colourDialog.setExitCommand("close colour choices", "close");

    if( !plotObjectAndExit )
    {
        dialog.setWindowTitle("Forcing Regions Plotter");
        dialog.setExitCommand("exit", "exit");

        PlotIt::buildColourDialog(colourDialog);

        aString pbCommands[] = {"plot",
                            // "plot the grid",
                                                        "regions info",
                                                        "pick colour...",
                      			    "exit",
                      			    ""};

        int numRows=4;
        dialog.setPushButtons( pbCommands, pbCommands, numRows ); 

    // --- Here are the picking options ---
        aString opcmd[] = {"pick off",
                                              "pick to colour blocks",
                                              "pick to edit region",
                                              ""};
        aString opLabel[] = {"off",
                                                  "colour blocks",
                                                  "edit region",
                                                  ""};
        dialog.addOptionMenu("Pick to:", opcmd,opLabel,pickingOption);


        aString tbCommands[] = {"body force shaded surfaces",
                      			    "body force block boundaries",
                      			    "body force grid lines",
                                                        "boundary force shaded surfaces",
                          			    "boundary force block boundaries",
                      			    "boundary force grid lines",
                                                        "pick closest",
                      			    ""};
        int tbState[10];
        tbState[0] = bodyForcePlotShaded;
        tbState[1] = bodyForcePlotBlockBoundaries;
        tbState[2] = bodyForcePlotGridLines;
        tbState[3] = boundaryForcePlotShaded;
        tbState[4] = boundaryForcePlotBlockBoundaries;
        tbState[5] = boundaryForcePlotGridLines;
        tbState[6] = pickClosest;
        int numColumns=1;
        dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns); 

        const int numberOfTextStrings=5;  // max number allowed
        aString textLabels[numberOfTextStrings];
        aString textStrings[numberOfTextStrings];


        int nt=0;
        textLabels[nt] = "line width:";  sPrintF(textStrings[nt],"%g",lineWidth);  nt++; 

    // null strings terminal list
        textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
        dialog.setTextBoxes(textLabels, textLabels, textStrings);


        gi.pushGUI( dialog );
    }


    int debug=0;
    if( dbase.has_key("debug" ) )
        debug = dbase.get<int>("debug");
    

    bool plotObject=true;
    aString answer,pickColour;
    SelectionInfo select; select.nSelect=0;
    int len=0;
    
    for( int it=0; ;it++)
    {
        if( it==0 )
            answer="plot";               // plot first time through 
        else if( it==1 && plotObjectAndExit )
            answer="exit this menu";
        else
        {
      // gi.getAnswer(answer,"");
            gi.savePickCommands(false); // temporarily turn off saving of pick commands.     
            gi.getAnswer(answer,"", select);
            gi.savePickCommands(true); // turn back on
        }
        

        if( answer=="exit" || answer=="exit this menu" )
        {
            break;
        }
        else if( dialog.getTextValue(answer,"line width:","%e",lineWidth) ){}  //
        else if( answer=="pick to colour blocks" || 
                          answer=="pick to edit region"   ||
                          answer=="pick off" )
        {
            pickingOption= (answer=="pick to colour blocks"  ? pickToColourBlocks :
                                            answer=="pick to edit region"    ? pickToEditRegion : 
                                            pickingOff);
            
            dialog.getOptionMenu("Pick to:").setCurrentChoice((int)pickingOption);
        }
        else if( (pickingOption==pickToColourBlocks || pickingOption==pickToEditRegion ) && 
           	     (select.active || select.nSelect ) )
        {
      // --- the user has picked an item ---
            if( pickClosest )
            {
                printF("Look for the closest item picked...(toggle `pick closest' to choose all items picked)\n");
            }
            else
            {
                printF("Look for the all items picked... (toggle `pick closest' to only choose the closest)\n");
            }

            if( dbase.get<bool >("turnOnBodyForcing") )
            {
	// Here is the array of body forcings:
      	std::vector<BodyForce*> & bodyForcings =  dbase.get<std::vector<BodyForce*> >("bodyForcings");
      	
      	for( int bf=0; bf<bodyForcings.size(); bf++ )
      	{
        	  BodyForce & bodyForce = *bodyForcings[bf];
                    if( !bodyForce.dbase.has_key("globalID") ) bodyForce.dbase.put<int>("globalID",-1); 
        	  const int & globalID = bodyForce.dbase.get<int>("globalID");
      	
        	  for( int i=0; i<(pickClosest ? 1 : select.nSelect); i++ )
        	  {
	    // printF("body.globalID=%i, select.globalID=%i\n",globalID,select.globalID);
          	    
          	    if( (pickClosest && globalID==select.globalID) ||
            		(!pickClosest && globalID==select.selection(i,0)) )
          	    {

            	      if( pickingOption==pickToColourBlocks )
            	      {
		// the value of pickColourIndex was set elsewhere
            		const aString pickColour=getXColour(pickColourIndex);

            		const aString & bodyForcingName= bodyForce.dbase.get<aString > ("bodyForcingName");
            		printF("Colour forcing region %i (%s) to be %s.\n",
                   		       bf,(const char*)bodyForcingName,(const char*)pickColour);

            		gi.outputToCommandFile(sPrintF(answer,"forcing region colour (bf,colour): %i %s\n",
                                     					       bf,(const char*)pickColour));
                            
            		if( !bodyForce.dbase.has_key("colour") ) bodyForce.dbase.put<int>("colour");
                                bodyForce.dbase.get<int>("colour")=pickColourIndex;

                // -- we need to erase the old display lists for unstructured mappings -- FIX ME
            		if( bodyForce.dbase.get<aString>("regionType")=="mapping" )
            		{
                                    MappingRC *& bodyForceMapping = bodyForce.dbase.get<MappingRC*>("bodyForceMapping");
                                    Mapping & map = bodyForceMapping->getMapping();
              		  if( map.getClassName()=="UnstructuredMapping" )
              		  {
                		    UnstructuredMapping & uns = (UnstructuredMapping&)map;
                		    uns.eraseUnstructuredMapping(gi);
              		  }
            		}

                        	gi.erase();
            		plotObject=true;
            	      } // end pickToColourBlocks
                            else if(  pickingOption==pickToEditRegion )
            	      {
                // --- edit the region ---
                // For now this means edit the mapping associated with the region

            		const aString & bodyForcingName= bodyForce.dbase.get<aString > ("bodyForcingName");
            		printF("Edit mapping for forcing region %i (%s).\n",bf,(const char*)bodyForcingName);

            		gi.outputToCommandFile(sPrintF(answer,"edit forcing region: %i\n",bf));

            		if( bodyForce.dbase.get<aString>("regionType")=="mapping" )
            		{
                                    MappingRC *& bodyForceMapping = bodyForce.dbase.get<MappingRC*>("bodyForceMapping");
                                    Mapping & map = bodyForceMapping->getMapping();
                                	  gi.erase();
                                    map.interactiveUpdate(gi) ;
            		}
    
                        	gi.erase();
            		plotObject=true;
            	      }
            	      
            	      
          	    }
        	  }
      	}
            }
        }
        else if( (len=answer.matches("forcing region colour (bf,colour):")) )
        {
      // here we process the command line that changes a body colour
            char colour[100];
            int bf=-1;
            sScanF( &answer[len],"%i %s",&bf,colour);
            if( dbase.get<bool >("turnOnBodyForcing") )
            {
	// Here is the array of body forcings:
      	std::vector<BodyForce*> & bodyForcings =  dbase.get<std::vector<BodyForce*> >("bodyForcings");
                
      	const int numberOfBodyForcingRegions=bodyForcings.size();
      	
      	if( bf<0 || bf>=numberOfBodyForcingRegions )
      	{
        	  printF("plotForcingRegions::ERROR:set colour: body forcing region %i is invalid! numberOfBodyForcingRegions=%i\n",
                                  bf,numberOfBodyForcingRegions);
        	  gi.stopReadingCommandFile();
        	  continue;
      	}
                BodyForce & bodyForce = *bodyForcings[bf];

      	int index=getXColour(colour);
      	if( index==0 )
      	{
        	  printF("plotForcingRegions::ERROR: colour=[%s] not recognized! using DARKTURQUOISE instead\n",(const char*)colour);
        	  index=getXColour("DARKTURQUOISE");
      	}
      	printF(" Setting forcing region %i to colour=%s (X colour index=%i)\n",bf,(const char*)colour,index);
      	if( !bodyForce.dbase.has_key("colour") ) bodyForce.dbase.put<int>("colour");
      	bodyForce.dbase.get<int>("colour")=index;

	// -- we need to erase the old display lists for unstructured mappings -- FIX ME
      	if( bodyForce.dbase.get<aString>("regionType")=="mapping" )
      	{
        	  MappingRC *& bodyForceMapping = bodyForce.dbase.get<MappingRC*>("bodyForceMapping");
        	  Mapping & map = bodyForceMapping->getMapping();
        	  if( map.getClassName()=="UnstructuredMapping" )
        	  {
          	    UnstructuredMapping & uns = (UnstructuredMapping&)map;
          	    uns.eraseUnstructuredMapping(gi);
        	  }
      	}
      	gi.erase();
                plotObject=true;
            }
            else
            {
      	printF("WARNING:There are no body forcing regions to colour!\n");
            }
            
        }
        else if( (len=answer.matches("edit forcing region:")) )
        {
      // -- edit a body forcing region --
            int bf=-1;
            sScanF( &answer[len],"%i",&bf);
            if( dbase.get<bool >("turnOnBodyForcing") )
            {
	// Here is the array of body forcings:
      	std::vector<BodyForce*> & bodyForcings =  dbase.get<std::vector<BodyForce*> >("bodyForcings");
                
      	const int numberOfBodyForcingRegions=bodyForcings.size();
      	
      	if( bf<0 || bf>=numberOfBodyForcingRegions )
      	{
        	  printF("plotForcingRegions::ERROR:edit region: body forcing region %i is invalid! numberOfBodyForcingRegions=%i\n",
                                  bf,numberOfBodyForcingRegions);
        	  gi.stopReadingCommandFile();
        	  continue;
      	}
                BodyForce & bodyForce = *bodyForcings[bf];

      	if( bodyForce.dbase.get<aString>("regionType")=="mapping" )
      	{
        	  MappingRC *& bodyForceMapping = bodyForce.dbase.get<MappingRC*>("bodyForceMapping");
        	  Mapping & map = bodyForceMapping->getMapping();
        	  gi.erase();
        	  map.interactiveUpdate(gi) ;
      	}
    
      	gi.erase();
      	plotObject=true;
            }
            
        }
        
        else if( answer=="plot" )
        {
      // plotting is done below
            plotObject=true;
        }
        else if( dialog.getToggleValue(answer,"body force shaded surfaces",bodyForcePlotShaded) )
        { 
            pspBody.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,bodyForcePlotShaded);
            pspBody.set(GI_PLOT_UNS_FACES,bodyForcePlotShaded);  // Unstructured mappings

            plotObject=true; 
            gi.erase();
        } //
        else if( dialog.getToggleValue(answer,"body force block boundaries",bodyForcePlotBlockBoundaries) )
        { 
            pspBody.set(GI_PLOT_BLOCK_BOUNDARIES,bodyForcePlotBlockBoundaries); // 2d block boundaries ??
            pspBody.set(GI_PLOT_MAPPING_EDGES,bodyForcePlotBlockBoundaries); // 3d block boundaries
            plotObject=true; 
            gi.erase();
        } //
        else if( dialog.getToggleValue(answer,"body force grid lines",bodyForcePlotGridLines) )
        { 
            if( numberOfDimensions==2 )
                pspBody.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,bodyForcePlotGridLines); // 2d grid lines
            pspBody.set(GI_PLOT_LINES_ON_MAPPING_BOUNDARIES,bodyForcePlotGridLines); // lines on 3d ??

            pspBody.set(GI_PLOT_GRID_POINTS_ON_CURVES,bodyForcePlotGridLines);  // grid points on curves

      // Unstructured mappings: 
            pspBody.set(GI_PLOT_UNS_EDGES,bodyForcePlotGridLines);
            pspBody.set(GI_PLOT_UNS_BOUNDARY_EDGES,bodyForcePlotGridLines);

            plotObject=true; 
            gi.erase();
        } //

        else if( dialog.getToggleValue(answer,"boundary force shaded surfaces",boundaryForcePlotShaded) )
        { 
            pspBoundary.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,boundaryForcePlotShaded);
            pspBoundary.set(GI_PLOT_UNS_FACES,boundaryForcePlotShaded);  // Unstructured mappings

            plotObject=true; 
            gi.erase();
        } //
        else if( dialog.getToggleValue(answer,"boundary force block boundaries",boundaryForcePlotBlockBoundaries) )
        {  
            pspBoundary.set(GI_PLOT_BLOCK_BOUNDARIES,boundaryForcePlotBlockBoundaries); // 2d block boundaries ??
            pspBoundary.set(GI_PLOT_MAPPING_EDGES,boundaryForcePlotBlockBoundaries); // 3d block boundaries
            plotObject=true; 
            gi.erase();
        } //
        else if( dialog.getToggleValue(answer,"boundary force grid lines",boundaryForcePlotGridLines) )
        {  
            if( numberOfDimensions==2 )
                pspBoundary.set(GI_PLOT_SHADED_MAPPING_BOUNDARIES,boundaryForcePlotGridLines); // 2d grid lines
            pspBoundary.set(GI_PLOT_LINES_ON_MAPPING_BOUNDARIES,boundaryForcePlotGridLines); // lines on 3d ??
      // Unstructured mappings: 
            pspBoundary.set(GI_PLOT_UNS_EDGES,boundaryForcePlotGridLines);
            pspBoundary.set(GI_PLOT_UNS_BOUNDARY_EDGES,boundaryForcePlotGridLines);

            plotObject=true; 
            gi.erase();
        } //
        else if( dialog.getToggleValue(answer,"pick closest",pickClosest) ){}//
        else if( answer=="pick colour..." )
        {
      // open the colour dialog 
            colourDialog.showSibling();
            if( pickingOption!=pickToColourBlocks )
            {
      	printF("INFO: setting picking option to `pick to colour grids'.\n");
      	pickingOption=pickToColourBlocks;
      	dialog.getOptionMenu("Pick to:").setCurrentChoice((int)pickingOption);
            }
        }
        else if( answer=="close colour choices" )
        {
            colourDialog.hideSibling();
        }
        else if( PlotIt::getColour( answer,colourDialog,pickColour ) )
        {
            printF("answer=%s was processed by the colourDialog\n",(const char*)answer);
            pickColourIndex=getXColour(pickColour);
            if( pickColourIndex==0 )
            {
      	printF(" ERROR: colour=[%s] not recognized! using aquamarine instead\n",(const char*)pickColour);
      	pickColourIndex=getXColour("aquamarine");
            }
        }

        else if( answer=="regions info" )
        {
            if( dbase.get<bool >("turnOnBodyForcing") )
            {
	// Here is the array of body forcings:
      	std::vector<BodyForce*> & bodyForcings =  dbase.get<std::vector<BodyForce*> >("bodyForcings");
      	
      	for( int bf=0; bf<bodyForcings.size(); bf++ )
      	{
        	  const BodyForce & bodyForce = *bodyForcings[bf];
        	  const aString & bodyForcingName= bodyForce.dbase.get<aString >("bodyForcingName");
        	  const aString & forcingType = bodyForce.dbase.get<aString >("forcingType");
        	  const aString & regionType = bodyForce.dbase.get<aString>("regionType");
        	  const int & visible = bodyForce.dbase.get<bool>("visible");
                    const bool & addForcing = bodyForce.dbase.get<bool >("addForcing");
        	  const bool & forcingIsTimeDependent =  bodyForce.dbase.get<bool >("forcingIsTimeDependent");
        	  
        	  printF("Body Force %i, name=%s, forcingType=%s, add=%i, time-dependent=%i, regionType=%s, visible=%i.\n",bf,(const char*)bodyForcingName,
                                  (const char*)forcingType,(int)addForcing,(int)forcingIsTimeDependent, (const char*)regionType,(int)visible);
      	}
            }

            if( dbase.get<bool >("turnOnBoundaryForcing") )
            {
	// Here is the array of boundary forcings:
      	std::vector<BodyForce*> & boundaryForcings =  dbase.get<std::vector<BodyForce*> >("boundaryForcings");
      	
      	for( int bf=0; bf<boundaryForcings.size(); bf++ )
      	{
        	  const BodyForce & boundaryForce = *boundaryForcings[bf];
        	  const aString & bodyForcingName= boundaryForce.dbase.get<aString >("bodyForcingName");
        	  const aString & forcingType = boundaryForce.dbase.get<aString >("forcingType");
        	  const aString & regionType = boundaryForce.dbase.get<aString>("regionType");
        	  const int & visible = boundaryForce.dbase.get<bool>("visible");
                    const bool & addForcing = boundaryForce.dbase.get<bool >("addForcing");
        	  const bool & forcingIsTimeDependent =  boundaryForce.dbase.get<bool >("forcingIsTimeDependent");
        	  
        	  printF("Boundary Force %i, name=%s, forcingType=%s, add=%i, time-dependent=%i, regionType=%s, visible=%i.\n",bf,
                                  (const char*)bodyForcingName,
                                  (const char*)forcingType,(int)addForcing,(int)forcingIsTimeDependent, (const char*)regionType,(int)visible);
      	}
            }

        }
        else 
        {
            printF("plotBodyForcingRegions:ERROR: unknown answer=[%s]\n",(const char*)answer);
            gi.stopReadingCommandFile();
        }
        
        
        plotObject = plotObject && gi.isInteractiveGraphicsOn();  // only plot if graphics is on

        if( plotObject )
        {
      // --- plot the regions ---

      // --- loop over different body forcings ---
            if( dbase.get<bool >("turnOnBodyForcing") )
            {
	// Here is the array of body forcings:
      	std::vector<BodyForce*> & bodyForcings =  dbase.get<std::vector<BodyForce*> >("bodyForcings");
      	
      	GraphicsParameters & psp = pspBody;
      	psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);

      	for( int bf=0; bf<bodyForcings.size(); bf++ )
      	{
        	  BodyForce & bodyForce = *bodyForcings[bf];
        	  if( !bodyForce.dbase.get<bool>("visible") )
        	  {
          	    if( debug & 8 ) printF("plotForcingRegions:INFO: body force region %i is not visible\n",bf);
          	    continue;  // this region should nu be plotted
        	  }
        	  
        	  const aString & forcingType = bodyForce.dbase.get<aString >("forcingType");
        	  const aString & regionType = bodyForce.dbase.get<aString>("regionType");
            
        	  if( bodyForce.dbase.has_key("colour") )
        	  {
                        int pickColourIndex=bodyForce.dbase.get<int>("colour");
                        const aString pickColour=getXColour(pickColourIndex);
                        pspBody.set(GI_MAPPING_COLOUR,pickColour);
        	  }
        	  else
        	  {
          	    pspBody.set(GI_MAPPING_COLOUR,"DARKTURQUOISE"); // default colour
        	  }
        	  
          //  save ID for picking:
                    if( !bodyForce.dbase.has_key("globalID") ) bodyForce.dbase.put<int>("globalID",-1); 
                    int & globalID = bodyForce.dbase.get<int>("globalID");
                    if( regionType=="box" )
                    {
                        const real *boxBounds =  bodyForce.dbase.get<real[6] >("boxBounds");
                        const int *linesToPlot =  bodyForce.dbase.get<int[3] >("linesToPlot");
                        const real xa = boxBounds[0];
                        const real xb = boxBounds[1];
                        const real ya = boxBounds[2];
                        const real yb = boxBounds[3];
                        const real za = boxBounds[4];
                        const real zb = boxBounds[5];
                        if( debug & 4 )
                            printF("plotBodyForcing: bf=%i, box bounds = [%e,%e]x[%e,%e][%e,%e]\n",bf,xa,xb,ya,yb,za,zb);
                        if( numberOfDimensions==2 )
                        {
                            SquareMapping square(xa,xb,ya,yb);
                            globalID=square.getGlobalID();  // save ID for picking 
              // To do : Just plot the square outline -- we could make this an option
                            square.setGridDimensions(axis1,linesToPlot[0]);
                            square.setGridDimensions(axis2,linesToPlot[1]);
                            PlotIt::plot(gi, square,psp);      
                        }
                        else
                        {
                            BoxMapping box(xa,xb,ya,yb,za,zb);
                            globalID=box.getGlobalID();  // save ID for picking 
              // To do :  Just plot the box outline -- we could make this an option
                            box.setGridDimensions(axis1,linesToPlot[0]);
                            box.setGridDimensions(axis2,linesToPlot[1]);
                            box.setGridDimensions(axis3,linesToPlot[2]);
                            PlotIt::plot(gi, box,psp);      
                        }
                    }
                    else if( regionType=="ellipse" )
                    {
            //   [(x-xe)/ae]^2 + [(y-ye)/be]^2 + [(z-ze)/ce]^2 = 1
                        const real *ellipse =  bodyForce.dbase.get<real[6] >("ellipse");
                        const int *linesToPlot =  bodyForce.dbase.get<int[3] >("linesToPlot");
                        const real ae = ellipse[0];
                        const real be = ellipse[1];
                        const real ce = ellipse[2];
                        const real xe = ellipse[3];
                        const real ye = ellipse[4];
                        const real ze = ellipse[5];
                        if( numberOfDimensions==2 )
                        {
                            AnnulusMapping map(0.,be, xe,ye, 0.,1.,ae/be);
                            globalID=map.getGlobalID();  // save ID for picking 
                            map.setGridDimensions(axis1,linesToPlot[0]);
                            map.setGridDimensions(axis2,linesToPlot[1]);
                            PlotIt::plot(gi, map,psp);      
                        }
                        else
                        {
              // **finish me**
                        }
                    }
                    else if( regionType=="maskFromGridFunction" )
                    {
                        if( dbase.get<bool >("plotBodyForceMaskSurface") )
                        {
                            if( !dbase.has_key("bodyForceMaskGridFunction") )
                            {
                      	printF("plotBodyForcingRegions: there is no body force mask defined!\n");
                      	continue;
                            }
                            realCompositeGridFunction & bodyForceMask = 
                      	*dbase.get<realCompositeGridFunction*>("bodyForceMaskGridFunction");
              // The body force mask iso surface has its own graphics parameters:
                            if( !dbase.has_key("bodyForceMaskGraphicsParameters") )
                            {
                      	dbase.put<GraphicsParameters>("bodyForceMaskGraphicsParameters");
                            }
                            printF("plotBodyForcingRegions: plot the body force mask iso-surface\n");
                            GraphicsParameters & gp = dbase.get<GraphicsParameters>("bodyForceMaskGraphicsParameters");
                            gp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
                            PlotIt::contour(gi,bodyForceMask, gp);
                        }
                    }
                    else if( regionType=="mapping" )
                    {
                        if( !bodyForce.dbase.has_key("bodyForceMapping") )
                        {
                            printF("plotBodyForcingRegions:WARNING: there is no body force Mapping!\n");
                            continue;
                        }
                        MappingRC *& bodyForceMapping = bodyForce.dbase.get<MappingRC*>("bodyForceMapping");
                        if( bodyForceMapping!=NULL )
                        {
                            if( false )
                      	printF("plotBodyForcingRegions: plotMapping [%s]\n",
                                              (const char*)bodyForceMapping->getName(Mapping::mappingName));
                            Mapping & map = bodyForceMapping->getMapping();
                            globalID=map.getGlobalID();  // save ID for picking 
                            real lineWidthSave, pointSizeSave;
                            if( numberOfDimensions==2 )
                            {
                      	psp.get(GraphicsParameters::lineWidth,lineWidthSave);  // save current line width
                      	psp.set(GraphicsParameters::lineWidth,lineWidth);  // default is 1
                      	psp.get(GI_POINT_SIZE,pointSizeSave); // save current point size
                                real pointSize=lineWidth*2;
                      	psp.set(GI_POINT_SIZE,pointSize); 
                            }
                            PlotIt::plot(gi,map,psp);  
                            if( numberOfDimensions==2 )
                            {
                      	psp.set(GraphicsParameters::lineWidth,lineWidthSave);  // reset 
                      	psp.set(GI_POINT_SIZE,pointSizeSave);    // reset 
                            }
                        }
                        else
                        {
                            printF("plotBodyForcingRegions:WARNING: the body force Mapping is NULL!\n");
                        }
                    }
                    else
                    {
                        printF("plotBodyForcing:WARNING: unexpected regionType=%s\n",(const char*)regionType);
                    }
      	} // end for bf 
      	
            }
            
      // --- loop over different boundary forcings ---
            if( dbase.get<bool>("turnOnBoundaryForcing") )
            {
	// Here is the array of boundary forcings:
      	std::vector<BodyForce*> & boundaryForcings =  dbase.get<std::vector<BodyForce*> >("boundaryForcings");

      	GraphicsParameters & psp = pspBoundary;
      	psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);

      	for( int bf=0; bf<boundaryForcings.size(); bf++ )
      	{
        	  BodyForce & bodyForce = *boundaryForcings[bf];
        	  if( !bodyForce.dbase.get<bool>("visible") )
        	  {
          	    if( debug & 8 ) printF("plotForcingRegions:INFO: boundary force region %i is not visible\n",bf);
          	    continue;  // this region should nu be plotted
        	  }

        	  const aString & forcingType = bodyForce.dbase.get<aString >("forcingType");
        	  const aString & regionType = bodyForce.dbase.get<aString>("regionType");
            
        	  if( bodyForce.dbase.has_key("colour") )
        	  {
                        int pickColourIndex=bodyForce.dbase.get<int>("colour");
                        const aString pickColour=getXColour(pickColourIndex);
                        pspBoundary.set(GI_MAPPING_COLOUR,pickColour);
	    // printF("Plot boundary forcing: colour=%s\n",(const char*)pickColour);
        	  }
        	  else
        	  {
          	    pspBoundary.set(GI_MAPPING_COLOUR,"DARKTURQUOISE"); // default colour
        	  }

          //  save ID for picking:
                    if( !bodyForce.dbase.has_key("globalID") ) bodyForce.dbase.put<int>("globalID",-1); 
                    int & globalID = bodyForce.dbase.get<int>("globalID");
                    if( regionType=="box" )
                    {
                        const real *boxBounds =  bodyForce.dbase.get<real[6] >("boxBounds");
                        const int *linesToPlot =  bodyForce.dbase.get<int[3] >("linesToPlot");
                        const real xa = boxBounds[0];
                        const real xb = boxBounds[1];
                        const real ya = boxBounds[2];
                        const real yb = boxBounds[3];
                        const real za = boxBounds[4];
                        const real zb = boxBounds[5];
                        if( debug & 4 )
                            printF("plotBodyForcing: bf=%i, box bounds = [%e,%e]x[%e,%e][%e,%e]\n",bf,xa,xb,ya,yb,za,zb);
                        if( numberOfDimensions==2 )
                        {
                            SquareMapping square(xa,xb,ya,yb);
                            globalID=square.getGlobalID();  // save ID for picking 
              // To do : Just plot the square outline -- we could make this an option
                            square.setGridDimensions(axis1,linesToPlot[0]);
                            square.setGridDimensions(axis2,linesToPlot[1]);
                            PlotIt::plot(gi, square,psp);      
                        }
                        else
                        {
                            BoxMapping box(xa,xb,ya,yb,za,zb);
                            globalID=box.getGlobalID();  // save ID for picking 
              // To do :  Just plot the box outline -- we could make this an option
                            box.setGridDimensions(axis1,linesToPlot[0]);
                            box.setGridDimensions(axis2,linesToPlot[1]);
                            box.setGridDimensions(axis3,linesToPlot[2]);
                            PlotIt::plot(gi, box,psp);      
                        }
                    }
                    else if( regionType=="ellipse" )
                    {
            //   [(x-xe)/ae]^2 + [(y-ye)/be]^2 + [(z-ze)/ce]^2 = 1
                        const real *ellipse =  bodyForce.dbase.get<real[6] >("ellipse");
                        const int *linesToPlot =  bodyForce.dbase.get<int[3] >("linesToPlot");
                        const real ae = ellipse[0];
                        const real be = ellipse[1];
                        const real ce = ellipse[2];
                        const real xe = ellipse[3];
                        const real ye = ellipse[4];
                        const real ze = ellipse[5];
                        if( numberOfDimensions==2 )
                        {
                            AnnulusMapping map(0.,be, xe,ye, 0.,1.,ae/be);
                            globalID=map.getGlobalID();  // save ID for picking 
                            map.setGridDimensions(axis1,linesToPlot[0]);
                            map.setGridDimensions(axis2,linesToPlot[1]);
                            PlotIt::plot(gi, map,psp);      
                        }
                        else
                        {
              // **finish me**
                        }
                    }
                    else if( regionType=="maskFromGridFunction" )
                    {
                        if( dbase.get<bool >("plotBodyForceMaskSurface") )
                        {
                            if( !dbase.has_key("bodyForceMaskGridFunction") )
                            {
                      	printF("plotBodyForcingRegions: there is no body force mask defined!\n");
                      	continue;
                            }
                            realCompositeGridFunction & bodyForceMask = 
                      	*dbase.get<realCompositeGridFunction*>("bodyForceMaskGridFunction");
              // The body force mask iso surface has its own graphics parameters:
                            if( !dbase.has_key("bodyForceMaskGraphicsParameters") )
                            {
                      	dbase.put<GraphicsParameters>("bodyForceMaskGraphicsParameters");
                            }
                            printF("plotBodyForcingRegions: plot the body force mask iso-surface\n");
                            GraphicsParameters & gp = dbase.get<GraphicsParameters>("bodyForceMaskGraphicsParameters");
                            gp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
                            PlotIt::contour(gi,bodyForceMask, gp);
                        }
                    }
                    else if( regionType=="mapping" )
                    {
                        if( !bodyForce.dbase.has_key("bodyForceMapping") )
                        {
                            printF("plotBodyForcingRegions:WARNING: there is no body force Mapping!\n");
                            continue;
                        }
                        MappingRC *& bodyForceMapping = bodyForce.dbase.get<MappingRC*>("bodyForceMapping");
                        if( bodyForceMapping!=NULL )
                        {
                            if( false )
                      	printF("plotBodyForcingRegions: plotMapping [%s]\n",
                                              (const char*)bodyForceMapping->getName(Mapping::mappingName));
                            Mapping & map = bodyForceMapping->getMapping();
                            globalID=map.getGlobalID();  // save ID for picking 
                            real lineWidthSave, pointSizeSave;
                            if( numberOfDimensions==2 )
                            {
                      	psp.get(GraphicsParameters::lineWidth,lineWidthSave);  // save current line width
                      	psp.set(GraphicsParameters::lineWidth,lineWidth);  // default is 1
                      	psp.get(GI_POINT_SIZE,pointSizeSave); // save current point size
                                real pointSize=lineWidth*2;
                      	psp.set(GI_POINT_SIZE,pointSize); 
                            }
                            PlotIt::plot(gi,map,psp);  
                            if( numberOfDimensions==2 )
                            {
                      	psp.set(GraphicsParameters::lineWidth,lineWidthSave);  // reset 
                      	psp.set(GI_POINT_SIZE,pointSizeSave);    // reset 
                            }
                        }
                        else
                        {
                            printF("plotBodyForcingRegions:WARNING: the body force Mapping is NULL!\n");
                        }
                    }
                    else
                    {
                        printF("plotBodyForcing:WARNING: unexpected regionType=%s\n",(const char*)regionType);
                    }
      	}
            }

      // Reset:
      // psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,plotObjectAndExit);
            
        }  // end if plotObject
        

    } // end for( it )
    
    if( !plotObjectAndExit )
    {
        gi.popGUI( );
    }
    
    return 0;
    
}
