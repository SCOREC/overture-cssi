// ==========================================================================================================
// Class to define exact solutions to Maxwell's equations
// 
//    Surface wave between two materials
//          - Surface Plasmon Polariton : surface wave between a metal (plasmon) and a dieletric (polariton)
// ==========================================================================================================

#include "SurfaceWaveExactSolution.h"

#include "DispersiveMaterialParameters.h"

#include "ParallelUtility.h"

#include <complex>

typedef ::real LocalReal;
// typedef ::real OV_real;

typedef std::vector<std::complex<Real> > ComplexVector;

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)



// ===============================================================================
/// \brief  Constructor for th class that defines exact solutions to Maxwell's equations for a sphere
// ===============================================================================
SurfaceWaveExactSolution::
SurfaceWaveExactSolution()
{

  dbase.put<int>("numberOfDimensions");
  dbase.put<bool>("initialized")=false;

  dbase.put<Real>("amp")=1.;

  std::complex<Real> & s  = dbase.put<std::complex<Real> >("s");
  std::complex<Real> & kx = dbase.put<std::complex<Real> >("kx");

  ComplexVector & kvyta   = dbase.put<ComplexVector>("kvyt");   // top ky's 
  ComplexVector & kvyba   = dbase.put<ComplexVector>("kvyb");   // bottom ky's 
  ComplexVector & qvta    = dbase.put<ComplexVector>("qvt");    // top eigenvectors
  ComplexVector & qvba    = dbase.put<ComplexVector>("qvb");    // bottom eigenvectors 

  
}


// ===============================================================================
/// \brief destructor for the class that defines exact solutions to Maxwell's equations for a sphere
// ===============================================================================
SurfaceWaveExactSolution::
~SurfaceWaveExactSolution()
{
}


// ===============================================================================
/// \brief Initialize the plane material interface solution.
// ===============================================================================
int SurfaceWaveExactSolution::
initialize( CompositeGrid & cg, DispersiveMaterialParameters & dmp1, DispersiveMaterialParameters & dmp2,
            const aString & caseName )
{
  bool & initialized=dbase.get<bool>("initialized");
  initialized=true;

  int & numberOfDimensions = dbase.get<int>("numberOfDimensions");
  numberOfDimensions=cg.numberOfDimensions();


  std::complex<Real> & s  = dbase.get<std::complex<Real> >("s");
  std::complex<Real> & kx = dbase.get<std::complex<Real> >("kx");

  ComplexVector & kvyta   = dbase.get<ComplexVector>("kvyt");   // top ky's 
  ComplexVector & kvyba   = dbase.get<ComplexVector>("kvyb");   // bottom ky's 
  ComplexVector & qvta    = dbase.get<ComplexVector>("qvt");    // top eigenvectors
  ComplexVector & qvba    = dbase.get<ComplexVector>("qvb");    // bottom eigenvectors 

  kvyta.resize(2);
  kvyba.resize(2);
  qvta.resize(12);
  qvba.resize(12);
  

#define kvyt(i) kvyta[(i)]
#define kvyb(i) kvyba[(i)]
#define qvt(i,j) qvta[(i)+6*(j)]
#define qvb(i,j) qvba[(i)+6*(j)]

  std::complex<LocalReal> I(0,1.); 

  // File generated by bamxp/matlab/baSurfaceWave.m: 
  if( caseName == "surfaceWaveCase1SpacePeriodic" )
  {
#include "surfaceWaveCase1SpacePeriodic.h"
  }
  else if( caseName == "surfaceWaveCase1TimePeriodic" )
  {
#include "surfaceWaveCase1TimePeriodic.h"
  }
  else
  {
    printF("SurfaceWaveExactSolution::initialize: ERROR: unknown caseName=[%s]\n",(const char*)caseName);
    OV_ABORT("error");
  }
  
  
  
  printF("\n ------------------- SurfaceWaveExactSolution:: END initialize ------------------------\n\n");

//   check();
  

  return 0;
}




//========================================================================================================
/// \brief Evaluate the BA surface wave solution
//========================================================================================================
int SurfaceWaveExactSolution::
evalBA( DispersiveMaterialParameters & dmp1,
	DispersiveMaterialParameters & dmp2,
	Real t, CompositeGrid & cg, int grid, 
        IntegerArray & matMask,
	realArray & ua, realArray & pv,
	const Index & I1a, const Index &I2a, const Index &I3a, 
	int numberOfTimeDerivatives /* = 0 */ ,
	int solveForAllFields /* = 1 */ )
{

  // domain number for this grid: 
  const int myDomain = cg.domainNumber(grid);

  std::complex<LocalReal> I(0,1.); 

  if( t <= 0. )
    printF("--SurfaceWaveExactSolution--  evalBA solution  on grid=%i, domain=%i, at t=%9.3e\n",grid,myDomain,t);

  bool & initialized=dbase.get<bool>("initialized");
  if( !initialized )
  {
    printf("SurfaceWaveExactSolution::evalBA: ERROR: solution is not initialized.\n");
    OV_ABORT("ERROR");
  }

  assert( solveForAllFields==1 );  // Fix me **
  
  Real & amp = dbase.get<Real>("amp");
  std::complex<Real> & s  = dbase.get<std::complex<Real> >("s");
  std::complex<Real> & kx = dbase.get<std::complex<Real> >("kx");

  ComplexVector & kvyta   = dbase.get<ComplexVector>("kvyt");   // top ky's 
  ComplexVector & kvyba   = dbase.get<ComplexVector>("kvyb");   // bottom ky's 
  ComplexVector & qvta    = dbase.get<ComplexVector>("qvt");    // top eigenvectors
  ComplexVector & qvba    = dbase.get<ComplexVector>("qvb");    // bottom eigenvectors 

#define kvyt(i) kvyta[(i)]
#define kvyb(i) kvyba[(i)]
#define qvt(i,j) qvta[(i)+6*(j)]
#define qvb(i,j) qvba[(i)+6*(j)]


  MappedGrid & mg = cg[grid];
  const int numberOfDimensions = cg.numberOfDimensions();
  
  OV_GET_SERIAL_ARRAY(Real,ua,uLocal);

  Index I1=I1a, I2=I2a, I3=I3a;
  bool ok = ParallelUtility::getLocalArrayBounds(ua,uLocal,I1,I2,I3,1);   
  if( !ok ) return 0;  // no points on this processor (NOTE: no communication should be done after this point)

  // -- we optimize for Cartesian grids (we can avoid creating the vertex array)
  const bool isRectangular=mg.isRectangular();
  if( !isRectangular )
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);

  OV_GET_SERIAL_ARRAY_CONDITIONAL(real,mg.center(),xLocal,!isRectangular); // *wdh* added conditional, Nov 21, 2020

  Real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  Real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
	xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular grids:
#undef XC
#define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

  
  // -- Store components here: 
  const int ex=0, ey=1, ez=2;
  const int hx=3, hy=4, hz= (solveForAllFields==1 || numberOfDimensions==3) ? 5 : 2;

  if( solveForAllFields && ua.getLength(3)<6 )
  {
    printF(" SurfaceWaveExactSolution::ERROR: Not enough space in ua to hold all 6 fields.\n");
    OV_ABORT("error");
  }
  

  // --- Get Arrays for the dispersive model ----

  // RealMappedGridFunction & pCur = getDispersionModelMappedGridFunction( grid,current );
      

  RealArray pLocal;
  const bool isDispersive = dmp1.isDispersiveMaterial() || dmp2.isDispersiveMaterial();
  if( isDispersive )
  {
    OV_GET_SERIAL_ARRAY(Real, pv,pLoc);
    pLocal.reference(pLoc);
  }
  const IntegerArray & NpBA1                  = dmp1.dbase.get<IntegerArray>("NpBA");
  const RealArray & bianisotropicParameters1  = dmp1.dbase.get<RealArray>("bianisotropicParameters");

  const IntegerArray & NpBA2                  = dmp2.dbase.get<IntegerArray>("NpBA");
  const RealArray & bianisotropicParameters2  = dmp2.dbase.get<RealArray>("bianisotropicParameters");
    
  Real x0[3]={0.,.0,0.};  // 

  std::complex<Real> pq[6], pijm;
#define q(i) pq[(i)]

  Real x,y,z=0.;
  if( numberOfTimeDerivatives==0 )
  {
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
      if( !isRectangular )
      {
	x= xLocal(i1,i2,i3,0)-x0[0];   // shift point to reference coordinates 
	y= xLocal(i1,i2,i3,1)-x0[1];
	if( numberOfDimensions==3 )
	  z= xLocal(i1,i2,i3,2)-x0[2];
      }
      else
      {
	x=XC(iv,0)-x0[0];
	y=XC(iv,1)-x0[1];
	if( numberOfDimensions==3 )
	  z=XC(iv,2)-x0[2];
      }

      // Here are the statements to eval the solution: 
      int mt = matMask(i1,i2,i3);  // material type: 0=left, 1=right
      if( mt==0 )  
      {
        // -- TOP ----
	for( int m=ex; m<=hz; m++ )
	{
         q(m) = amp*( exp( I*( kx*x + kvyt(0)*y ) + s*t )*qvt(m,0)  +
	             +exp( I*( kx*x + kvyt(1)*y ) + s*t )*qvt(m,1)  );

	  uLocal(i1,i2,i3,m) = std::real( q(m) );
	}
      }
      else
      {
        // --- Bottom ---
	for( int m=ex; m<=hz; m++ )
	{
         q(m) = amp*( exp( I*( kx*x + kvyb(0)*y ) + s*t )*qvb(m,0)  +
	             +exp( I*( kx*x + kvyb(1)*y ) + s*t )*qvb(m,1)  );
	  uLocal(i1,i2,i3,m) = std::real( q(m) );
	}
      }
   
      if( isDispersive )
      {
	const IntegerArray & NpBA = mt==0 ? NpBA1 : NpBA2;
	const RealArray & bianisotropicParameters = mt==0 ? bianisotropicParameters1 : bianisotropicParameters2;
	int m=0;
	for( int k1=0; k1<6; k1++ )
	{
	  for( int k2=0; k2<6; k2++ )
	  {
	    int ec=k2;  // *check me**
	    for( int n=0; n<NpBA(k1,k2); n++ )
	    {
	      LocalReal a0 = bianisotropicParameters(0,n,k1,k2);
	      LocalReal a1 = bianisotropicParameters(1,n,k1,k2);
	      LocalReal b0 = bianisotropicParameters(2,n,k1,k2);
	      LocalReal b1 = bianisotropicParameters(3,n,k1,k2);

	      pijm = (a0+a1*s)/(b0+b1*s+s*s) * q(ec);
	      pLocal(i1,i2,i3,m) = std::real(pijm);   // Pijm 
	      m++;   
	      pLocal(i1,i2,i3,m) = std::real(s*pijm); // Q = dP/dt
	      m++;

	    }
	  }
	}
      }

    } // end FOR
      
  }
  else
  {
    OV_ABORT("SurfaceWaveExactSolution::evalBA: ERROR: numberOfTimeDerivatives != 0 ");
    
  } // end if number of time derivatives 
    

  return 0;
}



