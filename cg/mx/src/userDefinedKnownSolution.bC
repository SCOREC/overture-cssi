#include "Maxwell.h"
#include "DispersiveMaterialParameters.h"
#include "GenericGraphicsInterface.h"
#include "ParallelUtility.h"

#include "PlaneInterfaceExactSolution.h"

#include "SurfaceWaveExactSolution.h"
#include "SlabsExactSolution.h"
#include "NonlinearExactSolution.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)

typedef ::real LocalReal;
// utility routine (using complex numbers) defined at the bottom of the file.
void
getTransmisionWaveNumber( const LocalReal & kr,  const LocalReal & ki, 
                          const LocalReal & kxr, const LocalReal & kxi, 
                          const LocalReal & kyr, const LocalReal & kyi, 
                          LocalReal & kxpr, LocalReal & kxpi, 
                          LocalReal & kypr, LocalReal & kypi );

void
checkPlaneMaterialInterfaceJumps( 
  const LocalReal & c1, const LocalReal & c2,
  const LocalReal & eps1, const LocalReal & eps2,
  const LocalReal & mu1, const LocalReal & mu2,

  const LocalReal & sr, const LocalReal & si,
  const LocalReal & rr, const LocalReal & ri, 
  const LocalReal & taur, const LocalReal & taui, 

  const LocalReal & eps1Hatr, const LocalReal & eps1Hati,
  const LocalReal & eps2Hatr, const LocalReal & eps2Hati,

  const LocalReal & psiSum1r, const LocalReal & psiSum1i,
  const LocalReal & psiSum2r, const LocalReal & psiSum12i,
  const LocalReal & kxr, const LocalReal & kxi,
  const LocalReal & kyr, const LocalReal & kyi,
  const LocalReal & kxpr, const LocalReal & kxpi,
  const LocalReal & kypr, const LocalReal & kypi
  );


#define evalMaterialInterfaceSolution3d EXTERN_C_NAME(evalmaterialinterfacesolution3d)
extern "C"
{

void  evalMaterialInterfaceSolution3d( const real&sr,const real&si, 
                                       const real&chiSum1r, const real&chiSum1i, const real&chiSum2r, const real&chiSum2i,
                                       const real&av,const real&nv,const real&kv,
                                       const real&eps1,const real&eps2,
                                       const real&mu1,const real&mu2,
                                       const real&krr,const real&kri,
                                       const real&ktr,const real&kti,
                                       real & arr, real & ari, real & atr, real & ati );

}

// ==========================================================================================
/// \brief  Evaluate a user defined known solution.
///
/// \param numberOfTimeDerivatives (input) : evaluate this many time-derivatives of the solution.
///     Normally  numberOfTimeDerivatives=0, but it can be 1 when the known solution is used
///      to define boundary conditions
/// \param pv (input) : holds polarization
/// \param qv (input) : holds nonlinear variables
///
// ==========================================================================================
int Maxwell::
getUserDefinedKnownSolution(int current, real t, CompositeGrid & cg, int grid, 
                            realArray & ua, realArray & pv, realArray & qv,
                            const Index & I1a, const Index &I2a, const Index &I3a, 
                            int numberOfTimeDerivatives /* = 0 */ )
{
  if( false )
    printF("--MX--getUserDefinedKnownSolution at t=%9.3e\n",t);

  MappedGrid & mg = cg[grid];
  const int numberOfDimensions = cg.numberOfDimensions();
  const real & dt= deltaT;
  
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
  {
    printF("--MX-- getUserDefinedKnownSolution:ERROR: sub-directory `userDefinedKnownSolutionData' not found!\n");
    OV_ABORT("error");
  }
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  const aString & userKnownSolution = db.get<aString>("userKnownSolution");

  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");
  
  OV_GET_SERIAL_ARRAY(real,ua,uLocal);

  Index I1=I1a, I2=I2a, I3=I3a;
  bool ok = ParallelUtility::getLocalArrayBounds(ua,uLocal,I1,I2,I3,1);   
  if( !ok ) return 0;  // no points on this processor (NOTE: no communication should be done after this point)

  // -- we optimize for Cartesian grids (we can avoid creating the vertex array)
  const bool isRectangular=mg.isRectangular();
  if( !isRectangular )
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);

  OV_GET_SERIAL_ARRAY_CONDITIONAL(real,mg.center(),xLocal,!isRectangular); // *wdh* added conditional, Nov 21, 2020

  real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
	xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular grids:
#undef XC
#define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

  
  if( userKnownSolution=="manufacturedPulse" )
  {
    // Manufactured pulse:
    //   A pulse like solution that requires a forcing function to make it a solution
    //   Used to test the forcing terms in the equations.
    const real amp = rpar[0];
    const real beta= rpar[1];
    const real x0  = rpar[2];
    const real y0  = rpar[3];
    const real z0  = rpar[4];
    const real cx  = rpar[5];
    const real cy  = rpar[6];
    const real cz  = rpar[7];

    real x,y,z;
    if( numberOfTimeDerivatives==0 )
    {
      if( numberOfDimensions==2 )
      {
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
	  }
	  else
	  {
            x=XC(iv,0);
            y=XC(iv,1);
	  }
	  
	  real psi = amp*exp(-beta*( SQR(x-x0-cx*t) + SQR(y-y0-cy*t) ));
	  uLocal(i1,i2,i3,ex) = -(y-y0-cy*t)*psi;    // Ex =  psi_y * const 
	  uLocal(i1,i2,i3,ey) =  (x-x0-cx*t)*psi;    // Ey = -psi_x * const
	  uLocal(i1,i2,i3,hz) =  psi;
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme

            // **check me**
	    real psit = (2.*beta)*( cx*(x-x0-cx*t) + cy*(y-y0-cy*t) )*psi;
	    uLocal(i1,i2,i3,ext) =  cy*psi  -(y-y0-cy*t)*psit;    
	    uLocal(i1,i2,i3,eyt) = -cx*psi  +(x-x0-cx*t)*psit;    
	    uLocal(i1,i2,i3,hzt) =  psit;
	  }
	}
      }
      else
      {
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
	    x= xLocal(i1,i2,i3,0);
	    y= xLocal(i1,i2,i3,1);
	    z= xLocal(i1,i2,i3,2);
	  }
	  else
	  {
	    x=XC(iv,0);
	    y=XC(iv,1);
	    z=XC(iv,2);
	  }

	  real psi = amp*exp(-beta*( SQR(x-x0-cx*t) + SQR(y-y0-cy*t) + SQR(z-z0-cz*t) ));
	  uLocal(i1,i2,i3,ex) = ((z-z0-cz*t)-(y-y0-cy*t))*psi;    // Ex = ( psi_z - psi_y ) * const
	  uLocal(i1,i2,i3,ey) = ((x-x0-cx*t)-(z-z0-cz*t))*psi;    // Ey = ( psi_x - psi_z ) * const
	  uLocal(i1,i2,i3,ez) = ((y-y0-cy*t)-(x-x0-cx*t))*psi;    // Ez = ( psi_y - psi_x ) * const
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme

            // **check me**
	    real psit = (2.*beta)*( cx*(x-x0-cx*t) + cy*(y-y0-cy*t) +cz*(z-z0-cz*t))*psi;
	    uLocal(i1,i2,i3,ext) = (-cz+cy)*psi + ((z-z0-cz*t)-(y-y0-cy*t))*psit;    
	    uLocal(i1,i2,i3,eyt) = (-cx+cz)*psi + ((x-x0-cx*t)-(z-z0-cz*t))*psit;    
            uLocal(i1,i2,i3,ezt) = (-cy+cx)*psi + ((y-y0-cy*t)-(x-x0-cx*t))*psit;
	  }	  
	  

	}
      }
    }
    else
    {
      OV_ABORT("finish me: numberOfTimeDerivatives1=0");
      
    }
    
  }
  else if( userKnownSolution=="chirpedPlaneWave" )
  {
    // -------------------------------------------
    // ---------- Chirped plane wave  -------------
    // -------------------------------------------

    // Chirped plane-wave parameters
    const ChirpedArrayType & cpw = dbase.get<ChirpedArrayType >("chirpedParameters");
    const real cpwTa   =cpw(0); // ta 
    const real cpwTb   =cpw(1); // tb 
    const real cpwAlpha=cpw(2); // alpha
    const real cpwBeta =cpw(3); // beta
    const real cpwAmp  =cpw(4); // amp
    const real cpwX0   =cpw(5); // x0
    const real cpwY0   =cpw(6); // y0
    const real cpwZ0   =cpw(7); // z0

    const real xi0 = .5*(cpwTa+cpwTb);
    const real cpwTau= cpwTb-cpwTa;    // tau=tb-ta
    
    printF("--UDKS-- eval chirped plane wave at t=%10.3e, [ta,tb]=[%g,%g]\n",t,cpwTa,cpwTb);

    c = cGrid(grid);
    const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);

    // For checking the scattering from a planar PEC boundary we change the
    // sign of the solution to be that for for scattered field.
    const bool & solveForScatteredField = dbase.get<bool>("solveForScatteredField");
    const real signForField = solveForScatteredField ? -1. : 1.;

    real x,y,z;
    if( numberOfTimeDerivatives==0 )
    {
      if( numberOfDimensions==2 )
      {
        // ----------- 2D --------------
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
	  }
	  else
	  {
            x=XC(iv,0);
            y=XC(iv,1);
	  }
 	  
          real xi = t - (kx*(x-cpwX0)+ky*(y-cpwY0))/cc - xi0;

	  real tanha = tanh(cpwBeta*(xi+.5*cpwTau));
	  real tanhb = tanh(cpwBeta*(xi-.5*cpwTau));
	  real amp = cpwAmp*.5*( tanha - tanhb );

	  real phi = cc*xi + cpwAlpha*xi*xi;
          real sinPhi = sin(twoPi*phi);

	  real  chirp = signForField*amp*sinPhi;
	  
	  uLocal(i1,i2,i3,ex) = chirp*pwc[0];
	  uLocal(i1,i2,i3,ey) = chirp*pwc[1];
	  uLocal(i1,i2,i3,hz) = chirp*pwc[5];
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme
            
            // tanh' = 1 - tanh^2
            real damp= cpwAmp*.5*cpwBeta*( -tanha*tanha + tanhb*tanhb );
            real dphi = cc + 2.*cpwAlpha*xi;

            chirp = signForField*( damp*sinPhi + amp*twoPi*dphi*cos(twoPi*phi) );

	    uLocal(i1,i2,i3,ext) = chirp*pwc[0];
	    uLocal(i1,i2,i3,eyt) = chirp*pwc[1];
	    uLocal(i1,i2,i3,hzt) = chirp*pwc[5];
	  }
	}
      }
      else
      {
        // ----------- 3D --------------
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
	    x= xLocal(i1,i2,i3,0);
	    y= xLocal(i1,i2,i3,1);
	    z= xLocal(i1,i2,i3,2);
	  }
	  else
	  {
	    x=XC(iv,0);
	    y=XC(iv,1);
	    z=XC(iv,2);
	  }

          real xi = t - (kx*(x-cpwX0)+ky*(y-cpwY0))/cc - xi0;

          // these next formulae are the same as in 2D
	  real tanha = tanh(cpwBeta*(xi+.5*cpwTau));
	  real tanhb = tanh(cpwBeta*(xi-.5*cpwTau));
	  real amp = cpwAmp*.5*( tanha - tanhb );

	  real phi = cc*xi + cpwAlpha*xi*xi;
          real sinPhi = sin(twoPi*phi);

	  real  chirp = signForField*amp*sinPhi;
	  
	  uLocal(i1,i2,i3,ex) =  chirp*pwc[0];
	  uLocal(i1,i2,i3,ey) =  chirp*pwc[1];
	  uLocal(i1,i2,i3,ez) =  chirp*pwc[2];
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme
            // tanh' = 1 - tanh^2
            real damp= cpwAmp*.5*cpwBeta*( -tanha*tanha + tanhb*tanhb );
            real dphi = cc + 2.*cpwAlpha*xi;

            chirp = signForField*( damp*sinPhi + amp*twoPi*dphi*cos(twoPi*phi) );

	    uLocal(i1,i2,i3,ext) = chirp*pwc[0];
	    uLocal(i1,i2,i3,eyt) = chirp*pwc[1];
	    uLocal(i1,i2,i3,ezt) = chirp*pwc[2];

	  }	  
	  

	}
      }
    }
    else
    {
      OV_ABORT("finish me: numberOfTimeDerivatives1=0");
      
    }
    
  }
  
  // else if( userKnownSolution=="dispersivePlaneWave" )
  // {
  //   // -----------------------------------------------
  //   // ---------- Dispersive plane wave  -------------
  //   // -----------------------------------------------

  //   assert( dispersionModel!=noDispersion );

  //   DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);

  //   // evaluate the dispersion relation,  exp(i(k*x-omega*t))
  //   //    omega is complex 
  //   const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz); // true wave-number (note factor of twoPi)
  //   real omegaDpwRe, omegaDpwIm;
  //   dmp.computeDispersivePlaneWaveParameters( c,eps,mu,kk, omegaDpwRe, omegaDpwIm );

  //   if( t<3.*dt )
  //     printF("--UDKS:DPW-- t=%10.3e, omegar=%g, omegai=%g\n",t,omegaDpwRe, omegaDpwIm );

  //   const real dpwExp =exp(omegaDpwIm*t);
    
  //   const real c = cGrid(grid);
  //   const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);

  //   const real eps = epsGrid(grid);
  //   const real mu  = muGrid(grid);
  //   const real ck2 = SQR(c*kk);

  //   // compute coefficients of P :   s = sr+I*si = -I*omega = -I*( omegar + I omegai) = omegai - I*omegar
  //   //     s^2 E = -(c*k)^2 E - (s^2/eps) * P 
  //   // ->  P = -eps*( 1 + (c*k/s)^2 ) E 
  //   real sr = omegaDpwIm, si=-omegaDpwRe;
  //   real sNorm2=sr*sr+si*si, sNorm4=sNorm2*sNorm2;
  //   real pc = -eps*( -2.*sr*si*ck2/sNorm4 );
  //   real ps = -eps*( 1. + ck2*(sr*sr-si*si)/sNorm4 );

  //   //  mu * (Hz)_t = (Ex)_y - (Ey)_x
  //   //  Hz = [hc*cos(xi) + hs*sin(xi) ]*exp(omegai*t)
  //   // *check me*
  //   real factor = twoPi*( kx*pwc[1] - ky*pwc[0] )/mu;  // (kx*Ey - ky*Ex )/mu
  //   real omegaNorm2=SQR(omegaDpwRe)+SQR(omegaDpwIm);
  //   real hs =  factor*omegaDpwRe/omegaNorm2;
  //   real hc = -factor*omegaDpwIm/omegaNorm2;
    

  //   if( t<3.*dt )
  //     printF("--UDKS:DPW-- ck2=%10.3e, pc=%g, ps=%g, sr=%g, si=%g, hc=%g hs=%g\n",ck2,pc,ps,sr,si,hc,hs);

  //   real x,y,z;
  //   if( numberOfTimeDerivatives==0 )
  //   {
  //     if( numberOfDimensions==2 )
  //     {
  //       // ----------- 2D --------------
  //       FOR_3D(i1,i2,i3,I1,I2,I3)
  //       {
  //         if( !isRectangular )
  //         {
  //          x= xLocal(i1,i2,i3,0);
  //          y= xLocal(i1,i2,i3,1);
  //         }
  //         else
  //         {
  //           x=XC(iv,0);
  //           y=XC(iv,1);
  //         }
  //         real xi=twoPi*(kx*x+ky*y) -omegaDpwRe*t;
  //         real sinxi=sin(xi), cosxi=cos(xi);

  //         uLocal(i1,i2,i3,ex) = sinxi*pwc[0]*dpwExp;
  //         uLocal(i1,i2,i3,ey) = sinxi*pwc[1]*dpwExp;
  //         uLocal(i1,i2,i3,hz) = (hc*cosxi+hs*sinxi)*dpwExp;

  //         // -- polarization vector --
  //         uLocal(i1,i2,i3,pxc) = (pc*cosxi+ps*sinxi)*pwc[0]*dpwExp;
  //         uLocal(i1,i2,i3,pyc) = (pc*cosxi+ps*sinxi)*pwc[1]*dpwExp;

  //         if( method==sosup )
  //         {
  //           // supply time-derivatives for sosup scheme
  //           OV_ABORT("finish me");
  //         }
  //       }
  //     }
  //     else
  //     {
  //       // ----------- 3D --------------
  //       FOR_3D(i1,i2,i3,I1,I2,I3)
  //       {
  //         if( !isRectangular )
  //         {
  //           x= xLocal(i1,i2,i3,0);
  //           y= xLocal(i1,i2,i3,1);
  //           z= xLocal(i1,i2,i3,2);
  //         }
  //         else
  //         {
  //           x=XC(iv,0);
  //           y=XC(iv,1);
  //           z=XC(iv,2);
  //         }

  //         OV_ABORT("finish me");
      
  //       }
  //     }
  //   }
  //   else
  //   {
  //     OV_ABORT("finish me: numberOfTimeDerivatives1=0");

  //   }
    
  // }
  else if( userKnownSolution=="dispersivePlaneWaveInterface" )
  {
    if( method==nfdtd )
    {
      // *new* way : July 6, 2019 - use version from the class
      if( !dbase.has_key("planeInterfaceExactSolution") )
      {
	// -- first time through: create class and initialize
	PlaneInterfaceExactSolution & pies = dbase.put<PlaneInterfaceExactSolution>("planeInterfaceExactSolution");
      
	const int domain1 = 0, domain2=1;
	DispersiveMaterialParameters & dmp1 = getDomainDispersiveMaterialParameters(domain1);
	DispersiveMaterialParameters & dmp2 = getDomainDispersiveMaterialParameters(domain2);

   
	real kvr[3]={kx,ky,kz};  // no factor of twoPi 
	real kvi[3]={0.,0.,0.};  // 

	real &ax=pwc[0], &ay=pwc[1], &az=pwc[2]; // Is this correct?
	real av[3]={ax,ay,az}; // 
  
	// // chosee av: *FIX ME** add update to pies to set    
	// if( cg.numberOfDimensions()==2 )
	// {
	// 	real kNorm=sqrt( SQR(kvr[0]) + SQR(kvr[1]) + SQR(kvr[2]) );
	// 	av[0]=-kvr[1]/kNorm;  // do this for now
	// 	av[1]= kvr[0]/kNorm;
	// }
	// else
	// {
	// 	real kNorm=sqrt( SQR(kvr[0]) + SQR(kvr[1]) + SQR(kvr[2]) );
	// 	av[0]=-kvr[1]/kNorm;  // do this for now
	// 	av[1]= kvr[0]/kNorm;

	// 	if( false )
	// 	{
	// 	  real bv[3]= {1.,-1.,1.};
	// 	  real kDotB= kvr[0]*bv[0]+kvr[1]*bv[1]+kvr[2]*bv[2];
	// 	  assert( fabs(kDotB)>1.e-10 );
       
	// 	  av[0]= (kvr[1]*bv[2]-kvr[2]*bv[1])/kDotB;
	// 	  av[1]= (kvr[2]*bv[0]-kvr[0]*bv[2])/kDotB;
	// 	  av[2]= (kvr[0]*bv[1]-kvr[1]*bv[0])/kDotB;
	// 	}
	
	// }

     
	pies.initialize( cg, dmp1,dmp2,av,kvr,kvi );

      }

      PlaneInterfaceExactSolution & pies = dbase.get<PlaneInterfaceExactSolution>("planeInterfaceExactSolution");
      bool computeMagneticField=false;
      pies.eval( t, cg, grid, ua, pv ,I1a,I2a,I3a, numberOfTimeDerivatives, computeMagneticField);

    }
    else if( method==bamx )
    {
      // printF("\n @@@@@@@ eval BA plane material interface exact solution @@@@@\n\n");

      // ----- BA Plane material interface ----
      assert( numberOfMaterialRegions==2 );
      std::vector<DispersiveMaterialParameters> & dmpVector = 
	dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

      DispersiveMaterialParameters & dmp1 = dmpVector[0];
      DispersiveMaterialParameters & dmp2 = dmpVector[1];


      if( !dbase.has_key("planeInterfaceExactSolution") )
      {
	// -- first time through: create class and initialize
	PlaneInterfaceExactSolution & pies = dbase.put<PlaneInterfaceExactSolution>("planeInterfaceExactSolution");

	Real kvp[3]= { kx*twoPi, ky*twoPi, kz*twoPi}; // 

        // -- when computing k given s, choose this s: 
	Real sr=0.;
	Real si = -sqrt( SQR(kvp[0]) + SQR(kvp[1]) + SQR(kvp[2]) );

	Real skr=sr, ski=si;
	pies.initializeBAPlaneInterfaceSolution( dmp1, dmp2, kvp, skr, ski );

      }
    

      PlaneInterfaceExactSolution & pies = dbase.get<PlaneInterfaceExactSolution>("planeInterfaceExactSolution");
      // pes.eval( t, cg, grid, ua, pv ,I1a,I2a,I3a, numberOfTimeDerivatives, computeMagneticField);

      int & solveForAllFields = dbase.get<int>("solveForAllFields");

      OV_GET_SERIAL_ARRAY(int,cg[grid].mask(),maskLocal);

      if( numberOfMaterialRegions>1 )
      {
	// assert( cg.numberOfComponentGrids()==1 );
	// assert( pBodyMask!=NULL );
        intCompositeGridFunction & materialMask = parameters.dbase.get<intCompositeGridFunction>("materialMask");
        OV_GET_SERIAL_ARRAY(int,materialMask[grid],matMask);
	pies.evalBA( dmp1, dmp2, t, cg, grid, matMask, ua, pv,I1a,I2a,I3a, numberOfTimeDerivatives, solveForAllFields);
      }
      else
      {
	pies.evalBA( dmp1, dmp2, t, cg, grid, maskLocal, ua, pv,I1a,I2a,I3a, numberOfTimeDerivatives, solveForAllFields);
      }

      // IntegerArray & matMask = numberOfMaterialRegions>1 ? *pBodyMask : maskLocal;


    }
    
  }
  

  else if( userKnownSolution=="interfaceSurfaceWave" )
  {
    if( method==nfdtd )
    {
      OV_ABORT("interfaceSurfaceWave: finish me");
      
    }
    else if( method==bamx )
    {
      // ----- BA interface surface wave  ----

      // printF("\n @@@@@@@ eval BA interface surface wave exact solution @@@@@\n\n");

      assert( numberOfMaterialRegions==2 );
      std::vector<DispersiveMaterialParameters> & dmpVector = 
	dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

      DispersiveMaterialParameters & dmp1 = dmpVector[0];
      DispersiveMaterialParameters & dmp2 = dmpVector[1];

      if( !dbase.has_key("surfaceWaveExactSolution") )
      {
	// -- first time through: create class and initialize
        const aString & caseName = dbase.get<aString>("caseName");
	SurfaceWaveExactSolution & swes = dbase.put<SurfaceWaveExactSolution>("surfaceWaveExactSolution");
	swes.initialize( cg,dmp1, dmp2,caseName );
      }

      SurfaceWaveExactSolution & swes = dbase.get<SurfaceWaveExactSolution>("surfaceWaveExactSolution");

      int & solveForAllFields = dbase.get<int>("solveForAllFields");

      OV_GET_SERIAL_ARRAY(int,cg[grid].mask(),maskLocal);
      if( numberOfMaterialRegions>1 )
      {
	assert( cg.numberOfComponentGrids()==1 );
      }
      intCompositeGridFunction & materialMask = parameters.dbase.get<intCompositeGridFunction>("materialMask");
      OV_GET_SERIAL_ARRAY(int,materialMask[grid],matMask);


      swes.evalBA( dmp1, dmp2, t, cg, grid, matMask, ua, pv,I1a,I2a,I3a, numberOfTimeDerivatives, solveForAllFields);

    }
    
  }
  
  else if( userKnownSolution=="slabs" )
  {
    // ======= SCATTERING FROM ONE OR MORE ADJACENT SLABS ===============
    if( method==nfdtd )
    {
      if( !dbase.has_key("slabsExactSolution") )
      {
	// -- first time through: create class and initialize
	SlabsExactSolution & ses = dbase.put<SlabsExactSolution>("slabsExactSolution");

        int numberOfDomains=cg.numberOfComponentGrids();

	if( !parameters.dbase.has_key("materialRegionParameters") )
	{
          // **** put this some where else ****
	  printF("\n ################ UDKS : CREATE DMP VECTOR ##################\n\n");
	  
	  std::vector<DispersiveMaterialParameters> & dmpVector =
	    parameters.dbase.put<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

	  // const int domain1 = 0, domain2=1, domain3=2;
	  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
	  {
	    int domain = grid;
     	    DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
	    dmpVector.push_back(dmp);
	  }
	  

	  // for( int domain=0; domain<cg.numberOfDomains(); domain++ )
	  // {
	  //   const DispersiveMaterialParameters & dmp0 = getDomainDispersiveMaterialParameters(domain);
	  //   dmpVector.push_back(dmp0);
	  // }
	  // if( cg.numberOfDomains()<numberOfDomains )
	  // {
          //   int domain=0;  // first domain equals last 
	  //   const DispersiveMaterialParameters & dmp0 = getDomainDispersiveMaterialParameters(domain);
	  //   dmpVector.push_back(dmp0);
	  // }
	  

	}
	
	std::vector<DispersiveMaterialParameters> & dmpVector = 
	  parameters.dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

	RealArray kvI(3);
        // real kx=1., ky=.5;
	// kvI(0)=kx*twoPi; kvI(1)=ky*twoPi; kvI(2)=0.;
    

	kvI(0)=kx*twoPi; kvI(1)=ky*twoPi; kvI(2)=kz*twoPi;
        real c0=1.;  // *fix me**
        real omega= c0*sqrt( SQR(kvI(0)) + SQR(kvI(1)) + SQR(kvI(2)) );
        const int & solveForAllFields = dbase.get<int>("solveForAllFields");

        ses.initialize( cg, numberOfDomains,dmpVector,omega,kvI,solveForAllFields );

        //  -- **make this an option**:	
        int scatCase=0;  // forward TEz
        // int scatCase=2;  // backward TEz
        ses.setScatteringCase( scatCase );
	
        printF(" SLABS: kx/(2*pi)=%g, ky/(2*pi)=%g, kz/(2*pi)=%g, omega/(2*pi)=%g\n",kx,ky,kz,omega/(twoPi));

      }

      SlabsExactSolution & ses = dbase.get<SlabsExactSolution>("slabsExactSolution");
      bool computeMagneticField=false;
      ses.eval( t, cg, grid, ua, pv ,I1a,I2a,I3a, numberOfTimeDerivatives, computeMagneticField);

    }
    else if( method==bamx )
    {
      OV_ABORT("finish me: SLABS BAMX");
      
    }
  }

  else if( userKnownSolution=="nonlinearPulse" )
  {
    // ======= NONLINEAR PULSE EXACT SOLUTION ===============
    printF("UDKS: nonlinearPulse: t=%9.3e, FINISH ME ...\n",t);


    if( !dbase.has_key("nonlinearExactSolution") )
    {
      // -- first time through: create class and initialize
      NonlinearExactSolution & nes = dbase.put<NonlinearExactSolution>("nonlinearExactSolution");

      int numberOfDomains=cg.numberOfComponentGrids();
      if( !parameters.dbase.has_key("materialRegionParameters") )
      {
	// **** put this some where else ****
	printF("\n ################ UDKS : NONLINEAR PULSE: CREATE DMP VECTOR ##################\n\n");
	  
	std::vector<DispersiveMaterialParameters> & dmpVector =
	  parameters.dbase.put<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

	for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
	{
	  int domain = grid;
	  DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
	  dmpVector.push_back(dmp);
	}
	  
      }
	
      std::vector<DispersiveMaterialParameters> & dmpVector = 
	parameters.dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

      RealArray kvI(3);
      // real kx=1., ky=.5;
      // kvI(0)=kx*twoPi; kvI(1)=ky*twoPi; kvI(2)=0.;
    

      kvI(0)=kx*twoPi; kvI(1)=ky*twoPi; kvI(2)=kz*twoPi;
      real c0=1.;  // *fix me**
      real omega= c0*sqrt( SQR(kvI(0)) + SQR(kvI(1)) + SQR(kvI(2)) );
      const int & solveForAllFields = dbase.get<int>("solveForAllFields");

      nes.initialize( cg, numberOfDomains,dmpVector,omega,kvI,solveForAllFields );

    }

    NonlinearExactSolution & nes = dbase.get<NonlinearExactSolution>("nonlinearExactSolution");
    bool computeMagneticField=false;
    nes.eval( t, cg, grid, ua, pv, qv, I1a,I2a,I3a, numberOfTimeDerivatives, computeMagneticField);

  }
  // end nonlinearPulse
  
  
  else
  {
    printF("getUserDefinedKnownSolution:ERROR: unknown value for userDefinedKnownSolution=%s\n",
	   (const char*)userKnownSolution);
    OV_ABORT("ERROR");
  }
  
  return 0;
}


int Maxwell::
updateUserDefinedKnownSolution(GenericGraphicsInterface & gi, CompositeGrid & cg)
// ==========================================================================================
/// \brief This function is called to set the user defined known solution.
/// 
// ==========================================================================================
{
  // Make  dbase.get<real >("a") sub-directory in the data-base to store variables used here
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
     dbase.put<DataBase>("userDefinedKnownSolutionData");
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  if( !db.has_key("userKnownSolution") )
  {
    db.put<aString>("userKnownSolution");
    db.get<aString>("userKnownSolution")="unknownSolution";
    
    db.put<real[20]>("rpar");
    db.put<int[20]>("ipar");
  }
  aString & userKnownSolution = db.get<aString>("userKnownSolution");
  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");


  const aString menu[]=
    {
      "no known solution",
      "manufactured pulse",
      "chirped plane wave",
      "dispersive plane wave",
      "dispersive plane wave interface",
      "interface surface wave",
      "slabs",
      "nonlinear pulse",
      "done",
      ""
    }; 

  gi.appendToTheDefaultPrompt("userDefinedKnownSolution>");
  aString answer;
  for( ;; ) 
  {

    int response=gi.getMenuItem(menu,answer,"Choose a known solution");
    
    if( answer=="done" || answer=="exit" )
    {
      break;
    }
    else if( answer=="no known solution" )
    {
      userKnownSolution="unknownSolution";
    }
    else if( answer=="manufactured pulse" ) 
    {
      userKnownSolution="manufacturedPulse";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

      printF("The manufactured pulse is based on \n"
             "    psi = amp*( -beta*( (x-x0-cx*t)^2 + (y-y0-cy*t)^2 + (z-z0-cz*t)^2 ) )\n"
             " ---2D ---\n"
	     "   Ex = -(y-y0-cy*t)*psi   ( Ex =  psi_y * const )\n"
             "   Ey =  (x-x0-cx*t)*psi   ( Ey = -psi_x * const )\n"
	     "   Hz =   psi;\n"
             " --- 3D ---\n"
	     "  Ex = ((z-z0-cz*t)-(y-y0-cy*t))*psi    ( Ex = ( psi_z - psi_y ) * const)\n"
	     "  Ey = ((x-x0-cx*t)-(z-z0-cz*t))*psi    ( Ey = ( psi_x - psi_z ) * const)\n"
	     "  Ez = ((y-y0-cy*t)-(x-x0-cx*t))*psi    ( Ez = ( psi_y - psi_x ) * const)\n"
                 );
      gi.inputString(answer,"Enter amp,beta,x0,y0,z0, cx,cy,cz");
      sScanF(answer,"%e %e %e %e %e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3],&rpar[4],&rpar[5],&rpar[6],&rpar[7]);
      printF(" Setting amp=%g, beta=%g, [x0,y0,z0]=[%g,%g,%g] [cx,cy,cz]=[%g,%g,%g]\n",
	     rpar[0],rpar[1],rpar[2],rpar[3],rpar[4],rpar[5],rpar[6],rpar[7]);
      
    }
    else if( answer=="chirped plane wave" ) 
    {
      userKnownSolution="chirpedPlaneWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

      printF("The chirped plane wave is defined by ...\n");
      
      
    }
    
    // replaced: 
    // else if( answer=="dispersive plane wave" ) 
    // {
    //   userKnownSolution="dispersivePlaneWave";
    //   dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

    //   printF("The dispersive plane wave is defined by: \n"
    //          "    E = a*sin( k*x - omegar*t)*exp(omegai*t)\n"
    //          "    P = [b*cos( k*x - omegar*t) + c*sin( k*x - omegar*t) ]*exp(omegai*t)\n"
    //         );
      
      
    // }
    else if( answer=="dispersive plane wave interface" ) 
    {
      userKnownSolution="dispersivePlaneWaveInterface";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      printF("The dispersive plane wave interface defines an exact solution for a plane wave\n"
             " hitting a planar material interface between two dispersive materials\n");
      
    }
    
    else if( answer=="interface surface wave" ) 
    {
      userKnownSolution="interfaceSurfaceWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      if( !dbase.has_key("caseName") )
	dbase.put<aString>("caseName");

      aString & caseName = dbase.get<aString>("caseName");
      
      printF("The interface surface wave is an exact solution for a traveling surface wave between two interfaces.\n"
	     " Available caseNames:\n"
	     "  (1) surfaceWaveCase1SpacePeriodic \n"
	     "  (2) surfaceWaveCase1TimePeriodic \n"
	);
      gi.inputString(caseName,"Enter the caseName");
      
    }
    
    else if( answer=="slabs" ) 
    {
      userKnownSolution="slabs";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      if( !dbase.has_key("caseName") )
	dbase.put<aString>("caseName");

      aString & caseName = dbase.get<aString>("caseName");
      
      printF("Slabs is an exact solution for a plane wave scattering from one or more slabs.\n"
	     " Available caseNames:\n"
	     "  (1) oneSlabIsoEps2 \n"
	);
      gi.inputString(caseName,"Enter the caseName");
      
    }
    
    else if( answer=="nonlinear pulse" ) 
    {
      userKnownSolution="nonlinearPulse";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      if( !dbase.has_key("caseName") )
	dbase.put<aString>("caseName");

      aString & caseName = dbase.get<aString>("caseName");
      
      printF("Choose the case:\n"
	     " Available caseNames:\n"
	     "  (1) soliton \n"
	);
      gi.inputString(caseName,"Enter the caseName");
      
    }
    
    else
    {
      printF("unknown response=[%s]\n",(const char*)answer);
      gi.stopReadingCommandFile();
    }
    
  }

  gi.unAppendTheDefaultPrompt();
  bool knownSolutionChosen = userKnownSolution!="unknownSolution";
  return knownSolutionChosen;
}


// Include complex down here to minimize name conflicts
#include <complex>

typedef ::real OV_real;
// =====================================================================================
/// \brief Utility routine to do some complex arithemetic for the dispersive plane
///    wave material interface.
///
///  Compute kxp=(kxpr,kxpi)  given (kr,ki), and kyp=(kypr,kypi)
///  kxp^2 + kyp^2 = (kr+I*ki)^2 = (kr^2-ki^2) + 2*I*kr*ki 
///  kxp = kxpr + I*kpri = sqrt( (kr+I*ki)^2 - kyp^2 )
// =====================================================================================
void
getTransmisionWaveNumber( const LocalReal & kr,  const LocalReal & ki, 
                          const LocalReal & kxr, const LocalReal & kxi, 
                          const LocalReal & kyr, const LocalReal & kyi, 
                          LocalReal & kxpr, LocalReal & kxpi, 
                          LocalReal & kypr, LocalReal & kypi )
{
  // No jump in tangential field: kyp=ky : 
  kypr=kyr;
  kypi=kyi;

  // std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> ky(kyr,kyi);
  std::complex<LocalReal> k(kr,ki);
  std::complex<LocalReal> kxp,kyp(kypr,kypi);

  // cout << "kyp=" << kyp << endl;

  kxp = std::sqrt( k*k - kyp*kyp );

  kxpr= std::real(kxp);
  kxpi= std::imag(kxp);
  
  // printF("--getTransmisionWaveNumber--- kx=(%g,%g) ky=(%g,%g) (kr,ki)=(%g,%g) kxp=(%g,%g) kyp=(%g,%g)\n",
  //            kxr,kxi,kyr,kyi,kr,ki,kxpr,kxpi,kypr,kypi);

}


// ---------------------------------------------------------------------------------------
// Check routine : 
//   Check the jump:
//       eps1Hat*khyat*(1-r) = eps2Hat*kyHatp*tau
// ---------------------------------------------------------------------------------------
void
checkPlaneMaterialInterfaceJumps( 
                          const LocalReal & c1, const LocalReal & c2,
                          const LocalReal & eps1, const LocalReal & eps2,
                          const LocalReal & mu1, const LocalReal & mu2,

                          const LocalReal & sr, const LocalReal & si,
                          const LocalReal & rr, const LocalReal & ri, 
                          const LocalReal & taur, const LocalReal & taui, 

                          const LocalReal & eps1Hatr, const LocalReal & eps1Hati,
                          const LocalReal & eps2Hatr, const LocalReal & eps2Hati,

                          const LocalReal & psiSum1r, const LocalReal & psiSum1i,
                          const LocalReal & psiSum2r, const LocalReal & psiSum2i,
                          const LocalReal & kxr, const LocalReal & kxi,
                          const LocalReal & kyr, const LocalReal & kyi,
                          const LocalReal & kxpr, const LocalReal & kxpi,
                          const LocalReal & kypr, const LocalReal & kypi

                            )
{

  std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> psiSum1(psiSum1r,psiSum1i);
  std::complex<LocalReal> psiSum2(psiSum2r,psiSum2i);

  std::complex<LocalReal> eps1Hat(eps1Hatr,eps1Hati);
  std::complex<LocalReal> eps2Hat(eps2Hatr,eps2Hati);
  std::complex<LocalReal> s(sr,si);
  std::complex<LocalReal> kx(kxr,kxi);
  std::complex<LocalReal> ky(kyr,kyi);
  std::complex<LocalReal> kxp(kxpr,kxpi);
  std::complex<LocalReal> kyp(kypr,kypi);
  std::complex<LocalReal> khx,khy, khpx,khpy;
  std::complex<LocalReal> r(rr,ri), tau(taur,taui);
  std::complex<LocalReal> dr1,dr2,jump;
  
  LocalReal kNorm = sqrt(kxr*kxr + kxi*kxi + kyr*kyr + kyi*kyi);
  khx= (kxr + I*kxi)/kNorm;
  khy= (kyr + I*kyi)/kNorm;
  
  LocalReal kpNorm = sqrt(kxpr*kxpr + kxpi*kxpi + kypr*kypr + kypi*kypi);
  khpx=(kxpr + I*kxpi)/kpNorm;
  khpy=(kypr + I*kypi)/kpNorm;
  
  printF("\n\n ** s=(%g,%g) kx=(%g,%g) ky=(%g,%g) c1=%g eps1=%g mu1=%g \n",sr,si,kxr,kxi,kyr,kyi,c1,eps1,mu1);
  

  jump = khx*(1.+r) - tau*khpx;
  printF("khx*(1.+r) - tau*khpx                 =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  
  jump =eps1Hat*khy*(1.-r) - eps2Hat*tau*khpy;
  printF(" [epsHat khy(1-r)- epsHat*tau*khy'    =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  
  // dispersion relations: 
  dr1 = s*s + c1*c1*(kx*kx  +ky*ky  ) + s*s*psiSum1;
  dr2 = s*s + c2*c2*(kxp*kxp+kyp*kyp) + s*s*psiSum2;

  printF(" dispersion-relation1                 =(%12.4e,%12.4e)\n",std::real(dr1), std::imag(dr1));
  printF(" dispersion-relation2                 =(%12.4e,%12.4e)\n",std::real(dr2), std::imag(dr2));

  jump = (1.-r)*( ky*khy + kx*khx )/mu1 - tau*( kyp*khpy+kxp*khpx )/mu2;
  printF(" (1-r)*( kSq )/mu1 - tau*( kpSq )/mu2'=(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( ky*ky + kx*kx )/(kNorm*mu1) - tau*( kyp*kyp+kxp*kxp )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( s*s*(1.+psiSum1)/(c1*c1) )/(kNorm*mu1) - tau*( s*s*(1.+psiSum2)/(c2*c2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( s*s*(1.+psiSum1)*(mu1*eps1) )/(kNorm*mu1) - tau*( s*s*(1.+psiSum2)*(mu2*eps2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( (1.+psiSum1)*(mu1*eps1) )/(kNorm*mu1) - tau*( (1.+psiSum2)*(mu2*eps2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( (1.+psiSum1)*(mu1*eps1) )*khy/(mu1) - tau*( (1.+psiSum2)*(mu2*eps2) )*khpy/(mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( (1.+psiSum1)*(eps1) )*khy - tau*( (1.+psiSum2)*(eps2) )*khpy;
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

}
