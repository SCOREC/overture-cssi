#include "Maxwell.h"
#include "DispersiveMaterialParameters.h"
#include "GenericGraphicsInterface.h"
#include "ParallelUtility.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)

typedef ::real LocalReal;
// utility routine (using complex numbers) defined at the bottom of the file.
void
getTransmisionWaveNumber( const LocalReal & kr,  const LocalReal & ki, 
                          const LocalReal & kxr, const LocalReal & kxi, 
                          const LocalReal & kyr, const LocalReal & kyi, 
                          LocalReal & kxpr, LocalReal & kxpi, 
                          LocalReal & kypr, LocalReal & kypi );

void
checkPlaneMaterialInterfaceJumps( 
  const LocalReal & c1, const LocalReal & c2,
  const LocalReal & eps1, const LocalReal & eps2,
  const LocalReal & mu1, const LocalReal & mu2,

  const LocalReal & sr, const LocalReal & si,
  const LocalReal & rr, const LocalReal & ri, 
  const LocalReal & taur, const LocalReal & taui, 

  const LocalReal & eps1Hatr, const LocalReal & eps1Hati,
  const LocalReal & eps2Hatr, const LocalReal & eps2Hati,

  const LocalReal & psiSum1r, const LocalReal & psiSum1i,
  const LocalReal & psiSum2r, const LocalReal & psiSum12i,
  const LocalReal & kxr, const LocalReal & kxi,
  const LocalReal & kyr, const LocalReal & kyi,
  const LocalReal & kxpr, const LocalReal & kxpi,
  const LocalReal & kypr, const LocalReal & kypi
  );


#define evalMaterialInterfaceSolution3d EXTERN_C_NAME(evalmaterialinterfacesolution3d)
extern "C"
{

void  evalMaterialInterfaceSolution3d( const real&sr,const real&si, 
                                       const real&chiSum1r, const real&chiSum1i, const real&chiSum2r, const real&chiSum2i,
                                       const real&av,const real&nv,const real&kv,
                                       const real&eps1,const real&eps2,
                                       const real&mu1,const real&mu2,
                                       const real&krr,const real&kri,
                                       const real&ktr,const real&kti,
                                       real & arr, real & ari, real & atr, real & ati );

}

// ==========================================================================================
/// \brief  Evaluate a user defined known solution.
///
/// \param numberOfTimeDerivatives (input) : evaluate this many time-derivatives of the solution.
///     Normally  numberOfTimeDerivatives=0, but it can be 1 when the known solution is used
//      to define boundary conditions 
// ==========================================================================================
int Maxwell::
getUserDefinedKnownSolution(int current, real t, CompositeGrid & cg, int grid, 
                            realArray & ua, realArray & pv,
                            const Index & I1a, const Index &I2a, const Index &I3a, 
                            int numberOfTimeDerivatives /* = 0 */ )
{
  if( false )
    printF("--MX--getUserDefinedKnownSolution at t=%9.3e\n",t);

  MappedGrid & mg = cg[grid];
  const int numberOfDimensions = cg.numberOfDimensions();
  const real & dt= deltaT;
  
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
  {
    printF("--MX-- getUserDefinedKnownSolution:ERROR: sub-directory `userDefinedKnownSolutionData' not found!\n");
    OV_ABORT("error");
  }
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  const aString & userKnownSolution = db.get<aString>("userKnownSolution");

  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");
  
  OV_GET_SERIAL_ARRAY(real,ua,uLocal);

  Index I1=I1a, I2=I2a, I3=I3a;
  bool ok = ParallelUtility::getLocalArrayBounds(ua,uLocal,I1,I2,I3,1);   
  if( !ok ) return 0;  // no points on this processor (NOTE: no communication should be done after this point)

  // -- we optimize for Cartesian grids (we can avoid creating the vertex array)
  const bool isRectangular=mg.isRectangular();
  if( !isRectangular )
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);
  OV_GET_SERIAL_ARRAY(real,mg.center(),xLocal);

  real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
	xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular grids:
#undef XC
#define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

  
  if( userKnownSolution=="manufacturedPulse" )
  {
    // Manufactured pulse:
    //   A pulse like solution that requires a forcing function to make it a solution
    //   Used to test the forcing terms in the equations.
    const real amp = rpar[0];
    const real beta= rpar[1];
    const real x0  = rpar[2];
    const real y0  = rpar[3];
    const real z0  = rpar[4];
    const real cx  = rpar[5];
    const real cy  = rpar[6];
    const real cz  = rpar[7];

    real x,y,z;
    if( numberOfTimeDerivatives==0 )
    {
      if( numberOfDimensions==2 )
      {
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
	  }
	  else
	  {
            x=XC(iv,0);
            y=XC(iv,1);
	  }
	  
	  real psi = amp*exp(-beta*( SQR(x-x0-cx*t) + SQR(y-y0-cy*t) ));
	  uLocal(i1,i2,i3,ex) = -(y-y0-cy*t)*psi;    // Ex =  psi_y * const 
	  uLocal(i1,i2,i3,ey) =  (x-x0-cx*t)*psi;    // Ey = -psi_x * const
	  uLocal(i1,i2,i3,hz) =  psi;
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme

            // **check me**
	    real psit = (2.*beta)*( cx*(x-x0-cx*t) + cy*(y-y0-cy*t) )*psi;
	    uLocal(i1,i2,i3,ext) =  cy*psi  -(y-y0-cy*t)*psit;    
	    uLocal(i1,i2,i3,eyt) = -cx*psi  +(x-x0-cx*t)*psit;    
	    uLocal(i1,i2,i3,hzt) =  psit;
	  }
	}
      }
      else
      {
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
	    x= xLocal(i1,i2,i3,0);
	    y= xLocal(i1,i2,i3,1);
	    z= xLocal(i1,i2,i3,2);
	  }
	  else
	  {
	    x=XC(iv,0);
	    y=XC(iv,1);
	    z=XC(iv,2);
	  }

	  real psi = amp*exp(-beta*( SQR(x-x0-cx*t) + SQR(y-y0-cy*t) + SQR(z-z0-cz*t) ));
	  uLocal(i1,i2,i3,ex) = ((z-z0-cz*t)-(y-y0-cy*t))*psi;    // Ex = ( psi_z - psi_y ) * const
	  uLocal(i1,i2,i3,ey) = ((x-x0-cx*t)-(z-z0-cz*t))*psi;    // Ey = ( psi_x - psi_z ) * const
	  uLocal(i1,i2,i3,ez) = ((y-y0-cy*t)-(x-x0-cx*t))*psi;    // Ez = ( psi_y - psi_x ) * const
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme

            // **check me**
	    real psit = (2.*beta)*( cx*(x-x0-cx*t) + cy*(y-y0-cy*t) +cz*(z-z0-cz*t))*psi;
	    uLocal(i1,i2,i3,ext) = (-cz+cy)*psi + ((z-z0-cz*t)-(y-y0-cy*t))*psit;    
	    uLocal(i1,i2,i3,eyt) = (-cx+cz)*psi + ((x-x0-cx*t)-(z-z0-cz*t))*psit;    
            uLocal(i1,i2,i3,ezt) = (-cy+cx)*psi + ((y-y0-cy*t)-(x-x0-cx*t))*psit;
	  }	  
	  

	}
      }
    }
    else
    {
      OV_ABORT("finish me: numberOfTimeDerivatives1=0");
      
    }
    
  }
  else if( userKnownSolution=="chirpedPlaneWave" )
  {
    // -------------------------------------------
    // ---------- Chirped plane wave  -------------
    // -------------------------------------------

    // Chirped plane-wave parameters
    const ChirpedArrayType & cpw = dbase.get<ChirpedArrayType >("chirpedParameters");
    const real cpwTa   =cpw(0); // ta 
    const real cpwTb   =cpw(1); // tb 
    const real cpwAlpha=cpw(2); // alpha
    const real cpwBeta =cpw(3); // beta
    const real cpwAmp  =cpw(4); // amp
    const real cpwX0   =cpw(5); // x0
    const real cpwY0   =cpw(6); // y0
    const real cpwZ0   =cpw(7); // z0

    const real xi0 = .5*(cpwTa+cpwTb);
    const real cpwTau= cpwTb-cpwTa;    // tau=tb-ta
    
    printF("--UDKS-- eval chirped plane wave at t=%10.3e, [ta,tb]=[%g,%g]\n",t,cpwTa,cpwTb);

    c = cGrid(grid);
    const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);

    // For checking the scattering from a planar PEC boundary we change the
    // sign of the solution to be that for for scattered field.
    const bool & solveForScatteredField = dbase.get<bool>("solveForScatteredField");
    const real signForField = solveForScatteredField ? -1. : 1.;

    real x,y,z;
    if( numberOfTimeDerivatives==0 )
    {
      if( numberOfDimensions==2 )
      {
        // ----------- 2D --------------
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
	  }
	  else
	  {
            x=XC(iv,0);
            y=XC(iv,1);
	  }
 	  
          real xi = t - (kx*(x-cpwX0)+ky*(y-cpwY0))/cc - xi0;

	  real tanha = tanh(cpwBeta*(xi+.5*cpwTau));
	  real tanhb = tanh(cpwBeta*(xi-.5*cpwTau));
	  real amp = cpwAmp*.5*( tanha - tanhb );

	  real phi = cc*xi + cpwAlpha*xi*xi;
          real sinPhi = sin(twoPi*phi);

	  real  chirp = signForField*amp*sinPhi;
	  
	  uLocal(i1,i2,i3,ex) = chirp*pwc[0];
	  uLocal(i1,i2,i3,ey) = chirp*pwc[1];
	  uLocal(i1,i2,i3,hz) = chirp*pwc[5];
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme
            
            // tanh' = 1 - tanh^2
            real damp= cpwAmp*.5*cpwBeta*( -tanha*tanha + tanhb*tanhb );
            real dphi = cc + 2.*cpwAlpha*xi;

            chirp = signForField*( damp*sinPhi + amp*twoPi*dphi*cos(twoPi*phi) );

	    uLocal(i1,i2,i3,ext) = chirp*pwc[0];
	    uLocal(i1,i2,i3,eyt) = chirp*pwc[1];
	    uLocal(i1,i2,i3,hzt) = chirp*pwc[5];
	  }
	}
      }
      else
      {
        // ----------- 3D --------------
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
	    x= xLocal(i1,i2,i3,0);
	    y= xLocal(i1,i2,i3,1);
	    z= xLocal(i1,i2,i3,2);
	  }
	  else
	  {
	    x=XC(iv,0);
	    y=XC(iv,1);
	    z=XC(iv,2);
	  }

          real xi = t - (kx*(x-cpwX0)+ky*(y-cpwY0))/cc - xi0;

          // these next formulae are the same as in 2D
	  real tanha = tanh(cpwBeta*(xi+.5*cpwTau));
	  real tanhb = tanh(cpwBeta*(xi-.5*cpwTau));
	  real amp = cpwAmp*.5*( tanha - tanhb );

	  real phi = cc*xi + cpwAlpha*xi*xi;
          real sinPhi = sin(twoPi*phi);

	  real  chirp = signForField*amp*sinPhi;
	  
	  uLocal(i1,i2,i3,ex) =  chirp*pwc[0];
	  uLocal(i1,i2,i3,ey) =  chirp*pwc[1];
	  uLocal(i1,i2,i3,ez) =  chirp*pwc[2];
          if( method==sosup )
	  {
	    // supply time-derivatives for sosup scheme
            // tanh' = 1 - tanh^2
            real damp= cpwAmp*.5*cpwBeta*( -tanha*tanha + tanhb*tanhb );
            real dphi = cc + 2.*cpwAlpha*xi;

            chirp = signForField*( damp*sinPhi + amp*twoPi*dphi*cos(twoPi*phi) );

	    uLocal(i1,i2,i3,ext) = chirp*pwc[0];
	    uLocal(i1,i2,i3,eyt) = chirp*pwc[1];
	    uLocal(i1,i2,i3,ezt) = chirp*pwc[2];

	  }	  
	  

	}
      }
    }
    else
    {
      OV_ABORT("finish me: numberOfTimeDerivatives1=0");
      
    }
    
  }
  
  // else if( userKnownSolution=="dispersivePlaneWave" )
  // {
  //   // -----------------------------------------------
  //   // ---------- Dispersive plane wave  -------------
  //   // -----------------------------------------------

  //   assert( dispersionModel!=noDispersion );

  //   DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);

  //   // evaluate the dispersion relation,  exp(i(k*x-omega*t))
  //   //    omega is complex 
  //   const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz); // true wave-number (note factor of twoPi)
  //   real omegaDpwRe, omegaDpwIm;
  //   dmp.computeDispersivePlaneWaveParameters( c,eps,mu,kk, omegaDpwRe, omegaDpwIm );

  //   if( t<3.*dt )
  //     printF("--UDKS:DPW-- t=%10.3e, omegar=%g, omegai=%g\n",t,omegaDpwRe, omegaDpwIm );

  //   const real dpwExp =exp(omegaDpwIm*t);
    
  //   const real c = cGrid(grid);
  //   const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);

  //   const real eps = epsGrid(grid);
  //   const real mu  = muGrid(grid);
  //   const real ck2 = SQR(c*kk);

  //   // compute coefficients of P :   s = sr+I*si = -I*omega = -I*( omegar + I omegai) = omegai - I*omegar
  //   //     s^2 E = -(c*k)^2 E - (s^2/eps) * P 
  //   // ->  P = -eps*( 1 + (c*k/s)^2 ) E 
  //   real sr = omegaDpwIm, si=-omegaDpwRe;
  //   real sNorm2=sr*sr+si*si, sNorm4=sNorm2*sNorm2;
  //   real pc = -eps*( -2.*sr*si*ck2/sNorm4 );
  //   real ps = -eps*( 1. + ck2*(sr*sr-si*si)/sNorm4 );

  //   //  mu * (Hz)_t = (Ex)_y - (Ey)_x
  //   //  Hz = [hc*cos(xi) + hs*sin(xi) ]*exp(omegai*t)
  //   // *check me*
  //   real factor = twoPi*( kx*pwc[1] - ky*pwc[0] )/mu;  // (kx*Ey - ky*Ex )/mu
  //   real omegaNorm2=SQR(omegaDpwRe)+SQR(omegaDpwIm);
  //   real hs =  factor*omegaDpwRe/omegaNorm2;
  //   real hc = -factor*omegaDpwIm/omegaNorm2;
    

  //   if( t<3.*dt )
  //     printF("--UDKS:DPW-- ck2=%10.3e, pc=%g, ps=%g, sr=%g, si=%g, hc=%g hs=%g\n",ck2,pc,ps,sr,si,hc,hs);

  //   real x,y,z;
  //   if( numberOfTimeDerivatives==0 )
  //   {
  //     if( numberOfDimensions==2 )
  //     {
  //       // ----------- 2D --------------
  //       FOR_3D(i1,i2,i3,I1,I2,I3)
  //       {
  //         if( !isRectangular )
  //         {
  //          x= xLocal(i1,i2,i3,0);
  //          y= xLocal(i1,i2,i3,1);
  //         }
  //         else
  //         {
  //           x=XC(iv,0);
  //           y=XC(iv,1);
  //         }
  //         real xi=twoPi*(kx*x+ky*y) -omegaDpwRe*t;
  //         real sinxi=sin(xi), cosxi=cos(xi);

  //         uLocal(i1,i2,i3,ex) = sinxi*pwc[0]*dpwExp;
  //         uLocal(i1,i2,i3,ey) = sinxi*pwc[1]*dpwExp;
  //         uLocal(i1,i2,i3,hz) = (hc*cosxi+hs*sinxi)*dpwExp;

  //         // -- polarization vector --
  //         uLocal(i1,i2,i3,pxc) = (pc*cosxi+ps*sinxi)*pwc[0]*dpwExp;
  //         uLocal(i1,i2,i3,pyc) = (pc*cosxi+ps*sinxi)*pwc[1]*dpwExp;

  //         if( method==sosup )
  //         {
  //           // supply time-derivatives for sosup scheme
  //           OV_ABORT("finish me");
  //         }
  //       }
  //     }
  //     else
  //     {
  //       // ----------- 3D --------------
  //       FOR_3D(i1,i2,i3,I1,I2,I3)
  //       {
  //         if( !isRectangular )
  //         {
  //           x= xLocal(i1,i2,i3,0);
  //           y= xLocal(i1,i2,i3,1);
  //           z= xLocal(i1,i2,i3,2);
  //         }
  //         else
  //         {
  //           x=XC(iv,0);
  //           y=XC(iv,1);
  //           z=XC(iv,2);
  //         }

  //         OV_ABORT("finish me");
      
  //       }
  //     }
  //   }
  //   else
  //   {
  //     OV_ABORT("finish me: numberOfTimeDerivatives1=0");

  //   }
    
  // }
  
  else if( userKnownSolution=="dispersivePlaneWaveInterface" )
  {
    // ----------------------------------------------------
    // ---- DISPERSIVE PLANE WAVE MATERIAL INTERFACE ------
    // ----------------------------------------------------
    // NOTES:
    //    (1) incident wave number is given --> compute s=sr + I*si 
    //    (2) Given s, compute wave number in right state

    assert( dispersionModel!=noDispersion );
    assert( cg.numberOfDomains()==2 );


    real sr,si;
    real kxr, kxi, kyr, kyi;        // Incident wave number (complex)
    real kxpr, kxpi, kypr, kypi;    // Transmitted wave number
  
    real chi1r[10],chi1i[10];
    real chi2r[10],chi2i[10];

    real chiSum1r=0.,chiSum1i=0;
    real chiSum2r=0.,chiSum2i=0;
 
   
    const int gridLeft = 0;
    const int gridRight=cg.numberOfComponentGrids()-1;

    real c1,c2,eps1,eps2,mu1,mu2;
    if( method==yee )
    {
      eps1=epsv(gridLeft);  mu1=muv(gridLeft);    // incident 
      eps2=epsv(gridRight); mu2=muv(gridRight);   // transmitted
    }
    else
    {
      eps1=epsGrid(gridLeft);  mu1=muGrid(gridLeft); // incident
      eps2=epsGrid(gridRight); mu2=muGrid(gridRight); // transmitted

    }
    c1=1./sqrt(eps1*mu1);  // incident 
    c2=1./sqrt(eps2*mu2);  // transmitted

    int domain=0;
    DispersiveMaterialParameters & dmp1 = getDomainDispersiveMaterialParameters(domain);
    const int & numberOfPolarizationVectors1=dmp1.numberOfPolarizationVectors;
    assert( numberOfPolarizationVectors1<10 );

    kxr=twoPi*kx; kxi=0.; kyr=twoPi*ky; kyi=0.;  // Incident wave number (complex)

    const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz );   
    dmp1.evaluateDispersionRelation( c1,kk, sr, si, chi1r,chi1i,chiSum1r,chiSum1i ); 
    // si = -si; // reverse the direction NO -- changes chi1 !

    // // Save the "sum" of the chi's times alphaP
    // chiSum1r=0.; chiSum1i=0;
    // for( int iv=0; iv<dmp1.numberOfPolarizationVectors; iv++ )
    // {
    //   chiSum1r += chi1r[iv];
    //   chiSum1i += chi1i[iv];
    // }
    // chiSum1r *= dmp1.alphaP;
    // chiSum1i *= dmp1.alphaP;
        
    // -- -right domain --
    domain=1;
    DispersiveMaterialParameters & dmp2 = getDomainDispersiveMaterialParameters(domain);
    const int & numberOfPolarizationVectors2=dmp2.numberOfPolarizationVectors;
    assert( numberOfPolarizationVectors2<10 );
   
    real kr,ki;
    dmp2.evaluateComplexWaveNumber( c2,sr,si, kr,ki, chi2r,chi2i,chiSum2r,chiSum2i );
    //  kxp^2 + kyp^2 = (kr+I*ki)^2 = (kr^2-ki^2) + 2*I*kr*ki 
    // kxp = kxpr + I*kpri = sqrt( (kr+I*ki)^2 - kyp^2 )
    getTransmisionWaveNumber( kr,ki, kxr,kxi, kyr,kyi, kxpr,kxpi, kypr,kypi );
    // // do this for now -- assume normal incidence
    // assert( ky==0. );
    // kxpr=kr; kxpi=ki;
    // kypr=0.; kypi=0.;
   
    if( false && t<3.*dt )
    {
      printF("\n --UDKS:DPWI-- t=%10.4e, grid=%i, s=(%16.10e,%16.10e) kx=(%16.10e,%16.10e) ky=(%16.10e,%16.10e) -> k2=(kr,ki)=(%16.10e,%16.10e) kxp=(%16.10e,%16.10e) kyp=(%16.10e,%16.10e)\n"
             ,t,grid,sr,si,kxr,kxi,kyr,kyi,kr,ki,kxpr,kxpi,kypr,kypi);
      printF("    chi1=(%16.10e,%16.10e), chi2=(%16.10e,%16.10e) \n",chi1r[0],chi1i[0],chi2r[0],chi2i[0]);
      
    }
    

    // // // Save the "sum" of the chi's  times alphaP
    // chiSum2r=0.; chiSum2i=0;
    // for( int iv=0; iv<dmp2.numberOfPolarizationVectors; iv++ )
    // {
    //   chiSum2r += chi2r[iv];
    //   chiSum2i += chi2i[iv];
    // }
    // chiSum2r *= dmp2.alphaP;
    // chiSum2i *= dmp2.alphaP;

    const real alphaP = dmp1.alphaP;
    const real a= 1.; // amplitude *FIX ME**


    // domain number for this grid: 
    const int myDomain = cg.domainNumber(grid);

    // --- Get Arrays for the dispersive model ----

    // realMappedGridFunction & pCur = getDispersionModelMappedGridFunction( grid,current );
    RealArray pLocal;
    if( (myDomain==0 && numberOfPolarizationVectors1>0) ||
        (myDomain==1 && numberOfPolarizationVectors2>0)  )
    {
      OV_GET_SERIAL_ARRAY(real, pv,pLoc);
      pLocal.reference(pLoc);
    }

    
    // For a rotated interface, nv = normal and x0 is a point on the interface.
    real *nv = normalPlaneMaterialInterface;
    real *x0 = x0PlaneMaterialInterface;
    
    real x,y,z=0.;
    if( numberOfTimeDerivatives==0 )
    {
      if( numberOfDimensions==2 )
      {
        // ----------- 2D --------------
	FOR_3D(i1,i2,i3,I1,I2,I3)
	{
	  if( !isRectangular )
	  {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
	  }
	  else
	  {
            x=XC(iv,0);
            y=XC(iv,1);
	  }

          // -- un-rotate the point (x,y) to the reference space and evaluate the solution 
          real ct= nv[0], st=nv[1];  // cos(theta), sin(theta)
          real xa=x-x0[0], ya=y-x0[1];
          x =  ct*xa + st*ya;
          y = -st*xa + ct*ya;
          

          // Here are the statements to eval the solution: 
#Include "dispersivePlaneWaveInterface.h"

          // ---- rotate the field from the reference space to the rotated space ---
          real Exra=Exr, Eyra=Eyr;
          Exr =  ct*Exra - st*Eyra;
          Eyr =  st*Exra + ct*Eyra;
          
          real Exia=Exi, Eyia=Eyi;
          Exi =  ct*Exia - st*Eyia;
          Eyi =  st*Exia + ct*Eyia;
          
          real Expra=Expr, Eypra=Eypr;
          Expr =  ct*Expra - st*Eypra;
          Eypr =  st*Expra + ct*Eypra;
          
          real Expia=Expi, Eypia=Eypi;
          Expi =  ct*Expia - st*Eypia;
          Eypi =  st*Expia + ct*Eypia;
          

          if( false )
          {
            printF("(i1,i2)=(%3i,%3i): chiSum1=(%9.3e,%9.3e) chiSum2=(%9.3e,%9.3e) r=(%8.2e,%8.2e) "
                   "tau=(%8.2e,%8.2e) khy=(%8.2e,%8.2e) khpy=(%8.2e,%8.2e): ",
                   i1,i2,chiSum1r,chiSum1i,chiSum2r,chiSum2i,rr,ri,taur,taui,khyr,khyi,khypr,khypi);
            real eps1Hatr = eps1*(1.+chiSum1r), eps1Hati=eps1*(chiSum1i);
            real eps2Hatr = eps2*(1.+chiSum2r), eps2Hati=eps2*(chiSum2i);


            checkPlaneMaterialInterfaceJumps( 
              c1,c2,eps1,eps2,mu1,mu2, sr,si, rr,ri, taur,taui, 
              eps1Hatr,eps1Hati, eps2Hatr,eps2Hati,
              chiSum1r,chiSum1i,chiSum2r,chiSum2i,
              kxr,kxi, kyr,kyi, kxpr,kxpi, kypr,kypi );
            
            OV_ABORT("stop here for now");
            
          }
          
          if( false )
          {
            printF("(i1,i2)=(%3i,%3i): kNorm=%g, kpNorm=%g, kappa=(%g,%g) beta=(%g,%g)\n",
                   i1,i2,kNorm,kpNorm,kappar,kappai,betar,betai);
            printF("    : eps1=%g, eps2=%g, r=(%g,%g) tau=(%g,%g) \n",eps1,eps2,rr,ri,taur,taui);
            // printF("    : chiSum1=(%g,%g) chiSum2=(%g,%g) \n",chiSum1r,chiSum1i,chiSum2r,chiSum2i);
            printF("    : Exr=%g, Eyr=%g, Exi=%g, Eyi=%g Hzr=%g Hzi=%g\n",Exr,Eyr,Exi,Eyi,Hzr,Hzi);
            printF("    : Expr=%g, Eypr=%g, Expi=%g, Eypi=%g Hzpr=%g Hzpi=%g\n",Expr,Eypr,Expi,Eypi,Hzpr,Hzpi);

            OV_ABORT("finish me");
          }
          

          if( myDomain==0 )
          {
            uLocal(i1,i2,i3,ex) = Exr;
            uLocal(i1,i2,i3,ey) = Eyr;
            uLocal(i1,i2,i3,hz) = Hzr;

            for( int iv=0; iv<numberOfPolarizationVectors1; iv++ )
            {
              const int pc= iv*numberOfDimensions;
              pLocal(i1,i2,i3,pc  ) = eps1*( chi1r[iv]*Exr - chi1i[iv]*Exi );
              pLocal(i1,i2,i3,pc+1) = eps1*( chi1r[iv]*Eyr - chi1i[iv]*Eyi );
            }

          }
          else
          {
            uLocal(i1,i2,i3,ex) = Expr;
            uLocal(i1,i2,i3,ey) = Eypr;
            uLocal(i1,i2,i3,hz) = Hzpr;
            for( int iv=0; iv<numberOfPolarizationVectors2; iv++ )
            {
              const int pc= iv*numberOfDimensions;
              pLocal(i1,i2,i3,pc  ) = eps2*( chi2r[iv]*Expr - chi2i[iv]*Expi );
              pLocal(i1,i2,i3,pc+1) = eps2*( chi2r[iv]*Eypr - chi2i[iv]*Eypi );
            }
          }
          
          // // -- polarization vector --
          // uLocal(i1,i2,i3,pxc) = (pc*cosxi+ps*sinxi)*pwc[0]*dpwExp;
          // uLocal(i1,i2,i3,pyc) = (pc*cosxi+ps*sinxi)*pwc[1]*dpwExp;

	}
      }
      else
      {
        // -----------------------------
        // ----------- 3D --------------
        // -----------------------------

        if( true )
        {
          real kzpr=0., kzpi=0.;  // ** FIX ME ***
          
          real &ax=pwc[0], &ay=pwc[1], &az=pwc[2]; // Is this correct?


          real av[3]={ax,ay,az}; // 
          real kv[3]={twoPi*kx,twoPi*ky,twoPi*kz}; // 
          real arr[3], ari[3], atr[3], ati[3];
          real krr[3], kri[3], ktr[3], kti[3];
         
          evalMaterialInterfaceSolution3d( sr,si, chiSum1r, chiSum1i, chiSum2r, chiSum2i,
                                           av[0],nv[0],kv[0], eps1,eps2,mu1,mu2, 
                                           krr[0],kri[0], ktr[0],kti[0], arr[0],ari[0], atr[0],ati[0] );

           
          if( false )
          {
            printF(" ar=(%.3g + %.3g I,%.3g + %.3g I,%.3g + %.3g I) \n",arr[0],ari[0],arr[1],ari[1],arr[2],ari[2]);
            printF(" at=(%.3g + %.3g I,%.3g + %.3g I,%.3g + %.3g I) \n",atr[0],ati[0],atr[1],ati[1],atr[2],ati[2]);
          }
          
          // OV_ABORT("Stop here for now");

          // These need to be set for the solution evaluation below:
          real axr=ax, axi=0., ayr=ay, ayi=0., azr=az, azi=0.;
          real arxr=arr[0], arxi=ari[0], aryr=arr[1], aryi=ari[1], arzr=arr[2], arzi=ari[2];
          real atxr=atr[0], atxi=ati[0], atyr=atr[1], atyi=ati[1], atzr=atr[2], atzi=ati[2];
          
          real kxr=twoPi*kx, kxi=0., kyr=twoPi*ky, kyi=0., kzr=twoPi*kz, kzi=0.;
          real krxr=krr[0], krxi=kri[0], kryr=krr[1], kryi=kri[1], krzr=krr[2], krzi=kri[2];
          real ktxr=ktr[0], ktxi=kti[0], ktyr=ktr[1], ktyi=kti[1], ktzr=ktr[2], ktzi=kti[2];


          FOR_3D(i1,i2,i3,I1,I2,I3)
          { 
            if( !isRectangular )
            {
              x= xLocal(i1,i2,i3,0);
              y= xLocal(i1,i2,i3,1);
              z= xLocal(i1,i2,i3,2);
            }
            else
            {
              x=XC(iv,0);
              y=XC(iv,1);
              z=XC(iv,2);
            }


            // Here are the statements to eval the solution: 
#Include "dispersivePlaneWaveInterface3d.h"


            if( myDomain==0 )
            {
              uLocal(i1,i2,i3,ex) = Exr;
              uLocal(i1,i2,i3,ey) = Eyr;
              uLocal(i1,i2,i3,ez) = Ezr;

              for( int iv=0; iv<numberOfPolarizationVectors1; iv++ )
              {
                const int pc= iv*numberOfDimensions;
                pLocal(i1,i2,i3,pc  ) = eps1*( chi1r[iv]*Exr - chi1i[iv]*Exi );
                pLocal(i1,i2,i3,pc+1) = eps1*( chi1r[iv]*Eyr - chi1i[iv]*Eyi );
                pLocal(i1,i2,i3,pc+2) = eps1*( chi1r[iv]*Ezr - chi1i[iv]*Ezi );
              }

            }
            else
            {
              uLocal(i1,i2,i3,ex) = Etxr;
              uLocal(i1,i2,i3,ey) = Etyr;
              uLocal(i1,i2,i3,ez) = Etzr;
              for( int iv=0; iv<numberOfPolarizationVectors2; iv++ )
              {
                const int pc= iv*numberOfDimensions;
                pLocal(i1,i2,i3,pc  ) = eps2*( chi2r[iv]*Etxr - chi2i[iv]*Etxi );
                pLocal(i1,i2,i3,pc+1) = eps2*( chi2r[iv]*Etyr - chi2i[iv]*Etyi );
                pLocal(i1,i2,i3,pc+2) = eps2*( chi2r[iv]*Etzr - chi2i[iv]*Etzi );
              }
            }
          

          }

        }
        else
        {
          // *** OLD WAY --- ONLY 2D SOLUTION ****
        
          FOR_3D(i1,i2,i3,I1,I2,I3)
          {
            if( !isRectangular )
            {
              x= xLocal(i1,i2,i3,0);
              y= xLocal(i1,i2,i3,1);
              z= xLocal(i1,i2,i3,2);
            }
            else
            {
              x=XC(iv,0);
              y=XC(iv,1);
              z=XC(iv,2);
            }

            // *** FINISH ME for true 3D  : this is taken from the 2D version *****


            // -- un-rotate the point (x,y) to the reference space and evaluate the solution 
            real ct= nv[0], st=nv[1];  // cos(theta), sin(theta)
            real xa=x-x0[0], ya=y-x0[1];
            x =  ct*xa + st*ya;
            y = -st*xa + ct*ya;
          

            // Here are the statements to eval the solution: 
#Include "dispersivePlaneWaveInterface.h"

            // ---- rotate the field from the reference space to the rotated space ---
            real Exra=Exr, Eyra=Eyr;
            Exr =  ct*Exra - st*Eyra;
            Eyr =  st*Exra + ct*Eyra;
          
            real Exia=Exi, Eyia=Eyi;
            Exi =  ct*Exia - st*Eyia;
            Eyi =  st*Exia + ct*Eyia;
          
            real Expra=Expr, Eypra=Eypr;
            Expr =  ct*Expra - st*Eypra;
            Eypr =  st*Expra + ct*Eypra;
          
            real Expia=Expi, Eypia=Eypi;
            Expi =  ct*Expia - st*Eypia;
            Eypi =  st*Expia + ct*Eypia;
          

            real Ezr, Ezi, Ezpr,Ezpi;
            Ezr=0.; Ezi=0.; Ezpr=0.; Ezpi=0.; // 
           
            if( false )
            {
              printF("(i1,i2)=(%3i,%3i): chiSum1=(%9.3e,%9.3e) chiSum2=(%9.3e,%9.3e) r=(%8.2e,%8.2e) "
                     "tau=(%8.2e,%8.2e) khy=(%8.2e,%8.2e) khpy=(%8.2e,%8.2e): ",
                     i1,i2,chiSum1r,chiSum1i,chiSum2r,chiSum2i,rr,ri,taur,taui,khyr,khyi,khypr,khypi);
              real eps1Hatr = eps1*(1.+chiSum1r), eps1Hati=eps1*(chiSum1i);
              real eps2Hatr = eps2*(1.+chiSum2r), eps2Hati=eps2*(chiSum2i);


              checkPlaneMaterialInterfaceJumps( 
                c1,c2,eps1,eps2,mu1,mu2, sr,si, rr,ri, taur,taui, 
                eps1Hatr,eps1Hati, eps2Hatr,eps2Hati,
                chiSum1r,chiSum1i,chiSum2r,chiSum2i,
                kxr,kxi, kyr,kyi, kxpr,kxpi, kypr,kypi );
            
              OV_ABORT("stop here for now");
            
            }
          
            if( false )
            {
              printF("(i1,i2)=(%3i,%3i): kNorm=%g, kpNorm=%g, kappa=(%g,%g) beta=(%g,%g)\n",
                     i1,i2,kNorm,kpNorm,kappar,kappai,betar,betai);
              printF("    : eps1=%g, eps2=%g, r=(%g,%g) tau=(%g,%g) \n",eps1,eps2,rr,ri,taur,taui);
              // printF("    : chiSum1=(%g,%g) chiSum2=(%g,%g) \n",chiSum1r,chiSum1i,chiSum2r,chiSum2i);
              printF("    : Exr=%g, Eyr=%g, Exi=%g, Eyi=%g Hzr=%g Hzi=%g\n",Exr,Eyr,Exi,Eyi,Hzr,Hzi);
              printF("    : Expr=%g, Eypr=%g, Expi=%g, Eypi=%g Hzpr=%g Hzpi=%g\n",Expr,Eypr,Expi,Eypi,Hzpr,Hzpi);

              OV_ABORT("finish me");
            }
          

            if( myDomain==0 )
            {
              uLocal(i1,i2,i3,ex) = Exr;
              uLocal(i1,i2,i3,ey) = Eyr;
              uLocal(i1,i2,i3,ez) = Ezr;

              for( int iv=0; iv<numberOfPolarizationVectors1; iv++ )
              {
                const int pc= iv*numberOfDimensions;
                pLocal(i1,i2,i3,pc  ) = eps1*( chi1r[iv]*Exr - chi1i[iv]*Exi );
                pLocal(i1,i2,i3,pc+1) = eps1*( chi1r[iv]*Eyr - chi1i[iv]*Eyi );
                pLocal(i1,i2,i3,pc+2) = eps1*( chi1r[iv]*Ezr - chi1i[iv]*Ezi );
              }

            }
            else
            {
              uLocal(i1,i2,i3,ex) = Expr;
              uLocal(i1,i2,i3,ey) = Eypr;
              uLocal(i1,i2,i3,ez) = Ezpr;
              for( int iv=0; iv<numberOfPolarizationVectors2; iv++ )
              {
                const int pc= iv*numberOfDimensions;
                pLocal(i1,i2,i3,pc  ) = eps2*( chi2r[iv]*Expr - chi2i[iv]*Expi );
                pLocal(i1,i2,i3,pc+1) = eps2*( chi2r[iv]*Eypr - chi2i[iv]*Eypi );
                pLocal(i1,i2,i3,pc+2) = eps2*( chi2r[iv]*Ezpr - chi2i[iv]*Ezpi );
              }
            }
          

          }
        } // end old way
        
      }
    }
    else
    {
      OV_ABORT("finish me: numberOfTimeDerivatives1=0");

    }
    
  }
  
  else
  {
    printF("getUserDefinedKnownSolution:ERROR: unknown value for userDefinedKnownSolution=%s\n",
	   (const char*)userKnownSolution);
    OV_ABORT("ERROR");
  }
  
  return 0;
}


int Maxwell::
updateUserDefinedKnownSolution(GenericGraphicsInterface & gi, CompositeGrid & cg)
// ==========================================================================================
/// \brief This function is called to set the user defined know solution.
/// 
// ==========================================================================================
{
  // Make  dbase.get<real >("a") sub-directory in the data-base to store variables used here
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
     dbase.put<DataBase>("userDefinedKnownSolutionData");
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  if( !db.has_key("userKnownSolution") )
  {
    db.put<aString>("userKnownSolution");
    db.get<aString>("userKnownSolution")="unknownSolution";
    
    db.put<real[20]>("rpar");
    db.put<int[20]>("ipar");
  }
  aString & userKnownSolution = db.get<aString>("userKnownSolution");
  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");


  const aString menu[]=
    {
      "no known solution",
      "manufactured pulse",
      "chirped plane wave",
      "dispersive plane wave",
      "dispersive plane wave interface",
      "done",
      ""
    }; 

  gi.appendToTheDefaultPrompt("userDefinedKnownSolution>");
  aString answer;
  for( ;; ) 
  {

    int response=gi.getMenuItem(menu,answer,"Choose a known solution");
    
    if( answer=="done" || answer=="exit" )
    {
      break;
    }
    else if( answer=="no known solution" )
    {
      userKnownSolution="unknownSolution";
    }
    else if( answer=="manufactured pulse" ) 
    {
      userKnownSolution="manufacturedPulse";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

      printF("The manufactured pulse is based on \n"
             "    psi = amp*( -beta*( (x-x0-cx*t)^2 + (y-y0-cy*t)^2 + (z-z0-cz*t)^2 ) )\n"
             " ---2D ---\n"
	     "   Ex = -(y-y0-cy*t)*psi   ( Ex =  psi_y * const )\n"
             "   Ey =  (x-x0-cx*t)*psi   ( Ey = -psi_x * const )\n"
	     "   Hz =   psi;\n"
             " --- 3D ---\n"
	     "  Ex = ((z-z0-cz*t)-(y-y0-cy*t))*psi    ( Ex = ( psi_z - psi_y ) * const)\n"
	     "  Ey = ((x-x0-cx*t)-(z-z0-cz*t))*psi    ( Ey = ( psi_x - psi_z ) * const)\n"
	     "  Ez = ((y-y0-cy*t)-(x-x0-cx*t))*psi    ( Ez = ( psi_y - psi_x ) * const)\n"
                 );
      gi.inputString(answer,"Enter amp,beta,x0,y0,z0, cx,cy,cz");
      sScanF(answer,"%e %e %e %e %e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3],&rpar[4],&rpar[5],&rpar[6],&rpar[7]);
      printF(" Setting amp=%g, beta=%g, [x0,y0,z0]=[%g,%g,%g] [cx,cy,cz]=[%g,%g,%g]\n",
	     rpar[0],rpar[1],rpar[2],rpar[3],rpar[4],rpar[5],rpar[6],rpar[7]);
      
    }
    else if( answer=="chirped plane wave" ) 
    {
      userKnownSolution="chirpedPlaneWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

      printF("The chirped plane wave is defined by ...\n");
      
      
    }
    
    // replaced: 
    // else if( answer=="dispersive plane wave" ) 
    // {
    //   userKnownSolution="dispersivePlaneWave";
    //   dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

    //   printF("The dispersive plane wave is defined by: \n"
    //          "    E = a*sin( k*x - omegar*t)*exp(omegai*t)\n"
    //          "    P = [b*cos( k*x - omegar*t) + c*sin( k*x - omegar*t) ]*exp(omegai*t)\n"
    //         );
      
      
    // }
    else if( answer=="dispersive plane wave interface" ) 
    {
      userKnownSolution="dispersivePlaneWaveInterface";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      

      printF("The dispersive plane wave interface defines an exact solution for a plane wave\n"
             " hitting a planar material interface between two dispersive materials\n");
      
    }
    
    else
    {
      printF("unknown response=[%s]\n",(const char*)answer);
      gi.stopReadingCommandFile();
    }
    
  }

  gi.unAppendTheDefaultPrompt();
  bool knownSolutionChosen = userKnownSolution!="unknownSolution";
  return knownSolutionChosen;
}


// Include complex down here to minimize name conflicts
#include <complex>

typedef ::real OV_real;
// =====================================================================================
/// \brief Utility routine to do some complex arithemetic for the dispersive plane
///    wave material interface.
///
///  Compute kxp=(kxpr,kxpi)  given (kr,ki), and kyp=(kypr,kypi)
///  kxp^2 + kyp^2 = (kr+I*ki)^2 = (kr^2-ki^2) + 2*I*kr*ki 
///  kxp = kxpr + I*kpri = sqrt( (kr+I*ki)^2 - kyp^2 )
// =====================================================================================
void
getTransmisionWaveNumber( const LocalReal & kr,  const LocalReal & ki, 
                          const LocalReal & kxr, const LocalReal & kxi, 
                          const LocalReal & kyr, const LocalReal & kyi, 
                          LocalReal & kxpr, LocalReal & kxpi, 
                          LocalReal & kypr, LocalReal & kypi )
{
  // No jump in tangential field: kyp=ky : 
  kypr=kyr;
  kypi=kyi;

  // std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> ky(kyr,kyi);
  std::complex<LocalReal> k(kr,ki);
  std::complex<LocalReal> kxp,kyp(kypr,kypi);

  // cout << "kyp=" << kyp << endl;

  kxp = std::sqrt( k*k - kyp*kyp );

  kxpr= std::real(kxp);
  kxpi= std::imag(kxp);
  
  // printF("--getTransmisionWaveNumber--- kx=(%g,%g) ky=(%g,%g) (kr,ki)=(%g,%g) kxp=(%g,%g) kyp=(%g,%g)\n",
  //            kxr,kxi,kyr,kyi,kr,ki,kxpr,kxpi,kypr,kypi);

}


// ---------------------------------------------------------------------------------------
// Check routine : 
//   Check the jump:
//       eps1Hat*khyat*(1-r) = eps2Hat*kyHatp*tau
// ---------------------------------------------------------------------------------------
void
checkPlaneMaterialInterfaceJumps( 
                          const LocalReal & c1, const LocalReal & c2,
                          const LocalReal & eps1, const LocalReal & eps2,
                          const LocalReal & mu1, const LocalReal & mu2,

                          const LocalReal & sr, const LocalReal & si,
                          const LocalReal & rr, const LocalReal & ri, 
                          const LocalReal & taur, const LocalReal & taui, 

                          const LocalReal & eps1Hatr, const LocalReal & eps1Hati,
                          const LocalReal & eps2Hatr, const LocalReal & eps2Hati,

                          const LocalReal & psiSum1r, const LocalReal & psiSum1i,
                          const LocalReal & psiSum2r, const LocalReal & psiSum2i,
                          const LocalReal & kxr, const LocalReal & kxi,
                          const LocalReal & kyr, const LocalReal & kyi,
                          const LocalReal & kxpr, const LocalReal & kxpi,
                          const LocalReal & kypr, const LocalReal & kypi

                            )
{

  // std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> psiSum1(psiSum1r,psiSum1i);
  std::complex<LocalReal> psiSum2(psiSum2r,psiSum2i);

  std::complex<LocalReal> eps1Hat(eps1Hatr,eps1Hati);
  std::complex<LocalReal> eps2Hat(eps2Hatr,eps2Hati);
  std::complex<LocalReal> s(sr,si);
  std::complex<LocalReal> kx(kxr,kxi);
  std::complex<LocalReal> ky(kyr,kyi);
  std::complex<LocalReal> kxp(kxpr,kxpi);
  std::complex<LocalReal> kyp(kypr,kypi);
  std::complex<LocalReal> khx,khy, khpx,khpy;
  std::complex<LocalReal> r(rr,ri), tau(taur,taui);
  std::complex<LocalReal> dr1,dr2,jump;
  
  LocalReal kNorm = sqrt(kxr*kxr + kxi*kxi + kyr*kyr + kyi*kyi);
  khx= (kxr + 1i*kxi)/kNorm;
  khy= (kyr + 1i*kyi)/kNorm;
  
  LocalReal kpNorm = sqrt(kxpr*kxpr + kxpi*kxpi + kypr*kypr + kypi*kypi);
  khpx=(kxpr + 1i*kxpi)/kpNorm;
  khpy=(kypr + 1i*kypi)/kpNorm;
  
  printF("\n\n ** s=(%g,%g) kx=(%g,%g) ky=(%g,%g) c1=%g eps1=%g mu1=%g \n",sr,si,kxr,kxi,kyr,kyi,c1,eps1,mu1);
  

  jump = khx*(1.+r) - tau*khpx;
  printF("khx*(1.+r) - tau*khpx                 =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  
  jump =eps1Hat*khy*(1.-r) - eps2Hat*tau*khpy;
  printF(" [epsHat khy(1-r)- epsHat*tau*khy'    =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  
  // dispersion relations: 
  dr1 = s*s + c1*c1*(kx*kx  +ky*ky  ) + s*s*psiSum1;
  dr2 = s*s + c2*c2*(kxp*kxp+kyp*kyp) + s*s*psiSum2;

  printF(" dispersion-relation1                 =(%12.4e,%12.4e)\n",std::real(dr1), std::imag(dr1));
  printF(" dispersion-relation2                 =(%12.4e,%12.4e)\n",std::real(dr2), std::imag(dr2));

  jump = (1.-r)*( ky*khy + kx*khx )/mu1 - tau*( kyp*khpy+kxp*khpx )/mu2;
  printF(" (1-r)*( kSq )/mu1 - tau*( kpSq )/mu2'=(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( ky*ky + kx*kx )/(kNorm*mu1) - tau*( kyp*kyp+kxp*kxp )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( s*s*(1.+psiSum1)/(c1*c1) )/(kNorm*mu1) - tau*( s*s*(1.+psiSum2)/(c2*c2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( s*s*(1.+psiSum1)*(mu1*eps1) )/(kNorm*mu1) - tau*( s*s*(1.+psiSum2)*(mu2*eps2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( (1.+psiSum1)*(mu1*eps1) )/(kNorm*mu1) - tau*( (1.+psiSum2)*(mu2*eps2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( (1.+psiSum1)*(mu1*eps1) )*khy/(mu1) - tau*( (1.+psiSum2)*(mu2*eps2) )*khpy/(mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

  jump = (1.-r)*( (1.+psiSum1)*(eps1) )*khy - tau*( (1.+psiSum2)*(eps2) )*khpy;
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));

}
