//#define BOUNDS_CHECK
//#define OV_DEBUG

#include "Maxwell.h"
#include "PlotStuff.h"
#include "GL_GraphicsInterface.h"
#include "DialogData.h"
#include "UnstructuredMapping.h"
#include "CompositeGridOperators.h"
#include "ParallelUtility.h"
#include "display.h"
#include "DispersiveMaterialParameters.h"
#include "BodyForce.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

// Define macros for forcing functions:
#Include "forcing.h"

static int numberOfPushButtons=0, numberOfTextBoxes=0;

//! Convert specified components of u (cellCentered of faceCentered) to vertexCentered values in v.
int
convertToVertexCentered( const realMappedGridFunction & u, const Range & Ru, 
                         realMappedGridFunction & v, const Range & Rv, bool plotDSIMaxVertVals = false )
{
  MappedGrid & mg = *(u.getMappedGrid());

  assert( mg.getGridType()==MappedGrid::unstructuredGrid );
  
  assert( Ru.getLength()==Rv.getLength() );

  UnstructuredMapping & map = (UnstructuredMapping &) mg.mapping().getMapping();
	    
  const realArray & x = map.getNodes();
  const int numberOfNodes = map.getNumberOfNodes();
  const int numberOfElements = map.getNumberOfElements();
  const intArray & element = map.getElements();

  const realArray & uu = u;
  realArray & vv = v;
  
  const int numberOfComponents=Ru.getLength();
  const int cu0=Ru.getBase();
  const int cv0=Rv.getBase();
  int c;

  Range all;
  for( c=0; c<numberOfComponents; c++ )
    vv(all,0,0,c+cv0)=0.;

  UnstructuredMapping::EntityTypeEnum centering;
  if ( mg.numberOfDimensions()==2 )
    {
      centering = u.getGridFunctionType()==GridFunctionParameters::cellCentered ? UnstructuredMapping::Face : UnstructuredMapping::Edge;
    }
  else
    {
      centering = u.getGridFunctionType()==GridFunctionParameters::faceCenteredAll ? UnstructuredMapping::Face : UnstructuredMapping::Edge;
    }

  IntegerArray numPerNode(numberOfNodes);
  numPerNode = 0;

  UnstructuredMappingIterator citer, citer_end;
  UnstructuredMappingAdjacencyIterator viter, viter_end;
  
  citer_end = map.end(centering);
  real minEx=REAL_MAX, minEy=REAL_MAX, maxEx=-REAL_MAX, maxEy=-REAL_MAX;
  for ( citer=map.begin(centering); citer!=citer_end; citer++ )
  {
    int e=*citer;
    viter_end = map.adjacency_end(citer, UnstructuredMapping::Vertex);
    for ( viter=map.adjacency_begin(citer,UnstructuredMapping::Vertex);
	  viter!=viter_end; viter++ )
    {
      int nn = *viter;
      for( c=0; c<numberOfComponents; c++ )
	if ( plotDSIMaxVertVals )
	{
	  if ( fabs(uu(e,0,0,c+cu0)) > fabs(vv(nn,0,0,c+cv0)) )
	    vv(nn,0,0,c+cv0) = uu(e,0,0,c+cu0);
	}
	else
	  vv(nn,0,0,c+cv0)+=uu(e,0,0,c+cu0);
      numPerNode(nn)+=1;
    }

    if ( !citer.isGhost() )
    {
	  
      minEx = min(minEx, uu(e,0,0,0));
      maxEx = max(maxEx, uu(e,0,0,0));
      if ( numberOfComponents==2 )
      {
	minEy = min(minEy, uu(e,0,0,1));
	maxEy = max(maxEy, uu(e,0,0,1));
      }

    }
  }
//   cout<<"min/max Ex "<<minEx<<"  "<<maxEx<<endl;
//   cout<<"min/max Ey "<<minEy<<"  "<<maxEy<<endl;

  int minADJ=1000;
  int maxADJ=0;
  for( int n=0; n<numberOfNodes && !plotDSIMaxVertVals; n++ )
  {
    for( c=0; c<numberOfComponents; c++ )
      if ( numPerNode(n) ) vv(n,0,0,c+cv0)/=real(numPerNode(n));
    minADJ = min(minADJ,numPerNode(n));
    maxADJ = max(maxADJ,numPerNode(n));
  }
  //    cout<<"min/max adj "<<minADJ<<"  "<<maxADJ<<endl<<"---"<<endl;

//   if( u.getGridFunctionType()==GridFunctionParameters::cellCentered )
//   {
//     // *** this computation should be done once in the calling function ****  fix this ****

//     // printF(" **** convertToVertexCentered: cell centred grid function found! ****\n");
	
//     // grid function is cell centered!
//     // For now make a node centered values for plotting by averaging.

//     IntegerArray numElementPerNode(numberOfNodes);
//     numElementPerNode=0;
	
// //     int e;
// //     for( e=0; e<numberOfElements; e++ )
// //     {
// //       int numNodes = map.getNumberOfNodesThisElement(e);
// //       for( int n=0; n<numNodes; n++ )
// //       {
// // 	int nn=element(e,n);
// //         for( c=0; c<numberOfComponents; c++ )
// //   	  vv(nn,0,0,c+cv0)+=uu(e,0,0,c+cu0);
// // 	numElementPerNode(nn)+=1;
// //       }
// //     }

//     UnstructuredMappingIterator eiter,eiter_end;
//     UnstructuredMappingAdjacencyIterator vert, vert_end;
//     eiter_end = map.end(UnstructuredMapping::Face);
//     for ( eiter=map.begin(UnstructuredMapping::Face); eiter!=eiter_end; eiter++ )
//       {
// 	int e = *eiter;
// 	vert_end = map.adjacency_end(eiter,UnstructuredMapping::Vertex);
// 	for ( vert=map.adjacency_begin(eiter,UnstructuredMapping::Vertex); vert!=vert_end; vert++ )
// 	  {
// 	    int nn = *vert;
// 	    for( c=0; c<numberOfComponents; c++ )
// 	      vv(nn,0,0,c+cv0)+=uu(e,0,0,c+cu0);
// 	    numElementPerNode(nn)+=1;
// 	  }
//       }

//     for( int n=0; n<numberOfNodes; n++ )
//     {
//       for( c=0; c<numberOfComponents; c++ )
//         vv(n,0,0,c+cv0)/=numElementPerNode(n);
//     }

//   }
//   else if( u.getGridFunctionType()==GridFunctionParameters::faceCenteredAll )
//   {
//     // printF(" **** convertToVertexCentered: FACE centred grid function found! ****\n");
	
//     // grid function is cell centered!
//     // For now make a node centered values for plotting by averaging.
	
//     IntegerArray numFacePerNode(numberOfNodes);
//     numFacePerNode=0;
	
//     const int numberOfFaces=map.getNumberOfFaces();
//     const intArray & faces = map.getFaces();
	
//     // **** this average will not work very well at boundaries *****

//     int f;
//     for( f=0; f<numberOfFaces; f++ )
//     {
//       int numNodes = map.getNumberOfNodesThisFace(f); // this should be 2
//       assert( numNodes==2 );
//       for( int n=0; n<numNodes; n++ )
//       {
// 	int nn=faces(f,n);
//         for( c=0; c<numberOfComponents; c++ )
//   	  vv(nn,0,0,c+cv0)+=uu(f,0,0,c+cu0);
// 	numFacePerNode(nn)+=1;
//       }
//     }
//     for( int n=0; n<numberOfNodes; n++ )
//     {
//       for( c=0; c<numberOfComponents; c++ )
// 	vv(n,0,0,c+cv0)/=numFacePerNode(n);
//     }
//   }
//   else
//   {
//     throw "error";
//   }
  
  return 0;
  
}



// =============================================================================================
/// \brief Create a grid function that holds all the things we can plot.
/// \param t (input) : if t<0 then only fill the component names into the grid function v.
// =============================================================================================
realCompositeGridFunction& Maxwell::
getAugmentedSolution(int current, realCompositeGridFunction & v, const real t)
{
  // if( true ) return gf[current].u; // test 
  
  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int numberOfDimensions = cg.numberOfDimensions();
  
  // const int numberOfComponents=mgp==NULL ? cgfields[current][0].getLength(3) : fields[current].getLength(3);

  int numberOfComponents;
    numberOfComponents= dbase.get<int>("numberOfComponents"); // *new way* Sept 01, 2017 *wdh*

  const bool saveErrors = plotErrors && !(errp==NULL && cgerrp==NULL);
  const bool saveDissipation =  plotDissipation && (( (artificialDissipation>0. || artificialDissipationCurvilinear>0.) 
                                && (method==nfdtd || method==bamx)) || dissipation || cgdissipation);

  const int & solveForAllFields = dbase.get<int>("solveForAllFields");

  Range all;
  const bool saveDsiDiss= saveDissipation && method==dsiMatVec && cg.numberOfDimensions()==3;
  
  // Determine the number of components to plot and the component numbers for the errors, etc.
  //    nErr : component where the error is stored
  //    ndd  : component where the dissipation is stored
  int numberToPlot=numberOfComponents;                  // save fields
  int nErr=numberToPlot;    numberToPlot += numberOfComponents*int(saveErrors);
  int ndd=numberToPlot;     numberToPlot += numberOfComponents*int(saveDissipation);
                            numberToPlot += cg.numberOfDimensions()*int( saveDsiDiss ); 
  int nVarDis=numberToPlot; numberToPlot += int(useVariableDissipation);
  int nDivE=numberToPlot;   numberToPlot += int(plotDivergence); 

  int nDivH=-1;
  int plotDivH = plotDivergence && (method==yee || solveForMagneticField ) && numberOfDimensions==3;
  plotDivH = plotDivH || ( method==bamx && (solveForAllFields==1 || numberOfDimensions==3) );
  if( plotDivH ) 
  { // plot div(H) or div(B) too
    nDivH=numberToPlot;  numberToPlot +=1;
  }
  if( method!=nfdtd && method!=yee && method!=sosup && method!=bamx )
  {
    numberToPlot += 2;  // something for Kyle
  }
  int nEdiss=numberToPlot;  numberToPlot += (cg.numberOfDimensions()+1)*int(e_cgdissipation ? 1 : 0);
  int nRho=numberToPlot;    numberToPlot += int(plotRho); 
  int nEnergyDensity=numberToPlot; numberToPlot += int(plotEnergyDensity);
  int nIntensity=numberToPlot; numberToPlot += int(plotIntensity);

  // There are 2 components of the harmonic field, Er and Ei for each component of E. 
  int nHarmonicE=numberToPlot;  numberToPlot += 2*(cg.numberOfDimensions())*int(plotHarmonicElectricFieldComponents);

  bool plotCurlE=false;     // for testing plot curl( E_known )
  if( method==yee && false )
    plotCurlE=true;
  int nCurlE = numberToPlot; numberToPlot += 2*(1 + 2*(numberOfDimensions-2))*int(plotCurlE);
  
  const int & maxNumberOfPolarizationComponents = parameters.dbase.get<int>("maxNumberOfPolarizationComponents");
  // total number of polarization components per grid 
  const IntegerArray & totalNumberOfPolarizationComponents =
    parameters.dbase.get<IntegerArray>("totalNumberOfPolarizationComponents");

  const int numPolarizationVectors=6;  // [Px,Py,Pz, Mx,My,Mz]
  bool plotPolarization = false && method==bamx && solveForAllFields && dispersionModel!=noDispersion; // *** FIX ME ***
  bool plotPolarizationErrors = plotPolarization && saveErrors;
  
  const int nPolarization=numberToPlot;
  const int nPolarizationErr=nPolarization+numPolarizationVectors;
  if(  plotPolarization )
    numberToPlot += numPolarizationVectors; // Plot polarization and magnetization vectors

  if( plotPolarizationErrors )
    numberToPlot += numPolarizationVectors;

  
  

//   int numberToPlot=numberOfComponents*(1+int(saveErrors)+int(saveDissipation))
//     + cg.numberOfDimensions()*int(saveDissipation&&method==dsiMatVec&&cg.numberOfDimensions()==3)
//     + int(useVariableDissipation)
//     + int(plotDivergence) + 2*(method!=nfdtd) + (cg.numberOfDimensions()+1)*int(e_cgdissipation ? 1 : 0);

  // we build a grid function with more components (errors, dissipation) for plotting
  v.updateToMatchGrid(cg,all,all,all,numberToPlot);

  v=0;
  if( method==nfdtd || method==yee || method==sosup || method==bamx ) 
  {
    for( int n=0; n<numberOfComponents; n++ )
    {
      if( mgp!=NULL )
      {
	MappedGrid & mg = *mgp;
	if( mg.getGridType()==MappedGrid::structuredGrid )
	{
	  if ( method==nfdtd || method==sosup || method==bamx || ( n<fields[current].getLength(3) ) )
	    v.setName(fields[current].getName(n),n);
	  else if ( n<fields[current].getLength(3) ) 
	    v.setName(fields[current+numberOfTimeLevels].getName(n-fields[current].getLength(3)),n);
		  
	  if( saveErrors )
	    v.setName(errp->getName(n),n+numberOfComponents);
	}
      }
      else
      {
	// *wdh* v.setName(cgfields[current].getName(n),n);
	v.setName(getCGField(HField,current).getName(n),n);
	if( saveErrors )
	  v.setName(cgerrp->getName(n),n+numberOfComponents);
	if( saveDissipation )
	  v.setName(cgdissipation->getName(n),n+ndd);
      }
	  
    }
  }
  else
  {
    if( cg.numberOfDimensions()==2 )
    {
      int i=3;
      v.setName("Hz",0);
      v.setName("Ex",1);
      v.setName("Ey",2);
      if( method==dsiMatVec )
      {
	v.setName("E.n",3);
	i=4;
      }
      if ( (dissipation ||cgdissipation )&& plotDissipation)
      {
	v.setName("Hz dissp",i++);
	v.setName("E.n dissp",i++);
	v.setName("Ex dissp",i++);
	v.setName("Ey dissp",i++);
      }
      if( saveErrors )
      {
	v.setName("Hz-err",i++);
	v.setName("Ex-err",i++);
	v.setName("Ey-err",i);
      }
    }
    else
    {
      v.setName("Hx",hx);
      v.setName("Hy",hy);
      v.setName("Hz",hz);
      v.setName("Ex",ex+3);
      v.setName("Ey",ey+3);
      v.setName("Ez",ez+3);
      v.setName("H.n",ez+4);
      v.setName("E.n",ez+5);
	  
      int i=8;
      if ( (dissipation ||cgdissipation) && plotDissipation)
      {
	v.setName("H.n dissp",i++);
	v.setName("Hx dissp",i++);
	v.setName("Hy dissp",i++);
	v.setName("Hz dissp",i++);
	v.setName("E.n dissp",i++);
	v.setName("Ex dissp",i++);
	v.setName("Ey dissp",i++);
	v.setName("Ez dissp",i++);
      }
	  
      if( saveErrors )
      {
	v.setName("Hx-err",i++);
	v.setName("Hy-err",i++);
	v.setName("Hz-err",i++);
	      
	v.setName("Ex-err",i++);
	v.setName("Ey-err",i++);
	v.setName("Ez-err",i);
      }
	  
	  
    }
      
  }

  if( plotDivergence && (method==nfdtd || method==yee || method==sosup || method==bamx) )
  {
    if( method==bamx )
    {
      v.setName("div(D)",nDivE);
      if( nDivH>=0 )
        v.setName("div(B)",nDivH);
    }
    else
    {
      v.setName("div(E)",nDivE);
      if( nDivH>=0 )
        v.setName("div(H)",nDivH);
    }
    
  }
  if( plotCurlE && (method==nfdtd || method==yee || method==sosup || method==bamx) )
  {
    if( numberOfDimensions==3 )
    {
      v.setName("curlExr",nCurlE  );
      v.setName("curlEyr",nCurlE+1);
      v.setName("curlEzr",nCurlE+2);
      v.setName("curlExi",nCurlE+3);
      v.setName("curlEyi",nCurlE+4);
      v.setName("curlEzi",nCurlE+5);
    }
    
  }
  
  if( plotPolarization )
  {
    v.setName("Px",nPolarization+0);
    v.setName("Py",nPolarization+1);
    v.setName("Pz",nPolarization+2);
    v.setName("Mx",nPolarization+3);
    v.setName("My",nPolarization+4);
    v.setName("Mz",nPolarization+5);
  }
  if( plotPolarizationErrors )
  {
    v.setName("Px error",nPolarizationErr+0);
    v.setName("Py error",nPolarizationErr+1);
    v.setName("Pz error",nPolarizationErr+2);
    v.setName("Mx error",nPolarizationErr+3);
    v.setName("My error",nPolarizationErr+4);
    v.setName("Mz error",nPolarizationErr+5);
  }
  
  if( useVariableDissipation )
    v.setName("varDis",nVarDis);
  if( plotRho )
    v.setName("rho",nRho);
  if( plotEnergyDensity )
    v.setName("energyDensity",nEnergyDensity);

  if( plotIntensity )
  {
    v.setName("intensity",nIntensity);
  }
    
  if( plotHarmonicElectricFieldComponents )
  {
    v.setName("Exr",nHarmonicE+0);
    v.setName("Exi",nHarmonicE+1);
    v.setName("Eyr",nHarmonicE+2);
    v.setName("Eyi",nHarmonicE+3);
    if( numberOfDimensions==3 )
    {
      v.setName("Ezr",nHarmonicE+4);
      v.setName("Ezi",nHarmonicE+5);
    }
  }
    
  if( t<0. )
  {
    // in this case we only assign the component names and return 
    return v;
  }


//   if( plotIntensity || plotHarmonicElectricFieldComponents )
//   {
//     if( false && intensityOption==1 )
//     {
//       // compute the intensity using current and prev values
//       int stepNumber=0;
//       real nextTimeToPlot=0.;
//       real dt=deltaT; // check this 
//       computeIntensity(current,t,dt,stepNumber,nextTimeToPlot);
//     }
//   }
  // printF(" plot: cg.numberOfComponentGrids() = %i \n",cg.numberOfComponentGrids());
  

  divEMax=0.;

  if( method==yee )
  {
    // compute node centered fields for plotting -- this will fill in v ---
    int option=3;
    int iparam[5] = { nDivE,nDivH,0,0,0 }; // 
    getValuesFDTD( option, iparam, current, t, deltaT, &v );
    // ::display(v[0],"v after getValuesFDTD","%5.2f");
    if( plotDivergence )
    {
      option=2; // compute div(E) ( and div(H) in 3D)
      getValuesFDTD( option, iparam, current, t, deltaT, &v );
    }
    if( plotCurlE )
    {
      option=4; // compute curl(E)
      iparam[0]=nCurlE;
      getValuesFDTD( option, iparam, current, t, deltaT, &v );
    }
    
  }


  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = mgp!=NULL ? *mgp : cg[grid];

    realMappedGridFunction & u = mgp!=NULL ? fields[current] : getCGField(HField,current)[grid];
    realMappedGridFunction & vg = v[grid];
  
#ifdef USE_PPP
    realSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
    realSerialArray vLocal; getLocalArrayWithGhostBoundaries(vg,vLocal);
    // const int includeGhost=1;
    // ok = ParallelUtility::getLocalArrayBounds(u[grid],uLocal,I1,I2,I3,includeGhost); 
#else
    const realSerialArray & uLocal = u;
    const realSerialArray & vLocal = vg;
#endif

    Range N=numberOfComponents;
    if( method==yee )
    {
      // this is done above
    }
    else if( method==nfdtd  || method==sosup || method==bamx )
    {
      vLocal(all,all,all,N)=uLocal(all,all,all,N); // for now make a copy *** fix this **
    }
    else
    {
      Range N1 = fields[current].getLength(3);
      Range N2 =fields[current+numberOfTimeLevels].getLength(3);
#ifdef USE_PPP
      realSerialArray f1Local; getLocalArrayWithGhostBoundaries(fields[current],f1Local);
      realSerialArray f2Local; getLocalArrayWithGhostBoundaries(fields[current+numberOfTimeLevels],f2Local);
#else
      const realSerialArray & f1Local = fields[current];
      const realSerialArray & f2Local = fields[current+numberOfTimeLevels];
#endif
      vLocal(all,all,all,N1) = f1Local(all,all,all,N1);
      vLocal(all,all,all,N2) = f2Local(all,all,all,N2);
    }


    const bool & solveForScatteredField = dbase.get<bool>("solveForScatteredField");
    
    if( ( solveForScatteredField && plotTotalField ) &&
	cg.domainNumber(grid)==0 )  //   assumes domain 0 is the exterior domain
    {
      // *** NOTE: only add plane wave to the outer domain

      const real cc= c*sqrt( kx*kx+ky*ky+kz*kz );
	
      mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex);  // *** fix for rectangular ***
	
      // // subtract off or add on the the incident field
      // const real pm = plotScatteredField ? 1. : -1.;

      const real pm = 1.;  // add on the incident field
      
      Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      getIndex(mg.dimension(),I1,I2,I3);
      const int includeGhost=1;
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost); 


#ifdef USE_PPP
      realSerialArray xLocal; getLocalArrayWithGhostBoundaries(mg.center(),xLocal);
#else
      const realSerialArray & xLocal = mg.center();
#endif

      if( ok )
      {
	if( mg.numberOfDimensions()==2 )
	{
	  const realSerialArray & x = xLocal(I1,I2,I3,0);
	  const realSerialArray & y = xLocal(I1,I2,I3,1);

	  vLocal(I1,I2,I3,ex)-=pm*exTrue(x,y,t);
	  vLocal(I1,I2,I3,ey)-=pm*eyTrue(x,y,t);
	  vLocal(I1,I2,I3,hz)-=pm*hzTrue(x,y,t);
	  if( method==sosup )
	  {
	    vLocal(I1,I2,I3,ext)-=pm*extTrue(x,y,t);
	    vLocal(I1,I2,I3,eyt)-=pm*eytTrue(x,y,t);
	    vLocal(I1,I2,I3,hzt)-=pm*hztTrue(x,y,t);
	  }
	  
	}
	else
	{
	  const realSerialArray & x = xLocal(I1,I2,I3,0);
	  const realSerialArray & y = xLocal(I1,I2,I3,1);
	  const realSerialArray & z = xLocal(I1,I2,I3,2);

	  if( solveForElectricField )
	  {
	    vLocal(I1,I2,I3,ex)-=pm*exTrue3d(x,y,z,t);
	    vLocal(I1,I2,I3,ey)-=pm*eyTrue3d(x,y,z,t);
	    vLocal(I1,I2,I3,ez)-=pm*ezTrue3d(x,y,z,t);
	    if( method==sosup )
	    {
	      vLocal(I1,I2,I3,ext)-=pm*extTrue3d(x,y,z,t);
	      vLocal(I1,I2,I3,eyt)-=pm*eytTrue3d(x,y,z,t);
	      vLocal(I1,I2,I3,ezt)-=pm*eztTrue3d(x,y,z,t);
	    }
	    
	  }

	}
      } // end if ok 
	
    } // end if( plotScatteredField || plotTotalField )
      
    if( plotEnergyDensity )
    {
      Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      getIndex(mg.dimension(),I1,I2,I3);
      const int includeGhost=1;
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost); 

      if( ok )
      {
	c = cGrid(grid);
	eps = epsGrid(grid);
	mu = muGrid(grid);

	if( mg.numberOfDimensions()==2 )
	{
	  // vLocal(I1,I2,I3,nEnergyDensity)= eps*( SQR(uLocal(I1,I2,I3,ex))+SQR(uLocal(I1,I2,I3,ey)) );
	  vLocal(I1,I2,I3,nEnergyDensity)= ( (.5*eps)*( SQR(uLocal(I1,I2,I3,ex))+SQR(uLocal(I1,I2,I3,ey)) )+
					     (.5*mu )*( SQR(uLocal(I1,I2,I3,hz)) ) );
	}
	else
	{
          Overture::abort("finish me -- we need H here");
	  vLocal(I1,I2,I3,nEnergyDensity)= eps*( SQR(uLocal(I1,I2,I3,ex))+SQR(uLocal(I1,I2,I3,ey))+
                                                 SQR(uLocal(I1,I2,I3,ez)) );
	}
      } // end if ok 
	
    } // end if( plotEnergyDensity )
      
    if( plotPolarization )
    {
      // --- plot P and M (sums) ----
      Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      getIndex(mg.dimension(),I1,I2,I3);
      const int includeGhost=1;

      // const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid);

      realMappedGridFunction & p = getDispersionModelMappedGridFunction( grid,current );
      OV_GET_SERIAL_ARRAY(real,p,pLocal);
      bool ok = ParallelUtility::getLocalArrayBounds(p,pLocal,I1,I2,I3,includeGhost); 

      // --- Errors in P ----
      bool getErrorGridFunction=plotPolarizationErrors;
      realMappedGridFunction & pErr = getDispersionModelMappedGridFunction( grid,current,getErrorGridFunction );
      OV_GET_SERIAL_ARRAY(real,pErr,pErrLocal);

      // printF("pLocal: [%d,%d][%d,%d][%d,%d][%d,%d]\n",
      //        pLocal.getBase(0),pLocal.getBound(0),
      //        pLocal.getBase(1),pLocal.getBound(1),
      //        pLocal.getBase(2),pLocal.getBound(2),
      //        pLocal.getBase(3),pLocal.getBound(3));

      // printF("vLocal: [%d,%d][%d,%d][%d,%d][%d,%d]\n",
      //        vLocal.getBase(0),vLocal.getBound(0),
      //        vLocal.getBase(1),vLocal.getBound(1),
      //        vLocal.getBase(2),vLocal.getBound(2),
      //        vLocal.getBase(3),vLocal.getBound(3));
      

      std::vector<DispersiveMaterialParameters> & dmpVector = 
	dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

      if( ok )
      {
        if( numberOfMaterialRegions>1 )
        {
          // assert( pBodyMask!=NULL );
          // const IntegerArray & matMask = *pBodyMask;  // material index 

	  intCompositeGridFunction & materialMask = parameters.dbase.get<intCompositeGridFunction>("materialMask");
	  OV_GET_SERIAL_ARRAY(int,materialMask[grid],matMask);

          int i1,i2,i3;
          FOR_3D(i1,i2,i3,I1,I2,I3)
          {
            const int mr = matMask(i1,i2,i3);
            assert( mr>=0 && mr<numberOfMaterialRegions );
            
            DispersiveMaterialParameters & dmp = dmpVector[mr]; 
            const IntegerArray & Np = dmp.getBianisotropicNp();  // We could speed this up by creating Npv(k1,k2,mr) 
            int pc=0;
            for( int k1=0; k1<6; k1++ )
            {
              int ec=k1;
              vLocal(i1,i2,i3,nPolarization+ec)=0.;
	      if( plotPolarizationErrors )
		vLocal(i1,i2,i3,nPolarizationErr+ec)=0.;
              for( int k2=0; k2<6; k2++ )
              {
                for( int n=0; n<Np(k1,k2); n++ )
                {
                  vLocal(i1,i2,i3,nPolarization+ec) += pLocal(i1,i2,i3,pc);
		  if( plotPolarizationErrors )
		    vLocal(i1,i2,i3,nPolarizationErr+ec) += pErrLocal(i1,i2,i3,pc);

                  pc+=2;   // we store p and pt so increment by 2
                }
              }
            }
            
          }
          
        }
        else
        {
          // single material region
          for( int mr=0; mr<numberOfMaterialRegions; mr++ )
          {
            DispersiveMaterialParameters & dmp = dmpVector[mr]; 
            const IntegerArray & Np = dmp.getBianisotropicNp();
            int pc=0;
            for( int k1=0; k1<6; k1++ )
            {
              int ec=k1;
              vLocal(I1,I2,I3,nPolarization+ec)=0.;
	      if( plotPolarizationErrors )
		vLocal(I1,I2,I3,nPolarizationErr+ec)=0.;
              for( int k2=0; k2<6; k2++ )
              {
                for( int n=0; n<Np(k1,k2); n++ )
                {
                  vLocal(I1,I2,I3,nPolarization+ec) += pLocal(I1,I2,I3,pc);
		  if( plotPolarizationErrors )
		    vLocal(I1,I2,I3,nPolarizationErr+ec) += pErrLocal(I1,I2,I3,pc);

                  pc+=2;   // we store p and pt so increment by 2
                }
              }
            }
          }
        }
      }
      
    } // end if plotPolarization



    if( plotIntensity )
    {
      Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      getIndex(mg.dimension(),I1,I2,I3);
      const int includeGhost=1;
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost); 

      if( pIntensity!=NULL )
      {
	realCompositeGridFunction & intensity = *pIntensity;
        #ifdef USE_PPP
          realSerialArray intensityLocal; getLocalArrayWithGhostBoundaries(intensity[grid],intensityLocal);
        #else
          const realSerialArray & intensityLocal = intensity[grid];
        #endif
	if( ok )
	{
	  vLocal(I1,I2,I3,nIntensity)= intensityLocal(I1,I2,I3);
	} // end if ok 
      }
      else
      {
	vLocal(I1,I2,I3,nIntensity)=0.;
      }
    } // end if( plotIntensity )

    if( plotHarmonicElectricFieldComponents )
    {
      // plot Er and Ei assuming : E(x,t) = Er(x)*cos(w*t) + Ei(x)*sin(w*t)

      Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      getIndex(mg.dimension(),I1,I2,I3);
      const int includeGhost=1;
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost); 

      Range Rx2=2*numberOfDimensions;
      if( pHarmonicElectricField!=NULL )
      {
	realCompositeGridFunction & hef = *pHarmonicElectricField;
        #ifdef USE_PPP
          realSerialArray hefLocal; getLocalArrayWithGhostBoundaries(hef[grid],hefLocal);
        #else
          const realSerialArray & hefLocal = hef[grid];
        #endif
	if( ok )
	{
	  vLocal(I1,I2,I3,Rx2+nHarmonicE)= hefLocal(I1,I2,I3,Rx2);
	} // end if ok 
      }
      else
      {
	vLocal(I1,I2,I3,Rx2+nHarmonicE)=0.;
      }
    }


    if( saveErrors )
    {
      realMappedGridFunction & err = errp!=NULL ? *errp : cgerrp!=NULL ? (*cgerrp)[grid] : u;    
#ifdef USE_PPP
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries(err,errLocal);
#else
      const realSerialArray & errLocal = err;
#endif
      vLocal(all,all,all,N+numberOfComponents)=errLocal(all,all,all,N);
    }
      
    if( useVariableDissipation )
    {
#ifdef USE_PPP
      realSerialArray varDissLocal; getLocalArrayWithGhostBoundaries((*variableDissipation)[grid],varDissLocal);
#else
      const realSerialArray & varDissLocal = (*variableDissipation)[grid];
#endif
      vLocal(all,all,all,nVarDis)=varDissLocal;
    }
      
    if( saveDissipation )
    {
#ifdef USE_PPP
      realSerialArray dissLocal; getLocalArrayWithGhostBoundaries((*cgdissipation)[grid],dissLocal);
#else
      const realSerialArray & dissLocal = (*cgdissipation)[grid];
#endif
      vLocal(all,all,all,N+ndd)=dissLocal(all,all,all,N);
    }

    if( plotRho )
    {
      getChargeDensity( current,t,v,nRho );
    }

    // **New way **
    if( method==nfdtd  || method==sosup || method==bamx )
    {
      // printF(" $$$$ plot: call getMaxDivergence $$$$\n");

      if( plotDivergence )
      {
	getMaxDivergence( current,t, &v,nDivE, &v,nRho);
      }
      else
      {
	getMaxDivergence( current,t );
      }   
    }

  }

// #ifndef USE_PPP  // *wdh* 090709
  if( plotDivergence && mgp==NULL ) 
  {
    // we need to interpolate the divergence to give values at the interp. pts. for plotting
    v.interpolate(Range(nDivE,nDivE));
  }
// #endif
  
  return v;
  
}

// =============================================================================================
/// \brief Plot the polarization vectors for dispersion domains. Different domains will have
///   potentially different numbers of polarization vectors.
// =============================================================================================
int Maxwell::
plotPolarization( int current, real t, real dt )
{
  if( dispersionModel == noDispersion )
  {
    printF("There are no polarization vectors to plot. These only exist for dispersive models.\n");
    return 0;
  }

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int & numberOfDimensions = cg.numberOfDimensions();

  GenericGraphicsInterface *& pps = gip; 
  if( pps==NULL )
    return 0;
  GenericGraphicsInterface & gi = *pps;

  PlotStuffParameters pspPolarization;  // separate for P
   
  const int & maxNumberOfPolarizationComponents = parameters.dbase.get<int>("maxNumberOfPolarizationComponents");
	   
  aString domainName="all";
  int gdmEquation=0;
  int pvComponent=0;
  bool plotErrors=false;
  

  GUIState dialog;

  dialog.setWindowTitle("Plot Polarization");
  dialog.setExitCommand("exit", "exit");

  if( method==nfdtd )
  {
    aString optionMenuCommands[] = {"Px",
				    "Py",
				    "Pz",
				    ""};

    if( numberOfDimensions==2 )
      optionMenuCommands[2]="";  // No Pz
   
    dialog.addOptionMenu("plot component:",optionMenuCommands,optionMenuCommands,pvComponent);
  }
  else
  {
    // BAMX: polarization entries: P0,Q0, P1,Q1, ... 
    aString *optionMenuCommands = new aString [2*maxNumberOfPolarizationComponents+1];
    for( int m=0; m<maxNumberOfPolarizationComponents; m++ )
    {
      optionMenuCommands[2*m  ] = sPrintF("P%d",m);
      optionMenuCommands[2*m+1] = sPrintF("Q%d",m);
    }
    optionMenuCommands[2*maxNumberOfPolarizationComponents]="";
   
    dialog.addOptionMenu("plot component:",optionMenuCommands,optionMenuCommands,pvComponent);
    delete []  optionMenuCommands;
  }
  
  aString pushButtonCommands[] = {"plot",
                                  "erase",
                                  "contour",
                                  ""};
  int numberOfPushButtons=3;  // number of entries in pushButtonCommands
  int numRows=numberOfPushButtons; // (numberOfPushButtons+1)/2;
  dialog.setPushButtons( pushButtonCommands, pushButtonCommands, numRows ); 

  aString tbCommands[] = {"plot errors",
 			  ""};
  int tbState[10];

  tbState[0] = plotErrors;
  int numColumns=1;
  dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns);


  // ----- Text strings ------
  const int numberOfTextStrings=10;
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;

  
  textCommands[nt] = "domain name:";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%s","all"); nt++; 

  textCommands[nt] = "GDM equation:";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",gdmEquation); nt++; 

  // textCommands[nt] = "component:";  
  // textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",pvComponent); nt++; 

  // null strings terminal list
  assert( nt<numberOfTextStrings );
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("polarization>"); // set the default prompt

  std::vector<DispersiveMaterialParameters> & dmpVector = 
    dbase.get<std::vector<DispersiveMaterialParameters> >("dispersiveMaterialParameters");

  bool plotObject=false;
  aString answer,buff;
  int len=0;
  for( int it=0;; it++ )
  {
    if( it==0 && plotObject )
      answer="plotObject";
    else
      gi.getAnswer(answer,"");  // gi.getMenuItem(menu,answer);
 

    if( answer == "exit" )
    {
      break;
    }
    else if( answer=="Px" || answer=="Py" || answer=="Pz" )
    {
      pvComponent = answer=="Px" ? 0 : answer=="Py" ? 1 : 2;
      printF("Setting polarization vector component=%i\n",pvComponent);
    }
    
    else if( len=answer.matches("P") )
    {
      int m=0;
      sScanF(answer(len,answer.length()-1),"%i",&m);
      pvComponent = 2*m;
      printF("Setting polarization component= P%i\n",m);
    }
    else if( len=answer.matches("Q") )
    {
      int m=0;
      sScanF(answer(len,answer.length()-1),"%i",&m);
      pvComponent = 2*m+1;
      printF("Setting polarization component= Q%i\n",m);
    }
    
    else if( dialog.getTextValue(answer,"domain name:","%s",domainName) )
    {
      printF("Setting domain name = [%s]\n",(const char*)domainName);
    }
    else if( dialog.getTextValue(answer,"GDM equation:","%i",gdmEquation) )
    {
      printF("Setting GDM equation number=%i\n",gdmEquation);
    }
    // else if( dialog.getTextValue(answer,"component:","%i",pvComponent) )
    // {
    //   pvComponent=max(0,min(numberOfDimensions,pvComponent));
      
    //   printF("Setting polarization vector component=%i\n",pvComponent);
    // }
    else if( dialog.getToggleValue(answer,"plot errors",plotErrors) )
    {
      printF("Setting plotErrors=%i\n",(int)plotErrors);
    }

    else if( answer=="erase" )
    {
      gi.erase();
      plotObject=false;
    }
    
    else if( answer=="plot" || answer=="plotObject" )
    {
      plotObject=true;
    }
    else if( answer=="contour" )
    {
      plotObject=true;
    }
    else 
    {
      gi.outputString( sPrintF(buff,"Unknown response=%s",(const char*)answer) );
      gi.stopReadingCommandFile();
    }

    if( plotObject )
    {
      int domainStart=-1, domainEnd=-1;
      if( domainName == "all" )
      {
        domainStart=0; domainEnd=cg.numberOfDomains()-1;
      }
      else
      {
        for( int domain=0; domain<cg.numberOfDomains(); domain++ )
        {
          if( cg.getDomainName(domain)==domainName )
          {
            printF("--MX:PP-- will plot polarization in domain number=%i name=[%s].\n",domain,(const char*)domainName);
            domainStart=domainEnd=domain;
            break;
          }
        }
      }
      
      if( domainStart<0  )
      {
        printF("--MX:PP-- WARNING: There is no domain with name =[%s].\n",(const char*)domainName);
        printF("Valid domains are:\n");
        for( int domain=0; domain<cg.numberOfDomains(); domain++ )
        {
          DispersiveMaterialParameters & dmp = dmpVector[domain];
          printF("  domain=%i: name=[%s] numberOfPolarizationVectors=%i.\n",
                 domain,(const char*)cg.getDomainName(domain),dmp.numberOfPolarizationVectors);
        }
        continue;
      }
      else
      {
        gi.erase();
        if( answer!="contour" )
        {
          pspPolarization.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
        }
        real pMin=REAL_MAX, pMax=-pMin;
        
	if( method==nfdtd )
	{
	  for( int domain=domainStart; domain<=domainEnd; domain++ )
	  {

	    DispersiveMaterialParameters & dmp = dmpVector[domain];
	    if( dmp.numberOfPolarizationVectors>0 )
	    {
	      const int component = pvComponent + numberOfDimensions*gdmEquation;
	      if( gdmEquation <  dmp.numberOfPolarizationVectors )
	      {
		pspPolarization.set(GI_COMPONENT_FOR_CONTOURS,component);

		realCompositeGridFunction & pv = *getDispersionModelCompositeGridFunction( domain,current );
		if( !plotErrors )
		{
		  real uMin,uMax;
		  PlotIt::getBounds(pv,uMin,uMax,pspPolarization,Range(component,component));
                
		  pMin=min(pMin,uMin);
		  pMax=max(pMax,uMax);

		  printF("--MX--plot: domain=%i: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
		  pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);
		  PlotIt::contour(gi,pv,pspPolarization);
		}
		else
		{
		  // --- Plot the errors in P ----
		  bool getErrorGridFunction=true;
		  realCompositeGridFunction & pvErr = 
		    *getDispersionModelCompositeGridFunction( domain,current,getErrorGridFunction );

		  real uMin,uMax;
		  PlotIt::getBounds(pvErr,uMin,uMax,pspPolarization,Range(component,component));
                
		  pMin=min(pMin,uMin);
		  pMax=max(pMax,uMax);

		  printF("--MX--plot: domain=%i: Error: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
		  pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);

		  PlotIt::contour(gi,pvErr,pspPolarization);

		  /* -- we could eval on demand 
		     CompositeGrid & cgd = cg.domain(domain);
		     Range Npv=dmp.numberOfPolarizationVectors;
		     realCompositeGridFunction pvErr(cgd,all,all,all,Npv);
                
		     getPolarizationError( domain, current, pvErr );
		  */ 
		  // printF("plotPolarization: FINISH ME -- plot errors\n");

		}
              
	      }
	      else
	      {
		printF("plotPolarization:INFO: Not plotting P vector in domain=%i since gdmEquation=%i but "
		       "numberOfPolarizationVectors=%i.\n",
		       domain,gdmEquation,dmp.numberOfPolarizationVectors);
	      }
            
	    }
	  }
	}
	else if( method==bamx )
	{
          // BAMX ---- polarization components ---
          int grid=0, domain=0;
	  
          realCompositeGridFunction & pv = *getDispersionModelCompositeGridFunction( domain,current );

	  const int component = pvComponent;
          pspPolarization.set(GI_COMPONENT_FOR_CONTOURS,component);

	  if( !plotErrors )
	  {
	    real uMin,uMax;
	    PlotIt::getBounds(pv,uMin,uMax,pspPolarization,Range(component,component));
                
	    pMin=min(pMin,uMin);
	    pMax=max(pMax,uMax);

	    printF("--MX--plot: domain=%i: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
	    pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);
	    PlotIt::contour(gi,pv,pspPolarization);
	  }
	  else
	  {
	    // --- Plot the errors in P ----
	    bool getErrorGridFunction=true;
	    realCompositeGridFunction & pvErr = 
	      *getDispersionModelCompositeGridFunction( domain,current,getErrorGridFunction );

	    real uMin,uMax;
	    PlotIt::getBounds(pvErr,uMin,uMax,pspPolarization,Range(component,component));
                
	    pMin=min(pMin,uMin);
	    pMax=max(pMax,uMax);

	    printF("--MX--plot: domain=%i: Error: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
	    pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);

	    PlotIt::contour(gi,pvErr,pspPolarization);

	  }


	}
	
	pspPolarization.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
	
      }
  
    } // end if plotObject 
    

  }

  gi.unAppendTheDefaultPrompt();  // reset
  gi.popGUI(); // restore the previous GUI


  return 0;
}


int Maxwell::
buildRunTimeDialog()
// =============================================================================================
// =============================================================================================
{
  GenericGraphicsInterface & ps = *gip;
  if( runTimeDialog==NULL )
  {
    runTimeDialog = new GUIState;
    GUIState & dialog = *runTimeDialog;
    

    dialog.setWindowTitle("Maxwell");
    dialog.setExitCommand("finish", "finish");

    aString cmds[] = {"break","continue",
                      "movie mode","movie and save",
                      "contour", "E field lines",
                      "grid", "erase",
                      "plot options...",
                      "parameters...",
                      "plot P...",
                      // "change the grid...",
                      // "show file options...","file output...",
                      // "pde parameters...",
                      ""};
    numberOfPushButtons=10;  // number of entries in cmds
    int numRows=(numberOfPushButtons+1)/2;
    dialog.setPushButtons( cmds, cmds, numRows ); 

    // get any extra components such as errors for tz flow or the pressure for CNS.
    realCompositeGridFunction v;
    real t=-1; // this means only fill in the component names. 
    realCompositeGridFunction & u = getAugmentedSolution(0,v,t);

    const int numberOfComponents = u.getComponentBound(0)-u.getComponentBase(0)+1;
    // create a new menu with options for choosing a component.
    aString *cmd = new aString[numberOfComponents+1];
    aString *label = new aString[numberOfComponents+1];
    for( int n=0; n<numberOfComponents; n++ )
    {
      label[n]=u.getName(n);
      cmd[n]="plot:"+u.getName(n);

    }
    cmd[numberOfComponents]="";
    label[numberOfComponents]="";
    
    dialog.addOptionMenu("plot component:", cmd,label,0);
    delete [] cmd;
    delete [] label;

//     aString tbCommands[] = {"project fields",
// 			    ""};
//     int tbState[10];
//     tbState[0] = projectFields; 
//     int numColumns=1;
//     dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns);

    const int numberOfTextStrings=7;
    aString textLabels[numberOfTextStrings];
    aString textStrings[numberOfTextStrings];

    int nt=0;
    textLabels[nt] = "final time";  sPrintF(textStrings[nt], "%g",tFinal);  nt++; 
    textLabels[nt] = "times to plot";  sPrintF(textStrings[nt], "%g",tPlot);  nt++; 
    textLabels[nt] = "cfl";  
    sPrintF(textStrings[nt], "%g",cfl);  nt++; 
    textLabels[nt] = "debug";  sPrintF(textStrings[nt], "%i",debug);  nt++; 
 
       // null strings terminal list
    textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
    dialog.setTextBoxes(textLabels, textLabels, textStrings);
    numberOfTextBoxes=nt;
    

    // ******************* file output *************************
//     DialogData & fileOutputDialog = dialog.getDialogSibling();

//     fileOutputDialog.setWindowTitle("File Output Parameters");
//     fileOutputDialog.setExitCommand("close file output dialog", "close");

//     aString cmdf[] = {"file output",
//                       "output periodically to a file",
//                       "close an output file",
//                       "save restart file",
//                       ""};
//     int numberOfRows=4;
//     fileOutputDialog.setPushButtons( cmdf, cmdf, numberOfRows );

//     nt=0;
//     textLabels[nt] = "output file name";  sPrintF(textStrings[nt], "%s","overBlown.out");  nt++; 
//     textLabels[nt]= "restart file name";  sPrintF(textStrings[nt], "%s",(const char*)restartFileName);nt++; 
//     textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
//     fileOutputDialog.setTextBoxes(textLabels, textLabels, textStrings);


//     // ****** pde parameters *************
//     DialogData &pdeDialog = dialog.getDialogSibling();
//     pdeDialog.setExitCommand("close pde options", "close");
//     setPdeParameters("build dialog",&pdeDialog);



    ps.pushGUI(dialog);


  }
  return 0;

}


static void
setSensitivity( GUIState & dialog, bool trueOrFalse )
{
  dialog.getOptionMenu(0).setSensitive(trueOrFalse);
  int n;
  for( n=1; n<numberOfPushButtons; n++ ) // leave first push button sensitive (=="break")
    dialog.setSensitive(trueOrFalse,DialogData::pushButtonWidget,n);
  
  for( n=0; n<numberOfTextBoxes; n++ )
    dialog.setSensitive(trueOrFalse,DialogData::textBoxWidget,n);
  
}

int Maxwell::
buildParametersDialog(DialogData & dialog )
// ==========================================================================================
// /Description:
//    Build the parameters dialog -- these are various parameters that can be changed
//   at run time. 
// ==========================================================================================
{

  // ************** PUSH BUTTONS *****************
  dialog.setOptionMenuColumns(1);

  aString tbCommands[] = {"project fields",
 			  ""};
  int tbState[15];
  tbState[0] = projectFields;

  int numColumns=1;
  dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns); 



  // ----- Text strings ------
  const int numberOfTextStrings=30;
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;
  textCommands[nt] = "dissipation"; 
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%e",artificialDissipation);  nt++; 

  textCommands[nt] = "dissipation (curvilinear)"; 
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%e",artificialDissipationCurvilinear);  nt++; 

  textCommands[nt] = "projection frequency";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",frequencyToProjectFields); nt++; 

  textCommands[nt] = "consecutive projection steps";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",numberOfConsecutiveStepsToProject); nt++; 

  textCommands[nt] = "number of divergence smooths";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",numberOfDivergenceSmooths); nt++; 

  // null strings terminal list
  assert( nt<numberOfTextStrings );
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  return 0;
}


// ========================================================================================
/// \brief Construct the label that defines the time-stepping method and used in the
///    title for plots
// ========================================================================================
void Maxwell::
getTimeSteppingLabel( real dt, aString & label ) const
{

  aString buff;
  label=sPrintF(buff,"dt=%4.1e",dt);

  if( timeSteppingMethod==modifiedEquationTimeStepping )
    label+=" TS=ME";
  else if( timeSteppingMethod==stoermerTimeStepping )
    label+=" TS=ST";
  else if( timeSteppingMethod==rungeKutta )
    label+= sPrintF(" TS=RK%d",dbase.get<int>("orderOfRungeKutta"));
  else if( timeSteppingMethod==defaultTimeStepping )
    label+=" TS=default ";
  else
    label+="TS=??, ";

  // -- label for dispersion model ---
  if( dispersionModel!=noDispersion )
  {
    aString & dispersionModelName=dbase.get<aString>("dispersionModelName");
    // int numPolar = numberOfPolarizationVectors;
    // if( method==bamx )
    // {
    //   // total number of polarization components per grid 
    //   const IntegerArray & totalNumberOfPolarizationComponents =
    //     parameters.dbase.get<IntegerArray>("totalNumberOfPolarizationComponents");
    //   int grid=0;  // ** FIX ME ** 
    //   numPolar=totalNumberOfPolarizationComponents(grid); // Counts P only, not Q
    // }
    
    // label+=sPrinF(" %s%d",(const char*)dispersionModelName,numPolar);

    label+= " " + dispersionModelName;

  }
  
  // if( twilightZoneOption==polynomialTwilightZone )
  //   label+=sPrintF(buff," order(X,T)=(%i,%i)",
  // 		   orderOfAccuracyInSpace,orderOfAccuracyInTime);

  if( method==nfdtd  )
  {
    if( artificialDissipation!=0. && artificialDissipation==artificialDissipationCurvilinear )
      label+=sPrintF(buff," ad%i=%4.2f",orderOfArtificialDissipation,artificialDissipation);
    else if( artificialDissipationCurvilinear!=0. )
      label+=sPrintF(buff," adr%i=%4.2f,adc%i=%4.2f",orderOfArtificialDissipation,artificialDissipation,
                     orderOfArtificialDissipation,artificialDissipationCurvilinear);
      
    if( applyFilter )
      label+=sPrintF(buff,", filter%i",orderOfFilter);

    if( divergenceDamping>0. )
      label+=sPrintF(buff," dd=%5.3f",divergenceDamping);
  }
  if( method==bamx )
  {
    // BAMX currently just uses a filter stage
    const int filterOrder=orderOfAccuracyInSpace + 2;
    
    if( artificialDissipation!=0. )
      label+=sPrintF(buff," F%i=%3.1f",filterOrder,artificialDissipation);

    if( divergenceDamping>0. )
      label+=sPrintF(buff," dd=%5.3f",divergenceDamping);
  }
  
}



int Maxwell::
plot( int current, real t, real dt )
// ========================================================================================
// /Description:
//  plotOptions :  0 = no plotting
//                 1 - plot and wait
//                 2 - do not wait for response after plotting
// /Return values: 0=normal exit. 1=user has requested "finish".
// ========================================================================================
{
  if( plotOptions==0 )
    return 0;

  real cpu0=getCPU();
  int returnValue=0;

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;

  //  GenericGraphicsInterface & ps = *gip;
  GenericGraphicsInterface *& pps = gip; 
  if( pps==NULL )
    return 0;
  GenericGraphicsInterface & ps = *pps;

  char buff[100];
  int & useSosupDissipation = parameters.dbase.get<int>("useSosupDissipation");
  aString suffix="";
  if( useSosupDissipation )
    suffix="s";  // name = FD22s, FD44s etc. for sosup dissipation
  psp.set(GI_TOP_LABEL,sPrintF(buff,"Maxwell %s%i%i%s: t=%6.2e ",(const char *)methodName,
                               orderOfAccuracyInTime,orderOfAccuracyInSpace,(const char *)suffix,t));
  aString label;
  getTimeSteppingLabel( dt,label );
  
  if( plotScatteredField )
    label+="(scattered field)";
    
  psp.set(GI_TOP_LABEL_SUB_1,label);

  // we need to know if the graphics is open on any processor -- fix this in the GraphicsInterface.
  int graphicsIsOn = ps.isGraphicsWindowOpen();
  graphicsIsOn=getMaxValue(graphicsIsOn);
  int readingCommandFile = ps.readingFromCommandFile();
  readingCommandFile=getMaxValue(readingCommandFile);

  // printF(" **** t=%e, graphicsIsOn=%i readingCommandFile=%i, processor=%i\n",t,graphicsIsOn,readingCommandFile, 
  //            myid);
  // fflush(stdout);

  // // set to true for debugging:   **WARNING: this will break the check files: output called twice:
  // bool getDiv=false; // true; 
  // if(  getDiv || (!graphicsIsOn && readingCommandFile && (method==nfdtd || method==sosup) ) )
  // {
  //   // printF(" **** call getMaxDivergence t=%e, processor=%i\n",t, myid);
  //   // fflush(stdout);
  

  //   // no plotting and reading from a command file
  //   // *** get divEMax and uMin, uMax
  //   if ( method==nfdtd || method==sosup )
  //     getMaxDivergence( current,t );

  //   printF(">>> Cgmx:%s: t=%6.2e, %s |div(E)|=%8.2e, |div(E)|/|grad(E)|=%8.2e, |grad(E)|=%8.2e (%i steps)\n",
  // 	   (const char *)methodName,t,(const char*)label,
  // 	   divEMax,divEMax/max(REAL_MIN*100.,gradEMax),gradEMax,numberOfStepsTaken);
  //   if( solveForMagneticField && cg.numberOfDimensions()==3 )
  //   {
  //     printF("                                                              "
  //            "|div(H)|=%8.2e, |div(H)|/|grad(H)|=%8.2e, |grad(H)|=%8.2e (%i steps)\n",
  // 	     divHMax,divHMax/max(REAL_MIN*100.,gradHMax),gradHMax,numberOfStepsTaken);
  //   }
    
  //   outputResults(current,t,dt);
    
  //   timing(timeForPlotting)+=getCPU()-cpu0;
  //   if( !getDiv ) return returnValue;
  // }
  

  if( runTimeDialog==NULL )
  {
    buildRunTimeDialog();
    // --- Build the sibling dialog for plot options ---
    DialogData & plotOptionsDialog = runTimeDialog->getDialogSibling();
    pPlotOptionsDialog = &plotOptionsDialog;
    plotOptionsDialog.setWindowTitle("MX Plot Options");
    plotOptionsDialog.setExitCommand("close plot options", "close");
    buildPlotOptionsDialog(plotOptionsDialog);

    DialogData & parametersDialog = runTimeDialog->getDialogSibling();
    pParametersDialog = &parametersDialog;
    parametersDialog.setWindowTitle("MX Parameters");
    parametersDialog.setExitCommand("close parameters", "close");
    buildParametersDialog(parametersDialog);

  }
  DialogData &plotOptionsDialog = *pPlotOptionsDialog;
  DialogData &parametersDialog = *pParametersDialog;

  GUIState & dialog = *runTimeDialog;

  aString answer;

  // get any extra components such as errors for tz flow or the pressure for CNS.

  // MappedGrid & mg = *(fields[current].getMappedGrid());

  // **** no need to compute extra components if we are in movie mode and we are not
  //      plotting any extra component ****
  realCompositeGridFunction v;
  realCompositeGridFunction & u = getAugmentedSolution(current,v,t);  // u is either solution or v

  const int numberOfComponents = u.getComponentBound(0)-u.getComponentBase(0)+1;

  const int & useSuperGrid = parameters.dbase.get<int>("useSuperGrid");
  int & absorbingLayerErrorOffset = parameters.dbase.get<int>("absorbingLayerErrorOffset");


  if( movieFrame>=0   )
  { // save a ppm file as part of a movie.
    psp.set(GI_HARD_COPY_TYPE,GraphicsParameters::ppm);
    ps.outputString(sPrintF(buff,"Saving file %s%i.ppm",(const char*)movieFileName,movieFrame));
    ps.hardCopy(    sPrintF(buff,            "%s%i.ppm",(const char*)movieFileName,movieFrame),psp);
    psp.set(GI_HARD_COPY_TYPE,GraphicsParameters::postScript);
    movieFrame++;
  }

  

  ps.erase();
  if( plotOptions & 1 )
  {

    // printF(">>> Cgmx:%s: t=%6.2e, %s |div(E)|=%8.2e, |div(E)|/|grad(E)|=%8.2e, |grad(E)|=%8.2e (%i steps)\n",
    // 	   (const char *)methodName,t,(const char*)label,
    // 	   divEMax,divEMax/max(REAL_MIN*100.,gradEMax),gradEMax,numberOfStepsTaken);
    // if( solveForMagneticField && cg.numberOfDimensions()==3 )
    // {
    //   printF("                                                              "
    //          "|div(H)|=%8.2e, |div(H)|/|grad(H)|=%8.2e, |grad(H)|=%8.2e (%i steps)\n",
    // 	     divHMax,divHMax/max(REAL_MIN*100.,gradHMax),gradHMax,numberOfStepsTaken);
    // }
    // outputResults(current,t,dt);
    

    // Plot all the the things that the user has previously plotted
    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

    if( numberOfMaterialRegions>1 ) // plot this first since title is wrong in body force graphics parameters
    {
      // printF("PLOT BODY FORCE REGIONS\n");
      // Plot body/boundary forcing regions and immersed boundaries. 
      BodyForce::plotForcingRegions(ps, parameters.dbase, *cgp, psp); 
      
    }

    if( plotChoices & 1 )
    {
      if( mgp!=NULL )
        PlotIt::plot(ps,*mgp,psp);
      else
        PlotIt::plot(ps,*cgp,psp);
    }
    if( plotChoices & 2 )
      PlotIt::contour(ps,u,psp);
    if( plotChoices & 4 )
      PlotIt::streamLines(ps,u,psp);


    bool programHalted=false;
    int checkForBreak=false;
    const int processorForGraphics = pps!=NULL ? pps->getProcessorForGraphics() : 0;
    if( plotOptions & 2  && pps!=NULL && !(ps.readingFromCommandFile()) &&
        myid==processorForGraphics && ps.isGraphicsWindowOpen() )
    { // we are running interactively and we should check for a "break" command:
      checkForBreak=true; 
    }
    broadCast(checkForBreak,processorForGraphics); // broadcast to all from the processor for graphics

    if( checkForBreak )
    {
      // movie mode ** check here if the user has hit break ***
      // ps.outputString(sPrintF(buff,"Check for break at t=%e\n",t));
      answer="";
      
      int menuItem = ps.getAnswerNoBlock(answer,"monitor>");
      // printf("answer = [%s]\n",(const char*)answer);
      
      if( answer=="break" )
      {
	programHalted=true;

      }
    }


    // bool programHalted=false;
    // if( plotOptions & 2 )
    // {
    //   // movie mode ** check here if the user has hit break ***
    //   if( ps.isGraphicsWindowOpen() && 
    //       !ps.readingFromCommandFile() )  // for now we cannot check if we are reading from a command file
    //   {
    // 	// ps.outputString(sPrintF(buff,"Check for break at t=%e\n",t));
    // 	answer="";
    // 	int menuItem = ps.getAnswerNoBlock(answer,"monitor>");
    // 	if( answer=="break" )
    // 	{
    // 	  programHalted=true;
    // 	}
    //   }
      
    // }
    
    if( ! (plotOptions & 2) || programHalted )
    {
      if( plotOptions & 1 )
      {
	setSensitivity( dialog,true );
      }
      
      plotOptions=1; // reset movie mode if set.
      movieFrame=-1;
      
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);

//       DialogData & fileOutputDialog = dialog.getDialogSibling(1);
//       DialogData & pdeDialog = dialog.getDialogSibling(2);

      int len;
      bool replot=false;
      for(;;)
      {
	// int menuItem = ps.getMenuItem(menu,answer,"choose an option");
        real timew=getCPU();
	int menuItem = ps.getAnswer(answer,"");
        timing(timeForWaiting)+=getCPU()-timew;

	if( answer=="contour" )
	{
          if(plotChoices & 2 )
            ps.erase();
	  
          PlotIt::contour(ps,u,psp);
	  if( psp.getObjectWasPlotted() ) 
	    plotChoices |= 2;
          else
            plotChoices &= ~2;

          replot=true;
	}

// 	else if( menuItem > chooseAComponentMenuItem && 
//                  menuItem <= chooseAComponentMenuItem+numberOfComponents )
// 	{
//           // plot a new component
// 	  int component=menuItem-chooseAComponentMenuItem-1;
//           if( plotChoices & 2 )
// 	  {
//             ps.erase();
// 	    psp.set(GI_COMPONENT_FOR_CONTOURS,component);
// 	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

// 	    if( plotChoices & 1 )
// 	      PlotIt::plot(ps,mg,psp);

// 	    PlotIt::contour(ps,u,psp);

// 	    if( plotChoices & 4 )
// 	      PlotIt::streamLines(ps,u,psp);

// 	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
// 	  }
// 	}
        else if( answer=="grid" )
	{
          if( mgp!=NULL )
            PlotIt::plot(ps,*mgp,psp);
          else
            PlotIt::plot(ps,*cgp,psp);

	  if( psp.getObjectWasPlotted() ) 
	    plotChoices |= 1;
          else
            plotChoices &= ~1;
	}
        else if( answer=="plot P..." )
        {
          plotPolarization( current,t,dt );
        }

	else if( answer=="E field lines" )
	{
          int uc,vc;
          if( ( mgp!=NULL && mgp->isRectangular() && method==defaultMethod) || method==yee )
	  {
	    uc=ex; vc=ey;
	  }
	  else
	  {
	    uc=ex10, vc=ey10;
	  }
	  psp.set(GI_U_COMPONENT_FOR_STREAM_LINES,uc);
	  psp.set(GI_V_COMPONENT_FOR_STREAM_LINES,vc);
          PlotIt::streamLines(ps,u,psp);

	  if( psp.getObjectWasPlotted() ) 
	    plotChoices |= 4;
          else
            plotChoices &= ~4;
	}
	else if( answer=="erase" )
	{
          ps.erase();
	  plotChoices=0;
	}
	else if( answer=="plot options..." )
	{
	  plotOptionsDialog.showSibling();
	}
	else if( answer=="close plot options" )
	{
	  plotOptionsDialog.hideSibling();
	}
	else if( answer=="parameters..." )
	{
	  parametersDialog.showSibling();
	}
	else if( answer=="close parameters" )
	{
	  parametersDialog.hideSibling();
	}
        
//         else if( answer=="save a restart file" )
// 	{
// 	  ps.inputFileName(answer,sPrintF(buff,"Enter the restart file name (default value=%s)",
// 					  (const char *)restartFileName));
// 	  if( answer!="" )
// 	    restartFileName=answer;

// 	  saveRestartFile(solution,restartFileName);
// 	}
//         else if( answer=="save restart file" ) // new way, do not prompt for restart file name
// 	{
// 	  saveRestartFile(solution,restartFileName);
// 	}
//         else if( answer=="output to a file" )
// 	{
// 	  FileOutput fileOutput;
// 	  fileOutput.update(u,ps);
// 	}
// 	else if( answer=="output periodically to a file" || answer=="output periodically to a file..." )
// 	{
//           if( numberOfOutputFiles>=maximumNumberOfOutputFiles )
// 	  {
// 	    printF("ERROR: too many files open\n");
// 	    continue;
// 	  }
//           fileOutputFrequency[numberOfOutputFiles]=1;
//           ps.inputString(answer,"Save to the file every how many steps? (default=1)");
//           sScanF(answer,"%i",&fileOutputFrequency[numberOfOutputFiles]);
	  
//           FileOutput & fileOutput = * new FileOutput;
// 	  outputFile[numberOfOutputFiles] = &fileOutput;
// 	  numberOfOutputFiles++;
          
//           fileOutput.update(u,ps);

	  
// 	}
// 	else if( answer=="close an output file" )
// 	{
//           aString *fileMenu = new aString [numberOfOutputFiles+2];
//           int n;
// 	  for( n=0; n<numberOfOutputFiles; n++ )
// 	  {
// 	    fileMenu[n]=outputFile[n]->getFileName();
// 	  }
//           fileMenu[parameters.numberOfOutputFiles]="none";
//           fileMenu[parameters.numberOfOutputFiles+1]="";
// 	  int fileChosen = ps.getMenuItem(fileMenu,answer,"Choose a file to close");
// 	  if( fileChosen>=0 && fileChosen<parameters.numberOfOutputFiles )
// 	  {
//             printF("close file %s\n",(const char*)fileMenu[fileChosen]);
// 	    delete parameters.outputFile[fileChosen];
//             parameters.numberOfOutputFiles--;
// 	    for( n=fileChosen; n<parameters.numberOfOutputFiles; n++ )
// 	      parameters.outputFile[n]=parameters.outputFile[n+1];
// 	    parameters.outputFile[parameters.numberOfOutputFiles]=NULL;
// 	  }
// 	}
	else if( answer=="continue" )
	{
          if( t >= tFinal-dt/10. )
	  {
	    printF("WARNING: t=tFinal. Choose `finish' if you really want to end\n");
	  }
	  else
            break;
 	}
	else if( answer=="movie mode" )
	{
          plotOptions=3;  // don't wait
          if( ! ps.isGraphicsWindowOpen() )
          {
            plotOptions=0;  // *wdh* No need to plot if graphics is off - Jan 28, 2020
          }
          

  	  setSensitivity( dialog,false );
          break;
 	}
        else if( answer=="movie and save" )
	{
	  ps.inputString(answer,"Enter basic name for the ppm files (default=plot)");
	  if( answer !="" && answer!=" ")
	    movieFileName=answer;
          else
	    movieFileName="plot";
          ps.outputString(sPrintF(buff,"pictures will be named %s0.ppm, %s1.ppm, ...",
            (const char*)movieFileName,(const char*)movieFileName));
	  movieFrame=0;
          plotOptions=3;  // don't wait

  	  setSensitivity( dialog,false );
          break;
	}
//         else if( answer=="show file options" || answer=="show file options..." )
// 	{
//            updateShowFile();
// 	}
	else if( answer=="finish" )
	{
          tFinal=t;
          returnValue=1;
          break;
 	}
	else if( plotOptionsDialog.getToggleValue(answer,"plot energy density",plotEnergyDensity) ){replot=true;}//
        else if( plotOptionsDialog.getToggleValue(answer,"plot intensity",plotIntensity) ){}//
        else if( plotOptionsDialog.getToggleValue(answer,"plot harmonic E field",plotHarmonicElectricFieldComponents) ){}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot errors",plotErrors) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot scattered field",plotScatteredField) )
        { printF("plotScatteredField=%i\n",(int)plotScatteredField);
          replot=true; 
        }
   
	else if( plotOptionsDialog.getToggleValue(answer,"plot total field",plotTotalField) )
        { printF("plotTotalField=%i\n",(int)plotTotalField);
          replot=true; 
        }

	else if( plotOptionsDialog.getToggleValue(answer,"plot dissipation",plotDissipation) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot divergence",plotDivergence) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"check errors",checkErrors) ){replot=true;}//
        else if( plotOptionsDialog.getToggleValue(answer,"compute energy",computeEnergy) ){}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot dsi vertex max",plotDSIMaxVertVals) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"compare to show file",compareToReferenceShowFile) )
         {replot=true;}//

	else if( dialog.getTextValue(answer,"cfl","%g",cfl) ){}//
	else if( dialog.getTextValue(answer,"final time","%g",tFinal) ){}//
	else if( dialog.getTextValue(answer,"times to plot","%g",tPlot) ){}//
        else if( dialog.getTextValue(answer,"debug","%i",debug) ){}//
        else if( dialog.getTextValue(answer,"radius for checking errors","%f",radiusForCheckingErrors) )
        {
          getErrors( current,t,dt );
          replot=true;
	}
	else if( plotOptionsDialog.getTextValue(answer,"pml error offset","%i",pmlErrorOffset) )
	{
          getErrors( current,t,dt );
          replot=true;
	}
	else if( plotOptionsDialog.getTextValue(answer,"absorbing layer error offset","%i",absorbingLayerErrorOffset) )
	{
	  printF("Setting absorbingLayerErrorOffset=%d\n",absorbingLayerErrorOffset);
	  if( useSuperGrid )
	  {
	    getErrors( current,t,dt );
	    replot=true;
	  }
	}

        else if( parametersDialog.getToggleValue(answer,"project fields",projectFields) ){}//
        else if( parametersDialog.getTextValue(answer,"projection frequency","%i",frequencyToProjectFields) ){}// 
        else if( parametersDialog.getTextValue(answer,"consecutive projection steps","%i",
                   numberOfConsecutiveStepsToProject) ){}// 
        else if( parametersDialog.getTextValue(answer,"number of divergence smooths","%i",
                   numberOfDivergenceSmooths) ){}// 
        else if( parametersDialog.getTextValue(answer,"dissipation (curvilinear)","%g",artificialDissipationCurvilinear) ){}//
        else if( parametersDialog.getTextValue(answer,"dissipation","%g",artificialDissipation) ){}//

	else if( len=answer.matches("plot:") )
	{
          // plot a new component
          aString name = answer(len,answer.length()-1);
          int component=-1;
	  for( int n=0; n<numberOfComponents; n++ )
	  {
	    if( name==u.getName(n) )
	    {
	      component=n;
	      break;
	    }
	  }
          if( component==-1 )
	  {
            printF("ERROR: unknown component name =[%s]\n",(const char*)name);
	    component=0;
	  }

          ps.erase();

          if( numberOfMaterialRegions>1 ) // plot this first since title is wrong in body force graphics parameters
          {
            // printF("PLOT BODY FORCE REGIONS (2)\n");
            // Plot body/boundary forcing regions and immersed boundaries. 
            psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);
            BodyForce::plotForcingRegions(ps, parameters.dbase, *cgp, psp); 
          }

          dialog.getOptionMenu(0).setCurrentChoice(component);
          if( plotChoices & 2 )
	  {
	    psp.set(GI_COMPONENT_FOR_CONTOURS,component);
	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

	    if( plotChoices & 1 )
	    {
	      if( mgp!=NULL )
	        PlotIt::plot(ps,*mgp,psp);
              else
	        PlotIt::plot(ps,*cgp,psp);
	    }
	    PlotIt::contour(ps,u,psp);

	    if( plotChoices & 4 )
	      PlotIt::streamLines(ps,u,psp);

	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
	  }
	}
// 	else if( answer=="file output..." )
// 	{
//           fileOutputDialog.showSibling();
// 	}
//         else if( answer=="close file output dialog" )
// 	{
//           fileOutputDialog.hideSibling();
// 	}
// 	else if( answer=="pde parameters..." )
// 	{
// 	  pdeDialog.showSibling();
// 	}
// 	else if( answer=="close pde options" )
// 	{
// 	  pdeDialog.hideSibling();  // pop timeStepping
// 	}
// 	else if( parameters.setPdeParameters(answer,&pdeDialog)==0 )
// 	{
// 	  printF("Answer was found in setPdeParameters\n");
// 	}
        else if( answer=="break" )
	{
	}
        else
	{
	  cout << "Unknown response: " << answer << endl;
	}
	if( replot )
	{
	  replot=false;
          getAugmentedSolution(current,v,t);
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
          ps.erase();


          //  itemsToPlot & 8 ) // plot this first since title is wrong in body force graphics parameters

          if( numberOfMaterialRegions>1 ) // plot this first since title is wrong in body force graphics parameters
          {
            // printF("PLOT BODY FORCE REGIONS (3) \n");
            // Plot body/boundary forcing regions and immersed boundaries. 
            BodyForce::plotForcingRegions(ps, parameters.dbase, *cgp, psp); 
          }

	  if( plotChoices & 1 )
	  {
	    if( mgp!=NULL )
	      PlotIt::plot(ps,*mgp,psp);
	    else
	      PlotIt::plot(ps,*cgp,psp);
	  }
	  if( plotChoices & 2 )
	    PlotIt::contour(ps,u,psp);
	  if( plotChoices & 4 )
	    PlotIt::streamLines(ps,u,psp);
  
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
        }//
      }
    }
  }
  

  if( plotOptions & 2  )
  {
    ps.redraw(TRUE);
    
  }
  
  timing(timeForPlotting)+=getCPU()-cpu0;
  return returnValue;
}
