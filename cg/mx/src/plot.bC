//#define BOUNDS_CHECK
//#define OV_DEBUG

#include "Maxwell.h"
#include "PlotStuff.h"
#include "GL_GraphicsInterface.h"
#include "DialogData.h"
#include "UnstructuredMapping.h"
#include "CompositeGridOperators.h"
#include "ParallelUtility.h"
#include "display.h"
#include "DispersiveMaterialParameters.h"
#include "BodyForce.h"
#include "xColours.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)

// Define macros for forcing functions:
#Include "forcing.h"

static int numberOfPushButtons=0, numberOfTextBoxes=0;

//! Convert specified components of u (cellCentered of faceCentered) to vertexCentered values in v.
int
convertToVertexCentered( const realMappedGridFunction & u, const Range & Ru, 
                         realMappedGridFunction & v, const Range & Rv, bool plotDSIMaxVertVals = false )
{
  MappedGrid & mg = *(u.getMappedGrid());

  assert( mg.getGridType()==MappedGrid::unstructuredGrid );
  
  assert( Ru.getLength()==Rv.getLength() );

  UnstructuredMapping & map = (UnstructuredMapping &) mg.mapping().getMapping();
	    
  const realArray & x = map.getNodes();
  const int numberOfNodes = map.getNumberOfNodes();
  const int numberOfElements = map.getNumberOfElements();
  const intArray & element = map.getElements();

  const realArray & uu = u;
  realArray & vv = v;
  
  const int numberOfComponents=Ru.getLength();
  const int cu0=Ru.getBase();
  const int cv0=Rv.getBase();
  int c;

  Range all;
  for( c=0; c<numberOfComponents; c++ )
    vv(all,0,0,c+cv0)=0.;

  UnstructuredMapping::EntityTypeEnum centering;
  if ( mg.numberOfDimensions()==2 )
    {
      centering = u.getGridFunctionType()==GridFunctionParameters::cellCentered ? UnstructuredMapping::Face : UnstructuredMapping::Edge;
    }
  else
    {
      centering = u.getGridFunctionType()==GridFunctionParameters::faceCenteredAll ? UnstructuredMapping::Face : UnstructuredMapping::Edge;
    }

  IntegerArray numPerNode(numberOfNodes);
  numPerNode = 0;

  UnstructuredMappingIterator citer, citer_end;
  UnstructuredMappingAdjacencyIterator viter, viter_end;
  
  citer_end = map.end(centering);
  real minEx=REAL_MAX, minEy=REAL_MAX, maxEx=-REAL_MAX, maxEy=-REAL_MAX;
  for ( citer=map.begin(centering); citer!=citer_end; citer++ )
  {
    int e=*citer;
    viter_end = map.adjacency_end(citer, UnstructuredMapping::Vertex);
    for ( viter=map.adjacency_begin(citer,UnstructuredMapping::Vertex);
	  viter!=viter_end; viter++ )
    {
      int nn = *viter;
      for( c=0; c<numberOfComponents; c++ )
	if ( plotDSIMaxVertVals )
	{
	  if ( fabs(uu(e,0,0,c+cu0)) > fabs(vv(nn,0,0,c+cv0)) )
	    vv(nn,0,0,c+cv0) = uu(e,0,0,c+cu0);
	}
	else
	  vv(nn,0,0,c+cv0)+=uu(e,0,0,c+cu0);
      numPerNode(nn)+=1;
    }

    if ( !citer.isGhost() )
    {
	  
      minEx = min(minEx, uu(e,0,0,0));
      maxEx = max(maxEx, uu(e,0,0,0));
      if ( numberOfComponents==2 )
      {
	minEy = min(minEy, uu(e,0,0,1));
	maxEy = max(maxEy, uu(e,0,0,1));
      }

    }
  }
//   cout<<"min/max Ex "<<minEx<<"  "<<maxEx<<endl;
//   cout<<"min/max Ey "<<minEy<<"  "<<maxEy<<endl;

  int minADJ=1000;
  int maxADJ=0;
  for( int n=0; n<numberOfNodes && !plotDSIMaxVertVals; n++ )
  {
    for( c=0; c<numberOfComponents; c++ )
      if ( numPerNode(n) ) vv(n,0,0,c+cv0)/=real(numPerNode(n));
    minADJ = min(minADJ,numPerNode(n));
    maxADJ = max(maxADJ,numPerNode(n));
  }
  //    cout<<"min/max adj "<<minADJ<<"  "<<maxADJ<<endl<<"---"<<endl;

//   if( u.getGridFunctionType()==GridFunctionParameters::cellCentered )
//   {
//     // *** this computation should be done once in the calling function ****  fix this ****

//     // printF(" **** convertToVertexCentered: cell centred grid function found! ****\n");
	
//     // grid function is cell centered!
//     // For now make a node centered values for plotting by averaging.

//     IntegerArray numElementPerNode(numberOfNodes);
//     numElementPerNode=0;
	
// //     int e;
// //     for( e=0; e<numberOfElements; e++ )
// //     {
// //       int numNodes = map.getNumberOfNodesThisElement(e);
// //       for( int n=0; n<numNodes; n++ )
// //       {
// // 	int nn=element(e,n);
// //         for( c=0; c<numberOfComponents; c++ )
// //   	  vv(nn,0,0,c+cv0)+=uu(e,0,0,c+cu0);
// // 	numElementPerNode(nn)+=1;
// //       }
// //     }

//     UnstructuredMappingIterator eiter,eiter_end;
//     UnstructuredMappingAdjacencyIterator vert, vert_end;
//     eiter_end = map.end(UnstructuredMapping::Face);
//     for ( eiter=map.begin(UnstructuredMapping::Face); eiter!=eiter_end; eiter++ )
//       {
// 	int e = *eiter;
// 	vert_end = map.adjacency_end(eiter,UnstructuredMapping::Vertex);
// 	for ( vert=map.adjacency_begin(eiter,UnstructuredMapping::Vertex); vert!=vert_end; vert++ )
// 	  {
// 	    int nn = *vert;
// 	    for( c=0; c<numberOfComponents; c++ )
// 	      vv(nn,0,0,c+cv0)+=uu(e,0,0,c+cu0);
// 	    numElementPerNode(nn)+=1;
// 	  }
//       }

//     for( int n=0; n<numberOfNodes; n++ )
//     {
//       for( c=0; c<numberOfComponents; c++ )
//         vv(n,0,0,c+cv0)/=numElementPerNode(n);
//     }

//   }
//   else if( u.getGridFunctionType()==GridFunctionParameters::faceCenteredAll )
//   {
//     // printF(" **** convertToVertexCentered: FACE centred grid function found! ****\n");
	
//     // grid function is cell centered!
//     // For now make a node centered values for plotting by averaging.
	
//     IntegerArray numFacePerNode(numberOfNodes);
//     numFacePerNode=0;
	
//     const int numberOfFaces=map.getNumberOfFaces();
//     const intArray & faces = map.getFaces();
	
//     // **** this average will not work very well at boundaries *****

//     int f;
//     for( f=0; f<numberOfFaces; f++ )
//     {
//       int numNodes = map.getNumberOfNodesThisFace(f); // this should be 2
//       assert( numNodes==2 );
//       for( int n=0; n<numNodes; n++ )
//       {
// 	int nn=faces(f,n);
//         for( c=0; c<numberOfComponents; c++ )
//   	  vv(nn,0,0,c+cv0)+=uu(f,0,0,c+cu0);
// 	numFacePerNode(nn)+=1;
//       }
//     }
//     for( int n=0; n<numberOfNodes; n++ )
//     {
//       for( c=0; c<numberOfComponents; c++ )
// 	vv(n,0,0,c+cv0)/=numFacePerNode(n);
//     }
//   }
//   else
//   {
//     throw "error";
//   }
  
  return 0;
  
}



// =============================================================================================
/// \brief Plot the polarization vectors for dispersion domains. Different domains will have
///   potentially different numbers of polarization vectors.
// =============================================================================================
int Maxwell::
plotPolarization( int current, real t, real dt )
{
  if( dispersionModel == noDispersion )
  {
    printF("There are no polarization vectors to plot. These only exist for dispersive models.\n");
    return 0;
  }

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int & numberOfDimensions = cg.numberOfDimensions();

  GenericGraphicsInterface *& pps = gip; 
  if( pps==NULL )
    return 0;
  GenericGraphicsInterface & gi = *pps;

  PlotStuffParameters pspPolarization;  // separate for P
   
  const int & maxNumberOfPolarizationComponents = parameters.dbase.get<int>("maxNumberOfPolarizationComponents");
	   
  aString domainName="all";
  int gdmEquation=0;
  int pvComponent=0;
  bool plotErrors=false;
  

  GUIState dialog;

  dialog.setWindowTitle("Plot Polarization");
  dialog.setExitCommand("exit", "exit");

  if( method==nfdtd )
  {
    aString optionMenuCommands[] = {"Px",
				    "Py",
				    "Pz",
				    ""};

    if( numberOfDimensions==2 )
      optionMenuCommands[2]="";  // No Pz
   
    dialog.addOptionMenu("plot component:",optionMenuCommands,optionMenuCommands,pvComponent);
  }
  else
  {
    // BAMX: polarization entries: P0,Q0, P1,Q1, ... 
    aString *optionMenuCommands = new aString [2*maxNumberOfPolarizationComponents+1];
    for( int m=0; m<maxNumberOfPolarizationComponents; m++ )
    {
      optionMenuCommands[2*m  ] = sPrintF("P%d",m);
      optionMenuCommands[2*m+1] = sPrintF("Q%d",m);
    }
    optionMenuCommands[2*maxNumberOfPolarizationComponents]="";
   
    dialog.addOptionMenu("plot component:",optionMenuCommands,optionMenuCommands,pvComponent);
    delete []  optionMenuCommands;
  }
  
  aString pushButtonCommands[] = {"plot",
                                  "erase",
                                  "contour",
                                  ""};
  int numberOfPushButtons=3;  // number of entries in pushButtonCommands
  int numRows=numberOfPushButtons; // (numberOfPushButtons+1)/2;
  dialog.setPushButtons( pushButtonCommands, pushButtonCommands, numRows ); 

  aString tbCommands[] = {"plot errors",
 			  ""};
  int tbState[10];

  tbState[0] = plotErrors;
  int numColumns=1;
  dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns);


  // ----- Text strings ------
  const int numberOfTextStrings=10;
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;

  
  textCommands[nt] = "domain name:";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%s","all"); nt++; 

  textCommands[nt] = "GDM equation:";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",gdmEquation); nt++; 

  // textCommands[nt] = "component:";  
  // textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",pvComponent); nt++; 

  // null strings terminal list
  assert( nt<numberOfTextStrings );
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("polarization>"); // set the default prompt

  std::vector<DispersiveMaterialParameters> & dmpVector = 
    dbase.get<std::vector<DispersiveMaterialParameters> >("dispersiveMaterialParameters");

  bool plotObject=false;
  aString answer,buff;
  int len=0;
  for( int it=0;; it++ )
  {
    if( it==0 && plotObject )
      answer="plotObject";
    else
      gi.getAnswer(answer,"");  // gi.getMenuItem(menu,answer);
 

    if( answer == "exit" )
    {
      break;
    }
    else if( answer=="Px" || answer=="Py" || answer=="Pz" )
    {
      pvComponent = answer=="Px" ? 0 : answer=="Py" ? 1 : 2;
      printF("Setting polarization vector component=%i\n",pvComponent);
    }
    
    else if( len=answer.matches("P") )
    {
      int m=0;
      sScanF(answer(len,answer.length()-1),"%i",&m);
      pvComponent = 2*m;
      printF("Setting polarization component= P%i\n",m);
    }
    else if( len=answer.matches("Q") )
    {
      int m=0;
      sScanF(answer(len,answer.length()-1),"%i",&m);
      pvComponent = 2*m+1;
      printF("Setting polarization component= Q%i\n",m);
    }
    
    else if( dialog.getTextValue(answer,"domain name:","%s",domainName) )
    {
      printF("Setting domain name = [%s]\n",(const char*)domainName);
    }
    else if( dialog.getTextValue(answer,"GDM equation:","%i",gdmEquation) )
    {
      printF("Setting GDM equation number=%i\n",gdmEquation);
    }
    // else if( dialog.getTextValue(answer,"component:","%i",pvComponent) )
    // {
    //   pvComponent=max(0,min(numberOfDimensions,pvComponent));
      
    //   printF("Setting polarization vector component=%i\n",pvComponent);
    // }
    else if( dialog.getToggleValue(answer,"plot errors",plotErrors) )
    {
      printF("Setting plotErrors=%i\n",(int)plotErrors);
    }

    else if( answer=="erase" )
    {
      gi.erase();
      plotObject=false;
    }
    
    else if( answer=="plot" || answer=="plotObject" )
    {
      plotObject=true;
    }
    else if( answer=="contour" )
    {
      plotObject=true;
    }
    else 
    {
      gi.outputString( sPrintF(buff,"Unknown response=%s",(const char*)answer) );
      gi.stopReadingCommandFile();
    }

    if( plotObject )
    {
      int domainStart=-1, domainEnd=-1;
      if( domainName == "all" )
      {
        domainStart=0; domainEnd=cg.numberOfDomains()-1;
      }
      else
      {
        for( int domain=0; domain<cg.numberOfDomains(); domain++ )
        {
          if( cg.getDomainName(domain)==domainName )
          {
            printF("--MX:PP-- will plot polarization in domain number=%i name=[%s].\n",domain,(const char*)domainName);
            domainStart=domainEnd=domain;
            break;
          }
        }
      }
      
      if( domainStart<0  )
      {
        printF("--MX:PP-- WARNING: There is no domain with name =[%s].\n",(const char*)domainName);
        printF("Valid domains are:\n");
        for( int domain=0; domain<cg.numberOfDomains(); domain++ )
        {
          DispersiveMaterialParameters & dmp = dmpVector[domain];
          printF("  domain=%i: name=[%s] numberOfPolarizationVectors=%i.\n",
                 domain,(const char*)cg.getDomainName(domain),dmp.numberOfPolarizationVectors);
        }
        continue;
      }
      else
      {
        gi.erase();
        if( answer!="contour" )
        {
          pspPolarization.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
        }
        real pMin=REAL_MAX, pMax=-pMin; // keep track of min and max over all domains 
        
	if( method==nfdtd )
	{
	  for( int domain=domainStart; domain<=domainEnd; domain++ )
	  {

	    DispersiveMaterialParameters & dmp = dmpVector[domain];
	    if( dmp.numberOfPolarizationVectors>0 )
	    {
	      const int component = pvComponent + numberOfDimensions*gdmEquation;
	      if( gdmEquation <  dmp.numberOfPolarizationVectors )
	      {
		pspPolarization.set(GI_COMPONENT_FOR_CONTOURS,component);

		realCompositeGridFunction & pv = *getDispersionModelCompositeGridFunction( domain,current );
		if( !plotErrors )
		{
		  real uMin,uMax;
		  PlotIt::getBounds(pv,uMin,uMax,pspPolarization,Range(component,component));
                
		  pMin=min(pMin,uMin);
		  pMax=max(pMax,uMax);

		  printF("--MX--plot: domain=%i: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
		  pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);
		  PlotIt::contour(gi,pv,pspPolarization);
		}
		else
		{
		  // --- Plot the errors in P ----
		  bool getErrorGridFunction=true;
		  realCompositeGridFunction & pvErr = 
		    *getDispersionModelCompositeGridFunction( domain,current,getErrorGridFunction );

		  real uMin,uMax;
		  PlotIt::getBounds(pvErr,uMin,uMax,pspPolarization,Range(component,component));
                
		  pMin=min(pMin,uMin);
		  pMax=max(pMax,uMax);

		  printF("--MX--plot: domain=%i: Error: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
		  pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);

		  PlotIt::contour(gi,pvErr,pspPolarization);

		  /* -- we could eval on demand 
		     CompositeGrid & cgd = cg.domain(domain);
		     Range Npv=dmp.numberOfPolarizationVectors;
		     realCompositeGridFunction pvErr(cgd,all,all,all,Npv);
                
		     getPolarizationError( domain, current, pvErr );
		  */ 
		  // printF("plotPolarization: FINISH ME -- plot errors\n");

		}
              
	      }
	      else
	      {
		printF("plotPolarization:INFO: Not plotting P vector in domain=%i since gdmEquation=%i but "
		       "numberOfPolarizationVectors=%i.\n",
		       domain,gdmEquation,dmp.numberOfPolarizationVectors);
	      }
            
	    }
	  }
	}
	else if( method==bamx )
	{
          // BAMX ---- polarization components ---
          int grid=0, domain=0;
	  
          realCompositeGridFunction & pv = *getDispersionModelCompositeGridFunction( domain,current );

	  const int component = pvComponent;
          pspPolarization.set(GI_COMPONENT_FOR_CONTOURS,component);

	  if( !plotErrors )
	  {
	    real uMin,uMax;
	    PlotIt::getBounds(pv,uMin,uMax,pspPolarization,Range(component,component));
                
	    pMin=min(pMin,uMin);
	    pMax=max(pMax,uMax);

	    printF("--MX--plot: domain=%i: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
	    pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);
	    PlotIt::contour(gi,pv,pspPolarization);
	  }
	  else
	  {
	    // --- Plot the errors in P ----
	    bool getErrorGridFunction=true;
	    realCompositeGridFunction & pvErr = 
	      *getDispersionModelCompositeGridFunction( domain,current,getErrorGridFunction );

	    real uMin,uMax;
	    PlotIt::getBounds(pvErr,uMin,uMax,pspPolarization,Range(component,component));
                
	    pMin=min(pMin,uMin);
	    pMax=max(pMax,uMax);

	    printF("--MX--plot: domain=%i: Error: (uMin,uMax=(%g,%g) (pMin,pMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
	    pspPolarization.setMinAndMaxContourLevels( pMin,pMax,component);

	    PlotIt::contour(gi,pvErr,pspPolarization);

	  }


	}
	
	pspPolarization.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
	
      }
  
    } // end if plotObject 
    

  }

  gi.unAppendTheDefaultPrompt();  // reset
  gi.popGUI(); // restore the previous GUI


  return 0;
}






// =============================================================================================
/// \brief Plot any variables associated with nonlinear models.
// =============================================================================================
int Maxwell::
plotNonlinearVariables( int current, real t, real dt )
{

  if( nonlinearModel == noNonlinearModel )
  {
    printF("There are no nonlinear variables to plot. These option only exist for nonlinear models.\n");
    return 0;
  }

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int & numberOfDimensions = cg.numberOfDimensions();

  GenericGraphicsInterface *& pps = gip; 
  if( pps==NULL )
    return 0;
  GenericGraphicsInterface & gi = *pps;

  PlotStuffParameters pspNonlinear;  // separate for P
   
  // const int & maxNumberOfPolarizationComponents = parameters.dbase.get<int>("maxNumberOfPolarizationComponents");
	   
  aString domainName="all";
  int nlComponent=0;
  bool plotErrors=false;
  


  GUIState dialog;

  dialog.setWindowTitle("Plot N");
  dialog.setExitCommand("exit", "exit");

  // if( method==nfdtd )
  // {
  //   aString optionMenuCommands[] = {"Px",
  // 				    "Py",
  // 				    "Pz",
  // 				    ""};

  //   if( numberOfDimensions==2 )
  //     optionMenuCommands[2]="";  // No Pz
   
  //   dialog.addOptionMenu("plot component:",optionMenuCommands,optionMenuCommands,nlComponent);
  // }
  // else
  // {
  //   // BAMX: polarization entries: P0,Q0, P1,Q1, ... 
  //   aString *optionMenuCommands = new aString [2*maxNumberOfPolarizationComponents+1];
  //   for( int m=0; m<maxNumberOfPolarizationComponents; m++ )
  //   {
  //     optionMenuCommands[2*m  ] = sPrintF("P%d",m);
  //     optionMenuCommands[2*m+1] = sPrintF("Q%d",m);
  //   }
  //   optionMenuCommands[2*maxNumberOfPolarizationComponents]="";
   
  //   dialog.addOptionMenu("plot component:",optionMenuCommands,optionMenuCommands,nlComponent);
  //   delete []  optionMenuCommands;
  // }
  
  aString pushButtonCommands[] = {"plot",
                                  "erase",
                                  "contour",
                                  ""};
  int numberOfPushButtons=3;  // number of entries in pushButtonCommands
  int numRows=numberOfPushButtons; // (numberOfPushButtons+1)/2;
  dialog.setPushButtons( pushButtonCommands, pushButtonCommands, numRows ); 

  aString tbCommands[] = {"plot errors",
 			  ""};
  int tbState[10];

  tbState[0] = plotErrors;
  int numColumns=1;
  dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns);


  // ----- Text strings ------
  const int numberOfTextStrings=10;
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;

  
  textCommands[nt] = "domain name:";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%s","all"); nt++; 

  // textCommands[nt] = "GDM equation:";  
  // textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",gdmEquation); nt++; 

  textCommands[nt] = "component:";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",nlComponent); nt++; 

  // null strings terminal list
  assert( nt<numberOfTextStrings );
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("polarization>"); // set the default prompt

  std::vector<DispersiveMaterialParameters> & dmpVector = 
    dbase.get<std::vector<DispersiveMaterialParameters> >("dispersiveMaterialParameters");

  int maxAtomicLevels=0;
  for( int domain=0; domain<cg.numberOfDomains(); domain++ )
  {
    DispersiveMaterialParameters & dmp = dmpVector[domain];
    maxAtomicLevels = max(maxAtomicLevels, dmp.getNumberOfAtomicLevels());
  }
  if(  maxAtomicLevels==0 )
  {
    printF("plotN: WARNING maxAtomicLevels=0 : there are no nonlinear variables to plot! nonLinearModel=%d\n",
	   nonlinearModel);
  }
  


  bool plotObject=false;
  aString answer,buff;
  int len=0;
  for( int it=0;; it++ )
  {
    if( it==0 && plotObject )
      answer="plotObject";
    else
      gi.getAnswer(answer,"");  // gi.getMenuItem(menu,answer);
 

    if( answer == "exit" )
    {
      break;
    }
    else if( dialog.getTextValue(answer,"domain name:","%s",domainName) )
    {
      printF("Setting domain name = [%s]\n",(const char*)domainName);
    }
    else if( dialog.getTextValue(answer,"component:","%i",nlComponent) )
    {
      if( nlComponent>=maxAtomicLevels )
	printF("plotNonlinearVariables:ERROR: nlComponent=%d is too big, >= maxAtomicLevels=%d\n",nlComponent,maxAtomicLevels);

       nlComponent=max(0,min(maxAtomicLevels-1,nlComponent));
      
       printF("Setting nonlinear component=%i\n",nlComponent);
    }
    else if( dialog.getToggleValue(answer,"plot errors",plotErrors) )
    {
      printF("Setting plotErrors=%i\n",(int)plotErrors);
    }

    else if( answer=="erase" )
    {
      gi.erase();
      plotObject=false;
    }
    
    else if( answer=="plot" || answer=="plotObject" )
    {
      plotObject=true;
    }
    else if( answer=="contour" )
    {
      plotObject=true;
    }
    else 
    {
      gi.outputString( sPrintF(buff,"Unknown response=%s",(const char*)answer) );
      gi.stopReadingCommandFile();
    }

    if( plotObject )
    {
      int domainStart=-1, domainEnd=-1;
      if( domainName == "all" )
      {
        domainStart=0; domainEnd=cg.numberOfDomains()-1;
      }
      else
      {
        for( int domain=0; domain<cg.numberOfDomains(); domain++ )
        {
          if( cg.getDomainName(domain)==domainName )
          {
            printF("--MX:PNV-- will plot nonlinear variables in domain number=%i name=[%s].\n",domain,(const char*)domainName);
            domainStart=domainEnd=domain;
            break;
          }
        }
      }
      
      if( domainStart<0  )
      {
        printF("--MX:PNV-- WARNING: There is no domain with name =[%s].\n",(const char*)domainName);
        printF("Valid domains are:\n");
        for( int domain=0; domain<cg.numberOfDomains(); domain++ )
        {
          DispersiveMaterialParameters & dmp = dmpVector[domain];
          printF("  domain=%i: name=[%s] numberOfAtomicLevels=%i.\n",domain,(const char*)cg.getDomainName(domain),dmp.getNumberOfAtomicLevels());
        }
        continue;
      }
      else
      {
        gi.erase();
        if( answer!="contour" )
          pspNonlinear.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
	else
          pspNonlinear.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
	
        real pMin=REAL_MAX, pMax=-pMin; // keep track of min and max over all domains 
        
	for( int domain=domainStart; domain<=domainEnd; domain++ )
	{

	  DispersiveMaterialParameters & dmp = dmpVector[domain];
	  if( dmp.getNumberOfAtomicLevels()>0 )
	  {
	    const int component = nlComponent;
	    if( component < dmp.getNumberOfAtomicLevels() )
	    {
	      pspNonlinear.set(GI_COMPONENT_FOR_CONTOURS,component);

	      realCompositeGridFunction & nlgf = *getNonlinearModelCompositeGridFunction( domain,current );
	      if( !plotErrors )
	      {
		real uMin,uMax;
		PlotIt::getBounds(nlgf,uMin,uMax,pspNonlinear,Range(component,component));
                
		pMin=min(pMin,uMin);
		pMax=max(pMax,uMax);

		printF("--MX--plot: domain=%i: this domain : (uMin,uMax=(%g,%g), all=(uMin,uMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
		pspNonlinear.setMinAndMaxContourLevels( pMin,pMax,component);
		PlotIt::contour(gi,nlgf,pspNonlinear);
	      }
	      else
	      {
		// --- Plot the errors in the nonlinear variables if available  ----
		bool getErrorGridFunction=true;
		realCompositeGridFunction & nlgfErr = *getNonlinearModelCompositeGridFunction( domain,current,getErrorGridFunction );

		real uMin,uMax;
		PlotIt::getBounds(nlgfErr,uMin,uMax,pspNonlinear,Range(component,component));
                
		pMin=min(pMin,uMin);
		pMax=max(pMax,uMax);

		printF("--MX--plot: domain=%i: Error: this domain (uMin,uMax=(%g,%g), all=(uMin,uMax=(%g,%g)\n",domain,uMin,uMax,pMin,pMax);
                
		pspNonlinear.setMinAndMaxContourLevels( pMin,pMax,component);

		PlotIt::contour(gi,nlgfErr,pspNonlinear);

	      }
              
	    }
	    else
	    {
	      printF("plotNonlinearVariables:INFO: Not plotting N in domain=%i since component=%i but "
		     "numberOfAtomicLevels=%i.\n",   domain,nlComponent,dmp.getNumberOfAtomicLevels());
	    }
	  } // end if numberOfAtomicLevels > 0
	}  // end for domain 
      }
      
  
    } // end if plotObject 
    

  }

  gi.unAppendTheDefaultPrompt();  // reset
  gi.popGUI(); // restore the previous GUI


  return 0;
}



int Maxwell::
buildRunTimeDialog()
// =============================================================================================
// =============================================================================================
{
  GenericGraphicsInterface & ps = *gip;
  if( runTimeDialog==NULL )
  {
    runTimeDialog = new GUIState;
    GUIState & dialog = *runTimeDialog;
    

    dialog.setWindowTitle("Maxwell");
    dialog.setExitCommand("finish", "finish");

    aString cmds[] = {"break",
                      "continue",
                      "movie mode",
                      "movie and save",
                      "contour",
                      "E field lines",
                      "grid",
                      "erase",
                      "plot options...",
                      "parameters...",
                      "plot distribution",
                      "plot materials",
                      "plot P...",
                      // "plot N...",
                      // "change the grid...",
                      // "show file options...","file output...",
                      // "pde parameters...",
                      ""};

    numberOfPushButtons=0;
    while( cmds[numberOfPushButtons] != "" ) numberOfPushButtons++;
    // numberOfPushButtons=11;  // number of entries in cmds

    int numRows=(numberOfPushButtons+1)/2;
    dialog.setPushButtons( cmds, cmds, numRows ); 

    // get any extra components such as errors for tz flow or the pressure for CNS.
    realCompositeGridFunction v;
    real t=-1; // this means only fill in the component names. 
    realCompositeGridFunction & u = getAugmentedSolution(0,v,t);

    const int numberOfComponents = u.getComponentBound(0)-u.getComponentBase(0)+1;
    // create a new menu with options for choosing a component.
    aString *cmd = new aString[numberOfComponents+1];
    aString *label = new aString[numberOfComponents+1];
    for( int n=0; n<numberOfComponents; n++ )
    {
      label[n]=u.getName(n);
      cmd[n]="plot:"+u.getName(n);

    }
    cmd[numberOfComponents]="";
    label[numberOfComponents]="";
    
    dialog.addOptionMenu("plot component:", cmd,label,0);
    delete [] cmd;
    delete [] label;

//     aString tbCommands[] = {"project fields",
// 			    ""};
//     int tbState[10];
//     tbState[0] = projectFields; 
//     int numColumns=1;
//     dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns);

    const int numberOfTextStrings=7;
    aString textLabels[numberOfTextStrings];
    aString textStrings[numberOfTextStrings];

    int nt=0;
    textLabels[nt] = "final time";  sPrintF(textStrings[nt], "%g",tFinal);  nt++; 
    textLabels[nt] = "times to plot";  sPrintF(textStrings[nt], "%g",tPlot);  nt++; 
    textLabels[nt] = "cfl";  
    sPrintF(textStrings[nt], "%g",cfl);  nt++; 
    textLabels[nt] = "debug";  sPrintF(textStrings[nt], "%i",debug);  nt++; 
 
       // null strings terminal list
    textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
    dialog.setTextBoxes(textLabels, textLabels, textStrings);
    numberOfTextBoxes=nt;
    

    // ******************* file output *************************
//     DialogData & fileOutputDialog = dialog.getDialogSibling();

//     fileOutputDialog.setWindowTitle("File Output Parameters");
//     fileOutputDialog.setExitCommand("close file output dialog", "close");

//     aString cmdf[] = {"file output",
//                       "output periodically to a file",
//                       "close an output file",
//                       "save restart file",
//                       ""};
//     int numberOfRows=4;
//     fileOutputDialog.setPushButtons( cmdf, cmdf, numberOfRows );

//     nt=0;
//     textLabels[nt] = "output file name";  sPrintF(textStrings[nt], "%s","overBlown.out");  nt++; 
//     textLabels[nt]= "restart file name";  sPrintF(textStrings[nt], "%s",(const char*)restartFileName);nt++; 
//     textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
//     fileOutputDialog.setTextBoxes(textLabels, textLabels, textStrings);


//     // ****** pde parameters *************
//     DialogData &pdeDialog = dialog.getDialogSibling();
//     pdeDialog.setExitCommand("close pde options", "close");
//     setPdeParameters("build dialog",&pdeDialog);



    ps.pushGUI(dialog);


  }
  return 0;

}


static void
setSensitivity( GUIState & dialog, bool trueOrFalse )
{
  dialog.getOptionMenu(0).setSensitive(trueOrFalse);
  int n;
  for( n=1; n<numberOfPushButtons; n++ ) // leave first push button sensitive (=="break")
    dialog.setSensitive(trueOrFalse,DialogData::pushButtonWidget,n);
  
  for( n=0; n<numberOfTextBoxes; n++ )
    dialog.setSensitive(trueOrFalse,DialogData::textBoxWidget,n);
  
}

int Maxwell::
buildParametersDialog(DialogData & dialog )
// ==========================================================================================
// /Description:
//    Build the parameters dialog -- these are various parameters that can be changed
//   at run time. 
// ==========================================================================================
{

  // ************** PUSH BUTTONS *****************
  dialog.setOptionMenuColumns(1);

  aString tbCommands[] = {"project fields",
 			  ""};
  int tbState[15];
  tbState[0] = projectFields;

  int numColumns=1;
  dialog.setToggleButtons(tbCommands, tbCommands, tbState, numColumns); 



  // ----- Text strings ------
  const int numberOfTextStrings=30;
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;
  textCommands[nt] = "dissipation"; 
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%e",artificialDissipation);  nt++; 

  textCommands[nt] = "dissipation (curvilinear)"; 
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%e",artificialDissipationCurvilinear);  nt++; 

  textCommands[nt] = "projection frequency";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",frequencyToProjectFields); nt++; 

  textCommands[nt] = "consecutive projection steps";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",numberOfConsecutiveStepsToProject); nt++; 

  textCommands[nt] = "number of divergence smooths";  
  textLabels[nt]=textCommands[nt]; sPrintF(textStrings[nt], "%i",numberOfDivergenceSmooths); nt++; 

  // null strings terminal list
  assert( nt<numberOfTextStrings );
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  return 0;
}


// ========================================================================================
/// \brief Construct the label that defines the time-stepping method and used in the
///    title for plots
// ========================================================================================
void Maxwell::
getTimeSteppingLabel( real dt, aString & label ) const
{

  aString buff;
  label=sPrintF(buff,"dt=%4.1e",dt);

  if( timeSteppingMethod==modifiedEquationTimeStepping )
    label+=" TS=ME";
  else if( timeSteppingMethod==stoermerTimeStepping )
    label+=" TS=ST";
  else if( timeSteppingMethod==rungeKutta )
    label+= sPrintF(" TS=RK%d",dbase.get<int>("orderOfRungeKutta"));
  else if( timeSteppingMethod==defaultTimeStepping )
    label+=" TS=default ";
  else
    label+="TS=??, ";

  // -- label for dispersion model ---
  if( nonlinearModel!=noNonlinearModel )
  {
    const aString & nonlinearModelName=dbase.get<aString>("nonlinearModelName");
    if( nonlinearModelName == "multilevelAtomic" )
    {
      label += " MLA";
    }
    else
    {
      printF("getTimeSteppingLabel:ERROR: unknown nonlinearModelName=[%s]\n",(const char*)nonlinearModelName);
    }
    
  }
  
  if( dispersionModel!=noDispersion )
  {
    aString & dispersionModelName=dbase.get<aString>("dispersionModelName");
    // int numPolar = numberOfPolarizationVectors;
    // if( method==bamx )
    // {
    //   // total number of polarization components per grid 
    //   const IntegerArray & totalNumberOfPolarizationComponents =
    //     parameters.dbase.get<IntegerArray>("totalNumberOfPolarizationComponents");
    //   int grid=0;  // ** FIX ME ** 
    //   numPolar=totalNumberOfPolarizationComponents(grid); // Counts P only, not Q
    // }
    
    // label+=sPrinF(" %s%d",(const char*)dispersionModelName,numPolar);

    label+= " " + dispersionModelName;

  }
  
  // if( twilightZoneOption==polynomialTwilightZone )
  //   label+=sPrintF(buff," order(X,T)=(%i,%i)",
  // 		   orderOfAccuracyInSpace,orderOfAccuracyInTime);

  if( method==nfdtd  )
  {
    if( artificialDissipation!=0. && artificialDissipation==artificialDissipationCurvilinear )
      label+=sPrintF(buff," ad%i=%4.2f",orderOfArtificialDissipation,artificialDissipation);
    else if( artificialDissipationCurvilinear!=0. )
      label+=sPrintF(buff," adr%i=%4.2f,adc%i=%4.2f",orderOfArtificialDissipation,artificialDissipation,
                     orderOfArtificialDissipation,artificialDissipationCurvilinear);
      
    if( applyFilter )
      label+=sPrintF(buff,", filter%i",orderOfFilter);

    if( divergenceDamping>0. )
      label+=sPrintF(buff," dd=%5.3f",divergenceDamping);
  }
  if( method==bamx )
  {
    // BAMX currently just uses a filter stage
    const int filterOrder=orderOfAccuracyInSpace + 2;
    
    if( artificialDissipation!=0. )
      label+=sPrintF(buff," F%i=%3.1f",filterOrder,artificialDissipation);

    if( divergenceDamping>0. )
      label+=sPrintF(buff," dd=%5.3f",divergenceDamping);
  }
  
}

// ========================================================================================
/// \brief plot grids coloured by material type
// ========================================================================================
int Maxwell::
plotMaterials( )
{

  GenericGraphicsInterface *& pps = gip; 
  if( pps==NULL )
    return 0;
  GenericGraphicsInterface & ps = *pps;
  
  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  PlotStuffParameters psp;


  if( method==bamx )
  {

    // 
    // ---- for BAMX we plot the material regions as contours based on the material index 0,1,2,3,... ----
    // 
    if( numberOfMaterialRegions>1 )
    {
      printF("plotMaterials: numberOfMaterialRegions=%d. Regions are plotted as contours by material index: 0,1,2,3...\n",
             numberOfMaterialRegions);


      // --- we need to save the materialMask as a REAL grid function so we can plot contours ---
      realGridCollectionFunction matMaskReal(cg);

      // ---- Here is a material mask ----
      intCompositeGridFunction & materialMask = parameters.dbase.get<intCompositeGridFunction>("materialMask");

      // real materialScaleFactor=255/max(1,numberOfMaterialRegions); // scale by 255 = number of colour names 

      Index I1,I2,I3;
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {

        OV_GET_SERIAL_ARRAY(int,materialMask[grid],matMaskLocal);
        OV_GET_SERIAL_ARRAY(real,matMaskReal[grid],matMaskRealLocal);

        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        bool ok=ParallelUtility::getLocalArrayBounds(matMaskReal[grid],matMaskRealLocal,I1,I2,I3);
        if( ok )
        {
          // we need to loop to assign values since we cannot set realArray = intArray
          FOR_3D(i1,i2,i3,I1,I2,I3)
          {
            matMaskRealLocal(i1,i2,i3) = matMaskLocal(i1,i2,i3);
          }
        }
      }
	      
      // change the default colour table
      RealArray ctSave(3,256);
      psp.getColourTable( ctSave );  // save current "rainbow" colour table 

      RealArray ct(3,256);  // holds new colour table 
      ct=ctSave;            // set default to rainbow 

      IntegerArray numberList(numberOfMaterialRegions); // for coloured "squares" list of numbers used 
      numberList=0;

      // --- We can colour materials using the same colours used to colour grids ----
      // Otherwise colour using the rainbow colour table 

      // If there are too many materials we should probably plot using the rainbow
      bool colourMaterialsUsingGridColours = true; // *** make this an option ***

      if( colourMaterialsUsingGridColours )
      {
        // -- set colours to match coloured "squares" used when plotting grids
        

        std::vector<DispersiveMaterialParameters> & dmpVector = 
          dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");
 
        aString matColourName;
        real rgb[3];
        for( int m=0; m<numberOfMaterialRegions; m++ )
        {
           aString materialName = dmpVector[m].getMaterialName();           

           matColourName = ps.getColourName( m );
           getXColour( matColourName, rgb);
 
           printF("material %s: index=%4d, colour=%s.\n",(const char*)materialName,m,(const char*)matColourName);
           // printF("material index=%4d, colour=%s.\n",m,(const char*)matColourName);

           ct(0,m)=rgb[0];  ct(1,m)=rgb[1]; ct(2,m)=rgb[2];
           numberList(m)=m;
        }

        // -- set contour bounds to be [0,255] ----
        IntegerArray & minAndMaxContourLevelsSpecified  = psp.minAndMaxContourLevelsSpecified;
        RealArray & minAndMaxContourLevels = psp.minAndMaxContourLevels;

        if( minAndMaxContourLevelsSpecified.getLength(0)<1 )
        {
          minAndMaxContourLevelsSpecified.redim(1);
          minAndMaxContourLevels.redim(2,1);
        }
        
        minAndMaxContourLevelsSpecified=true;   // give values to new entries
        minAndMaxContourLevels(0,0)=0; 
        minAndMaxContourLevels(1,0)=255; 

        psp.set(GI_PLOT_COLOUR_BAR,false);

      }

      
      psp.setColourTable( ct );

      ps.erase();
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
      psp.set(GI_TOP_LABEL,"BA materials");

      const bool plotOnThisProcessor = Communication_Manager::localProcessNumber()==ps.getProcessorForGraphics();
      if( colourMaterialsUsingGridColours && plotOnThisProcessor )
      {  // draw coloured "squares" to associate a colour with a material index
         // 0 = blue
         // 1 = green ...
         ps.drawColouredSquares(numberList,psp);
      }        

      PlotIt::contour(ps,matMaskReal,psp);
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);

      // reset
      psp.setColourTable( ctSave );
    }
    else
    {
      printF("plotMaterials:There is only one material region. Nothing plotted.\n");
    }

    
    return 0;
  }
  
  // Colour grid lines and boundaries by the material
  psp.set(GI_GRID_LINE_COLOUR_OPTION,GraphicsParameters::colourByIndex);
  psp.set(GI_BOUNDARY_COLOUR_OPTION ,GraphicsParameters::colourByIndex); 

  // const int numMaterialColours=7;
  // int matColour[numMaterialColours];
  // matColour[0]=getXColour("BLUE");
  // matColour[1]=getXColour("RED");
  // matColour[2]=getXColour("GREEN");
  // matColour[3]=getXColour("NAVYBLUE");
  // matColour[4]=getXColour("ORANGE");
  // matColour[5]=getXColour("DARKGREEN");
  // matColour[6]=getXColour("LIGHTBLUE");

  // aString pickColour;
  // pickColour="NAVYBLUE";
  // int pickColourIndex=getXColour(pickColour);

  if( psp.gridColours.getLength(0)<cg.numberOfComponentGrids() )
  {
    psp.gridColours.resize(cg.numberOfComponentGrids(),8);
  }
  Range all;
  int numberOfMaterials=0; // counts distinct materials
  IntegerArray matNumber(cg.numberOfComponentGrids());  // material number for a grid 
  matNumber=0;
  int matColourIndex=0;  // current colour index 
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {

    //  dispersionModel!=noDispersion; 
    if( method!=bamx )
    {
      // --- Isotropic Maxwell  ----

      const int domain = cg.domainNumber(grid);
      const DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
      aString materialName = dmp.getMaterialName();

      // printF("grid=%d, domain=%d:  materialName =%s\n",grid,domain,(const char*)materialName);

      // Check to see if the material name has already appeared in a previous grid
      bool matFound=false;
      for( int g=0; g<grid; g++ )
      {
        if( getDomainDispersiveMaterialParameters(cg.domainNumber(g)).getMaterialName() == materialName )
        {
          matNumber(grid) = matNumber(g);
          matFound=true;
          break;
        }
      }
      if( !matFound )
      {
        // new material found 
        matNumber(grid)=numberOfMaterials;
        numberOfMaterials++;
      }


      // -- Use colours from coloured "squares" used when plotting the grid ---
      aString matColourName = ps.getColourName( matNumber(grid) );
      matColourIndex = getXColour(matColourName);

      // if( false && matNumber(grid) < numMaterialColours )
      // {
      //   // use predefined colours to start
      //   matColourIndex = matColour[ ( matNumber(grid) % numMaterialColours) ];
      // }
      // else
      // {
      //   // cycle through some X-colours
      //   const int numXColoursToUse=64;
      //   matColourIndex = matNumber(grid) % numXColoursToUse;
      // }
      

      if( !matFound )
      {
        // aString matColourName = getXColour( matColourIndex );
        printF("material %s: index=%4d, colour=%s.\n",(const char*)materialName,matColourIndex,(const char*)matColourName);
      }
      
      psp.gridColours(grid,all)= matColourIndex; // gridColour[ ( matNumber(grid) % numMaterialColours) ];
      
    }
    else
    {
      printF("plotMaterials: finish me for the bamx solver\n");
    }
    
  }
  printF("plotMaterials: There are %d distinct materials.\n",numberOfMaterials);
  
  psp.set(GI_TOP_LABEL,"Materials");
  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
  PlotIt::plot( ps, cg,psp );
  return 0;
}


int Maxwell::
plot( int current, real t, real dt )
// ========================================================================================
// /Description:
//  plotOptions :  0 = no plotting
//                 1 - plot and wait
//                 2 - do not wait for response after plotting
// /Return values: 0=normal exit. 1=user has requested "finish".
// ========================================================================================
{
  if( plotOptions==0 )
    return 0;

  real cpu0=getCPU();
  int returnValue=0;

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;

  //  GenericGraphicsInterface & ps = *gip;
  GenericGraphicsInterface *& pps = gip; 
  if( pps==NULL )
    return 0;
  GenericGraphicsInterface & ps = *pps;

  char buff[100];
  int & useSosupDissipation = parameters.dbase.get<int>("useSosupDissipation");
  aString suffix="";
  if( useSosupDissipation )
    suffix="s";  // name = FD22s, FD44s etc. for sosup dissipation
  psp.set(GI_TOP_LABEL,sPrintF(buff,"Maxwell %s%i%i%s: t=%6.2e ",(const char *)methodName,
                               orderOfAccuracyInTime,orderOfAccuracyInSpace,(const char *)suffix,t));
  aString label;
  getTimeSteppingLabel( dt,label );
  
  if( plotScatteredField )
    label+="(scattered field)";
    
  psp.set(GI_TOP_LABEL_SUB_1,label);

  // we need to know if the graphics is open on any processor -- fix this in the GraphicsInterface.
  int graphicsIsOn = ps.isGraphicsWindowOpen();
  graphicsIsOn = ParallelUtility::getMaxValue(graphicsIsOn);
  int readingCommandFile = ps.readingFromCommandFile();
  readingCommandFile = ParallelUtility::getMaxValue(readingCommandFile);

  // printF(" **** t=%e, graphicsIsOn=%i readingCommandFile=%i, processor=%i\n",t,graphicsIsOn,readingCommandFile, 
  //            myid);
  // fflush(stdout);

  // // set to true for debugging:   **WARNING: this will break the check files: output called twice:
  // bool getDiv=false; // true; 
  // if(  getDiv || (!graphicsIsOn && readingCommandFile && (method==nfdtd || method==sosup) ) )
  // {
  //   // printF(" **** call getMaxDivergence t=%e, processor=%i\n",t, myid);
  //   // fflush(stdout);
  

  //   // no plotting and reading from a command file
  //   // *** get divEMax and uMin, uMax
  //   if ( method==nfdtd || method==sosup )
  //     getMaxDivergence( current,t );

  //   printF(">>> Cgmx:%s: t=%6.2e, %s |div(E)|=%8.2e, |div(E)|/|grad(E)|=%8.2e, |grad(E)|=%8.2e (%i steps)\n",
  // 	   (const char *)methodName,t,(const char*)label,
  // 	   divEMax,divEMax/max(REAL_MIN*100.,gradEMax),gradEMax,numberOfStepsTaken);
  //   if( solveForMagneticField && cg.numberOfDimensions()==3 )
  //   {
  //     printF("                                                              "
  //            "|div(H)|=%8.2e, |div(H)|/|grad(H)|=%8.2e, |grad(H)|=%8.2e (%i steps)\n",
  // 	     divHMax,divHMax/max(REAL_MIN*100.,gradHMax),gradHMax,numberOfStepsTaken);
  //   }
    
  //   outputResults(current,t,dt);
    
  //   timing(timeForPlotting)+=getCPU()-cpu0;
  //   if( !getDiv ) return returnValue;
  // }
  

  if( runTimeDialog==NULL )
  {
    buildRunTimeDialog();
    // --- Build the sibling dialog for plot options ---
    DialogData & plotOptionsDialog = runTimeDialog->getDialogSibling();
    pPlotOptionsDialog = &plotOptionsDialog;
    plotOptionsDialog.setWindowTitle("MX Plot Options");
    plotOptionsDialog.setExitCommand("close plot options", "close");
    buildPlotOptionsDialog(plotOptionsDialog);

    DialogData & parametersDialog = runTimeDialog->getDialogSibling();
    pParametersDialog = &parametersDialog;
    parametersDialog.setWindowTitle("MX Parameters");
    parametersDialog.setExitCommand("close parameters", "close");
    buildParametersDialog(parametersDialog);

  }
  DialogData &plotOptionsDialog = *pPlotOptionsDialog;
  DialogData &parametersDialog = *pParametersDialog;

  GUIState & dialog = *runTimeDialog;

  aString answer;

  // get any extra components such as errors for tz flow or the pressure for CNS.

  // MappedGrid & mg = *(fields[current].getMappedGrid());

  // **** no need to compute extra components if we are in movie mode and we are not
  //      plotting any extra component ****
  realCompositeGridFunction v;
  realCompositeGridFunction & u = getAugmentedSolution(current,v,t);  // u is either solution or v

  const int numberOfComponents = u.getComponentBound(0)-u.getComponentBase(0)+1;

  const int & useSuperGrid = parameters.dbase.get<int>("useSuperGrid");
  int & absorbingLayerErrorOffset = parameters.dbase.get<int>("absorbingLayerErrorOffset");

  bool & plotPolarizationComponents = dbase.get<bool>("plotPolarizationComponents");
  bool & plotNonlinearComponents    = dbase.get<bool>("plotNonlinearComponents");

  if( movieFrame>=0   )
  { // save a ppm file as part of a movie.
    psp.set(GI_HARD_COPY_TYPE,GraphicsParameters::ppm);
    ps.outputString(sPrintF(buff,"Saving file %s%i.ppm",(const char*)movieFileName,movieFrame));
    ps.hardCopy(    sPrintF(buff,            "%s%i.ppm",(const char*)movieFileName,movieFrame),psp);
    psp.set(GI_HARD_COPY_TYPE,GraphicsParameters::postScript);
    movieFrame++;
  }

  

  ps.erase();
  if( plotOptions & 1 )
  {

    // printF(">>> Cgmx:%s: t=%6.2e, %s |div(E)|=%8.2e, |div(E)|/|grad(E)|=%8.2e, |grad(E)|=%8.2e (%i steps)\n",
    // 	   (const char *)methodName,t,(const char*)label,
    // 	   divEMax,divEMax/max(REAL_MIN*100.,gradEMax),gradEMax,numberOfStepsTaken);
    // if( solveForMagneticField && cg.numberOfDimensions()==3 )
    // {
    //   printF("                                                              "
    //          "|div(H)|=%8.2e, |div(H)|/|grad(H)|=%8.2e, |grad(H)|=%8.2e (%i steps)\n",
    // 	     divHMax,divHMax/max(REAL_MIN*100.,gradHMax),gradHMax,numberOfStepsTaken);
    // }
    // outputResults(current,t,dt);
    

    // Plot all the the things that the user has previously plotted
    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

    if( numberOfMaterialRegions>1 ) // plot this first since title is wrong in body force graphics parameters
    {
      // printF("PLOT BODY FORCE REGIONS\n");
      // Plot body/boundary forcing regions and immersed boundaries. 
      BodyForce::plotForcingRegions(ps, parameters.dbase, *cgp, psp); 
      
    }

    if( plotChoices & 1 )
    {
      if( mgp!=NULL )
        PlotIt::plot(ps,*mgp,psp);
      else
        PlotIt::plot(ps,*cgp,psp);
    }
    if( plotChoices & 2 )
      PlotIt::contour(ps,u,psp);
    if( plotChoices & 4 )
      PlotIt::streamLines(ps,u,psp);


    bool programHalted=false;
    int checkForBreak=false;
    const int processorForGraphics = pps!=NULL ? pps->getProcessorForGraphics() : 0;
    if( plotOptions & 2  && pps!=NULL && !(ps.readingFromCommandFile()) &&
        myid==processorForGraphics && ps.isGraphicsWindowOpen() )
    { // we are running interactively and we should check for a "break" command:
      checkForBreak=true; 
    }
    broadCast(checkForBreak,processorForGraphics); // broadcast to all from the processor for graphics

    if( checkForBreak )
    {
      // movie mode ** check here if the user has hit break ***
      // ps.outputString(sPrintF(buff,"Check for break at t=%e\n",t));
      answer="";
      
      int menuItem = ps.getAnswerNoBlock(answer,"monitor>");
      // printf("answer = [%s]\n",(const char*)answer);
      
      if( answer=="break" )
      {
	programHalted=true;

      }
    }


    // bool programHalted=false;
    // if( plotOptions & 2 )
    // {
    //   // movie mode ** check here if the user has hit break ***
    //   if( ps.isGraphicsWindowOpen() && 
    //       !ps.readingFromCommandFile() )  // for now we cannot check if we are reading from a command file
    //   {
    // 	// ps.outputString(sPrintF(buff,"Check for break at t=%e\n",t));
    // 	answer="";
    // 	int menuItem = ps.getAnswerNoBlock(answer,"monitor>");
    // 	if( answer=="break" )
    // 	{
    // 	  programHalted=true;
    // 	}
    //   }
      
    // }
    
    if( ! (plotOptions & 2) || programHalted )
    {
      if( plotOptions & 1 )
      {
	setSensitivity( dialog,true );
      }
      
      plotOptions=1; // reset movie mode if set.
      movieFrame=-1;
      
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);

//       DialogData & fileOutputDialog = dialog.getDialogSibling(1);
//       DialogData & pdeDialog = dialog.getDialogSibling(2);

      int len;
      bool replot=false;
      for(;;)
      {
	// int menuItem = ps.getMenuItem(menu,answer,"choose an option");
        real timew=getCPU();
	int menuItem = ps.getAnswer(answer,"");
        timing(timeForWaiting)+=getCPU()-timew;

	if( answer=="contour" )
	{
          if(plotChoices & 2 )
            ps.erase();
	  
          PlotIt::contour(ps,u,psp);
	  if( psp.getObjectWasPlotted() ) 
	    plotChoices |= 2;
          else
            plotChoices &= ~2;

          replot=true;
	}

// 	else if( menuItem > chooseAComponentMenuItem && 
//                  menuItem <= chooseAComponentMenuItem+numberOfComponents )
// 	{
//           // plot a new component
// 	  int component=menuItem-chooseAComponentMenuItem-1;
//           if( plotChoices & 2 )
// 	  {
//             ps.erase();
// 	    psp.set(GI_COMPONENT_FOR_CONTOURS,component);
// 	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

// 	    if( plotChoices & 1 )
// 	      PlotIt::plot(ps,mg,psp);

// 	    PlotIt::contour(ps,u,psp);

// 	    if( plotChoices & 4 )
// 	      PlotIt::streamLines(ps,u,psp);

// 	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
// 	  }
// 	}
        else if( answer=="grid" )
	{
          if( mgp!=NULL )
            PlotIt::plot(ps,*mgp,psp);
          else
            PlotIt::plot(ps,*cgp,psp);

	  if( psp.getObjectWasPlotted() ) 
	    plotChoices |= 1;
          else
            plotChoices &= ~1;
	}
        else if( answer=="plot P..." )
        {
          plotPolarization( current,t,dt );
        }
        else if( answer=="plot N..." )
        {
          plotNonlinearVariables( current,t,dt );
        }

        else if( answer=="plot distribution" )
        {
          ps.erase();
          PlotIt::plotParallelGridDistribution(cg,ps,psp );
        }
        
        else if( answer=="plot materials" )
        {
          // plot grids coloured by material
          ps.erase();
          plotMaterials();
        }
        

	else if( answer=="E field lines" )
	{
          int uc,vc;
          if( ( mgp!=NULL && mgp->isRectangular() && method==defaultMethod) || method==yee )
	  {
	    uc=ex; vc=ey;
	  }
	  else
	  {
	    uc=ex10, vc=ey10;
	  }
	  psp.set(GI_U_COMPONENT_FOR_STREAM_LINES,uc);
	  psp.set(GI_V_COMPONENT_FOR_STREAM_LINES,vc);
          PlotIt::streamLines(ps,u,psp);

	  if( psp.getObjectWasPlotted() ) 
	    plotChoices |= 4;
          else
            plotChoices &= ~4;
	}
	else if( answer=="erase" )
	{
          ps.erase();
	  plotChoices=0;
	}
	else if( answer=="plot options..." )
	{
	  plotOptionsDialog.showSibling();
	}
	else if( answer=="close plot options" )
	{
	  plotOptionsDialog.hideSibling();
	}
	else if( answer=="parameters..." )
	{
	  parametersDialog.showSibling();
	}
	else if( answer=="close parameters" )
	{
	  parametersDialog.hideSibling();
	}
        
//         else if( answer=="save a restart file" )
// 	{
// 	  ps.inputFileName(answer,sPrintF(buff,"Enter the restart file name (default value=%s)",
// 					  (const char *)restartFileName));
// 	  if( answer!="" )
// 	    restartFileName=answer;

// 	  saveRestartFile(solution,restartFileName);
// 	}
//         else if( answer=="save restart file" ) // new way, do not prompt for restart file name
// 	{
// 	  saveRestartFile(solution,restartFileName);
// 	}
//         else if( answer=="output to a file" )
// 	{
// 	  FileOutput fileOutput;
// 	  fileOutput.update(u,ps);
// 	}
// 	else if( answer=="output periodically to a file" || answer=="output periodically to a file..." )
// 	{
//           if( numberOfOutputFiles>=maximumNumberOfOutputFiles )
// 	  {
// 	    printF("ERROR: too many files open\n");
// 	    continue;
// 	  }
//           fileOutputFrequency[numberOfOutputFiles]=1;
//           ps.inputString(answer,"Save to the file every how many steps? (default=1)");
//           sScanF(answer,"%i",&fileOutputFrequency[numberOfOutputFiles]);
	  
//           FileOutput & fileOutput = * new FileOutput;
// 	  outputFile[numberOfOutputFiles] = &fileOutput;
// 	  numberOfOutputFiles++;
          
//           fileOutput.update(u,ps);

	  
// 	}
// 	else if( answer=="close an output file" )
// 	{
//           aString *fileMenu = new aString [numberOfOutputFiles+2];
//           int n;
// 	  for( n=0; n<numberOfOutputFiles; n++ )
// 	  {
// 	    fileMenu[n]=outputFile[n]->getFileName();
// 	  }
//           fileMenu[parameters.numberOfOutputFiles]="none";
//           fileMenu[parameters.numberOfOutputFiles+1]="";
// 	  int fileChosen = ps.getMenuItem(fileMenu,answer,"Choose a file to close");
// 	  if( fileChosen>=0 && fileChosen<parameters.numberOfOutputFiles )
// 	  {
//             printF("close file %s\n",(const char*)fileMenu[fileChosen]);
// 	    delete parameters.outputFile[fileChosen];
//             parameters.numberOfOutputFiles--;
// 	    for( n=fileChosen; n<parameters.numberOfOutputFiles; n++ )
// 	      parameters.outputFile[n]=parameters.outputFile[n+1];
// 	    parameters.outputFile[parameters.numberOfOutputFiles]=NULL;
// 	  }
// 	}
	else if( answer=="continue" )
	{
          if( t >= tFinal-dt/10. )
	  {
	    printF("WARNING: t=tFinal. Choose `finish' if you really want to end\n");
	  }
	  else
            break;
 	}
	else if( answer=="movie mode" )
	{
          plotOptions=3;  // don't wait
          if( ! ps.isGraphicsWindowOpen() )
          {
            plotOptions=0;  // *wdh* No need to plot if graphics is off - Jan 28, 2020
          }
          

  	  setSensitivity( dialog,false );
          break;
 	}
        else if( answer=="movie and save" )
	{
	  ps.inputString(answer,"Enter basic name for the ppm files (default=plot)");
	  if( answer !="" && answer!=" ")
	    movieFileName=answer;
          else
	    movieFileName="plot";
          ps.outputString(sPrintF(buff,"pictures will be named %s0.ppm, %s1.ppm, ...",
            (const char*)movieFileName,(const char*)movieFileName));
	  movieFrame=0;
          plotOptions=3;  // don't wait

  	  setSensitivity( dialog,false );
          break;
	}
//         else if( answer=="show file options" || answer=="show file options..." )
// 	{
//            updateShowFile();
// 	}
	else if( answer=="finish" )
	{
          tFinal=t;
          returnValue=1;
          break;
 	}
	else if( plotOptionsDialog.getToggleValue(answer,"plot energy density",plotEnergyDensity) ){replot=true;}//
        else if( plotOptionsDialog.getToggleValue(answer,"plot intensity",plotIntensity) ){}//
        else if( plotOptionsDialog.getToggleValue(answer,"plot harmonic E field",plotHarmonicElectricFieldComponents) ){}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot errors",plotErrors) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot scattered field",plotScatteredField) )
        { printF("plotScatteredField=%i\n",(int)plotScatteredField);
          replot=true; 
        }
   
	else if( plotOptionsDialog.getToggleValue(answer,"plot total field",plotTotalField) )
        { printF("plotTotalField=%i\n",(int)plotTotalField);
          replot=true; 
        }

        else if( plotOptionsDialog.getToggleValue(answer,"plot polarization components",plotPolarizationComponents) )
        {
          printF("plotPolarizationComponents=%d : 1=plot all component polarization variables for dispersive materials.\n",
                 plotPolarizationComponents);
        }
    
        else if( plotOptionsDialog.getToggleValue(answer,"plot nonlinear components",plotNonlinearComponents) ){}//

	else if( plotOptionsDialog.getToggleValue(answer,"plot dissipation",plotDissipation) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot divergence",plotDivergence) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"check errors",checkErrors) ){replot=true;}//
        else if( plotOptionsDialog.getToggleValue(answer,"compute energy",computeEnergy) ){}//
	else if( plotOptionsDialog.getToggleValue(answer,"plot dsi vertex max",plotDSIMaxVertVals) ){replot=true;}//
	else if( plotOptionsDialog.getToggleValue(answer,"compare to show file",compareToReferenceShowFile) )
         {replot=true;}//

	else if( dialog.getTextValue(answer,"cfl","%g",cfl) ){}//
	else if( dialog.getTextValue(answer,"final time","%g",tFinal) ){}//
	else if( dialog.getTextValue(answer,"times to plot","%g",tPlot) ){}//
        else if( dialog.getTextValue(answer,"debug","%i",debug) ){}//
        else if( dialog.getTextValue(answer,"radius for checking errors","%f",radiusForCheckingErrors) )
        {
          getErrors( current,t,dt );
          replot=true;
	}
	else if( plotOptionsDialog.getTextValue(answer,"pml error offset","%i",pmlErrorOffset) )
	{
          getErrors( current,t,dt );
          replot=true;
	}
	else if( plotOptionsDialog.getTextValue(answer,"absorbing layer error offset","%i",absorbingLayerErrorOffset) )
	{
	  printF("Setting absorbingLayerErrorOffset=%d\n",absorbingLayerErrorOffset);
	  if( useSuperGrid )
	  {
	    getErrors( current,t,dt );
	    replot=true;
	  }
	}

        else if( parametersDialog.getToggleValue(answer,"project fields",projectFields) ){}//
        else if( parametersDialog.getTextValue(answer,"projection frequency","%i",frequencyToProjectFields) ){}// 
        else if( parametersDialog.getTextValue(answer,"consecutive projection steps","%i",
                   numberOfConsecutiveStepsToProject) ){}// 
        else if( parametersDialog.getTextValue(answer,"number of divergence smooths","%i",
                   numberOfDivergenceSmooths) ){}// 
        else if( parametersDialog.getTextValue(answer,"dissipation (curvilinear)","%g",artificialDissipationCurvilinear) ){}//
        else if( parametersDialog.getTextValue(answer,"dissipation","%g",artificialDissipation) ){}//

	else if( len=answer.matches("plot:") )
	{
          // plot a new component
          aString name = answer(len,answer.length()-1);
          int component=-1;
	  for( int n=0; n<numberOfComponents; n++ )
	  {
	    if( name==u.getName(n) )
	    {
	      component=n;
	      break;
	    }
	  }
          if( component==-1 )
	  {
            printF("ERROR: unknown component name =[%s]\n",(const char*)name);
	    component=0;
	  }

          ps.erase();

          if( numberOfMaterialRegions>1 ) // plot this first since title is wrong in body force graphics parameters
          {
            // printF("PLOT BODY FORCE REGIONS (2)\n");
            // Plot body/boundary forcing regions and immersed boundaries. 
            psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);
            BodyForce::plotForcingRegions(ps, parameters.dbase, *cgp, psp); 
          }

          dialog.getOptionMenu(0).setCurrentChoice(component);
          if( plotChoices & 2 )
	  {
	    psp.set(GI_COMPONENT_FOR_CONTOURS,component);
	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

	    if( plotChoices & 1 )
	    {
	      if( mgp!=NULL )
	        PlotIt::plot(ps,*mgp,psp);
              else
	        PlotIt::plot(ps,*cgp,psp);
	    }
	    PlotIt::contour(ps,u,psp);

	    if( plotChoices & 4 )
	      PlotIt::streamLines(ps,u,psp);

	    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
	  }
	}
// 	else if( answer=="file output..." )
// 	{
//           fileOutputDialog.showSibling();
// 	}
//         else if( answer=="close file output dialog" )
// 	{
//           fileOutputDialog.hideSibling();
// 	}
// 	else if( answer=="pde parameters..." )
// 	{
// 	  pdeDialog.showSibling();
// 	}
// 	else if( answer=="close pde options" )
// 	{
// 	  pdeDialog.hideSibling();  // pop timeStepping
// 	}
// 	else if( parameters.setPdeParameters(answer,&pdeDialog)==0 )
// 	{
// 	  printF("Answer was found in setPdeParameters\n");
// 	}
        else if( answer=="break" )
	{
	}
        else
	{
	  cout << "Unknown response: " << answer << endl;
	}
	if( replot )
	{
	  replot=false;
          getAugmentedSolution(current,v,t);
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
          ps.erase();


          //  itemsToPlot & 8 ) // plot this first since title is wrong in body force graphics parameters

          if( numberOfMaterialRegions>1 ) // plot this first since title is wrong in body force graphics parameters
          {
            // printF("PLOT BODY FORCE REGIONS (3) \n");
            // Plot body/boundary forcing regions and immersed boundaries. 
            BodyForce::plotForcingRegions(ps, parameters.dbase, *cgp, psp); 
          }

	  if( plotChoices & 1 )
	  {
	    if( mgp!=NULL )
	      PlotIt::plot(ps,*mgp,psp);
	    else
	      PlotIt::plot(ps,*cgp,psp);
	  }
	  if( plotChoices & 2 )
	    PlotIt::contour(ps,u,psp);
	  if( plotChoices & 4 )
	    PlotIt::streamLines(ps,u,psp);
  
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
        }//
      }
    }
  }
  

  if( plotOptions & 2  )
  {
    ps.redraw(TRUE);
    
  }
  
  timing(timeForPlotting)+=getCPU()-cpu0;
  return returnValue;
}
