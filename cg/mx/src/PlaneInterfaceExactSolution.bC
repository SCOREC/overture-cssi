#include "PlaneInterfaceExactSolution.h"

#include "DispersiveMaterialParameters.h"

#include "ParallelUtility.h"

// ===============================================================================
// Class to define exact solutions to Maxwell's equations
// 
//     Scattering from a plane material interface in 2D and 3D , dispersive or not
// ===============================================================================



// #define scatSphere EXTERN_C_NAME(scatsphere)

// extern "C"
// {

// void scatSphere(const int&nd ,
//           const int&n1a,const int&n1b,const int&n2a,const int&n2b,const int&n3a,const int&n3b,const int&nd1a,
//           const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,const int&nd4a,const int&nd4b,
//           const real& xy, real&u, const int&ipar, const real&rpar );

// }


#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)



#define evalMaterialInterfaceSolution3d EXTERN_C_NAME(evalmaterialinterfacesolution3d)
extern "C"
{

void  evalMaterialInterfaceSolution3d( const real&sr,const real&si, 
                                       const real&chiSum1r, const real&chiSum1i, const real&chiSum2r, const real&chiSum2i,
                                       const real&av,const real&nv,const real&kv,
                                       const real&eps1,const real&eps2,
                                       const real&mu1,const real&mu2,
                                       const real&krr,const real&kri,
                                       const real&ktr,const real&kti,
                                       real & arr, real & ari, real & atr, real & ati );

}




// ===============================================================================
/// \brief  Constructor for th class that defines exact solutions to Maxwell's equations for a sphere
// ===============================================================================
PlaneInterfaceExactSolution::
PlaneInterfaceExactSolution()
{

  dbase.put<int>("numberOfDimensions");

  dbase.put<real>("amp");

  dbase.put<real[2]>("s"); 

  dbase.put<real>("eps1"); 
  dbase.put<real>("mu1"); 

  dbase.put<real>("eps2"); 
  dbase.put<real>("mu2"); 

  
  dbase.put<real[3]>("av");

  dbase.put<real[3]>("arr");
  dbase.put<real[3]>("ari");
  dbase.put<real[3]>("atr");
  dbase.put<real[3]>("ati");

  dbase.put<real[3]>("krr");
  dbase.put<real[3]>("kri");
  dbase.put<real[3]>("ktr");
  dbase.put<real[3]>("kti");

  dbase.put<real[3]>("kv");
  dbase.put<real[3]>("kvr");
  dbase.put<real[3]>("kvi");

  dbase.put<real[3]>("kpvr");
  dbase.put<real[3]>("kpvi");


  dbase.put<int>("numberOfPolarizationVectors1");

  dbase.put<int>("numberOfPolarizationVectors2");

  dbase.put<real>("eps1Hatr");
  dbase.put<real>("eps1Hati");

  dbase.put<real>("eps2Hatr");
  dbase.put<real>("eps2Hati");

  dbase.put<real>("chiSum1r");
  dbase.put<real>("chiSum1i");

  dbase.put<real>("chiSum2r");
  dbase.put<real>("chiSum2i");

  dbase.put<real[10]>("chi1r");
  dbase.put<real[10]>("chi1i");

  dbase.put<real[10]>("chi2r");
  dbase.put<real[10]>("chi2i");

  dbase.put<real[3]>("normalPlaneMaterialInterface");
  dbase.put<real[3]>("x0PlaneMaterialInterface");
  
}


// ===============================================================================
/// \brief destructor for the class that defines exact solutions to Maxwell's equations for a sphere
// ===============================================================================
PlaneInterfaceExactSolution::
~PlaneInterfaceExactSolution()
{
}


// ===============================================================================
/// \brief Initialize the plane material interface solution.
// ===============================================================================
int PlaneInterfaceExactSolution::
initialize( CompositeGrid & cg, DispersiveMaterialParameters & dmp1, DispersiveMaterialParameters & dmp2,
            real *av_, real *kvr_, real *kvi_ )
{
  int & numberOfDimensions = dbase.get<int>("numberOfDimensions");
  numberOfDimensions=cg.numberOfDimensions();


  assert( cg.numberOfDomains()==2 );

  real & a = dbase.get<real>("amp");
  a =1.;  // amplitude 

  // --------- Find the normal to the interface and a point on it -------

  const int grid=0, side=1, axis=0;
  
  MappedGrid & mg = cg[grid];
  mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex | MappedGrid::THEvertexBoundaryNormal);  
  OV_GET_VERTEX_BOUNDARY_NORMAL(mg,side,axis,normal);
  OV_GET_SERIAL_ARRAY(real,mg.vertex(),xLocal);
  
  // ** DO THIS FOR NOW **
  real kx=kvr_[0], ky=kvr_[1], kz=kvr_[2];

  real (&av)[3] = dbase.get<real[3]>("av");
  for( int i=0; i<3; i++ ){ av[i]=av_[i]; }  // 
  
  real kNorm = sqrt( SQR(kvr_[0]) + SQR(kvr_[1]) + SQR(kvr_[2]) + SQR(kvi_[0]) + SQR(kvi_[1]) + SQR(kvi_[2]) );
  real aNorm = sqrt( SQR(av[0]) + SQR(av[1]) + SQR(av[2]) );

  real aDotK = av[0]*kx + av[1]*ky + av[2]*kz;
  if( fabs(aDotK) > REAL_EPSILON*100. * max(aNorm,kNorm) )
  {

    printF("PlaneInterfaceExactSolution::initialize:ERROR: a.k != 0\n");
    printF(" av=[%g,%g,%g] kv=[%g,%g,%g]\n",av[0],av[1],av[2],kx,ky,kz);
    OV_ABORT("error");
  }
  

  real (&normalPlaneMaterialInterface)[3] = dbase.get<real[3]>("normalPlaneMaterialInterface");
  real (&x0PlaneMaterialInterface)[3] = dbase.get<real[3]>("x0PlaneMaterialInterface");

  real *nv = normalPlaneMaterialInterface;
  real *x0 = x0PlaneMaterialInterface;
  for( int i=0; i<3; i++ ){ nv[i]=0.; x0[i]=0.; }  // 
  
  if( true )
  {
    // --- evaluate the normal to the interface and a point on the interface ---
    // *new* way for parallel Nov. 18, 2020 *wdh*
    Mapping & map = mg.mapping().getMapping();
                  
    RealArray r(1,3), x(1,3), rx(1,3,3);
    r=.5; r(0,axis)=side;    // r-coords for a point on the middle of the face of (grid,side,axis)
    map.mapS(r,x); 
    map.inverseMapS(x,r,rx);  // easier to get normal from rx

    // length :  || grad(r)_xv ||
    const real norm = cg.numberOfDimensions()==2 ?
      sqrt(SQR(rx(0,axis,0))+SQR(rx(0,axis,1))) :
      sqrt(SQR(rx(0,axis,0))+SQR(rx(0,axis,1))+SQR(rx(0,axis,2)));
    assert( norm>0. );
    for( int dir=0; dir<cg.numberOfDimensions(); dir++ )
    {
      nv[dir] = (2*side-1.)*rx(0,axis,dir)/norm; // outward normal = grad(r)_xv / || grad(r)_xv ||
      x0[dir] = x(0,dir);
    }

  }
  printF("\n ------------------- PlaneInterfaceExactSolution::initialize ------------------------\n\n");
  printF(" av=[%g,%g,%g] x0=[%g,%g,%g] nv=[%g,%g,%g]\n",av[0],av[1],av[2],x0[0],x0[1],x0[2],nv[0],nv[1],nv[2]);

  if( false )
  {
    // **old way**     
    const IntegerArray & gid = mg.gridIndexRange();
    // mid point of a face: 
    int i1 = gid(1,0), i2= int( (gid(0,1)+gid(1,1))/2 ), i3= int( (gid(0,2)+gid(1,2))/2 );
    for( int axis=0; axis<cg.numberOfDimensions(); axis++ )
    {
      nv[axis]=normal(i1,i2,i3,axis);
      x0[axis]=xLocal(i1,i2,i3,axis);
    }
  

    printF("\n ------------------- PlaneInterfaceExactSolution::initialize **OLD** ------------------------\n\n");
    printF(" av=[%g,%g,%g] x0=[%g,%g,%g] nv=[%g,%g,%g]\n",av[0],av[1],av[2],x0[0],x0[1],x0[2],nv[0],nv[1],nv[2]);
  }
  
  // Should n.k be always positive ??
  real nDotK = nv[0]*kx + nv[1]*ky + nv[2]*kz;
  printF(" n.k = %g\n",nDotK);
  if( nDotK < 0 )
  {
    printF("\n\n *****************************************************************************\n");
    printF("PlaneInterfaceExactSolution::initialize: WARNING n.k < 0 -- this may not work\n");
    printF(" *****************************************************************************\n\n");
  }
  
  

  
  real & eps1 = dbase.get<real>("eps1");
  real & eps2 = dbase.get<real>("eps2");
  real & mu1 = dbase.get<real>("mu1");
  real & mu2 = dbase.get<real>("mu2");
  

  eps1 = dmp1.getEpsInf();
  eps2 = dmp2.getEpsInf();
  mu1=1.;  // do this for now 
  mu2=1.;
  

  printF(" eps1=%g, eps2=%g, [kx,ky,kz]=[%g,%g,%g] \n",eps1,eps2,kx,ky,kz);



  // ----------------------------------------------------
  // ---- DISPERSIVE PLANE WAVE MATERIAL INTERFACE ------
  // ----------------------------------------------------
  // NOTES:
  //    (1) incident wave number is given --> compute s=sr + I*si 
  //    (2) Given s, compute wave number in right state


  LocalReal (&s)[2] = dbase.get<LocalReal[2]>("s");

  real & sr = s[0], &si = s[1];

  real (&kv)[3] = dbase.get<real[3]>("kv");
  real (&kvr)[3] = dbase.get<real[3]>("kvr");
  real (&kvi)[3] = dbase.get<real[3]>("kvi");

  real (&kpvr)[3] = dbase.get<real[3]>("kpvr");
  real (&kpvi)[3] = dbase.get<real[3]>("kpvi");

  real &kxr =kvr[0], &kxi=kvi[0], &kyr=kvr[1], &kyi=kvi[1];          // Incident wave number (complex)
  real &kxpr =kpvr[0], &kxpi=kpvi[0], &kypr=kpvr[1], &kypi=kvi[1];   // 
  
  int & numberOfPolarizationVectors1 = dbase.get<int>("numberOfPolarizationVectors1");
  int & numberOfPolarizationVectors2 = dbase.get<int>("numberOfPolarizationVectors2");

  real (&chi1r)[10] = dbase.get<real[10]>("chi1r");
  real (&chi1i)[10] = dbase.get<real[10]>("chi1i");

  real (&chi2r)[10] = dbase.get<real[10]>("chi2r");
  real (&chi2i)[10] = dbase.get<real[10]>("chi2i");



  // real chi1r[10],chi1i[10];
  // real chi2r[10],chi2i[10];

  real & chiSum1r = dbase.get<real>("chiSum1r");
  real & chiSum1i = dbase.get<real>("chiSum1i");
  
  real & chiSum2r = dbase.get<real>("chiSum2r");
  real & chiSum2i = dbase.get<real>("chiSum2i");
  

  chiSum1r=0.; chiSum1i=0;
  chiSum2r=0.; chiSum2i=0;
 
   
  const int gridLeft = 0;
  const int gridRight=cg.numberOfComponentGrids()-1;

  real c1=1./sqrt(eps1*mu1);  // incident 
  real c2=1./sqrt(eps2*mu2);  // transmitted

  int domain=0;
  numberOfPolarizationVectors1=dmp1.numberOfPolarizationVectors;
  assert( numberOfPolarizationVectors1<10 );

  kxr=twoPi*kx; kxi=0.; kyr=twoPi*ky; kyi=0.;  // Incident wave number (complex)

  kv[0]=twoPi*kx; kv[1]=twoPi*ky; kv[2]=twoPi*kz;  // is this needed?
  

  const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz );   
  dmp1.evaluateDispersionRelation( c1,kk, sr, si, chi1r,chi1i,chiSum1r,chiSum1i ); 
  // si = -si; // reverse the direction NO -- changes chi1 !

         
  // -- -right domain --
  domain=1;
  numberOfPolarizationVectors2=dmp2.numberOfPolarizationVectors;
  assert( numberOfPolarizationVectors2<10 );
   
  real kr,ki;
  dmp2.evaluateComplexWaveNumber( c2,sr,si, kr,ki, chi2r,chi2i,chiSum2r,chiSum2i );
  //  kxp^2 + kyp^2 = (kr+I*ki)^2 = (kr^2-ki^2) + 2*I*kr*ki 
  // kxp = kxpr + I*kpri = sqrt( (kr+I*ki)^2 - kyp^2 )
  getTransmisionWaveNumber( kr,ki, kxr,kxi, kyr,kyi, kxpr,kxpi, kypr,kypi );
  // // do this for now -- assume normal incidence
  // assert( ky==0. );
  // kxpr=kr; kxpi=ki;
  // kypr=0.; kypi=0.;
   

  real & eps1Hatr = dbase.get<real>("eps1Hatr");
  real & eps1Hati = dbase.get<real>("eps1Hati");
  
  real & eps2Hatr = dbase.get<real>("eps2Hatr");
  real & eps2Hati = dbase.get<real>("eps2Hati");

  eps1Hatr = eps1*(1.+chiSum1r); eps1Hati=eps1*(chiSum1i);
  eps2Hatr = eps2*(1.+chiSum2r); eps2Hati=eps2*(chiSum2i);

  if( true )
  {
    printF(" s=(%16.10e,%16.10e) kx=(%16.10e,%16.10e) ky=(%16.10e,%16.10e) \n"
           "   -> k2=(kr,ki)=(%16.10e,%16.10e) \n"
           " Right: kxp=(%16.10e,%16.10e) kyp=(%16.10e,%16.10e)\n"
           ,sr,si,kxr,kxi,kyr,kyi,kr,ki,kxpr,kxpi,kypr,kypi);
    for( int i=0; i<numberOfPolarizationVectors1; i++ )
      printF("    chi1=(%16.10e,%16.10e) \n",chi1r[i],chi1i[i]);
    for( int i=0; i<numberOfPolarizationVectors2; i++ )
      printF("    chi2=(%16.10e,%16.10e) \n",chi2r[0],chi2i[0]);
      
  }
    
  if( cg.numberOfDimensions()==2 )
  {
    // 2D -- 
    //    sr,si : s= sr + I*si 
    //    kxr,kxi,  kyr,kyi,     : complex wave number on left
    //    kxpr,kxpi,  kypr,kypi, : complex wave number on right (plus)


    
    real x=.5, y=.5;
    real t=0.;

    #Include "dispersivePlaneWaveInterface.h"

    printF("chiSum1=(%9.3e,%9.3e) chiSum2=(%9.3e,%9.3e) r=(%8.2e,%8.2e) "
           "tau=(%8.2e,%8.2e) khy=(%8.2e,%8.2e) khpy=(%8.2e,%8.2e): ",
           chiSum1r,chiSum1i,chiSum2r,chiSum2i,rr,ri,taur,taui,khyr,khyi,khypr,khypi);


    checkPlaneMaterialInterfaceJumps( 
      c1,c2,eps1,eps2,mu1,mu2, sr,si, rr,ri, taur,taui, 
      eps1Hatr,eps1Hati, eps2Hatr,eps2Hati,
      chiSum1r,chiSum1i,chiSum2r,chiSum2i,
      kxr,kxi, kyr,kyi, kxpr,kxpi, kypr,kypi );
            
    // OV_ABORT("stop here for now");
            
  }

  
  if( cg.numberOfDimensions()==3 )
  {
// -- 3D
//    s=sr + I*si : complex frequency
//    [ax,ay,az] = amplitude vector of incident wave, ax=axr+I*axi etc.
//    [arx,ary,arz] = amplitude vector of reflected wave, arx=arxr+I*arxi etc.
//    [atx,aty,atz] = amplitude vector of transmitted wave, atx=atxr+I*atxi etc.
//    [kx,ky,kz] = incident wave vector, kx=kxr+I*kxi etc. 
//    [krx,kry,krz] = reflected wave vector, krx=krxr+I*krxi etc. 
//    [ktx,kty,ktz] = reflected wave vector, ktx=ktxr+I*ktxi etc. 


    // real kv[3]={twoPi*kx,twoPi*ky,twoPi*kz}; // 
         
    real (&arr)[3] = dbase.get<real[3]>("arr");
    real (&ari)[3] = dbase.get<real[3]>("ari");
    real (&atr)[3] = dbase.get<real[3]>("atr");
    real (&ati)[3] = dbase.get<real[3]>("ati");

    real (&krr)[3] = dbase.get<real[3]>("krr");
    real (&kri)[3] = dbase.get<real[3]>("kri");
    real (&ktr)[3] = dbase.get<real[3]>("ktr");
    real (&kti)[3] = dbase.get<real[3]>("kti");

    printF("chiSum1=(%9.3e,%9.3e) chiSum2=(%9.3e,%9.3e)\n",
           chiSum1r,chiSum1i,chiSum2r,chiSum2i);

    evalMaterialInterfaceSolution3d( sr,si, chiSum1r, chiSum1i, chiSum2r, chiSum2i,
                                     av[0],nv[0],kv[0], eps1,eps2,mu1,mu2, 
                                     krr[0],kri[0], ktr[0],kti[0], arr[0],ari[0], atr[0],ati[0] );
    
     if( true )
     {
       printF(" INIT:\n");
       printF(" kr =(%7.3f + %7.3f I,%7.3f + %7.3f I,%7.3f + %7.3f I) \n",krr[0],kri[0],krr[1],kri[1],krr[2],kri[2]);
       printF(" kt =(%7.3f + %7.3f I,%7.3f + %7.3f I,%7.3f + %7.3f I) \n",ktr[0],kti[0],ktr[1],kti[1],ktr[2],kti[2]);

       printF(" ar =(%7.3f + %7.3f I,%7.3f + %7.3f I,%7.3f + %7.3f I) \n",arr[0],ari[0],arr[1],ari[1],arr[2],ari[2]);
       printF(" at =(%7.3f + %7.3f I,%7.3f + %7.3f I,%7.3f + %7.3f I) \n",atr[0],ati[0],atr[1],ati[1],atr[2],ati[2]);

     }

  }
  
  printF("\n ------------------- PlaneInterfaceExactSolution:: END initialize ------------------------\n\n");

  check();
  

  return 0;
}






// ===================================================================================
/// \brief Evaluate the frequency space solution (complex valued) at a single point.
/// \param x[3] (input): point to evaluate the solution
/// 
/// \param E[6] (output):  real and imaginary parts of E : [Exr,Eyr,Ezr,Exi,Eyi,Ezi]
/// \param H[6] (output):  optionally compute real and imaginary parts of H : [Hxr,Hyr,Hzr,Hxi,Hyi,Hzi]
///
/// \note: This may not be so efficient.
// ===================================================================================
int PlaneInterfaceExactSolution::
eval( real xv[3], real *Ev, real *Hv /*= NULL */  )
{
  const int & numberOfDimensions = dbase.get<int>("numberOfDimensions");

  bool computeMagneticField = Hv != NULL;
  // printF("PIES:eval: computeMagneticField=%i, numberOfDimensions=%i\n",(int)computeMagneticField,numberOfDimensions);
  
  // const int numVars = computeMagneticField ? 12 : 6;

  const real & a = dbase.get<real>("amp");

  real (&normalPlaneMaterialInterface)[3] = dbase.get<real[3]>("normalPlaneMaterialInterface");
  real (&x0PlaneMaterialInterface)[3] = dbase.get<real[3]>("x0PlaneMaterialInterface");

  real *nv = normalPlaneMaterialInterface;
  real *x0 = x0PlaneMaterialInterface;

  // Here we assume that the normal points from domain 1 into domain 2
  real nDotX = nv[0]*(xv[0]-x0[0]) + nv[1]*(xv[1]-x0[1]) + nv[2]*(xv[2]-x0[2]);
  
  const int myDomain = nDotX > 0. ? 1 : 0;
  
  LocalReal (&s)[2] = dbase.get<LocalReal[2]>("s");

  real & sr = s[0], &si = s[1];
  real (&av)[3] = dbase.get<real[3]>("av");

  real (&kv)[3] = dbase.get<real[3]>("kv");

  real & eps1 = dbase.get<real>("eps1");
  real & eps2 = dbase.get<real>("eps2");
  real & mu1 = dbase.get<real>("mu1");
  real & mu2 = dbase.get<real>("mu2");

  // -- these are needed to compute P : 
  // int & numberOfPolarizationVectors1 = dbase.get<int>("numberOfPolarizationVectors1");
  // int & numberOfPolarizationVectors2 = dbase.get<int>("numberOfPolarizationVectors2");

  // real (&chi1r)[10] = dbase.get<real[10]>("chi1r");
  // real (&chi1i)[10] = dbase.get<real[10]>("chi1i");

  // real (&chi2r)[10] = dbase.get<real[10]>("chi2r");
  // real (&chi2i)[10] = dbase.get<real[10]>("chi2i");



  real t=0.;
  // const real & a = dbase.get<real>("amp");
  
  real x=xv[0]-x0[0], y=xv[1]-x0[1], z=xv[2]-x0[2]; // *** NOTE: shift point 

  if( numberOfDimensions==2 )
  {

    // -- for 2d eval: 
    real (&kvr)[3] = dbase.get<real[3]>("kvr");
    real (&kvi)[3] = dbase.get<real[3]>("kvi");

    real (&kpvr)[3] = dbase.get<real[3]>("kpvr");
    real (&kpvi)[3] = dbase.get<real[3]>("kpvi");

    real &kxr =kvr[0], &kxi=kvi[0], &kyr=kvr[1], &kyi=kvi[1];   // Incident wave number (complex)
    real &kxpr =kpvr[0], &kxpi=kpvi[0], &kypr=kpvr[1], &kypi=kvi[1];   // 


    // -- un-rotate the point (x,y) to the reference space and evaluate the solution 
    real ct= nv[0], st=nv[1];  // cos(theta), sin(theta)
    // real xa=x-x0[0], ya=y-x0[1];
    real xa=x, ya=y;
    x =  ct*xa + st*ya;
    y = -st*xa + ct*ya;
          

    // Here are the statements to eval the solution: 
#Include "dispersivePlaneWaveInterface.h"

    // ---- rotate the field from the reference space to the rotated space ---
    real Exra, Eyra;
    real Exia, Eyia;
    if( myDomain==0 )
    {
      Exra=Exr, Eyra=Eyr;
      Exia=Exi, Eyia=Eyi;
    }
    else
    {
      Exra=Expr, Eyra=Eypr;
      Exia=Expi, Eyia=Eypi;
    }
    Exr =  ct*Exra - st*Eyra;
    Eyr =  st*Exra + ct*Eyra;
          
    Exi =  ct*Exia - st*Eyia;
    Eyi =  st*Exia + ct*Eyia;
  
    Ev[0]=Exr; Ev[1]=Eyr; Ev[2]=0.;
    Ev[3]=Exi; Ev[4]=Eyi; Ev[5]=0.;
    
    if( computeMagneticField )
    {
      for( int i=0; i<6; i++ ){ Hv[i]=0.; }  
      if( myDomain==0 )
      {
        Hv[2]=Hzr;
        Hv[5]=Hzi;
      }
      else
      {
        Hv[2]=Hzpr;
        Hv[5]=Hzpi;
      }
      
    }
    
  }
  else
  {
    // -- for 3d eval: 

    real (&arr)[3] = dbase.get<real[3]>("arr");
    real (&ari)[3] = dbase.get<real[3]>("ari");
    real (&atr)[3] = dbase.get<real[3]>("atr");
    real (&ati)[3] = dbase.get<real[3]>("ati");

    real (&krr)[3] = dbase.get<real[3]>("krr");
    real (&kri)[3] = dbase.get<real[3]>("kri");
    real (&ktr)[3] = dbase.get<real[3]>("ktr");
    real (&kti)[3] = dbase.get<real[3]>("kti");
    const real &ax=av[0], &ay=av[1], &az=av[2]; 

    // These need to be set for the solution evaluation below:
    real axr=ax, axi=0., ayr=ay, ayi=0., azr=az, azi=0.;
    real arxr=arr[0], arxi=ari[0], aryr=arr[1], aryi=ari[1], arzr=arr[2], arzi=ari[2];
    real atxr=atr[0], atxi=ati[0], atyr=atr[1], atyi=ati[1], atzr=atr[2], atzi=ati[2];
          
    // real kxr=twoPi*kx, kxi=0., kyr=twoPi*ky, kyi=0., kzr=twoPi*kz, kzi=0.;
    real kxr=kv[0], kxi=0., kyr=kv[1], kyi=0., kzr=kv[2], kzi=0.;
    real krxr=krr[0], krxi=kri[0], kryr=krr[1], kryi=kri[1], krzr=krr[2], krzi=kri[2];
    real ktxr=ktr[0], ktxi=kti[0], ktyr=ktr[1], ktyi=kti[1], ktzr=ktr[2], ktzi=kti[2];


    

    // Here are the statements to eval the solution: 
    if( true )
    {
      // *** NOTE: Frequency domain: 
      #Include "dispersivePlaneWaveInterfaceFreqE3d.h"
      // #Include "dispersivePlaneWaveInterface3d.h"

      if( myDomain==0 )
      {
        Ev[0]=Exr; Ev[1]=Eyr; Ev[2]=Ezr;
        Ev[3]=Exi; Ev[4]=Eyi; Ev[5]=Ezi;
      }
      else
      {
        Ev[0]=Etxr; Ev[1]=Etyr; Ev[2]=Etzr;
        Ev[3]=Etxi; Ev[4]=Etyi; Ev[5]=Etzi;
      }
    }
    
    if( computeMagneticField )
    {
      // Here is the computation of H 
      // *** NOTE: Frequency domain: 
      #Include "dispersivePlaneWaveInterfaceFreqH3d.h"
      // #Include "dispersivePlaneWaveInterfaceH3d.h"

      // printF(" myDomain=%i: Hz=(%g,%g) Htz=(%g,%g)\n",myDomain,Hzr,Hzi,Htzr,Htzi);
      
      if( myDomain==0 )
      {
        Hv[0]=Hxr; Hv[1]=Hyr; Hv[2]=Hzr;
        Hv[3]=Hxi; Hv[4]=Hyi; Hv[5]=Hzi;
      }
      else
      {
        Hv[0]=Htxr; Hv[1]=Htyr; Hv[2]=Htzr;
        Hv[3]=Htxi; Hv[4]=Htyi; Hv[5]=Htzi;
      }

    }

    
  }
    
  return 0;
}







// ==========================================================================================
/// \brief  Evaluate the solution and save in an array.
///
/// \param numberOfTimeDerivatives (input) : evaluate this many time-derivatives of the solution.
/// \param computeMagneticField (input): if true return the magnetic field in 3D (in 2D the magnetic field is always computed). 
// ==========================================================================================
int PlaneInterfaceExactSolution::
eval(real t, CompositeGrid & cg, int grid, 
     realArray & ua, realArray & pv,
     const Index & I1a, const Index &I2a, const Index &I3a, 
     int numberOfTimeDerivatives /* = 0 */,
     bool computeMagneticField /* = false */ )
{

  // domain number for this grid: 
  const int myDomain = cg.domainNumber(grid);


  if( t <= 0. )
    printF("--PlaneInterfaceExactSolution--  eval on grid=%i, domain=%i, at t=%9.3e\n",grid,myDomain,t);

  MappedGrid & mg = cg[grid];
  const int numberOfDimensions = cg.numberOfDimensions();
  
  
  OV_GET_SERIAL_ARRAY(real,ua,uLocal);

  Index I1=I1a, I2=I2a, I3=I3a;
  bool ok = ParallelUtility::getLocalArrayBounds(ua,uLocal,I1,I2,I3,1);   
  if( !ok ) return 0;  // no points on this processor (NOTE: no communication should be done after this point)

  // -- we optimize for Cartesian grids (we can avoid creating the vertex array)
  const bool isRectangular=mg.isRectangular();
  if( !isRectangular )
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);

  OV_GET_SERIAL_ARRAY_CONDITIONAL(real,mg.center(),xLocal,!isRectangular); // *wdh* added conditional, Nov 21, 2020

  real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
        xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular grids:
#undef XC
#define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

  
  const real & a = dbase.get<real>("amp");

  LocalReal (&s)[2] = dbase.get<LocalReal[2]>("s");

  real & sr = s[0], &si = s[1];
  real (&av)[3] = dbase.get<real[3]>("av");

  real (&kv)[3] = dbase.get<real[3]>("kv");

  real & eps1 = dbase.get<real>("eps1");
  real & eps2 = dbase.get<real>("eps2");
  real & mu1 = dbase.get<real>("mu1");
  real & mu2 = dbase.get<real>("mu2");

  // -- for 2d eval: 

  real (&kvr)[3] = dbase.get<real[3]>("kvr");
  real (&kvi)[3] = dbase.get<real[3]>("kvi");

  real (&kpvr)[3] = dbase.get<real[3]>("kpvr");
  real (&kpvi)[3] = dbase.get<real[3]>("kpvi");

  real &kxr =kvr[0], &kxi=kvi[0], &kyr=kvr[1], &kyi=kvi[1];   // Incident wave number (complex)
  real &kxpr =kpvr[0], &kxpi=kpvi[0], &kypr=kpvr[1], &kypi=kvi[1];   // 


  int & numberOfPolarizationVectors1 = dbase.get<int>("numberOfPolarizationVectors1");
  int & numberOfPolarizationVectors2 = dbase.get<int>("numberOfPolarizationVectors2");

  real (&chi1r)[10] = dbase.get<real[10]>("chi1r");
  real (&chi1i)[10] = dbase.get<real[10]>("chi1i");

  real (&chi2r)[10] = dbase.get<real[10]>("chi2r");
  real (&chi2i)[10] = dbase.get<real[10]>("chi2i");

  // -- for 3d eval: 

  real (&arr)[3] = dbase.get<real[3]>("arr");
  real (&ari)[3] = dbase.get<real[3]>("ari");
  real (&atr)[3] = dbase.get<real[3]>("atr");
  real (&ati)[3] = dbase.get<real[3]>("ati");

  real (&krr)[3] = dbase.get<real[3]>("krr");
  real (&kri)[3] = dbase.get<real[3]>("kri");
  real (&ktr)[3] = dbase.get<real[3]>("ktr");
  real (&kti)[3] = dbase.get<real[3]>("kti");



  real (&normalPlaneMaterialInterface)[3] = dbase.get<real[3]>("normalPlaneMaterialInterface");
  real (&x0PlaneMaterialInterface)[3] = dbase.get<real[3]>("x0PlaneMaterialInterface");

  real *nv = normalPlaneMaterialInterface;
  real *x0 = x0PlaneMaterialInterface;


  // -- Store components here: 
  const int ex=0, ey=1, ez=2;
  const int hx=3, hy=4, hz=numberOfDimensions==2 ? 2 :  5;

  if( computeMagneticField && numberOfDimensions==3 && ua.getLength(3)<6 )
  {
    printF(" PlaneInterfaceExactSolution::ERROR: Not enough spacein ua to hold the H field\n");
    OV_ABORT("error");
  }
  

  // --- Get Arrays for the dispersive model ----

  // realMappedGridFunction & pCur = getDispersionModelMappedGridFunction( grid,current );
  RealArray pLocal;
  if( (myDomain==0 && numberOfPolarizationVectors1>0) ||
      (myDomain==1 && numberOfPolarizationVectors2>0)  )
  {
    OV_GET_SERIAL_ARRAY(real, pv,pLoc);
    pLocal.reference(pLoc);
  }

    
  real x,y,z=0.;
  if( numberOfTimeDerivatives==0 )
  {
    if( numberOfDimensions==2 )
    {
      // ----------- 2D --------------
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0)-x0[0];   // shift point to reference coordinates 
          y= xLocal(i1,i2,i3,1)-x0[1];
        }
        else
        {
          x=XC(iv,0)-x0[0];
          y=XC(iv,1)-x0[1];
        }

        // -- un-rotate the point (x,y) to the reference space and evaluate the solution 
        real ct= nv[0], st=nv[1];  // cos(theta), sin(theta)
        // real xa=x-x0[0], ya=y-x0[1];
        real xa=x, ya=y;
        x =  ct*xa + st*ya;
        y = -st*xa + ct*ya;
          

        // Here are the statements to eval the solution: 
#Include "dispersivePlaneWaveInterface.h"

        // ---- rotate the field from the reference space to the rotated space ---
        real Exra=Exr, Eyra=Eyr;
        Exr =  ct*Exra - st*Eyra;
        Eyr =  st*Exra + ct*Eyra;
          
        real Exia=Exi, Eyia=Eyi;
        Exi =  ct*Exia - st*Eyia;
        Eyi =  st*Exia + ct*Eyia;
          
        real Expra=Expr, Eypra=Eypr;
        Expr =  ct*Expra - st*Eypra;
        Eypr =  st*Expra + ct*Eypra;
          
        real Expia=Expi, Eypia=Eypi;
        Expi =  ct*Expia - st*Eypia;
        Eypi =  st*Expia + ct*Eypia;
          

          
        if( false )
        {
          printF("(i1,i2)=(%3i,%3i): kNorm=%g, kpNorm=%g, kappa=(%g,%g) beta=(%g,%g)\n",
                 i1,i2,kNorm,kpNorm,kappar,kappai,betar,betai);
          printF("    : eps1=%g, eps2=%g, r=(%g,%g) tau=(%g,%g) \n",eps1,eps2,rr,ri,taur,taui);
          // printF("    : chiSum1=(%g,%g) chiSum2=(%g,%g) \n",chiSum1r,chiSum1i,chiSum2r,chiSum2i);
          printF("    : Exr=%g, Eyr=%g, Exi=%g, Eyi=%g Hzr=%g Hzi=%g\n",Exr,Eyr,Exi,Eyi,Hzr,Hzi);
          printF("    : Expr=%g, Eypr=%g, Expi=%g, Eypi=%g Hzpr=%g Hzpi=%g\n",Expr,Eypr,Expi,Eypi,Hzpr,Hzpi);

          OV_ABORT("finish me");
        }
          

        if( myDomain==0 )
        {
          uLocal(i1,i2,i3,ex) = Exr;
          uLocal(i1,i2,i3,ey) = Eyr;
          uLocal(i1,i2,i3,hz) = Hzr;

          for( int iv=0; iv<numberOfPolarizationVectors1; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            pLocal(i1,i2,i3,pc  ) = eps1*( chi1r[iv]*Exr - chi1i[iv]*Exi );
            pLocal(i1,i2,i3,pc+1) = eps1*( chi1r[iv]*Eyr - chi1i[iv]*Eyi );
          }

        }
        else
        {
          uLocal(i1,i2,i3,ex) = Expr;
          uLocal(i1,i2,i3,ey) = Eypr;
          uLocal(i1,i2,i3,hz) = Hzpr;
          for( int iv=0; iv<numberOfPolarizationVectors2; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            pLocal(i1,i2,i3,pc  ) = eps2*( chi2r[iv]*Expr - chi2i[iv]*Expi );
            pLocal(i1,i2,i3,pc+1) = eps2*( chi2r[iv]*Eypr - chi2i[iv]*Eypi );
          }
        }

      }
    }
    else
    {
      // -----------------------------
      // ----------- 3D --------------
      // -----------------------------

      const real &ax=av[0], &ay=av[1], &az=av[2]; 

      // These need to be set for the solution evaluation below:
      real axr=ax, axi=0., ayr=ay, ayi=0., azr=az, azi=0.;
      real arxr=arr[0], arxi=ari[0], aryr=arr[1], aryi=ari[1], arzr=arr[2], arzi=ari[2];
      real atxr=atr[0], atxi=ati[0], atyr=atr[1], atyi=ati[1], atzr=atr[2], atzi=ati[2];
          
      // real kxr=twoPi*kx, kxi=0., kyr=twoPi*ky, kyi=0., kzr=twoPi*kz, kzi=0.;
      real kxr=kv[0], kxi=0., kyr=kv[1], kyi=0., kzr=kv[2], kzi=0.;
      real krxr=krr[0], krxi=kri[0], kryr=krr[1], kryi=kri[1], krzr=krr[2], krzi=kri[2];
      real ktxr=ktr[0], ktxi=kti[0], ktyr=ktr[1], ktyi=kti[1], ktzr=ktr[2], ktzi=kti[2];


      FOR_3D(i1,i2,i3,I1,I2,I3)
      { 
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0)-x0[0];
          y= xLocal(i1,i2,i3,1)-x0[1];
          z= xLocal(i1,i2,i3,2)-x0[2];
        }
        else
        {
          x=XC(iv,0)-x0[0];
          y=XC(iv,1)-x0[1];
          z=XC(iv,2)-x0[2];
        }

        // Here are the statements to eval the time-dependent solution: 
        #Include "dispersivePlaneWaveInterface3d.h"

        if( myDomain==0 )
        {
          uLocal(i1,i2,i3,ex) = Exr;
          uLocal(i1,i2,i3,ey) = Eyr;
          uLocal(i1,i2,i3,ez) = Ezr;

          for( int iv=0; iv<numberOfPolarizationVectors1; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            pLocal(i1,i2,i3,pc  ) = eps1*( chi1r[iv]*Exr - chi1i[iv]*Exi );
            pLocal(i1,i2,i3,pc+1) = eps1*( chi1r[iv]*Eyr - chi1i[iv]*Eyi );
            pLocal(i1,i2,i3,pc+2) = eps1*( chi1r[iv]*Ezr - chi1i[iv]*Ezi );
          }

        }
        else
        {
          uLocal(i1,i2,i3,ex) = Etxr;
          uLocal(i1,i2,i3,ey) = Etyr;
          uLocal(i1,i2,i3,ez) = Etzr;
          for( int iv=0; iv<numberOfPolarizationVectors2; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            pLocal(i1,i2,i3,pc  ) = eps2*( chi2r[iv]*Etxr - chi2i[iv]*Etxi );
            pLocal(i1,i2,i3,pc+1) = eps2*( chi2r[iv]*Etyr - chi2i[iv]*Etyi );
            pLocal(i1,i2,i3,pc+2) = eps2*( chi2r[iv]*Etzr - chi2i[iv]*Etzi );
          }
        }
          

        if( computeMagneticField )
        {
          // Here are the statements to eval the time-dependent solution: 
          #Include "dispersivePlaneWaveInterfaceH3d.h"
          if( myDomain==0 )
          {
            uLocal(i1,i2,i3,hx) = Hxr;
            uLocal(i1,i2,i3,hy) = Hyr;
            uLocal(i1,i2,i3,hz) = Hzr;
          }
          else
          {
            uLocal(i1,i2,i3,hx) = Htxr;
            uLocal(i1,i2,i3,hy) = Htyr;
            uLocal(i1,i2,i3,hz) = Htzr;
          }
        }
        

      } // end FOR
      

        
    }
  }
  else
  {
    OV_ABORT("ERROR: numberOfTimeDerivatives != 0 ");
    
  } // end if number of time derivatives 
    
  

  return 0;

}













// Include complex down here to minimize name conflicts
#include <complex>

typedef ::real LocalReal;
typedef ::real OV_real;



// ===============================================================================
/// \brief Check the solution.
// ===============================================================================
int PlaneInterfaceExactSolution::
PlaneInterfaceExactSolution::check()
{

  // ------------- CHECK THAT THE EQUATIONS ARE SATISFIED AT POINTS INSIDE AND OUTSIDE ------

  printF("------------ PlaneInterfaceExactSolution::check: CHECK THE EQUATIONS ------------\n\n");

  LocalReal maxErr=0.;

  const LocalReal & a = dbase.get<LocalReal>("amp");
  LocalReal (&normalPlaneMaterialInterface)[3] = dbase.get<LocalReal[3]>("normalPlaneMaterialInterface");
  LocalReal (&x0PlaneMaterialInterface)[3] = dbase.get<LocalReal[3]>("x0PlaneMaterialInterface");

  LocalReal *nv = normalPlaneMaterialInterface;
  LocalReal *x0 = x0PlaneMaterialInterface;

  LocalReal (&s)[2] = dbase.get<LocalReal[2]>("s");

  LocalReal & sr = s[0], &si = s[1];
  LocalReal (&av)[3] = dbase.get<LocalReal[3]>("av");

  LocalReal (&kv)[3] = dbase.get<LocalReal[3]>("kv");

  LocalReal & eps1 = dbase.get<LocalReal>("eps1");
  LocalReal & eps2 = dbase.get<LocalReal>("eps2");
  LocalReal & mu1 = dbase.get<LocalReal>("mu1");
  LocalReal & mu2 = dbase.get<LocalReal>("mu2");

  LocalReal & eps1Hatr = dbase.get<LocalReal>("eps1Hatr");
  LocalReal & eps1Hati = dbase.get<LocalReal>("eps1Hati");
  
  LocalReal & eps2Hatr = dbase.get<LocalReal>("eps2Hatr");
  LocalReal & eps2Hati = dbase.get<LocalReal>("eps2Hati");


  std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> ss(sr,si); // s = -i omega
  std::complex<LocalReal>  eps1Hat, mu1Hat, eps2Hat, mu2Hat, beta1, beta2;

  eps1Hat = eps1Hatr + I*eps1Hati;  // complex epsHat
  mu1Hat  = mu1;                     // complex muHat

  eps2Hat = eps2Hatr + I*eps2Hati;  // complex epsHat
  mu2Hat  = mu2;                     // complex muHat

  beta1 = sqrt( -ss*ss*eps1Hat*mu1Hat );
  beta2 = sqrt( -ss*ss*eps2Hat*mu2Hat );


  LocalReal deps1  = 10.*pow(REAL_EPSILON,1./2.);   // delta to compute 1st derivatives by differences 
  LocalReal deps2  = 10.*pow(REAL_EPSILON,1./3.);   // delta compute 2nd derivatives by differences 

  LocalReal xx0,yy0,zz0, x[3], xm[3], xp[3], Ev[6], Hv[6];
  std::complex<LocalReal> E[3],Em[3],Ep[3], Ex[3],Ey[3], Ez[3], Exx[3],Eyy[3], Ezz[3], DeltaE[3];
  std::complex<LocalReal> H[3],Hm[3],Hp[3], Hx[3],Hy[3], Hz[3], Hxx[3],Hyy[3], Hzz[3], DeltaH[3];

  std::complex<LocalReal>  epsHat, muHat, beta;

  for( int ip=0; ip<2; ip++ )
  {
    const LocalReal dist=.2;
    if( ip==0 )
    {  // Domain 1 : left 
      for( int i=0; i<3; i++ ){ x[i]=x0[i] -nv[i]*dist; }; 
       beta=beta1; epsHat=eps1Hat; muHat=mu1Hat; 
    }
    else
    { // Domain 2 : right 
      for( int i=0; i<3; i++ ){ x[i]=x0[i] + nv[i]*dist; }; 
      beta=beta2; epsHat=eps2Hat; muHat=mu2Hat; 
    }
    
    // To do: Make a macro to eval and return complex values 

// ----------------------------------------------------------------
// Macro: Compute 2nd derivatives of E and H by differences 
// ----------------------------------------------------------------
#beginMacro computeSecondDeriv( dx0,dx1,dx2, Exx,Hxx )
    eval( x, Ev,Hv );
    for( int i=0; i<3; i++ ) { E[i]= Ev[i]+I*Ev[i+3]; H[i]= Hv[i]+I*Hv[i+3]; } //

    xm[0]=x[0]-dx0; xm[1]=x[1]-dx1; xm[2]=x[2]-dx2;
    eval( xm, Ev,Hv );
    for( int i=0; i<3; i++ ) { Em[i]=  Ev[i]+I*Ev[i+3]; Hm[i]= Hv[i]+I*Hv[i+3]; } //

    xp[0]=x[0]+dx0; xp[1]=x[1]+dx1; xp[2]=x[2]+dx2;
    eval( xp, Ev,Hv );
    for( int i=0; i<3; i++ ) { Ep[i]=  Ev[i]+I*Ev[i+3]; Hp[i]=  Hv[i]+I*Hv[i+3]; } //
    
    for( int i=0; i<3; i++ ) { Exx[i]=  (Ep[i]-2.*E[i]+Em[i])/(deps2*deps2); Hxx[i]=  (Hp[i]-2.*H[i]+Hm[i])/(deps2*deps2);} // 
#endMacro     

// ----------------------------------------------------------------
// Macro: Compute 1st derivatives of E and H by differences 
// ----------------------------------------------------------------
#beginMacro computeFirstDeriv( dx0,dx1,dx2, Ex,Hx )
    xm[0]=x[0]-dx0; xm[1]=x[1]-dx1; xm[2]=x[2]-dx2;
    eval( xm, Ev,Hv );
    for( int i=0; i<3; i++ ) { Em[i]=  Ev[i]+I*Ev[i+3]; Hm[i]= Hv[i]+I*Hv[i+3]; } //

    xp[0]=x[0]+dx0; xp[1]=x[1]+dx1; xp[2]=x[2]+dx2;
    eval( xp, Ev,Hv );
    for( int i=0; i<3; i++ ) { Ep[i]=  Ev[i]+I*Ev[i+3]; Hp[i]=  Hv[i]+I*Hv[i+3]; } //
    
    for( int i=0; i<3; i++ ) { Ex[i]=  (Ep[i]-Em[i])/(2.*deps1); Hx[i]=  (Hp[i]-Hm[i])/(2.*deps1);} // 
#endMacro     

    
    // macro calls 
    computeSecondDeriv( deps2,0,0, Exx,Hxx );
    computeSecondDeriv( 0,deps2,0, Eyy,Hyy );
    computeSecondDeriv( 0,0,deps2, Ezz,Hzz );
     
    // macro calls
    computeFirstDeriv( deps1,0,0, Ex,Hx );
    computeFirstDeriv( 0,deps1,0, Ey,Hy );
    computeFirstDeriv( 0,0,deps1, Ez,Hz );
     
    
    // Check E wave equation:   
    //     Delta Ev = s^2 epsHat muHat Ev = - m^2 k^2 Ev = - beta^2 Ev 
    for( int i=0; i<3; i++ ) { DeltaE[i]= Exx[i]+Eyy[i]+Ezz[i]; DeltaH[i]= Hxx[i]+Hyy[i]+Hzz[i]; } //

    LocalReal normDeltaE =  max(abs(DeltaE[0]),abs(DeltaE[1]),abs(DeltaE[2]));
    LocalReal errE = max( abs( DeltaE[0] + beta*beta*E[0] ),
                          abs( DeltaE[1] + beta*beta*E[1] ),
                          abs( DeltaE[2] + beta*beta*E[2] ) )/normDeltaE;
    
    maxErr = max(maxErr,errE);

    LocalReal normDeltaH =  max(abs(DeltaH[0]),abs(DeltaH[1]),abs(DeltaH[2]));
    LocalReal errH = max( abs( DeltaH[0] + beta*beta*H[0] ),
                          abs( DeltaH[1] + beta*beta*H[1] ),
                          abs( DeltaH[2] + beta*beta*H[2] ) )/normDeltaH;
    
    maxErr = max(maxErr,errH);


    //  Check E FOS equation:    eps*E_t = curl(H) 
    //  s epsHat E = curl( H )
    std::complex<LocalReal> curlE[3], curlH[3], EtHat[3], HtHat[3];
    LocalReal normCurlH, normCurlE, errEt, errHt;
    curlH[0] = Hy[2] - Hz[1];
    curlH[1] = Hz[0] - Hx[2];
    curlH[2] = Hx[1] - Hy[0];

    normCurlH = max(abs(curlH[0]),abs(curlH[1]),abs(curlH[2])); 
    for( int i=0; i<3; i++ ){ EtHat[i] = ss*epsHat*E[i] - curlH[i]; } // 
    errEt = max( abs(EtHat[0]),abs(EtHat[1]),abs(EtHat[2]) )/normCurlH;

    maxErr = max(maxErr,errEt);


    // Check H FOS equation:
    //     mu*H_t = -curl(E) 
    //  s muHat H = -curl( E )
    curlE[0] = Ey[2] - Ez[1];
    curlE[1] = Ez[0] - Ex[2];
    curlE[2] = Ex[1] - Ey[0];

    normCurlE = max(abs(curlE[0]),abs(curlE[1]),abs(curlE[2])); 
    for( int i=0; i<3; i++ ){ HtHat[i] = ss*muHat*H[i] + curlE[i]; } 
    errHt = max( abs(HtHat[0]),abs(HtHat[1]),abs(HtHat[2]) )/normCurlE;

    maxErr = max(maxErr,errHt);

    // printF("(1) maxErr=%g\n",maxErr);

    printF(" Point: (x,y,z)=(%g,%g,%g) beta%d=(%g,%g) s=(%g,%g) epsHat%d=(%g,%g)\n",
           x[0],x[1],x[2],ip+1,std::real(beta),std::imag(beta),std::real(ss),std::imag(ss),
                          ip+1,std::real(epsHat),std::imag(epsHat));
    printF(" SOS(E):  |Delta(E)|=%9.2e, | Delta(E) + beta^2*E|/|Delta(E)| =%9.2e\n",normDeltaE,errE);
    printF(" SOS(H):  |Delta(H)|=%9.2e, | Delta(H) + beta^2*H|/|Delta(H)| =%9.2e\n",normDeltaH,errH);
    printF(" FOS(E):  |curl(H) |=%9.2e, | s*eps*E - curl(H)  |/|curl(H) | =%9.2e\n",normCurlH,errEt);
    printF(" FOS(H):  |curl(E) |=%9.2e, | s*mu*H + curl(E)   |/|curl(E) | =%9.2e\n",normCurlE,errHt);

    if( false )
    {
      for( int i=0; i<3; i++ )
      {
        printF(" i=%d: s*eps*E = (%g,%g) curl(H)=(%g,%g) \n",i,
               std::real(ss*epsHat*E[i]),std::imag(ss*epsHat*E[i]),
               std::real(curlH[i]),std::imag(curlH[i]));

        printF(" i=%d: DeltaE = (%g,%g) beta^2*E=(%g,%g) \n",i,
               std::real(DeltaE[i]),std::imag(DeltaE[i]),
               std::real(beta*beta*E[i]),std::imag(beta*beta*E[i]));
        printF(" i=%d: DeltaH = (%g,%g) beta^2*H=(%g,%g) \n",i,
               std::real(DeltaH[i]),std::imag(DeltaH[i]),
               std::real(beta*beta*H[i]),std::imag(beta*beta*H[i]));
     
      }
    }
    // eval( xp, Evp,Hvp );

  } // end for ip


  if( true )
  {
    // --- CHECK INTERFACE JUMP CONDITIONS -------------
    // LocalReal theta,phi;
    // std::complex<LocalReal> Er,Etheta,Ephi,Hr,Htheta,Hphi;
    printF("JUMPS: nv=(%g,%g,%g) \n",nv[0],nv[1],nv[2]);
    
    LocalReal dist=1.e-9;

    // Evaluate left side of the interface 
    for( int i=0; i<3; i++ ){ x[i]=x0[i] -nv[i]*dist; }; 
    eval( x, Ev,Hv );
    for( int i=0; i<3; i++ ) { Em[i]=  Ev[i]+I*Ev[i+3]; Hm[i]=  Hv[i]+I*Hv[i+3]; } //

    // Evaluate right side
    for( int i=0; i<3; i++ ){ x[i]=x0[i] + nv[i]*dist; }; 
    eval( x, Ev,Hv );
    for( int i=0; i<3; i++ ) { Ep[i]=  Ev[i]+I*Ev[i+3]; Hp[i]=  Hv[i]+I*Hv[i+3]; } //

    // E = jump in E : [E] 
    for( int i=0; i<3; i++ ) { E[i]= Ep[i]-Em[i];  H[i]= Hp[i]-Hm[i]; } //


    // Compute n X E and n X H 
    std::complex<LocalReal> nCrossE[3], nCrossH[3], nDotE;
    nCrossE[0] = nv[1]*E[2] - nv[2]*E[1];
    nCrossE[1] = nv[2]*E[0] - nv[0]*E[2];
    nCrossE[2] = nv[0]*E[1] - nv[1]*E[0];

    nCrossH[0] = nv[1]*H[2] - nv[2]*H[1];
    nCrossH[1] = nv[2]*H[0] - nv[0]*H[2];
    nCrossH[2] = nv[0]*H[1] - nv[1]*H[0];

    nDotE = nv[0]*E[0] + nv[1]*E[1] + nv[2]*E[2];

    printF("JUMPS: abs([n.E]) = %10.2e\n",abs(nDotE));
    printF("JUMPS: [E] =(%10.2e,%10.2e,%10.2e)+ I*(%10.2e,%10.2e,%10.2e) \n",
           std::real(E[0]),std::real(E[1]),std::real(E[2]), imag(E[0]), imag(E[1]), imag(E[2]) );
    printF("JUMPS: abs([E])     =(%10.2e,%10.2e,%10.2e)  [H]    =(%10.2e,%10.2e,%10.2e) \n",
               abs(E[0]),abs(E[1]),abs(E[2]), abs(H[0]),abs(H[1]),abs(H[2]) );
    printF("JUMPS: abs([n X E]) =(%10.2e,%10.2e,%10.2e) abs([n X H]) =(%10.2e,%10.2e,%10.2e) \n",
           abs(nCrossE[0]),abs(nCrossE[1]),abs(nCrossE[2]), abs(nCrossH[0]),abs(nCrossH[1]),abs(nCrossH[2]) );
    maxErr = max(maxErr,abs(nCrossE[0]),abs(nCrossE[1]),abs(nCrossE[2]));
    maxErr = max(maxErr,abs(nCrossH[0]),abs(nCrossH[1]),abs(nCrossH[2]));



  }
  
  
  
  printF("\n Max-error in tests = %9.2e. TESTS %s.\n",maxErr,(maxErr<1.e-5 ? "PASSED" : "***FAILED***"));
  
  printF("\n------------ FINSHED CHECK EQUATIONS ------------\n\n");


  
  return 0;
}



/* -----
// =======================================================================================
///  \brief Compute some derived quanities 
/// \param beta0v[2], beta1v[2] (output) : phase parameters beta= m*k
// =======================================================================================
int PlaneInterfaceExactSolution::
getDispersiveParameters( LocalReal beta0v[2], LocalReal beta1v[2] )
{


  // const int & numDomains = dbase.get<int>("numDomains");

  // const LocalReal &a =dbase.get<LocalReal>("radius");

  LocalReal (&s)[2] = dbase.get<LocalReal[2]>("s");
  LocalReal (&k)[2] = dbase.get<LocalReal[2]>("k");

  LocalReal (&eps0)[2] = dbase.get<LocalReal[2]>("eps0");
  LocalReal (&eps1)[2] = dbase.get<LocalReal[2]>("eps1");
  LocalReal (&mu0)[2] = dbase.get<LocalReal[2]>("mu0");
  LocalReal (&mu1)[2] = dbase.get<LocalReal[2]>("mu1");
  
  // const LocalReal c1 = 1./sqrt(eps0[0]*mu0[0]);
  // const LocalReal c2 = 1./sqrt(eps1[0]*mu1[0]);
  
  LocalReal sr = s[0], si = s[1]; // -twoPi*kx*c1;
  
  std::complex<LocalReal> ss(sr,si); // s = -i omega
  std::complex<LocalReal> epsHat, epsHat0, epsHat1, muHat, muHat0, muHat1, cHat0, cHat1, eta0, eta1, m0,m1, kx;
  std::complex<LocalReal>  beta, beta0, beta1;
  
  // *** WE COULD RETURN OTHER QUANTITIES TOO 

  kx = k[0] + I*k[1];  // complex k, wave-number

  epsHat0 = eps0[0] + I*eps0[1];  // complex epsHat
  muHat0  = mu0[0]  + I*mu0[1];  // complex muHat
  
  epsHat1 = eps1[0] + I*eps1[1];  // complex epsHat
  muHat1  = mu1[0]  + I*mu1[1];  // complex muHat
  

  cHat0= 1./sqrt(epsHat0*muHat0); 
  m0   = 1./cHat0;              // index of refraction in the outer domain 
  eta0 = sqrt(muHat0/epsHat0);     // impedance
  
  cHat1= 1./sqrt(epsHat1*muHat1); 
  m1   = 1./cHat1;              // index of refraction in the inner domain 
  eta1 = sqrt(muHat1/epsHat1);    // impedance

                                   
  beta0 = m0*kx;   // complex wave number (outer domain) 

  beta0v[0]=std::real(beta0);
  beta0v[1]=std::imag(beta0);

  beta1v[0]=std::real(beta0);
  beta1v[1]=std::imag(beta0);


  return 0;
}
---- */


// =====================================================================================
/// \brief Utility routine to do some complex arithemetic for the dispersive plane
///    wave material interface.
///
///  Compute kxp=(kxpr,kxpi)  given (kr,ki), and kyp=(kypr,kypi)
///  kxp^2 + kyp^2 = (kr+I*ki)^2 = (kr^2-ki^2) + 2*I*kr*ki 
///  kxp = kxpr + I*kpri = sqrt( (kr+I*ki)^2 - kyp^2 )
// =====================================================================================
void PlaneInterfaceExactSolution::
getTransmisionWaveNumber( const LocalReal & kr,  const LocalReal & ki, 
                          const LocalReal & kxr, const LocalReal & kxi, 
                          const LocalReal & kyr, const LocalReal & kyi, 
                          LocalReal & kxpr, LocalReal & kxpi, 
                          LocalReal & kypr, LocalReal & kypi )
{
  // No jump in tangential field: kyp=ky : 
  kypr=kyr;
  kypi=kyi;

  // std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> ky(kyr,kyi);
  std::complex<LocalReal> k(kr,ki);
  std::complex<LocalReal> kxp,kyp(kypr,kypi);

  // cout << "kyp=" << kyp << endl;

  kxp = std::sqrt( k*k - kyp*kyp );

  kxpr= std::real(kxp);
  kxpi= std::imag(kxp);
  
  // printF("--getTransmisionWaveNumber--- kx=(%g,%g) ky=(%g,%g) (kr,ki)=(%g,%g) kxp=(%g,%g) kyp=(%g,%g)\n",
  //            kxr,kxi,kyr,kyi,kr,ki,kxpr,kxpi,kypr,kypi);

}


// ---------------------------------------------------------------------------------------
// Check routine : 
//   Check the jump:
//       eps1Hat*khyat*(1-r) = eps2Hat*kyHatp*tau
// ---------------------------------------------------------------------------------------
void PlaneInterfaceExactSolution::
checkPlaneMaterialInterfaceJumps( 
                          const LocalReal & c1, const LocalReal & c2,
                          const LocalReal & eps1, const LocalReal & eps2,
                          const LocalReal & mu1, const LocalReal & mu2,

                          const LocalReal & sr, const LocalReal & si,
                          const LocalReal & rr, const LocalReal & ri, 
                          const LocalReal & taur, const LocalReal & taui, 

                          const LocalReal & eps1Hatr, const LocalReal & eps1Hati,
                          const LocalReal & eps2Hatr, const LocalReal & eps2Hati,

                          const LocalReal & psiSum1r, const LocalReal & psiSum1i,
                          const LocalReal & psiSum2r, const LocalReal & psiSum2i,
                          const LocalReal & kxr, const LocalReal & kxi,
                          const LocalReal & kyr, const LocalReal & kyi,
                          const LocalReal & kxpr, const LocalReal & kxpi,
                          const LocalReal & kypr, const LocalReal & kypi

                            )
{

  std::complex<LocalReal> I(0.0,1.0); 
  std::complex<LocalReal> psiSum1(psiSum1r,psiSum1i);
  std::complex<LocalReal> psiSum2(psiSum2r,psiSum2i);

  std::complex<LocalReal> eps1Hat(eps1Hatr,eps1Hati);
  std::complex<LocalReal> eps2Hat(eps2Hatr,eps2Hati);
  std::complex<LocalReal> s(sr,si);
  std::complex<LocalReal> kx(kxr,kxi);
  std::complex<LocalReal> ky(kyr,kyi);
  std::complex<LocalReal> kxp(kxpr,kxpi);
  std::complex<LocalReal> kyp(kypr,kypi);
  std::complex<LocalReal> khx,khy, khpx,khpy;
  std::complex<LocalReal> r(rr,ri), tau(taur,taui);
  std::complex<LocalReal> dr1,dr2,jump;
  
  LocalReal kNorm = sqrt(kxr*kxr + kxi*kxi + kyr*kyr + kyi*kyi);
  khx= (kxr + I*kxi)/kNorm;
  khy= (kyr + I*kyi)/kNorm;
  
  LocalReal kpNorm = sqrt(kxpr*kxpr + kxpi*kxpi + kypr*kypr + kypi*kypi);
  khpx=(kxpr + I*kxpi)/kpNorm;
  khpy=(kypr + I*kypi)/kpNorm;
  
  printF("\n\n ** s=(%g,%g) kx=(%g,%g) ky=(%g,%g) c1=%g eps1=%g mu1=%g \n",sr,si,kxr,kxi,kyr,kyi,c1,eps1,mu1);
  
  LocalReal maxErr=0.;

  jump = khx*(1.+r) - tau*khpx;
  printF("khx*(1.+r) - tau*khpx                 =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));
  
  jump =eps1Hat*khy*(1.-r) - eps2Hat*tau*khpy;
  printF(" [epsHat khy(1-r)- epsHat*tau*khy'    =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));
  
  // dispersion relations: 
  dr1 = s*s + c1*c1*(kx*kx  +ky*ky  ) + s*s*psiSum1;
  dr2 = s*s + c2*c2*(kxp*kxp+kyp*kyp) + s*s*psiSum2;

  printF(" dispersion-relation1                 =(%12.4e,%12.4e)\n",std::real(dr1), std::imag(dr1));
  printF(" dispersion-relation2                 =(%12.4e,%12.4e)\n",std::real(dr2), std::imag(dr2));
  maxErr=max(maxErr,abs(dr1));
  maxErr=max(maxErr,abs(dr2));

  jump = (1.-r)*( ky*khy + kx*khx )/mu1 - tau*( kyp*khpy+kxp*khpx )/mu2;
  printF(" (1-r)*( kSq )/mu1 - tau*( kpSq )/mu2'=(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  jump = (1.-r)*( ky*ky + kx*kx )/(kNorm*mu1) - tau*( kyp*kyp+kxp*kxp )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  jump = (1.-r)*( s*s*(1.+psiSum1)/(c1*c1) )/(kNorm*mu1) - tau*( s*s*(1.+psiSum2)/(c2*c2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  jump = (1.-r)*( s*s*(1.+psiSum1)*(mu1*eps1) )/(kNorm*mu1) - tau*( s*s*(1.+psiSum2)*(mu2*eps2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  jump = (1.-r)*( (1.+psiSum1)*(mu1*eps1) )/(kNorm*mu1) - tau*( (1.+psiSum2)*(mu2*eps2) )/(kpNorm*mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  jump = (1.-r)*( (1.+psiSum1)*(mu1*eps1) )*khy/(mu1) - tau*( (1.+psiSum2)*(mu2*eps2) )*khpy/(mu2);
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  jump = (1.-r)*( (1.+psiSum1)*(eps1) )*khy - tau*( (1.+psiSum2)*(eps2) )*khpy;
  printF(" (1-r)*( kSq )/mu1-tau*( kpSq )/mu2'  =(%12.4e,%12.4e)\n",std::real(jump), std::imag(jump));
  maxErr=max(maxErr,abs(jump));

  if( maxErr< REAL_EPSILON*1000. )
  {
    printF("ALL CHECKS PASSED!  maxErr=%9.3e\n",maxErr);
  }
  else
  {
    printF("**ERROR** SOME CHECKS FAILED!  maxErr=%9.3e\n",maxErr);
  }
  

}
