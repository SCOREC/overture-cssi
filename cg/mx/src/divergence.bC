#include "Maxwell.h"
#include "UnstructuredMapping.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "ParallelUtility.h"
#include "DispersiveMaterialParameters.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

extern Maxwell *cgmxPointer;
  
#define getDiv EXTERN_C_NAME(getdiv)

extern "C"
{
  void getDiv(const int&nd,
      const int&n1a,const int&n1b,const int&n2a,const int&n2b,const int&n3a,const int&n3b,
      const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
      const int&nd4a,const int&nd4b,
      const int&mask,const real&rx, 
      const real&u,const real&p, real&v,
      real& divD, real& divB, const real& K0, const int & matMask,
      const int&ipar, const real&rpar, int&ierr );
}

// ===================================================================================================
//  This macro will compute the divergence (or E or H) as well as the max |grad(E)| or |grad(H)|
// Input:
//  ex,ey,ez,E,gradEMax,divEMax : replane "e" by "h" for magnetic field
//  component : save the div here for plotting
// ===================================================================================================
#beginMacro computeDiv(ex,ey,ez,E,gradEMax,divEMax,component)

 if( computeMaxNorms )
 {
   mgop.useConservativeApproximations(false);  // turn off since there are no conservative

   divLocal=0.;

   if( method!=bamx )
   {

     realSerialArray udLocal(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2),E);

     real *udp = udLocal.Array_Descriptor.Array_View_Pointer3;
     const int udDim0=udLocal.getRawDataSize(0);
     const int udDim1=udLocal.getRawDataSize(1);
     const int udDim2=udLocal.getRawDataSize(2);
#undef UD
#define UD(i0,i1,i2,i3) udp[i0+udDim0*(i1+udDim1*(i2+udDim2*(i3)))]

     mgop.derivative(MappedGridOperators::xDerivative,uLocal,udLocal,I1,I2,I3,E);
     //display(div(I1,I2,I3)," compute div: ux","%6.2f ");
     if( mg.numberOfDimensions()==2 )
     {
       FOR_3D(i1,i2,i3,I1,I2,I3)
       {
         if( MASK(i1,i2,i3)>0 )
         { // find max of x-derivatives:
           gradEMax=max(gradEMax,max(fabs(UD(i1,i2,i3,ex)),fabs(UD(i1,i2,i3,ey))));
           DIV(i1,i2,i3)=UD(i1,i2,i3,ex);
         }
       }
     }
     else
     {
       FOR_3D(i1,i2,i3,I1,I2,I3)
       {
         if( MASK(i1,i2,i3)>0 )
         { // find max of x-derivatives:
           gradEMax=max(gradEMax,max(fabs(UD(i1,i2,i3,ex)),fabs(UD(i1,i2,i3,ey)),fabs(UD(i1,i2,i3,ez))));
           DIV(i1,i2,i3)=UD(i1,i2,i3,ex);
         }
       }
     }
   
     mgop.derivative(MappedGridOperators::yDerivative,uLocal, udLocal,I1,I2,I3,E);
     //display(ud(I1,I2,I3)," compute div: uy","%6.2f ");

     if( mg.numberOfDimensions()==2 )
     {
       FOR_3D(i1,i2,i3,I1,I2,I3)
       {
         if( MASK(i1,i2,i3)>0 )
         {  // include max of y-derivatives:
           gradEMax=max(gradEMax,max(fabs(UD(i1,i2,i3,ex)),fabs(UD(i1,i2,i3,ey))));
           DIV(i1,i2,i3)+=UD(i1,i2,i3,ey);
         }
       }
     }
     else
     {
       FOR_3D(i1,i2,i3,I1,I2,I3)
       {
         if( MASK(i1,i2,i3)>0 )
         { // include max of y-derivatives:
           gradEMax=max(gradEMax,max(fabs(UD(i1,i2,i3,ex)),fabs(UD(i1,i2,i3,ey)),fabs(UD(i1,i2,i3,ez))));
           DIV(i1,i2,i3)+=UD(i1,i2,i3,ey);
         }
       }

       mgop.derivative(MappedGridOperators::zDerivative,uLocal,udLocal,I1,I2,I3,E);
       FOR_3(i1,i2,i3,I1,I2,I3)
       { 
         if( MASK(i1,i2,i3)>0 )
         { // include max of z-derivatives:
           gradEMax=max(gradEMax,fabs(UD(i1,i2,i3,ex)),fabs(UD(i1,i2,i3,ey)),fabs(UD(i1,i2,i3,ez)));
           DIV(i1,i2,i3)+=UD(i1,i2,i3,ez);
         }
       }
     }
   }
   else
   {
     // ----- BA - MAXWELL : compute div(D) and div(B) ----
     
     if( false )
     {
       if( ex==0 )
	 printF("compute div(D) for BA Maxwell. t=%9.3e\n",t);
       else
	 printF("compute div(B) for BA Maxwell. t=%9.3e\n",t);
     }

     
     // assert( solveForAllFields==1 );
     
     const int & solveForAllFields = dbase.get<int>("solveForAllFields");
     const int & maxNumberOfPolarizationComponents = parameters.dbase.get<int>("maxNumberOfPolarizationComponents");
     // total number of polarization components per grid 
     const IntegerArray & totalNumberOfPolarizationComponents =
       parameters.dbase.get<IntegerArray>("totalNumberOfPolarizationComponents");
     
     std::vector<DispersiveMaterialParameters> & dmpVector =
              dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

     // w(i1,i2,i3,0:2) holds D or B 
     Range R3=3;
     RealArray w(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2),R3);  

     // -- This next code is also found in getForcing **FIX ME** put somewhere -- 
     if( !dbase.has_key("K0") )
     {
       // -- build the K0(6,6,numberOfMaterialRegions) for TZ forcing 

       RealArray & K0 = dbase.put<RealArray>("K0");
       K0.redim(6,6,numberOfMaterialRegions);

       std::vector<DispersiveMaterialParameters> & dmpVector = 
	 dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

       RealArray K0Temp;
       for( int mr=0; mr<numberOfMaterialRegions; mr++ )
       {
	 DispersiveMaterialParameters & dmp = dmpVector[mr];  
	 dmp.getBianisotropicMaterialMatrix( K0Temp );
	 K0(all,all,mr)=K0Temp;
       }
       if( false )
	 ::display(K0,"compute div(D) and div(B) for BAMX: combined Material matrix K0(*,*,*):","%5.2f ");
    
     }
     RealArray & K0 = dbase.get<RealArray>("K0");

     // ::display(K0,"K0","%5.2f ");

     // ------- Compute D or B --------
     w=0.;
     if( numberOfMaterialRegions==1 )
     {
       const int mr=0;
       // include ghost since we compute derivatives: 
       if( numberOfDimensions==3 || solveForAllFields )
       {
	 for(int m2=0; m2<6; m2++ )
	 {
	   for(int m1=0; m1<3; m1++ )
	   {
	     // W = K0*U 
	     const int m1a=m1+ex;
	     w(D1,D2,D3,m1) += K0(m1a,m2,mr)*uLocal(D1,D2,D3,m2);  
	   }
	 }
       }
       else
       {
	 // TEZ polarization: 
         assert( ex==0 );
	 w(D1,D2,D3,0) += (K0(0,0,mr)*uLocal(D1,D2,D3,0) +
			   K0(0,1,mr)*uLocal(D1,D2,D3,1) +
			   K0(0,5,mr)*uLocal(D1,D2,D3,2));  
	 w(D1,D2,D3,1) += (K0(1,0,mr)*uLocal(D1,D2,D3,0) +
			   K0(1,1,mr)*uLocal(D1,D2,D3,1) +
			   K0(1,5,mr)*uLocal(D1,D2,D3,2));  
       }
       
       if( dispersionModel!=noDispersion )
       {
	 realMappedGridFunction & p = getDispersionModelMappedGridFunction( grid,current );
	 OV_GET_SERIAL_ARRAY(real,p,pLocal);

         // -- add on P or M ----
	 DispersiveMaterialParameters & dmp = dmpVector[mr]; 
	 const IntegerArray & Np = dmp.getBianisotropicNp();  // We could speed this up by creating Npv(k1,k2,mr) 
	 int pc=0;
	 for( int k1=0; k1<6; k1++ )
	 {
	   const int ec=k1, ecw=ec-ex;
	   // vLocal(I1,I2,I3,nPolarization+ec)=0.;
	   for( int k2=0; k2<6; k2++ )
	   {
	     for( int n=0; n<Np(k1,k2); n++ )
	     {
               if( ecw>=0 && ecw<3 )
  	         w(D1,D2,D3,ecw) +=  pLocal(D1,D2,D3,pc);
	       // vLocal(I1,I2,I3,nPolarization+ec) += pLocal(I1,I2,I3,pc);
	       pc+=2;   // we store p and pt so increment by 2
	     }
	   }
	 }
       }
       
     }
     else
     {

       // assert( pBodyMask!=NULL );
       // IntegerArray & matMask = *pBodyMask;

       intCompositeGridFunction & materialMask = parameters.dbase.get<intCompositeGridFunction>("materialMask");
       OV_GET_SERIAL_ARRAY(int,materialMask[grid],matMask);

       // include ghost since we compute derivatives: 
       if( numberOfDimensions==3 || solveForAllFields )
       {
	 FOR_3D(i1,i2,i3,D1,D2,D3)
	 {
	   const int mr = matMask(i1,i2,i3);
	   assert( mr>=0 && mr<numberOfMaterialRegions );  // ** eventually remove this **
	   for(int m2=0; m2<6; m2++ )
	   {
	     for(int m1=0; m1<3; m1++ )
	     {
	       // W = K0*U 
	       const int m1a=m1+ex;
	       w(i1,i2,i3,m1) += K0(m1a,m2,mr)*uLocal(i1,i2,i3,m2); // Optimize this
	     }
	   }
	 }
       }
       else
       {
	 FOR_3D(i1,i2,i3,D1,D2,D3)
	 {
	   const int mr = matMask(i1,i2,i3);
	   assert( mr>=0 && mr<numberOfMaterialRegions );  // ** eventually remove this **
	   // TEZ polarization: 
	   assert( ex==0 );
	   w(i1,i2,i3,0) += (K0(0,0,mr)*uLocal(i1,i2,i3,0) +
			     K0(0,1,mr)*uLocal(i1,i2,i3,1) +
			     K0(0,5,mr)*uLocal(i1,i2,i3,2));  
	   w(i1,i2,i3,1) += (K0(1,0,mr)*uLocal(i1,i2,i3,0) +
			     K0(1,1,mr)*uLocal(i1,i2,i3,1) +
			     K0(1,5,mr)*uLocal(i1,i2,i3,2));  
	 }
       }
       
	 
       if( dispersionModel!=noDispersion )
       {
	 realMappedGridFunction & p = getDispersionModelMappedGridFunction( grid,current );
	 OV_GET_SERIAL_ARRAY(real,p,pLocal);

         // -- add on P or M ----
	 FOR_3D(i1,i2,i3,D1,D2,D3)
	 {
	   const int mr = matMask(i1,i2,i3);
	   assert( mr>=0 && mr<numberOfMaterialRegions );  // ** eventually remove this **
	   DispersiveMaterialParameters & dmp = dmpVector[mr]; 
	   const IntegerArray & Np = dmp.getBianisotropicNp();  // We could speed this up by creating Npv(k1,k2,mr) 
	   int pc=0;
	   for( int k1=0; k1<6; k1++ )
	   {
	     const int ec=k1, ecw=ec-ex;
	     // vLocal(I1,I2,I3,nPolarization+ec)=0.;
	     for( int k2=0; k2<6; k2++ )
	     {
	       for( int n=0; n<Np(k1,k2); n++ )
	       {
		 if( ecw>=0 && ecw<3 )
		   w(i1,i2,i3,ecw) +=  pLocal(i1,i2,i3,pc);
		 // vLocal(I1,I2,I3,nPolarization+ec) += pLocal(I1,I2,I3,pc);
		 pc+=2;   // we store p and pt so increment by 2
	       }
	     }
	   }
	 }
       }
       


     }
     
     realSerialArray ux(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2),R3), &uy=ux, &uz=ux;

     mgop.derivative(MappedGridOperators::xDerivative,w,ux,I1,I2,I3,R3);
     divLocal(I1,I2,I3) = ux(I1,I2,I3,0);
     gradEMax=max(fabs(ux(I1,I2,I3,R3)));
     
     mgop.derivative(MappedGridOperators::yDerivative,w,uy,I1,I2,I3,R3);
     divLocal(I1,I2,I3) += uy(I1,I2,I3,1);
     gradEMax=max( gradEMax, max(fabs(uy(I1,I2,I3,R3))));


     if( numberOfDimensions==3 )
     {
       mgop.derivative(MappedGridOperators::zDerivative,w,uz,I1,I2,I3,R3);
       divLocal(I1,I2,I3) += uz(I1,I2,I3,2);
       gradEMax=max( gradEMax, max(fabs(uz(I1,I2,I3,R3))) );
     }
     
     if( false )
     {
       if( ex==0 )
	 printF(" max(abs(div(D))) = %9.3e\n",max(fabs(divLocal(I1,I2,I3))));
       else
	 printF(" max(abs(div(B))) = %9.3e\n",max(fabs(divLocal(I1,I2,I3))));
     }

   }
   
   if( debug & 8 )
   {
     display(divLocal,sPrintF(" divLocal p=%i, t=%9.3e",myid,t), pDebugFile," %10.2e ");
   }

   
 } // end if compute max norms
 
 if( !computeMaxNorms || useConservativeDivergence )
 {
   // just compute div(E) -- no max norms
   if( useConservativeDivergence )
	mgop.useConservativeApproximations(useConservative);
   else
     mgop.useConservativeApproximations(false); 

   if( (debug & 4) && useConservativeDivergence )
     printF("getMaxDivergence: get conservative divergence t=%9.3e, useConservative=%i\n",t,useConservative);
   mgop.derivative(MappedGridOperators::divergence,uLocal,divLocal,I1,I2,I3,E);
 }

 mgop.useConservativeApproximations(useConservative);  // reset
 
 #If #E eq "E"
 if( useChargeDensity )
 {
   // --- Subtract off rho from div(E) ----

   assert( pDensity!=NULL );
   realMappedGridFunction & rhog = (*pDensity)[grid]; 

   #ifdef USE_PPP
     realSerialArray rhoLocal; getLocalArrayWithGhostBoundaries(rhog,rhoLocal);
   #else
     const realSerialArray & rhoLocal = rhog;
   #endif
   
   real *rhop = rhoLocal.Array_Descriptor.Array_View_Pointer3;
   const int rhoDim0=rhoLocal.getRawDataSize(0);
   const int rhoDim1=rhoLocal.getRawDataSize(1);
   const int rhoDim2=rhoLocal.getRawDataSize(2);
   const int rhod3=rhoDim2*(rhoComponent);
   #define RHO(i0,i1,i2) rhop[i0+rhoDim0*(i1+rhoDim1*(i2+rhod3))]

   FOR_3D(i1,i2,i3,I1,I2,I3)
   {
     if( MASK(i1,i2,i3)>0 )
     {  
        DIV(i1,i2,i3)-=RHO(i1,i2,i3);
     }
     else
     {
       DIV(i1,i2,i3)=0.; 
     }
	
   }
 }
 #End

 if( computeMaxNorms )
 {
   real uMax[3]={0.,0.,0.}; //
   FOR_3D(i1,i2,i3,I1,I2,I3)
   {
     if( MASK(i1,i2,i3)>0 )
     {
       if( fabs(DIV(i1,i2,i3))>divEMax )
       {
         i1Max=i1; i2Max=i2; i3Max=i3; gridMax=grid;
         divEMax=fabs(DIV(i1,i2,i3));
       }
       uMax[0]=max(fabs(U(i1,i2,i3,ex)),uMax[0]);
       uMax[1]=max(fabs(U(i1,i2,i3,ey)),uMax[1]);
       uMax[2]=max(fabs(U(i1,i2,i3,hz)),uMax[2]);  // hz=ez for 3D
     }
     else
     {
       DIV(i1,i2,i3)=0.;
     }
   }

   // *** FIX ME *****
   solutionNorm=-1;
   
   solutionNorm(ex)=max(solutionNorm(ex),uMax[0]);
   solutionNorm(ey)=max(solutionNorm(ey),uMax[1]);
   solutionNorm(hz)=max(solutionNorm(hz),uMax[2]);  // hz=ez for 3D
   
  RealArray & polarizationNorm   =  dbase.get<RealArray>("polarizationNorm");
  if( polarizationNorm.getLength(0)!=cg.numberOfDomains() )
    polarizationNorm.redim(cg.numberOfDomains());
  polarizationNorm=-1;

 }

  if( pdiv!=NULL )
  {
    // save the divergence (for plotting probably)
    OV_GET_SERIAL_ARRAY(real,(*pdiv)[grid],div);
    
    div(I1,I2,I3,component)=divLocal(I1,I2,I3);  // we could avoid storage for div in this case
  }


#endMacro



// ========================================================================================
//  Evaluate the divergence of D and/or B for the BA Maxwell equations
// ========================================================================================
#beginMacro getDivergenceBA()

  cgmxPointer = this; // for getGMDParameters 

  real dx[3];

  const bool isRectangular=mg.isRectangular();
  real *rxptr = uLocal.getDataPointer();  // give a default value if not needed
  if( isRectangular )
    mg.getDeltaX( dx );
  else
  {
    mg.update(MappedGrid::THEinverseVertexDerivative );
    OV_GET_SERIAL_ARRAY(real,mg.inverseVertexDerivative(),rxLocal);
    rxptr = rxLocal.getDataPointer();
  }
  

  int saveDivergence = pdiv !=NULL;  // save the divergence in *pdiv
  int gridType = isRectangular? 0 : 1;
  int ipar[] ={
    saveDivergence,     // =ipar(0)
    method,             // =ipar(1)
    gridType,           // =ipar(2)
    orderOfAccuracyInSpace,    // =ipar(3)
    ex,                 // =ipar(4)
    ey,                 // =ipar(5)
    ez,                 // =ipar(6)
    hx,                 // =ipar(7)
    hy,                 // =ipar(8)
    hz,                 // =ipar(9)
    dispersionModel,    // =ipar(10)
    grid,               // =ipar(11)
    solveForAllFields,  // =ipar(12)
    numberOfMaterialRegions, // = ipar(13)
    debug               // =ipar(14)
  };
  real rpar[11]= {
    dx[0], // =rpar(0)
    dx[1], // =rpar(1)
    dx[2], // =rpar(2)
    mg.gridSpacing(0), // =rpar(3)
    mg.gridSpacing(1), // =rpar(4)
    mg.gridSpacing(2), // =rpar(5)
    t,                 // =rpar(6)
    divDmax,           // =rpar(7) : max(div(D)) returned here 
    gradDmax,          // =rpar(8) : max(grad(D)) returned here 
    divBmax,           // =rpar(9) : max(div(B)) returned here 
    gradBmax           // =rpar(10): max(grad(B)) returned here 
  };
  
  bool outputDiv=false;
  if( outputDiv )
  {
    if( pdiv!=NULL )
    {
      OV_GET_SERIAL_ARRAY(real,(*pdiv)[grid],div);
      Range all;
      ::display(div(all,all,all,component  ),"div(D) (old way)");
      ::display(div(all,all,all,component+1),"div(B) (old way)");
    }
  }


  realSerialArray vLocal(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2),uLocal.dimension(3));
  // realSerialArray divD(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2));
  // realSerialArray divB(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2));

  real *pDivD = vLocal.getDataPointer();  // give default values if not used 
  real *pDivB = vLocal.getDataPointer();
  if( pdiv!=NULL )
  {
    OV_GET_SERIAL_ARRAY(real,(*pdiv)[grid],divLocal);

    pDivD = & (divLocal(divLocal.getBase(0),divLocal.getBase(1),divLocal.getBase(2),component));
    divLocal(all,all,all,component)=0.;
    
    if( solveForAllFields || cg.numberOfDimensions()==3 )
    {
      pDivB = & (divLocal(divLocal.getBase(0),divLocal.getBase(1),divLocal.getBase(2),component+1));
      divLocal(all,all,all,component+1)=0.;
    }
    
  }



  int *pMatMask = maskLocal.getDataPointer();
  if( numberOfMaterialRegions>1 )
  {
    intCompositeGridFunction & materialMask = parameters.dbase.get<intCompositeGridFunction>("materialMask");
    OV_GET_SERIAL_ARRAY(int,materialMask[grid],matMask);
    pMatMask=matMask.getDataPointer();
  }
  
  realMappedGridFunction & p = getDispersionModelMappedGridFunction( grid,current );
  OV_GET_SERIAL_ARRAY(real,p,pLocal);

  // -- This next code is also found in getForcing **FIX ME** put somewhere -- 
  if( !dbase.has_key("K0") )
  {
    // -- build the K0(6,6,numberOfMaterialRegions) for TZ forcing 

    RealArray & K0 = dbase.put<RealArray>("K0");
    K0.redim(6,6,numberOfMaterialRegions);

    std::vector<DispersiveMaterialParameters> & dmpVector = 
      dbase.get<std::vector<DispersiveMaterialParameters> >("materialRegionParameters");

    RealArray K0Temp;
    for( int mr=0; mr<numberOfMaterialRegions; mr++ )
    {
      DispersiveMaterialParameters & dmp = dmpVector[mr];  
      dmp.getBianisotropicMaterialMatrix( K0Temp );
      K0(all,all,mr)=K0Temp;
    }
  }

  RealArray & K0 = dbase.get<RealArray>("K0");  // may have been created with old way call *** FIX ME **

  // divD=0; divB=0;
  int ierr=0;
  if( true )
  {
  
    getDiv(numberOfDimensions,
           I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound(),
           uLocal.getBase(0),uLocal.getBound(0),uLocal.getBase(1),uLocal.getBound(1),
           uLocal.getBase(2),uLocal.getBound(2),uLocal.getBase(3),uLocal.getBound(3),
           *maskLocal.getDataPointer(),*rxptr,
           *uLocal.getDataPointer(), *pLocal.getDataPointer(), *vLocal.getDataPointer(),
           *pDivD, *pDivB, *K0.getDataPointer(), *pMatMask,
           ipar[0],rpar[0],ierr );
    
    // return values 
    divDmax=rpar[7]; gradDmax=rpar[8]; divBmax=rpar[9]; gradBmax=rpar[10];
    
    if( false )
    {
      printF("After getDiv t=%9.3e: divDmax=%9.3e, gradDmax=%8.2e, divBmax=%9.3e, gradBmax=%8.2e (saveDivergence=%i)\n",
    	 t,divDmax,gradDmax,divBmax,gradBmax,(int)saveDivergence);
    }
  }
  else
  {
    // for testing do not compute the divergence 
    divDmax=0.; gradDmax=0.; divBmax=0.; gradBmax=0.;
  }

  if( outputDiv )
  {
    // ::display(divD,"divD (new way)");
    // ::display(divB,"divB (new way)");

    if( pdiv!=NULL )
    {
      OV_GET_SERIAL_ARRAY(real,(*pdiv)[grid],div);
      Range all;
      ::display(div(all,all,all,component  ),"div(D) (new way)");
      ::display(div(all,all,all,component+1),"div(B) (new way)");
    }
  }
      

  divEMax=divDmax;
  gradEMax=gradDmax;
  divHMax=divBmax;
  gradHMax=gradBmax;

#endMacro



void Maxwell::
getMaxDivergence( const int current, real t, realCompositeGridFunction *pdiv /* =NULL */, 
                  int component /* =0 */,
                  realCompositeGridFunction *pDensity /* = NULL */, 
                  int rhoComponent /* =0 */,
                  bool computeMaxNorms /* = true */ )
// ======================================================================================
// Compute the maximum divergence 
// 
//  /pdiv,component (input) : save the divergence in 'component' if this pointer is non-NULL.
//
// /pCharge, rhoComponent (input) : if there is a charge density then supply rho
//   in component "rhoComponent" of the grid function *pDensity
// ======================================================================================
{
  real time0 = getCPU();
  
  if( debug & 8  )
  {
    // This routine is sometimes called more times than necessary:
    //   getAugmentedSolution
    //   printTimeStepInfo
    printF("\n $$$$$$ getMaxDivergence t=%8.2e $$$$$$$$\n\n",t);
  }
  


  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int numberOfDimensions=cg.numberOfDimensions();
  
  Range all;

  if( useChargeDensity && pDensity==NULL )
  {
    // Compute the charge density if it is not supplied
    if( pRho==NULL )
      pRho=new realCompositeGridFunction(cg);

    getChargeDensity(current,t,*pRho );
    pDensity=pRho;
    rhoComponent=0;
  }

  const int & solveForAllFields = dbase.get<int>("solveForAllFields");

  Range C(ex,hz);
  if( method==sosup )
  {
    C = cgfields[0][0].getLength(3);
  }
  
  if( computeMaxNorms )
  {
    solutionNorm.redim(C); 
    solutionNorm=0.;

    divEMax=0.;
    gradEMax=0.;  // holds the max(|ux|,|vy|,|wz|) 

    divHMax=0.;
    gradHMax=0.;
  }
  
  real divDmax=0., gradDmax=0., divBmax=0., gradBmax=0.; // for BA

  int i1Max=0, i2Max=0, i3Max=0, gridMax=0;  // keeps point where max occurs


  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    realMappedGridFunction & u = mgp!=NULL ? fields[current] : getCGField(HField,current)[grid];


    MappedGrid & mg = cg[grid];

    const intArray & mask = mg.mask();
    #ifdef USE_PPP
      intSerialArray  maskLocal; getLocalArrayWithGhostBoundaries(mask,maskLocal);
      realSerialArray uLocal;    getLocalArrayWithGhostBoundaries(u,uLocal);
    #else
      const intSerialArray & maskLocal = mask;
      const realSerialArray & uLocal   = u;
    #endif


    Index D1,D2,D3;
    getIndex(mg.dimension(),D1,D2,D3);
    getIndex(mg.gridIndexRange(),I1,I2,I3);
    // Here is the box where we apply the interior equations when there is a PML
    getBoundsForPML( mg,Iv ); 

    int includeGhost=1;
    bool ok=ParallelUtility::getLocalArrayBounds(u,uLocal,D1,D2,D3,includeGhost);

    includeGhost=0; // do not include ghost
    ok=ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
    if( !ok ) continue;  // no communication allowed after this point

    realSerialArray divLocal(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2));
    
    assert( mgp==NULL || op!=NULL );
    MappedGridOperators & mgop = mgp!=NULL ? *op : (*cgop)[grid];

    int i1,i2,i3;

    const int *maskp = maskLocal.Array_Descriptor.Array_View_Pointer2;
    const int maskDim0=maskLocal.getRawDataSize(0);
    const int maskDim1=maskLocal.getRawDataSize(1);
    const int md1=maskDim0, md2=md1*maskDim1; 
#define MASK(i0,i1,i2) maskp[(i0)+(i1)*md1+(i2)*md2]

    real *divp = divLocal.Array_Descriptor.Array_View_Pointer2;
    const int divDim0=divLocal.getRawDataSize(0);
    const int divDim1=divLocal.getRawDataSize(1);
    const int d1=divDim0, d2=d1*divDim1; 
#define DIV(i0,i1,i2) divp[(i0)+(i1)*d1+(i2)*d2]

    real *up = uLocal.Array_Descriptor.Array_View_Pointer3;
    const int uDim0=uLocal.getRawDataSize(0);
    const int uDim1=uLocal.getRawDataSize(1);
    const int uDim2=uLocal.getRawDataSize(2);
#undef U
#define U(i0,i1,i2,i3) up[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]


    if( method!=bamx )
    {
      if( debug & 8 )
      {
        display(uLocal,sPrintF("getMaxDivergence: grid=%i u p=%i, t=%9.3e",grid,myid,t), pDebugFile," %10.2e ");
      }
      

      if( true ) // **TEMP** turn off for checking timing 
      {
        if( (solveForMagneticField && cg.numberOfDimensions()==3) ||
            method==bamx && ( solveForAllFields==1 || cg.numberOfDimensions()==3 ) )
        {

          Range H(hx,hx+mg.numberOfDimensions()-1);
          computeDiv(hx,hy,hz,H,gradHMax,divHMax,component+1);

          if( computeMaxNorms && debug & 4 )
            fprintf(pDebugFile,"+++ divHMax=%8.2e max at i=(%i,%i,%i) grid=%i \n",divHMax,i1Max,i2Max,i3Max,gridMax);
        }

        Range E(ex,ex+mg.numberOfDimensions()-1);
        computeDiv(ex,ey,ez,E,gradEMax,divEMax,component);
      }
      else
      {
        divEMax=0.; gradEMax=1.;
        divHMax=0.; gradHMax=1.;
        
      }
      

    }
    else
    {
      assert( method==bamx );
      // *new* optimized way *wdh* Jan 29, 2020
      getDivergenceBA();
      
    }
    


    if( computeMaxNorms && debug & 4 )
      fprintf(pDebugFile,"+++ divEMax=%8.2e max at i=(%i,%i,%i) grid=%i \n",divEMax,i1Max,i2Max,i3Max,gridMax);

    // if( false ) // ****
    //   printF("+++ divEMax=%8.2e max at i=(%i,%i,%i) grid=%i \n",divEMax,i1Max,i2Max,i3Max,gridMax);
      

    // Communication_Manager::Sync();
    
  } // end for grid

  if( computeMaxNorms )
  {
    divEMax =ParallelUtility::getMaxValue(divEMax);  // get max over all processors
    gradEMax=ParallelUtility::getMaxValue(gradEMax);  // get max over all processors

    if( solveForMagneticField && cg.numberOfDimensions()==3 )
    {
      divHMax=ParallelUtility::getMaxValue(divHMax);  // get max over all processors
      gradHMax=ParallelUtility::getMaxValue(gradHMax);  // get max over all processors
    }
    
    for( int c=C.getBase(); c<=C.getBound(); c++ )
      solutionNorm(c)=ParallelUtility::getMaxValue(solutionNorm(c)); // get max over all processors
  }
  

  timing(timeForGetDivergence)+=getCPU()-time0;
  

#undef DIV
#undef MASK
#undef U
#undef UD
}




// ===========================================================================
//     Gaussian Charge Pulse
//
//      rho = a*exp( - [beta* | xv - vv*t | ]^p ) )
//
//  DIM : 2,3
//  GRIDTYPE : curvilinear, rectangular
// ===========================================================================
#beginMacro getGaussianPulseChargeDensity(I1,I2,I3,DIM,GRIDTYPE)


FOR_3D(i1,i2,i3,I1,I2,I3)
{
 if( MASK(i1,i2,i3)!=0 )  
 {
   #If #GRIDTYPE eq "curvilinear"
     x0 = X(i1,i2,i3,0)-xp0;
     x1 = X(i1,i2,i3,1)-xp1;
     #If #DIM == "3"
       x2 = X(i1,i2,i3,2)-xp2;
     #End
   #Else
     x0 = xab[0][0]+i1*dx[0] -xp0;
     x1 = xab[0][1]+i2*dx[1] -xp1;
     #If #DIM == "3"
       x2 = xab[0][2]+i3*dx[2] -xp2;
     #End
   #End

   #If #DIM == "2"
     rad = sqrt( SQR( x0-vp0*t ) + SQR( x1-vp1*t ) ); 
   #Else
     rad = sqrt( SQR( x0-vp0*t ) + SQR( x1-vp1*t ) + SQR( x2-vp2*t ) );
   #End

  U(i1,i2,i3,component)=amplitude*exp(- pow(beta*rad,p) );
  
 }
}

#endMacro



void Maxwell::
getChargeDensity( int current, real t, realCompositeGridFunction & ucg, int component /* =0 */ )
// ======================================================================================
// Determine the charge density and save in u(i1,i2,i3,component)
// 
// ======================================================================================
{
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  Range all;
  
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    getChargeDensity( t, ucg[grid], component );
      
  }

}

void Maxwell::
getChargeDensity( real t, realMappedGridFunction & u, int component /* =0 */ )
// ======================================================================================
// Determine the charge density and save in u(i1,i2,i3,component)
// 
// ======================================================================================
{
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];

  MappedGrid & mg = *u.getMappedGrid(); 

  const bool isRectangular = mg.isRectangular();

  const intArray & mask = mg.mask();

  #ifdef USE_PPP
    realSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
    intSerialArray  maskLocal; getLocalArrayWithGhostBoundaries(mask,maskLocal);
  #else
    const realSerialArray & uLocal   = u;
    const intSerialArray & maskLocal = mask;
  #endif


  int extra=orderOfAccuracyInSpace/2;
  getIndex(mg.gridIndexRange(),I1,I2,I3,extra);

  int includeGhost=0; // do not include ghost
  bool ok=ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);  // 

  if( !ok ) return;  // no communication allowed after this point

  if( forcingOption==twilightZoneForcing )
  {
    mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex );
      
    #ifdef USE_PPP
      realSerialArray xLocal; getLocalArrayWithGhostBoundaries(mg.vertex(),xLocal);
    #else
      const realSerialArray & xLocal = mg.vertex(); // fix this 
    #endif

    assert( tz!=NULL );
    OGFunction & e = *tz;
    realSerialArray rho(I1,I2,I3); // ****************

    e.gd( rho,xLocal,mg.numberOfDimensions(),isRectangular,0,0,0,0,I1,I2,I3,rc,t);
    uLocal(I1,I2,I3,component)=rho;
  }
  else 
  {

    real dx[3],xab[2][3];
    if( isRectangular )
      mg.getRectangularGridParameters( dx, xab );
    else
      mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex );

    const int *maskp = maskLocal.Array_Descriptor.Array_View_Pointer2;
    const int maskDim0=maskLocal.getRawDataSize(0);
    const int maskDim1=maskLocal.getRawDataSize(1);
    const int md1=maskDim0, md2=md1*maskDim1; 
#define MASK(i0,i1,i2) maskp[(i0)+(i1)*md1+(i2)*md2]

    real *up = uLocal.Array_Descriptor.Array_View_Pointer3;
    const int uDim0=uLocal.getRawDataSize(0);
    const int uDim1=uLocal.getRawDataSize(1);
    const int uDim2=uLocal.getRawDataSize(2);
#undef U
#define U(i0,i1,i2,i3) up[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]

    #ifdef USE_PPP
      realSerialArray xLocal; if( isRectangular ) getLocalArrayWithGhostBoundaries(mg.center(),xLocal);
    #else
      const realArray & xLocal = isRectangular ? u : mg.center();
    #endif

    real *xp = xLocal.Array_Descriptor.Array_View_Pointer3;
    const int xDim0=xLocal.getRawDataSize(0);
    const int xDim1=xLocal.getRawDataSize(1);
    const int xDim2=xLocal.getRawDataSize(2);
#undef X
#define X(i0,i1,i2,i3) xp[i0+xDim0*(i1+xDim1*(i2+xDim2*(i3)))]

    int i1,i2,i3;

    real x0,x1,x2;
      
    if( forcingOption==gaussianChargeSource )
    {
      //   rho = a*exp( -beta* | xv - vv*t |^2 ) )

      real rad;
      real amplitude,beta,p,xp0,xp1,xp2,vp0,vp1,vp2;
	
      int ngcs=0;  // only assign one source for now

      amplitude=gaussianChargeSourceParameters[ngcs][0];
      beta     =gaussianChargeSourceParameters[ngcs][1];
      p        =gaussianChargeSourceParameters[ngcs][2];
      xp0      =gaussianChargeSourceParameters[ngcs][3];
      xp1      =gaussianChargeSourceParameters[ngcs][4];
      xp2      =gaussianChargeSourceParameters[ngcs][5];
      vp0      =gaussianChargeSourceParameters[ngcs][6];
      vp1      =gaussianChargeSourceParameters[ngcs][7];
      vp2      =gaussianChargeSourceParameters[ngcs][8];
	
      if( mg.numberOfDimensions()==2 && isRectangular )
      {
	getGaussianPulseChargeDensity(I1,I2,I3,2,rectangular);
      }
      else if( mg.numberOfDimensions()==2 && !isRectangular )
      {
	getGaussianPulseChargeDensity(I1,I2,I3,2,curvilinear);
      }
      else if( mg.numberOfDimensions()==3 && isRectangular )
      {
	getGaussianPulseChargeDensity(I1,I2,I3,3,rectangular);
      }
      else if( mg.numberOfDimensions()==3 && !isRectangular )
      {
	getGaussianPulseChargeDensity(I1,I2,I3,3,curvilinear);
      }
      else
      {
	Overture::abort("getChargeDensity:error: This shouldn't happen.");
      }
	
    }
    else
    {
      printF("getChargeDensity:ERROR: unexpected forcingOption=%i\n",forcingOption); 
      Overture::abort("error");
    }
      
  }
}

