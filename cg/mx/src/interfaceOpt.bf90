! *******************************************************************************
!   Interface boundary conditions
! *******************************************************************************

! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
!* #Include "defineDiffNewerOrder2f.h"
!* #Include "defineDiffNewerOrder4f.h"

! These next include file will define the macros that will define the difference approximations (in op/src)
! Defines getDuDx2(u,aj,ff), getDuDxx2(u,aj,ff), getDuDx3(u,aj,ff), ...  etc. 
#Include "derivMacroDefinitions.h"

! Define 
!    defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)
!       defines -> ur2, us2, ux2, uy2, ...            (2D)
!                  ur3, us3, ut3, ux3, uy3, uz3, ...  (3D)
#Include "defineParametricDerivMacros.h"

! defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)
! 2D, order=6, components=1
! defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)

 defineParametricDerivativeMacros(rsxy1,dr1,dx1,3,2,2,4)
 defineParametricDerivativeMacros(rsxy1,dr1,dx1,3,4,2,2)
 defineParametricDerivativeMacros(u1,dr1,dx1,3,2,1,4)
 defineParametricDerivativeMacros(u1,dr1,dx1,3,4,1,2)

 ! We need up to 2 derivatives of u1n to order 2 -- do order 4 for TZ
 defineParametricDerivativeMacros(u1n,dr1,dx1,3,4,1,2)
 defineParametricDerivativeMacros(u1n,dr1,dx1,3,2,1,2)

 ! q1 for nonlinear dispersive MLA
 defineParametricDerivativeMacros(q1,dr1,dx1,3,4,1,2)
 defineParametricDerivativeMacros(q1,dr1,dx1,3,2,1,2)

 ! We need up to 2 derivatives of p1 to order 2-- do order 4 for TZ
 defineParametricDerivativeMacros(p1,dr1,dx1,3,4,1,2)
 defineParametricDerivativeMacros(p1n,dr1,dx1,3,4,1,2)
 defineParametricDerivativeMacros(p1,dr1,dx1,3,2,1,2)
 defineParametricDerivativeMacros(p1n,dr1,dx1,3,2,1,2)

 defineParametricDerivativeMacros(rsxy2,dr2,dx2,3,2,2,4)
 defineParametricDerivativeMacros(rsxy2,dr2,dx2,3,4,2,2)
 defineParametricDerivativeMacros(u2,dr2,dx2,3,2,1,4)
 defineParametricDerivativeMacros(u2,dr2,dx2,3,4,1,2)

 ! We need up to 2 derivatives of u2n to order 2-- do order 4 for TZ
 defineParametricDerivativeMacros(u2n,dr2,dx2,3,4,1,2)
 defineParametricDerivativeMacros(u2n,dr2,dx2,3,2,1,2)

 ! q2 for nonlinear dispersive MLA
 defineParametricDerivativeMacros(q2,dr2,dx2,3,4,1,2)
 defineParametricDerivativeMacros(q2,dr2,dx2,3,2,1,2)

 ! We need up to 2 derivatives of p2 to order 2-- do order 4 for TZ
 defineParametricDerivativeMacros(p2,dr1,dx1,3,4,1,2)
 defineParametricDerivativeMacros(p2n,dr1,dx1,3,4,1,2)
 defineParametricDerivativeMacros(p2,dr1,dx1,3,2,1,2)
 defineParametricDerivativeMacros(p2n,dr1,dx1,3,2,1,2)

! ===========================================================================================
! Macro: Output some debug info for the first few time-steps 
! ===========================================================================================
#beginMacro INFO(string)
if( t.le.3.*dt .and. debug.gt.0 )then
  write(*,'("Interface>>>",string)')
end if
#endMacro


! ******************************************************************************************************************
! ************* These are altered version of those from insImp.h ***************************************************
! ******************************************************************************************************************

! ==========================================================================================
!  Evaluate the Jacobian and its derivatives (parametric and spatial). 
!    rsxy   : jacobian matrix name 
!    aj     : prefix for the name of the resulting jacobian variables, 
!             e.g. ajrx, ajsy, ajrxx, ajsxy, ...
!    MAXDER : number of derivatives to evaluate.  
! ==========================================================================================
#beginMacro opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,MAXDER)

#If $GRIDTYPE eq "curvilinear"
 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
 #peval evalJacobianDerivatives(rsxy,i1,i2,i3,aj,$DIM,$ORDER,MAXDER)

#End

#endMacro 

! ==========================================================================================
!  Evaluate the parametric derivatives of u.
!    u      : evaluate derivatives of this function.
!    uc     : component to evaluate
!    uu     : prefix for the name of the resulting derivatives, e.g. uur, uus, uurr, ...
!    MAXDER : number of derivatives to evaluate.  
! ==========================================================================================
#beginMacro opEvalParametricDerivative(u,i1,i2,i3,uc,uu,MAXDER)
#If $GRIDTYPE eq "curvilinear" 
 #peval evalParametricDerivativesComponents1(u,i1,i2,i3,uc, uu,$DIM,$ORDER,MAXDER)
#Else
 uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
#End
#endMacro


! ==========================================================================================
!  Evaluate a derivative. (assumes parametric derivatives have already been evaluated)
!   DERIV   : name of the derivative. One of 
!                x,y,z,xx,xy,xz,...
!    u      : evaluate derivatives of this function.
!    uc     : component to evaluate
!    uu     : prefix for the name of the resulting derivatives (same name used with opEvalParametricDerivative) 
!    aj     : prefix for the name of the jacobian variables.
!    ud     : derivative is assigned to this variable.
! ==========================================================================================
#beginMacro getOp(DERIV, u,i1,i2,i3,uc,uu,aj,ud )

 #If $GRIDTYPE eq "curvilinear" 
  #peval getDuD ## DERIV ## $DIM(uu,aj,ud)  ! Note: The perl variables are evaluated when the macro is USED. 
 #Else
  #peval ud = u ## DERIV ## $ORDER(i1,i2,i3,uc)
 #End

#endMacro

! ******************************************************************************************************************

! loop over the boundary points
#beginMacro beginLoops(n1a,n1b,n2a,n2b,n3a,n3b,na,nb)
do i3=n3a,n3b
do i2=n2a,n2b
do i1=n1a,n1b
do n=na,nb
  ! write(*,'(" periodic i1,i2,i3,n=",4i4)') i1,i2,i3,n
#endMacro

#beginMacro endLoops()
end do
end do
end do
end do
#endMacro


! loop over the boundary points
#beginMacro beginLoops2d()
 i3=n3a
 j3=m3a

 j2=m2a
 do i2=n2a,n2b
  j1=m1a
  do i1=n1a,n1b
#endMacro
#beginMacro endLoops2d()
   j1=j1+1
  end do
  j2=j2+1
 end do
#endMacro

! loop over the boundary points with a mask. 
! Assign pts where both mask1 and mask2 are discretization pts.
! If mask1>0 and mask2<0 then we just leave the extrapolated values in u1 and u2 .
#beginMacro beginLoopsMask2d()
 i3=n3a
 j3=m3a

 j2=m2a
 do i2=n2a,n2b
  j1=m1a
  do i1=n1a,n1b
   if( mask1(i1,i2,i3).gt.0 .and. mask2(j1,j2,j3).gt.0 )then
#endMacro
#beginMacro endLoopsMask2d()
   end if
   j1=j1+1
  end do
  j2=j2+1
 end do
#endMacro

! loop over the boundary points that includes ghost points in the tangential direction
#beginMacro beginGhostLoops2d()
 i3=n3a
 j3=m3a
 j2=mm2a
 do i2=nn2a,nn2b
  j1=mm1a
  do i1=nn1a,nn1b
#endMacro

! ============================================================================================
! Macro:
!  loop over the boundary points that includes ghost points in the tangential direction.
!  Assign pts where both mask1 and mask2 are discretization OR interpolation pts.
!  If mask1>0 and mask2<0 then we just leave the extrapolated values in u1 and u2 .
! ============================================================================================
#beginMacro beginGhostLoopsMask2d()
 i3=n3a
 j3=m3a
 j2=mm2a
 do i2=nn2a,nn2b
  j1=mm1a
  do i1=nn1a,nn1b
  ! if( mask1(i1,i2,i3).gt.0 .and. mask2(j1,j2,j3).gt.0 )then
  ! *wdh* 2015/08/14 -- project interpolation points too
  if( mask1(i1,i2,i3).ne.0 .and. mask2(j1,j2,j3).ne.0 )then
#endMacro

#beginMacro beginLoops3d()
 j3=m3a
 do i3=n3a,n3b
 j2=m2a
 do i2=n2a,n2b
 j1=m1a
 do i1=n1a,n1b
#endMacro
#beginMacro endLoops3d()
   j1=j1+1
  end do
  j2=j2+1
 end do
  j3=j3+1
 end do
#endMacro

! Assign pts where both mask1 and mask2 are discretization pts.
! If mask1>0 and mask2<0 then we just leave the extrapolated values in u1 and u2 .
#beginMacro beginLoopsMask3d()
 j3=m3a
 do i3=n3a,n3b
 j2=m2a
 do i2=n2a,n2b
 j1=m1a
 do i1=n1a,n1b
 if( mask1(i1,i2,i3).gt.0 .and. mask2(j1,j2,j3).gt.0 )then
#endMacro
#beginMacro endLoopsMask3d()
  end if
   j1=j1+1
  end do
  j2=j2+1
 end do
  j3=j3+1
 end do
#endMacro

#beginMacro beginGhostLoops3d()
 j3=mm3a
 do i3=nn3a,nn3b
 j2=mm2a
 do i2=nn2a,nn2b
  j1=mm1a
  do i1=nn1a,nn1b
#endMacro


! ============================================================================================
! Macro:
!  loop over the boundary points that includes ghost points in the tangential direction.
!  Assign pts where both mask1 and mask2 are discretization OR interpolation pts.
!  If mask1>0 and mask2<0 then we just leave the extrapolated values in u1 and u2 .
! ============================================================================================
#beginMacro beginGhostLoopsMask3d()
 j3=mm3a
 do i3=nn3a,nn3b
 j2=mm2a
 do i2=nn2a,nn2b
  j1=mm1a
  do i1=nn1a,nn1b
  ! if( mask1(i1,i2,i3).gt.0 .and. mask2(j1,j2,j3).gt.0 )then
  ! *wdh* 2015/08/14 -- project interpolation points too
  if( mask1(i1,i2,i3).ne.0 .and. mask2(j1,j2,j3).ne.0 )then
#endMacro

#defineMacro extrap2(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (2.*uu(k1,k2,k3,kc)-uu(k1+ks1,k2+ks2,k3+ks3,kc))

#defineMacro extrap3(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (3.*uu(k1,k2,k3,kc)-3.*uu(k1+ks1,k2+ks2,k3+ks3,kc)\
            +   uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc))

#defineMacro extrap4(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (4.*uu(k1,k2,k3,kc)-6.*uu(k1+ks1,k2+ks2,k3+ks3,kc)\
            +4.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)-uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc))

#defineMacro extrap5(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (5.*uu(k1,k2,k3,kc)-10.*uu(k1+ks1,k2+ks2,k3+ks3,kc)\
            +10.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)-5.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
            +uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc))

! -----------------------------------------------------------------------
! Macro: utility macro to extrapolate 3 field values 
! -----------------------------------------------------------------------
#beginMacro extrapolateFields(ex,ey,ez,u,i1,i2,i3,is1,is2,is3)
  if( orderOfAccuracy.eq.2 )then
     u(i1-is1,i2-is2,i3-is3,ex)=extrap3(u,i1,i2,i3,ex,is1,is2,is3)
     u(i1-is1,i2-is2,i3-is3,ey)=extrap3(u,i1,i2,i3,ey,is1,is2,is3)
     u(i1-is1,i2-is2,i3-is3,ez)=extrap3(u,i1,i2,i3,ez,is1,is2,is3)
  else
     u(i1-is1,i2-is2,i3-is3,ex)=extrap5(u,i1,i2,i3,ex,is1,is2,is3)
     u(i1-is1,i2-is2,i3-is3,ey)=extrap5(u,i1,i2,i3,ey,is1,is2,is3)
     u(i1-is1,i2-is2,i3-is3,ez)=extrap5(u,i1,i2,i3,ez,is1,is2,is3)
  end if
#endMacro

! TEMP: 
#defineMacro u1x22r(i1,i2,i3,cc) (u1(i1+1,i2,i3,cc)-u1(i1-1,i2,i3,cc))/(2.*dx1(0))
#defineMacro u1y22r(i1,i2,i3,cc) (u1(i1,i2+1,i3,cc)-u1(i1,i2-1,i3,cc))/(2.*dx1(1))

#defineMacro u2x22r(i1,i2,i3,cc) (u2(i1+1,i2,i3,cc)-u2(i1-1,i2,i3,cc))/(2.*dx2(0))
#defineMacro u2y22r(i1,i2,i3,cc) (u2(i1,i2+1,i3,cc)-u2(i1,i2-1,i3,cc))/(2.*dx2(1))

! u ## x43r(i1,i2,i3)=(8.*(u(i1+1,i2,i3)-u(i1-1,i2,i3))-(u(i1+2,i2,i3)-u(i1-2,i2,i3)))*dx ## 41(0)
! u ## y43r(i1,i2,i3)=(8.*(u(i1,i2+1,i3)-u(i1,i2-1,i3))-(u(i1,i2+2,i3)-u(i1,i2-2,i3)))*dx ## 41(1)

! Fourth-order first-derivative (Cartesian)
#defineMacro Dx4r(u,dx,i1,i2,i3,cc) (8.*(u(i1+1,i2,i3,cc)-u(i1-1,i2,i3,cc))-(u(i1+2,i2,i3,cc)-u(i1-2,i2,i3,cc)))/(12.*dx(0))
#defineMacro Dy4r(u,dx,i1,i2,i3,cc) (8.*(u(i1,i2+1,i3,cc)-u(i1,i2-1,i3,cc))-(u(i1,i2+2,i3,cc)-u(i1,i2-2,i3,cc)))/(12.*dx(1))

! -------------------------------------------------------------------
! Macro: Fixup the end values of the interface
! DIM (input): number of dimensions (2 or 3)
! GRIDTYPE (input) : curvilinear or rectangular
!
! This routine sets points near the corner (maybe A, B, C for 2D, order=2)
!
!           |    |    |    |
!           G----+----+----+---
!           |    |    |    |
!           A----X----+----+---    X=corner-pt
!           |    |    |    |
!      E----C----B----G----G---    G=Ghost    
!      |    |
!      F----G     
!--------------------------------------------------------------------
#beginMacro fixupInterfaceEndValues(DIM,GRIDTYPE,u,side,axis,axisp1,axisp2,boundaryCondition,gridIndexRange,dx,dr)
 ! **FINISH ME**
 iv(2)=0
 ksv(0)=0
 ksv(1)=0
 ksv(2)=0
 #If #DIM eq "2"

  do sidea=0,1 ! loop over adjacent sides
    if( boundaryCondition(sidea,axisp1).gt.0 )then ! adjacent boundary is a physical BC or farfield BC
     ! Set iv = corner point X
     iv(axis  )=gridIndexRange(side,axis )
     iv(axisp1)=gridIndexRange(sidea,axisp1)
     ksv(axisp1)=1-2*sidea  ! tangential direction to the interface

     ii1=iv(0)
     ii2=iv(1)
     ii3=iv(2)
     ks1=ksv(0)
     ks2=ksv(1)
     ks3=ksv(2)

     if( debug.gt.1 )then
       write(debugFile,'("Interface:fixupEnds u: side,axis=",2i3," axisp1,sidea=",2i3)') side,axis,axisp1,sidea
       write(debugFile,'("... iv=",3i3," ksv=",3i2," ghost=",3i4)') ii1,ii2,ii3,ks1,ks2,ks3,ii1-ks1,ii2-ks2,ii3-ks3
     end if

     ! extrapolate value on extended boundary, point A or B, from points along the interface
     ! extrapolateFields(ex,ey,hz,u,ii1,ii2,ii3,ks1,ks2,ks3)

     ! -------------------------------------------------------
     ! -------------------- set div(E)=0 ---------------------
     ! -------------------------------------------------------
     #If #GRIDTYPE eq "rectangular"
      if( axis.eq.0 )then
        ! set point B on extended material interface boundary
        if( orderOfAccuracy.eq.2 )then
          u(ii1-ks1,ii2-ks2,ii3,ey)=u(ii1+ks1,ii2+ks2,ii3,ey) \
                   + 2.*ksv(axisp1)*dx(axisp1)*u ## x22r(ii1,ii2,ii3,ex)
        else if( orderOfAccuracy.eq.4 )then
          ! Set first ghost value from div(E)=0
          ! from abc.bf line 1684: 
          u(ii1,ii2-ks2,ii3,ey)=(-u(ii1,ii2+2*ks2,ii3,ey)+8.*u(ii1,ii2+ks2,ii3,ey)+u(ii1,ii2-2*ks2,ii3,ey))/8. \
                                                     + 1.5*ks2*dx(axis)*Dx4r(u,dx,ii1,ii2,ii3,ex) 
        end if

      else
        ! set point A on extended material interface boundary
        if( orderOfAccuracy.eq.2 )then
          u(ii1-ks1,ii2-ks2,ii3,ex)=u(ii1+ks1,ii2+ks2,ii3,ex) \
                          + 2.*ksv(axisp1)*dx(axisp1)*u ## y22r(ii1,ii2,ii3,ey)
        else if( orderOfAccuracy.eq.4 )then
          ! Set first ghost value from div(E)=0
          ! from abc.bf line 1684: 
          u(ii1-ks1,ii2,ii3,ex)=(-u(ii1+2*ks1,ii2,ii3,ex)+8.*u(ii1+ks1,ii2,ii3,ex)+u(ii1-2*ks1,ii2,ii3,ex))/8. \
                                  + 1.5*ks1*dx(axis)*Dy4r(u,dx,ii1,ii2,ii3,ey)
        else 
          stop 4432
        end if
         
      end if
     #End
     #If #GRIDTYPE eq "curvilinear"
      ! **FINISH ME**
      dx(0)=dr(0)
      dx(1)=dr(1)
      if( axis.eq.0 )then
        ! set point B on extended material interface boundary
        if( orderOfAccuracy.eq.2 )then
          u(ii1-ks1,ii2-ks2,ii3,ey)=u(ii1+ks1,ii2+ks2,ii3,ey) \
                   + 2.*ksv(axisp1)*dx(axisp1)*u ## x22r(ii1,ii2,ii3,ex)
        else if( orderOfAccuracy.eq.4 )then
          ! Set first ghost value from div(E)=0
          ! from abc.bf line 1684: 
          u(ii1,ii2-ks2,ii3,ey)=(-u(ii1,ii2+2*ks2,ii3,ey)+8.*u(ii1,ii2+ks2,ii3,ey)+u(ii1,ii2-2*ks2,ii3,ey))/8. \
                                                     + 1.5*ks2*dx(axis)*Dx4r(u,dx,ii1,ii2,ii3,ex) 
        end if

      else
        ! set point A on extended material interface boundary
        if( orderOfAccuracy.eq.2 )then
          u(ii1-ks1,ii2-ks2,ii3,ex)=u(ii1+ks1,ii2+ks2,ii3,ex) \
                          + 2.*ksv(axisp1)*dx(axisp1)*u ## y22r(ii1,ii2,ii3,ey)
        else if( orderOfAccuracy.eq.4 )then
          ! Set first ghost value from div(E)=0
          ! from abc.bf line 1684: 
          u(ii1-ks1,ii2,ii3,ex)=(-u(ii1+2*ks1,ii2,ii3,ex)+8.*u(ii1+ks1,ii2,ii3,ex)+u(ii1-2*ks1,ii2,ii3,ex))/8. \
                                  + 1.5*ks1*dx(axis)*Dy4r(u,dx,ii1,ii2,ii3,ey)
        else 
          stop 4432
        end if
         
      end if
     #End

     ! extrapolate corner point C along the diagonal
     ksv(axis)=1-2*side
     extrapolateFields(ex,ey,hz,u,ii1,ii2,ii3,ksv(0),ksv(1),ksv(2))
     if( orderOfAccuracy.eq.4 )then
       ! extrapolate extra corner points E-F-G
       extrapolateFields(ex,ey,hz,u,ii1-ksv(0),ii2       ,ii3,ksv(0),ksv(1),ksv(2))
       extrapolateFields(ex,ey,hz,u,ii1       ,ii2-ksv(1),ii3,ksv(0),ksv(1),ksv(2))
       extrapolateFields(ex,ey,hz,u,ii1-ksv(0),ii2-ksv(1),ii3,ksv(0),ksv(1),ksv(2))
     end if

     if( debug.gt.1 )then
       if( orderOfAccuracy.eq.2 )then
         dive=u ## x22r(ii1,ii2,ii3,ex) + u ## y22r(ii1,ii2,ii3,ey)
       else
         dive=Dx4r(u,dx,ii1,ii2,ii3,ex) + Dy4r(u,dx,ii1,ii2,ii3,ey)
       end if
       write(debugFile,'("... after: div(E)=",e10.2)') dive
     end if

     ksv(axisp1)=0 ! reset
     ksv(axis)=0 ! reset
    end if
  end do ! end sidea

 #Else
   stop 1777
 #End
#endMacro


! ********************************************************************************
!       INTERFACE MACROS (used in interfaceOpt.bf90 and interface3dOrder4.bf)
! ********************************************************************************
#Include "interfaceMacros.h"


! ********************************************************************************
!     Usage: setJacobianRS( aj1, r, s)
!            setJacobianRS( aj1, s, r)
! ********************************************************************************
#beginMacro setJacobianRS(aj, R, S)
 rx   =aj ## R ## x
 ry   =aj ## R ## y
                    
 rxx  =aj ## R ## xx  
 rxy  =aj ## R ## xy  
 ryy  =aj ## R ## yy  
                    
 rxxx =aj ## R ## xxx 
 rxxy =aj ## R ## xxy 
 rxyy =aj ## R ## xyy 
 ryyy =aj ## R ## yyy 
                    
 rxxxx=aj ## R ## xxxx
 rxxyy=aj ## R ## xxyy
 ryyyy=aj ## R ## yyyy

 sx   =aj ## S ## x   
 sy   =aj ## S ## y   
                    
 sxx  =aj ## S ## xx  
 sxy  =aj ## S ## xy  
 syy  =aj ## S ## yy  
                    
 sxxx =aj ## S ## xxx 
 sxxy =aj ## S ## xxy 
 sxyy =aj ## S ## xyy 
 syyy =aj ## S ## yyy 
                    
 sxxxx=aj ## S ## xxxx
 sxxyy=aj ## S ## xxyy
 syyyy=aj ## S ## yyyy

#endMacro

! ***************************************************************************
! This macro will set the temp variables rx, rxx, ry, ryx, ...
! If axis=0 then
!   rx = ajrx
!   sx = ajsx
!    ...
!  else if axis=1
!    -- permute r <-> s 
!   rx = ajsx
!   sx = ajrx
!    ...
! ***************************************************************************
#beginMacro setJacobian(aj, axis)
if( axis.eq.0 )then
 setJacobianRS( aj, r, s)
else
 setJacobianRS( aj, s, r)
end if

#endMacro

! ===================================================================================
!  Optimized periodic update: (only applied in serial)
!     update the periodic ghost points used by an interface on the grid face (side,axis)
! ===================================================================================
#beginMacro periodicUpdate2d(u,bc,gid,side,axis)
if( parallel.eq.0 )then
 axisp1=mod(axis+1,nd)
 if( bc(0,axisp1).lt.0 )then
  ! direction axisp1 is periodic
  diff(axis)=0
  diff(axisp1)=gid(1,axisp1)-gid(0,axisp1)

  if( side.eq.0 )then
    ! assign 4 ghost points outside lower corner
    np1a=gid(0,0)-2
    np1b=gid(0,0)-1
    np2a=gid(0,1)-2
    np2b=gid(0,1)-1

    beginLoops(np1a,np1b,np2a,np2b,n3a,n3b,ex,hz)
     u(i1,i2,i3,n) = u(i1+diff(0),i2+diff(1),i3,n)
    endLoops()

    ! assign 4 ghost points outside upper corner
    if( axis.eq.0 )then
      np2a=gid(1,axisp1)+1
      np2b=gid(1,axisp1)+2
    else
      np1a=gid(1,axisp1)+1
      np1b=gid(1,axisp1)+2
    end if

    beginLoops(np1a,np1b,np2a,np2b,n3a,n3b,ex,hz)
     u(i1,i2,i3,n) = u(i1-diff(0),i2-diff(1),i3,n)
    endLoops()

  else

    ! assign 4 ghost points outside upper corner
    np1a=gid(1,0)+1
    np1b=gid(1,0)+2
    np2a=gid(1,1)+1
    np2b=gid(1,1)+2

    beginLoops(np1a,np1b,np2a,np2b,n3a,n3b,ex,hz)
     u(i1,i2,i3,n) = u(i1-diff(0),i2-diff(1),i3,n)
    endLoops()

    if( axis.eq.0 )then
      np2a=gid(0,axisp1)-2
      np2b=gid(0,axisp1)-1
    else
      np1a=gid(0,axisp1)-2
      np1b=gid(0,axisp1)-1
    end if

    beginLoops(np1a,np1b,np2a,np2b,n3a,n3b,ex,hz)
     u(i1,i2,i3,n) = u(i1+diff(0),i2+diff(1),i3,n)
    endLoops()
  end if

 endif
end if

#endMacro

! ===================================================================================
!  Optimized periodic update:
!     update the periodic ghost points used by an interface on the grid face (side,axis)
! ===================================================================================
#beginMacro periodicUpdate3d(u,bc,gid,side,axis)
if( parallel.eq.0 )then
 axisp1=mod(axis+1,nd)
 axisp2=mod(axis+2,nd)
 if( bc(0,axisp1).lt.0 .or. bc(0,axisp2).lt.0 )then
  ! We assume this is done by the calling program
  ! write(*,'("periodicUpdate3d: finish me")')
  ! stop 
 end if
end if
#endMacro


! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#beginMacro getOp2d2r(DERIV, u,i1,i2,i3,uc,uu,aj,ud )

 #If $GRIDTYPE eq "curvilinear" 
  #peval getDuD ## DERIV ## 2(uu,aj,ud)  ! Note: The perl variables are evaluated when the macro is USED. 
 #Else
  #peval ud = u ## DERIV ## 2(i1,i2,i3,uc)
 #End

#endMacro

! ******************************************************************************
!   This next macro is called by other macros to evaluate the first and second derivatives
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalSecondDerivs2d2r(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,uu)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu1,2)    ! computes uu1r, uu1s 
 getOp2d2r(x ,u1,i1,i2,i3,ex,uu1,aj1,uu ## x)            ! u1.x
 getOp2d2r(y ,u1,i1,i2,i3,ex,uu1,aj1,uu ## y)            ! u1.y
 getOp2d2r(xx,u1,i1,i2,i3,ex,uu1,aj1,uu ## xx)
 getOp2d2r(yy,u1,i1,i2,i3,ex,uu1,aj1,uu ## yy)
 uu ## Lap = uu ## xx+ uu ## yy
#endMacro 


! *********************************************************************************
!   Evaluate derivatives for the 2nd-order 2D interface equations
! *********************************************************************************
#beginMacro evalInterfaceDerivatives2d2r()
 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,1)
 evalSecondDerivs2d2r(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,u1)
 evalSecondDerivs2d2r(rsxy1,aj1,u1,i1,i2,i3,ey,vv1,v1)

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,1)
 evalSecondDerivs2d2r(rsxy2,aj2,u2,j1,j2,j3,ex,uu2,u2)
 evalSecondDerivs2d2r(rsxy2,aj2,u2,j1,j2,j3,ey,vv2,v2)
#endMacro


! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$





! ******************************************************************************
!   This next macro is called by other macros to evaluate the first and second derivatives
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,uu)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu1,2)    ! computes uu1r, uu1s 
 getOp(x ,u1,i1,i2,i3,ex,uu1,aj1,uu ## x)            ! u1.x
 getOp(y ,u1,i1,i2,i3,ex,uu1,aj1,uu ## y)            ! u1.y
 getOp(xx,u1,i1,i2,i3,ex,uu1,aj1,uu ## xx)
 getOp(yy,u1,i1,i2,i3,ex,uu1,aj1,uu ## yy)
 uu ## Lap = uu ## xx+ uu ## yy
#endMacro 


! *********************************************************************************
!   Evaluate derivatives for the 2nd-order 2D interface equations
! *********************************************************************************
#beginMacro evalInterfaceDerivatives2d()
 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,1)
 evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,u1)
 evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,ey,vv1,v1)

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,1)
 evalSecondDerivs(rsxy2,aj2,u2,j1,j2,j3,ex,uu2,u2)
 evalSecondDerivs(rsxy2,aj2,u2,j1,j2,j3,ey,vv2,v2)
#endMacro

! ******************************************************************************
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalMagneticFieldInterfaceDerivatives2d()
 evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,hz,ww1,w1)
 evalSecondDerivs(rsxy2,aj2,u2,j1,j2,j3,hz,ww2,w2)
#endMacro


! ******************************************************************************
!   This next macro is called by evalDerivs2dOrder4
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalFourthDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,uu)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu1,4)    ! computes uu1r, uu1s 
 getOp(xxx ,u1,i1,i2,i3,ex,uu1,aj1,uu ## xxx)       ! u1.xxx
 getOp(xxy ,u1,i1,i2,i3,ex,uu1,aj1,uu ## xxy)       ! u1.xxy
 getOp(xyy ,u1,i1,i2,i3,ex,uu1,aj1,uu ## xyy) 
 getOp(yyy ,u1,i1,i2,i3,ex,uu1,aj1,uu ## yyy) 
 getOp(xxxx,u1,i1,i2,i3,ex,uu1,aj1,uu ## xxxx) 
 getOp(xxyy,u1,i1,i2,i3,ex,uu1,aj1,uu ## xxyy) 
 getOp(yyyy,u1,i1,i2,i3,ex,uu1,aj1,uu ## yyyy) 
 uu ## LapSq = uu ## xxxx +2.* uu ## xxyy + uu ## yyyy
#endMacro 

! ******************************************************************************
!   Evaluate derivatives for the 4th-order 2D interface equations
! ******************************************************************************
#beginMacro evalDerivs2dOrder4()

#perl $ORDER=2;
 ! These derivatives are computed to 2nd-order accuracy

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,3)
 evalFourthDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,u1)
 evalFourthDerivs(rsxy1,aj1,u1,i1,i2,i3,ey,vv1,v1)

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,3)
 evalFourthDerivs(rsxy2,aj2,u2,j1,j2,j3,ex,uu2,u2)
 evalFourthDerivs(rsxy2,aj2,u2,j1,j2,j3,ey,vv2,v2)

#perl $ORDER=4;
 ! These derivatives are computed to 4th-order accuracy

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,1)
 evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,u1)
 evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,ey,vv1,v1)

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,1)
 evalSecondDerivs(rsxy2,aj2,u2,j1,j2,j3,ex,uu2,u2)
 evalSecondDerivs(rsxy2,aj2,u2,j1,j2,j3,ey,vv2,v2)

#endMacro

! ******************************************************************************
!   Evaluate derivatives of the magnetic field for the 4th-order 2D interface equations
! ******************************************************************************
#beginMacro evalMagneticDerivs2dOrder4()

#perl $ORDER=4;
 ! These derivatives are computed to 4th-order accuracy
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,1)
 evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,hz,ww1,w1)

 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,1)
 evalSecondDerivs(rsxy2,aj2,u2,j1,j2,j3,hz,ww2,w2)

#perl $ORDER=2;
 ! These derivatives are computed to 2nd-order accuracy
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,1)
 evalFourthDerivs(rsxy1,aj1,u1,i1,i2,i3,hz,ww1,w1)

 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,1)
 evalFourthDerivs(rsxy2,aj2,u2,j1,j2,j3,hz,ww2,w2)

#endMacro

! ******************************************************************************
!   This next macro is called by other macros to evaluate the first and second derivatives
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalSecondDerivs3d(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,uu)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu1,2)    ! computes uu1r, uu1s 
 getOp(x ,u1,i1,i2,i3,ex,uu1,aj1,uu ## x)            ! u1.x
 getOp(y ,u1,i1,i2,i3,ex,uu1,aj1,uu ## y)            ! u1.y
 getOp(z ,u1,i1,i2,i3,ex,uu1,aj1,uu ## z)            ! u1.z
 getOp(xx,u1,i1,i2,i3,ex,uu1,aj1,uu ## xx)
 getOp(yy,u1,i1,i2,i3,ex,uu1,aj1,uu ## yy)
 getOp(zz,u1,i1,i2,i3,ex,uu1,aj1,uu ## zz)
 uu ## Lap = uu ## xx+ uu ## yy+ uu ## zz
#endMacro 


! *********************************************************************************
!   Evaluate derivatives for the 2nd-order 3D interface equations
! *********************************************************************************
#beginMacro evalInterfaceDerivatives3d()
 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy1,i1,i2,i3,aj1,1)
 evalSecondDerivs3d(rsxy1,aj1,u1,i1,i2,i3,ex,uu1,u1)
 evalSecondDerivs3d(rsxy1,aj1,u1,i1,i2,i3,ey,vv1,v1)
 evalSecondDerivs3d(rsxy1,aj1,u1,i1,i2,i3,ez,ww1,w1)

 ! NOTE: the jacobian derivatives can be computed once for all components
 opEvalJacobianDerivatives(rsxy2,j1,j2,j3,aj2,1)
 evalSecondDerivs3d(rsxy2,aj2,u2,j1,j2,j3,ex,uu2,u2)
 evalSecondDerivs3d(rsxy2,aj2,u2,j1,j2,j3,ey,vv2,v2)
 evalSecondDerivs3d(rsxy2,aj2,u2,j1,j2,j3,ez,ww2,w2)
#endMacro


! *********************************************************************
! ********** MACROS FOR DISPERSIVE INTERFACE CONDITIONS ***************
! *********************************************************************
#Include "dispersiveInterfaceMacros.h"

#Include "dispersiveInterfaceMacros2d.h"

! *********************************************************************
! ********** MACROS FOR NONLINEAR INTERFACE CONDITIONS ****************
! *********************************************************************
#Include "nonlinearInterfaceMacros.h"

! ----------------------------------------------------------------------------
!  MACRO: Eval jump conditions for Hz, 2D, 2nd-order
!  [ w.n/eps] = 0
!  [ Lap(w)*c^2] = 0
! ----------------------------------------------------------------------------
#beginMacro evalMagneticField2dJumpOrder2()

 f(0) = (an1*w1x+an2*w1y)/eps1 -\
        (an1*w2x+an2*w2y)/eps2
 f(1) = w1Lap*c1**2 - w2Lap*c2**2

 if( twilightZone.eq.1 )then
   call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wex  )
   call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wey  )
   call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexx )
   call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, weyy )
   weLap = wexx + weyy
   f(0) = f(0) - (an1*wex+an2*wey)*( 1./eps1 - 1./eps2 )
   f(1) = f(1) - ( weLap )*( c1**2 - c2**2 )
 end if
#endMacro



! --------------------------------------------------------------------
! Macro: Assign interface ghost values, DIM=2, ORDER=2, GRID=Rectangular
! 
! Here are the jump conditions
!   [ u.x + v.y  ] = 0
!   [ (Delta u)/mu ] = 0
! 
!   [ (v.x-u.y)/mu] = 0 
!   [ (Delta v)*c^2 ] = 0
! 
!  H_OPTION : NO_MAG_FIELD - do not solve for Hz 
! ---------------------------------------------------------------------
#beginMacro assignInterfaceGhost22r( H_OPTION )

 ! ****************************************************
 ! ***********  2D, ORDER=2, RECTANGULAR **************
 ! ****************************************************

 if( t.le.5*dt .or. debug.gt.3 )then

   write(*,'("macro: assignInterfaceGhost22r : t,dt=",2e10.2)') t,dt

 end if

 ! --- FORM the matrix of coefficients for the unknowns u1(-1),v1(-1),u2(-1),v2(-1)
 ! Solve:
 !     
 !       A [ U ] = A [ U(old) ] - [ f ]

 ! Eqn 0: [ u.x + v.y ]  = 0 
 ! Eqn 2: [  (v.x - u.y)/mu ] = 0 

 if( axis1.eq.0 )then    
   a4(0,0) = -is1/(2.*dx1(0))         ! coeff of u1(-1) from [u.x+v.y] 
   a4(0,1) = 0.                       ! coeff of v1(-1) from [u.x+v.y] 
 
   a4(2,0) = 0.
   a4(2,1) = -is1/(2.*dx1(0)) /mu1    ! coeff of v1(-1) from [(v.x - u.y)/mu1] 
 else 
   a4(0,0) = 0.                 
   a4(0,1) = -is2/(2.*dx1(1))         ! coeff of v1(-1) from [u.x+v.y] 

   a4(2,0) =  is2/(2.*dx1(1)) /mu1    ! coeff of u1(-1) from [v.x - u.y] 
   a4(2,1) = 0.
 end if

 if( axis2.eq.0 )then
   a4(0,2) = js1/(2.*dx2(0))         ! coeff of u2(-1) from [u.x+v.y] 
   a4(0,3) = 0. 
 
   a4(2,2) = 0.
   a4(2,3) = js1/(2.*dx2(0)) /mu2    ! coeff of v2(-1) from [(v.x - u.y)/mu]
 else
   a4(0,2) = 0. 
   a4(0,3) = js2/(2.*dx2(1))         ! coeff of v2(-1) from [u.x+v.y] 

   a4(2,2) =-js2/(2.*dx2(1)) /mu2    ! coeff of u2(-1) from [(v.x - u.y)/mu] 
   a4(2,3) = 0.
 end if

 ! [ Delta(u) / mu] = 0 
 ! equation 1:
 if( setDivergenceAtInterfaces.eq.0 )then
   a4(1,0) = ( 1./(dx1(axis1)**2) )/mu1  ! coeff of u1(-1) from [(u.xx + u.yy)/mu]
   a4(1,1) = 0. 
   a4(1,2) =-( 1./(dx2(axis2)**2) )/mu2  ! coeff of u2(-1) from [(u.xx + u.yy)/mu]
   a4(1,3) = 0. 
 else
   ! u1x+v1y=0
   if( axis1.eq.0 )then
     a4(1,0) = -is1/(2.*dx1(0))    ! coeff of u1(-1) from [u.x+v.y] 
     a4(1,1) = 0.                  ! coeff of v1(-1) from [u.x+v.y] 
   else 
     a4(1,0) = 0.                 
     a4(1,1) = -is2/(2.*dx1(1))    ! coeff of v1(-1) from [u.x+v.y] 
   end if
   a4(1,2) = 0.
   a4(1,3) = 0.
 end if 
   
 ! [ Delta(v) * c^2 ] = 0 
 ! equation 3: 
 a4(3,0) = 0.                      
 a4(3,1) = c1**2/(dx1(axis1)**2)  ! coeff of v1(-1) from [ c^2 (v.xx+v.yy) ]
 a4(3,2) = 0. 
 a4(3,3) =-c2**2/(dx2(axis2)**2) ! coeff of v2(-1) from [ c^2 (v.xx+v.yy) ]
     

 if( debug>0 )then
   write(*,*) "22r: Matrix a4"
   do n=0,3
     write(*,'(4(1pe10.2))') (a4(n,nn),nn=0,3)
   end do 
 end if 

 do m2=0,3
   do m1=0,3
     a4f(m1,m2)=a4(m1,m2)  ! holds factored version
   end do
 end do
 ! factor the matrix
 ! numberOfEquations=4
 call dgeco( a4f(0,0), 4, 4, ipivot4(0),rcond,work(0))
 ! write(debugFile,'(" --> a4: rcond=",e10.2)') rcond


 ! -- Form matrix for hz ----
 ! -- Form matrix for hz ----
 a2h(0,0)=-is*(1./(2.*dx1(axis1)*eps1)) ! coeff of w1(-1) in [w.n/eps]=0 
 a2h(0,1)= js*(1./(2.*dx2(axis2)*eps2)) ! coeff of w2(-1) in [w.n/eps]=0 
 a2h(1,0)=   1./(dx1(axis1)**2 *c1**2)    ! coeff of w1(-1) in [Lap(w)/eps ]=0 
 a2h(1,1)=  -1./(dx2(axis2)**2 *c2**2)    ! coeff of w2(-1) in [Lap(w)/eps ]=0 
 do m2=0,1
   do m1=0,1
     a2hf(m1,m2)=a2h(m1,m2)  ! holds factored version
   end do
 end do

 if( debug>7 )then
   write(*,*) "22r: Matrix a2h for Hz"
   do n=0,1
     write(*,'(2(1pe10.2))') (a2h(n,nn),nn=0,1)
   end do 
 end if 

 call dgeco( a2hf(0,0), 2, 2, ipivot2h(0),rcond,work(0))
 !  write(*,'("a2h: factored:  rcond=",e10.2)') rcond 



   
beginLoopsMask2d()

  ! --- first evaluate the equations we want to solve with the wrong values at the ghost points: ----
  evalInterfaceDerivatives2d()
 
  ! [ u.x + v.y ]  = 0 
  f(0)=(u1x+v1y) - \
       (u2x+v2y)

  ! [ Delta(u) / mu] = 0 
  f(1)=(u1xx+u1yy)/mu1 - \
       (u2xx+u2yy)/mu2

  ! [  (v.x - u.y)/mu ] = 0 
  f(2)=(v1x-u1y)/mu1 - \
       (v2x-u2y)/mu2
  
  ! [ Delta(v) * c^2 ] = 0 
  f(3)=(v1xx+v1yy)*c1**2 - \
       (v2xx+v2yy)*c2**2

  if( twilightZone.eq.1 )then

    call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uex  )
    call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uey  )

    call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vex  )
    call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vey  )

    call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexx )
    call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyy )

    call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexx )
    call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyy )
 
    ueLap = uexx + ueyy
    veLap = vexx + veyy
 
    f(1) = f(1) - ( ueLap     )*(1./mu1 - 1./mu2)

    f(2) = f(2) - ( vex - uey )*(1./mu1 - 1./mu2)

    f(3) = f(3) - ( veLap )*(c1**2 - c2**2)

  end if

  ! write(debugFile,'(" --> i1,i2=",2i4," f(start)=",4f8.3)') i1,i2,f(0),f(1),f(2),f(3)

  q(0) = u1(i1-is1,i2-is2,i3,ex)
  q(1) = u1(i1-is1,i2-is2,i3,ey)
  q(2) = u2(j1-js1,j2-js2,j3,ex)
  q(3) = u2(j1-js1,j2-js2,j3,ey)

  ! subtract off the contributions from the wrong values at the ghost points:
  do n=0,3
    f(n) = (a4(n,0)*q(0)+a4(n,1)*q(1)+a4(n,2)*q(2)+a4(n,3)*q(3)) - f(n)
  end do

  ! write(debugFile,'(" --> i1,i2=",2i4," f(subtract)=",4f8.3)') i1,i2,f(0),f(1),f(2),f(3)
  if( debug>0 .and. twilightZone.eq.1 )then
     write(*,'("   22r --> i1,i2=",2i4," RHS f=",4f12.7)') i1,i2,f(0),f(1),f(2),f(3)
     write(*,'("                             q=",4f12.7)') q(0),q(1),q(2),q(3)
   end if


  ! solve A Q = F
  job=0
  call dgesl( a4f(0,0), 4, 4, ipivot4(0), f(0), job)
  ! write(debugFile,'(" --> i1,i2=",2i4," f(solve)=",4f8.3)') i1,i2,f(0),f(1),f(2),f(3)

  u1(i1-is1,i2-is2,i3,ex)=f(0)
  u1(i1-is1,i2-is2,i3,ey)=f(1)
  u2(j1-js1,j2-js2,j3,ex)=f(2)
  u2(j1-js1,j2-js2,j3,ey)=f(3)

  if( debug>0 .and. twilightZone.eq.1 )then
    ! check errors
    call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, ex, evv(0) )
    call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, ey, evv(1) )
  
    call ogderiv(ep, 0,0,0,0, xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1),0.,t, ex, evv(2) )
    call ogderiv(ep, 0,0,0,0, xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1),0.,t, ey, evv(3) )
  
    maxErr=0.
    do n=0,3
      maxErr =max(maxErr,abs(evv(n)-f(n)))
    end do
    write(*,'("22r: i1,i2,i3=",3i4," t=",e9.3)') i1,i2,i3,t 
    write(*,'("     true= ",4(1pe10.2))') (evv(n),n=0,3)
    write(*,'("      err= ",4(1pe8.1)," -> maxErr=",e8.1)') (abs(evv(n)-f(n)),n=0,3),maxErr
  
  
  end if

   
  !-   if( debug.gt.2 )then ! re-evaluate
  !-    evalInterfaceDerivatives2d()
  !-    f(0)=(u1x+v1y) - \
  !-         (u2x+v2y)
  !-    if( setDivergenceAtInterfaces.eq.0 )then
  !-      f(1)=(u1xx+u1yy) - \
  !-           (u2xx+u2yy)
  !-    else
  !-      f(1)=(u1x+v1y)
  !-    end if
  !-    f(2)=(v1x-u1y)/mu1 - \
  !-         (v2x-u2y)/mu2
  !-    f(3)=(v1xx+v1yy)/epsmu1 - \
  !-         (v2xx+v2yy)/epsmu2
  !-    write(debugFile,'("i3d: --> i1,i2=",2i4," f(re-eval)=",4e10.2)') i1,i2,f(0),f(1),f(2),f(3)
  !-   end if


 #If #H_OPTION ne "NO_MAG_FIELD" 
    ! -------------------------------------------------------
    ! solve for Hz       
    !  [ w.n/eps] = 0
    !  [ Lap(w)*c^2] = 0
 
    evalMagneticFieldInterfaceDerivatives2d()
    evalMagneticField2dJumpOrder2()
  
  
    q(0) = u1(i1-is1,i2-is2,i3,hz)
    q(1) = u2(j1-js1,j2-js2,j3,hz)
  
 
    ! subtract off the contributions from the wrong values at the ghost points:
    do n=0,1
      f(n) = (a2h(n,0)*q(0)+a2h(n,1)*q(1)) - f(n)
    end do
  
    !- if( debug>7 .and. twilightZone.eq.1 )then
    !-   write(*,'("22r: i1,i2,i3=",3i4," t=",e9.3)') i1,i2,i3,t 
    !-   write(*,'("  hz-RHS= ",4(1pe10.2))') (f(n),n=0,1)
    !- end if 
 
    job=0
    call dgesl( a2hf(0,0), 2, 2, ipivot2h(0), f(0), job)
  
    u1(i1-is1,i2-is2,i3,hz)=f(0)
    u2(j1-js1,j2-js2,j3,hz)=f(1)
 
   !-  if( debug>0 .and. twilightZone.eq.1 )then
   !-    ! check errors
   !-    call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, hz, evv(0) )
   !-    call ogderiv(ep, 0,0,0,0, xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1),0.,t, hz, evv(1) )
   !-  
   !-    maxErr=0.
   !-    do n=0,1
   !-      maxErr =max(maxErr,abs(evv(n)-f(n)))
   !-    end do
   !-    ! write(*,'("22r: i1,i2,i3=",3i4," t=",e9.3)') i1,i2,i3,t 
   !-    write(*,'("  hz-true= ",4(1pe10.2))') (evv(n),n=0,1)
   !-    write(*,'("  hz- err= ",4(1pe8.1)," -> maxErr=",e8.1)') (abs(evv(n)-f(n)),n=0,1),maxErr
   !-  
   !-  
   !-  end if
 #End 

 endLoopsMask2d()
#endMacro

! --------------------------------------------------------------------------------------------
! Macro: Evaluate jump conditions - order 2
! --------------------------------------------------------------------------------------------
#beginMacro eval2dJumpOrder2()

 f(0)=( u1x+v1y ) - \
      ( u2x+v2y )

 f(1)=( an1*u1Lap +an2*v1Lap )/mu1 - \
      ( an1*u2Lap +an2*v2Lap )/mu2

 f(2)=( v1x-u1y )/mu1 - \
      ( v2x-u2y )/mu2

 f(3)=( tau1*u1Lap +tau2*v1Lap )*c1**2 - \
      ( tau1*u2Lap +tau2*v2Lap )*c2**2

 if( twilightZone.eq.1 )then

   call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uey )
   call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vex )

   call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexx )
   call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyy )
   call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexx )
   call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyy )

   ueLap = uexx + ueyy
   veLap = vexx + veyy

   f(1) = f(1) - ( an1*ueLap + an2*veLap )*( 1./mu1 - 1./mu2 )

   f(2) = f(2) - ( vex - uey )*( 1./mu1 - 1./mu2 )

   f(3) = f(3) - ( tau1*ueLap +tau2*veLap )*( c1**2 - c2**2 )

   ! write(debugFile,'(" u1Lap,ueLap=",2e10.2," v1Lap,veLap=",2e10.2)') u1Lap,ueLap,v1Lap,veLap

 end if
#endMacro

! ----------------------------------------------------------------------------------
!  Macro:
!    Evaluate the interface equations for checking the coefficients
! ----------------------------------------------------------------------------------
#beginMacro evalInterfaceEquations22c()
  evalInterfaceDerivatives2d() 
  eval2dJumpOrder2()
#endMacro


! --------------------------------------------------------------------
! Macro: Assign interface ghost values, DIM=2, ORDER=2, GRID=Curvilinear
! 
! Here are the jump conditions
!   [ u.x + v.y +w.z ] = 0
!   [ u.xx + u.yy +u.zz ] = 0
! 
!   [ tau1.(w.y-v.z, u.z-w.x, v.x-u.y)/mu] = 0 
!   [ (v.xx+v.yy+v.zz)/eps ] = 0
! 
!   [ tau2.(w.y-v.z, u.z-w.x, v.x-u.y)/mu] = 0 
!   [ (w.xx+w.yy+w.zz)/eps ] = 0
!  H_OPTION : NO_MAG_FIELD - do not solve for Hz 
! ---------------------------------------------------------------------
#beginMacro assignInterfaceGhost22c( H_OPTION )

  ! ****************************************************
  ! ***********  2D, ORDER=2, CURVILINEAR **************
  ! ****************************************************

  if( t.le.5*dt .or. debug.gt.3 )then
   write(*,'("macro: assignInterfaceGhost22c : t,dt=",2e10.2)') t,dt
  end if

  beginLoopsMask2d()

    ! here is the normal (assumed to be the same on both sides)
    an1=rsxy1(i1,i2,i3,axis1,0)   ! normal (an1,an2)
    an2=rsxy1(i1,i2,i3,axis1,1)
    aNorm=max(epsx,sqrt(an1**2+an2**2))
    an1=an1/aNorm
    an2=an2/aNorm
    tau1=-an2
    tau2= an1

    ! first evaluate the equations we want to solve with the wrong values at the ghost points:

    evalInterfaceDerivatives2d()
    eval2dJumpOrder2()

    ! write(debugFile,'(" --> order2-curv: i1,i2=",2i4," f(start)=",4f8.3)') i1,i2,f(0),f(1),f(2),f(3)
    ! write(debugFile,'(" --> u1(ghost),u1=",4f8.3)') u1(i1-is1,i2-is2,i3,ex),u1(i1,i2,i3,ex)
    ! write(debugFile,'(" --> u2(ghost),u2=",4f8.3)') u2(j1-js1,j2-js2,j3,ex),u2(j1,j2,j3,ex)
    ! '

    ! here is the matrix of coefficients for the unknowns u1(-1),v1(-1),u2(-1),v2(-1)
    ! Solve:
    !     
    !       A [ U ] = A [ U(old) ] - [ f ]
    a4(0,0) = -is*rsxy1(i1,i2,i3,axis1,0)/(2.*dr1(axis1))    ! coeff of u1(-1) from [u.x+v.y] 
    a4(0,1) = -is*rsxy1(i1,i2,i3,axis1,1)/(2.*dr1(axis1))    ! coeff of v1(-1) from [u.x+v.y] 
    a4(0,2) =  js*rsxy2(j1,j2,j3,axis2,0)/(2.*dr2(axis2))    ! coeff of u2(-1) from [u.x+v.y] 
    a4(0,3) =  js*rsxy2(j1,j2,j3,axis2,1)/(2.*dr2(axis2))    ! coeff of v2(-1) from [u.x+v.y] 

    a4(2,0) =  is*rsxy1(i1,i2,i3,axis1,1)/(2.*dr1(axis1)) /mu1  ! coeff of u1(-1) from [(v.x - u.y)/mu] 
    a4(2,1) = -is*rsxy1(i1,i2,i3,axis1,0)/(2.*dr1(axis1)) /mu1  ! coeff of v1(-1) from [(v.x - u.y)/mu] 

    a4(2,2) = -js*rsxy2(j1,j2,j3,axis2,1)/(2.*dr2(axis2)) /mu2  ! coeff of u2(-1) from [(v.x - u.y)/mu] 
    a4(2,3) =  js*rsxy2(j1,j2,j3,axis2,0)/(2.*dr2(axis2)) /mu2  ! coeff of v2(-1) from [(v.x - u.y)/mu] 


    ! coeff of u(-1) from lap = u.xx + u.yy
    rxx1(0,0,0)=aj1rxx
    rxx1(1,0,0)=aj1sxx
    rxx1(0,1,1)=aj1ryy
    rxx1(1,1,1)=aj1syy

    rxx2(0,0,0)=aj2rxx
    rxx2(1,0,0)=aj2sxx
    rxx2(0,1,1)=aj2ryy
    rxx2(1,1,1)=aj2syy

    ! clap1=(rsxy1(i1,i2,i3,axis1,0)**2+rsxy1(i1,i2,i3,axis1,1)**2)/(dr1(axis1)**2) \
    !           -is*(rsxy1x22(i1,i2,i3,axis1,0)+rsxy1y22(i1,i2,i3,axis1,1))/(2.*dr1(axis1))
    ! clap2=(rsxy2(j1,j2,j3,axis2,0)**2+rsxy2(j1,j2,j3,axis2,1)**2)/(dr2(axis2)**2) \
    !             -js*(rsxy2x22(j1,j2,j3,axis2,0)+rsxy2y22(j1,j2,j3,axis2,1))/(2.*dr2(axis2)) 
    clap1=(rsxy1(i1,i2,i3,axis1,0)**2+rsxy1(i1,i2,i3,axis1,1)**2)/(dr1(axis1)**2) \
              -is*(rxx1(axis1,0,0)+rxx1(axis1,1,1))/(2.*dr1(axis1))
    clap2=(rsxy2(j1,j2,j3,axis2,0)**2+rsxy2(j1,j2,j3,axis2,1)**2)/(dr2(axis2)**2) \
              -js*(rxx2(axis2,0,0)+rxx2(axis2,1,1))/(2.*dr2(axis2)) 

    !   [ n.(uv.xx + u.yy)/mu ] = 0
    a4(1,0) = an1*clap1/mu1
    a4(1,1) = an2*clap1/mu1
    a4(1,2) =-an1*clap2/mu2
    a4(1,3) =-an2*clap2/mu2
    !   [ tau.(uv.xx+uv.yy) * c^2 ] = 0
    a4(3,0) = tau1*clap1 *c1**2
    a4(3,1) = tau2*clap1 *c1**2
    a4(3,2) =-tau1*clap2 *c2**2
    a4(3,3) =-tau2*clap2 *c2**2
      

    q(0) = u1(i1-is1,i2-is2,i3,ex)
    q(1) = u1(i1-is1,i2-is2,i3,ey)
    q(2) = u2(j1-js1,j2-js2,j3,ex)
    q(3) = u2(j1-js1,j2-js2,j3,ey)


    ! --- check matrix coefficients by delta function approach ----
    ! comment out to speed up compilation 
    !- if( checkCoeff.eq.1 )then
    !-   numberOfEquations=4
    !-   checkCoefficients(i1,i2,i3, j1,j2,j3,numberOfEquations,a4,evalInterfaceEquations22c )
    !- end if




    ! write(debugFile,'(" --> xy1=",4f8.3)') xy1(i1,i2,i3,0),xy1(i1,i2,i3,1)
    ! write(debugFile,'(" --> rsxy1=",4f8.3)') rsxy1(i1,i2,i3,0,0),rsxy1(i1,i2,i3,1,0),rsxy1(i1,i2,i3,0,1),rsxy1(i1,i2,i3,1,1)
    ! write(debugFile,'(" --> rsxy2=",4f8.3)') rsxy2(j1,j2,j3,0,0),rsxy2(j1,j2,j3,1,0),rsxy2(j1,j2,j3,0,1),rsxy2(j1,j2,j3,1,1)

    ! write(debugFile,'(" --> rxx1=",2f8.3)') rxx1(axis1,0,0),rxx1(axis1,1,1)
    ! write(debugFile,'(" --> rxx2=",2f8.3)') rxx2(axis2,0,0),rxx2(axis1,1,1)

    ! write(debugFile,'(" --> a4(0,.)=",4f8.3)') a4(0,0),a4(0,1),a4(0,2),a4(0,3)
    ! write(debugFile,'(" --> a4(1,.)=",4f8.3)') a4(1,0),a4(1,1),a4(1,2),a4(1,3)
    ! write(debugFile,'(" --> a4(2,.)=",4f8.3)') a4(2,0),a4(2,1),a4(2,2),a4(2,3)
    ! write(debugFile,'(" --> a4(3,.)=",4f8.3)') a4(3,0),a4(3,1),a4(3,2),a4(3,3)
    ! write(debugFile,'(" --> an1,an2=",2f8.3)') an1,an2
    ! write(debugFile,'(" --> clap1,clap2=",2f8.3)') clap1,clap2
    ! subtract off the contributions from the wrong values at the ghost points:
    do n=0,3
      f(n) = (a4(n,0)*q(0)+a4(n,1)*q(1)+a4(n,2)*q(2)+a4(n,3)*q(3)) - f(n)
    end do
    ! write(debugFile,'(" --> order2-curv: i1,i2=",2i4," f(subtract)=",4f8.3)') i1,i2,f(0),f(1),f(2),f(3)
    ! solve A Q = F
    ! factor the matrix
    numberOfEquations=4
    call dgeco( a4(0,0), numberOfEquations, numberOfEquations, ipvt(0),rcond,work(0))
    ! solve
    ! write(debugFile,'(" --> order2-curv: i1,i2=",2i4," rcond=",e10.2)') i1,i2,rcond
    job=0
    call dgesl( a4(0,0), numberOfEquations, numberOfEquations, ipvt(0), f(0), job)
    ! write(debugFile,'(" --> order2-curv: i1,i2=",2i4," f(solve)=",4f8.3)') i1,i2,f(0),f(1),f(2),f(3)

    u1(i1-is1,i2-is2,i3,ex)=f(0)
    u1(i1-is1,i2-is2,i3,ey)=f(1)
    u2(j1-js1,j2-js2,j3,ex)=f(2)
    u2(j1-js1,j2-js2,j3,ey)=f(3)

  !-    if( debug.gt.3 )then ! re-evaluate
  !-      evalInterfaceDerivatives2d()
  !-      eval2dJumpOrder2()
  !-      !write(debugFile,'(" --> order2-curv: xy1(ghost)=",2e11.3)') xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1)
  !-      !write(debugFile,'(" --> order2-curv: xy2(ghost)=",2e11.3)') xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1)
  !-      if( twilightZone.eq.1 )then
  !-        call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, ex, uex  )
  !-        call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, ey, uey  )
  !-       write(debugFile,'(" --> order2-curv: i1,i2=",2i4," u1=",2e11.3," err=",2e11.3)') i1,i2,u1(i1-is1,i2-is2,i3,ex),u1(i1-is1,i2-is2,i3,ey),u1(i1-is1,i2-is2,i3,ex)-uex,u1(i1-is1,i2-is2,i3,ey)-uey
  !-        ! '
  !-      else
  !-       write(debugFile,'(" --> order2-curv: i1,i2=",2i4," u1=",2e11.3)') i1,i2,u1(i1-is1,i2-is2,i3,ex),u1(i1-is1,i2-is2,i3,ey)
  !-        ! '
  !-      end if
  !-      write(debugFile,'(" --> order2-curv: j1,j2=",2i4," u2=",2e11.3)') j1,j2,u2(j1-js1,j2-js2,j3,ex),u2(j1-js1,j2-js2,j3,ey)
  !-        ! '
  !-      write(debugFile,'(" --> order2-curv: i1,i2=",2i4," f(re-eval)=",4e10.2)') i1,i2,f(0),f(1),f(2),f(3)
  !-        ! '
  !-    end if

    ! solve for Hz
    !  [ w.n/eps] = 0
    !  [ Lap(w)/eps] = 0

    evalMagneticFieldInterfaceDerivatives2d()
    evalMagneticField2dJumpOrder2()

    a2(0,0)=-is*(an1*rsxy1(i1,i2,i3,axis1,0)+an2*rsxy1(i1,i2,i3,axis1,1))/(2.*dr1(axis1)*eps1)
    a2(0,1)= js*(an1*rsxy2(j1,j2,j3,axis2,0)+an2*rsxy2(j1,j2,j3,axis2,1))/(2.*dr2(axis2)*eps2)

    a2(1,0)= clap1/eps1
    a2(1,1)=-clap2/eps2

    q(0) = u1(i1-is1,i2-is2,i3,hz)
    q(1) = u2(j1-js1,j2-js2,j3,hz)

    ! subtract off the contributions from the wrong values at the ghost points:
    do n=0,1
      f(n) = (a2(n,0)*q(0)+a2(n,1)*q(1)) - f(n)
    end do

    call dgeco( a2(0,0), 2, 2, ipvt(0),rcond,work(0))
    job=0
    call dgesl( a2(0,0), 2, 2, ipvt(0), f(0), job)

    u1(i1-is1,i2-is2,i3,hz)=f(0)
    u2(j1-js1,j2-js2,j3,hz)=f(1)

  !-    if( debug.gt.3 )then ! re-evaluate
  !-
  !-      evalMagneticFieldInterfaceDerivatives2d()
  !-      evalMagneticField2dJumpOrder2()
  !-
  !-      write(debugFile,'(" --> order2-curv: i1,i2=",2i4," hz-f(re-eval)=",4e10.2)') i1,i2,f(0),f(1)
  !-        ! '
  !-    end if

  endLoopsMask2d()
  if( checkCoeff.eq.1 )then
    write(*,'("+++++ i22c: check coeff in interface: max(diff) = ",1pe8.2)') coeffDiff
  end if

#endMacro

! --------------------------------------------------------------------------
! Macro: 
! --------------------------------------------------------------------------
#beginMacro evalMagneticField2dJumpOrder4()
 f(0)=(an1*w1x+an2*w1y)/eps1 - \
      (an1*w2x+an2*w2y)/eps2
 f(1)=w1Lap/eps1 - \
      w2Lap/eps2
 f(2)=(an1*(w1xxx+w1xyy)+an2*(w1xxy+w1yyy))/eps1**2 - \
      (an1*(w2xxx+w2xyy)+an2*(w2xxy+w2yyy))/eps2**2
 f(3)=w1LapSq/eps1**2 - \
      w2LapSq/eps2**2
 if( twilightZone.eq.1 )then

   call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wex  )
   call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wey  )
   call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexx )
   call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, weyy )

   call ogderiv(ep, 0,3,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexxx )
   call ogderiv(ep, 0,2,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexxy )
   call ogderiv(ep, 0,1,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexyy )
   call ogderiv(ep, 0,0,3,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, weyyy )

   call ogderiv(ep, 0,4,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexxxx )
   call ogderiv(ep, 0,2,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, wexxyy )
   call ogderiv(ep, 0,0,4,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, hz, weyyyy )

   weLap = wexx + weyy
   weLapSq = wexxxx + 2.*wexxyy + weyyyy

   f(0) = f(0) - (an1*wex+an2*wey)*(1./eps1 - 1./eps2)
   f(1) = f(1) - ( weLap )*(1./eps1 - 1./eps2)
   f(2) = f(2) - (an1*(wexxx+wexyy)+an2*(wexxy+weyyy))*(1./eps1**2 - 1./eps2**2)
   f(3) = f(3) - weLapSq*(1./eps1**2 - 1./eps2**2)

 end if
#endMacro


!-------------------------------------------------------------------------
#beginMacro getJumpOrder4Macro()

   ! first evaluate the equations we want to solve with the wrong values at the ghost points:
   ! evalDerivs2dOrder4()
   evalDerivs2dOrder4()

   ! New form of jump conditions: *wdh* Jan 27, 2021 
   f(0)=(u1x+v1y) - \
        (u2x+v2y)

   f(1)=(u1Lap)/mu1 - \
        (u2Lap)/mu2

   f(2)=(v1x-u1y)/mu1 - \
        (v2x-u2y)/mu2

   !  J3:  [ c^2 Delta v] 
   f(3)=(v1Lap)*c1**2 - \
        (v2Lap)*c2**2

   ! J4: [ (u.x + v.y).xx ] -> [ (c^2/mu) ( u.xxx - v.yyy) ] 
   f(4)=(u1xxx - v1yyy)*c1**2/mu1 - \
        (u2xxx - v2yyy)*c2**2/mu2

   ! J5: Convert u.xxy -> -v.xyy
   !    [ (c^2/mu) Delta( v.x - u.y) ] 
   f(5)=( v1xxx + 2.*v1xyy - u1yyy )*c1**2/mu1 - \
        ( v2xxx + 2.*v2xyy - u2yyy )*c2**2/mu2

   ! [ c^2/mu Delta(u) ]=0
   f(6)=(u1LapSq) * c1**2/mu1 - \
        (u2LapSq) * c2**2/mu2

   ! [ c^4 Delta(v) ]=0
   f(7)=(v1LapSq)*c1**4 - \
        (v2LapSq)*c2**4
   
   if( twilightZone.eq.1 )then
     call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uex  )
     call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uey  )

     call ogderiv(ep, 0,1,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vex  )
     call ogderiv(ep, 0,0,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vey  )

     call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexx )
     call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyy )

     call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexx )
     call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyy )
  
     call ogderiv(ep, 0,3,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxx )
     call ogderiv(ep, 0,2,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxy )
     call ogderiv(ep, 0,0,3,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyyy )
  
     call ogderiv(ep, 0,3,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexxx )
     call ogderiv(ep, 0,1,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexyy )
     call ogderiv(ep, 0,0,3,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyyy )
  
     call ogderiv(ep, 0,4,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxxx )
     call ogderiv(ep, 0,2,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxyy )
     call ogderiv(ep, 0,0,4,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyyyy )
  
     call ogderiv(ep, 0,4,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexxxx )
     call ogderiv(ep, 0,2,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexxyy )
     call ogderiv(ep, 0,0,4,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyyyy )
  
     ueLap = uexx + ueyy
     veLap = vexx + veyy
     ueLapSq = uexxxx + 2.*uexxyy + ueyyyy
     veLapSq = vexxxx + 2.*vexxyy + veyyyy
  
     ! New form of jump conditions: *wdh* Jan 27, 2021 

     f(1) = f(1) - ( ueLap )*(1./mu1 - 1./mu2)
     f(2) = f(2) - ( vex - uey  )*(1./mu1 - 1./mu2)
     !  J3:  [ c^2 Delta v] 
     f(3) = f(3) - ( veLap )*(c1**2 - c2**2)
     ! J4: [ (u.x + v.y).xx ] -> [ c^2( u.xxx - v.yyy) ] 
     f(4) = f(4) - ( uexxx - veyyy )*(c1**2/mu1 - c2**2/mu2)
     ! J5   [ (c^2/mu) Delta( v.x - u.y) ] 
     f(5) = f(5) - ( vexxx + 2.*vexyy - ueyyy )*(c1**2/mu1 - c2**2/mu2)
     f(6) = f(6) - ( ueLapSq )*(c1**2/mu1 - c2**2/mu2)
     f(7) = f(7) - ( veLapSq )*(c1**4 - c2**4)

   end if

#endMacro 
!-------------------------------------------------------------------------


! --------------------------------------------------------------------------
! Macro: Assign interface ghost values, DIM=2, ORDER=4, GRID=Rectangular
! 
! --------------------------------------------------------------------------
#beginMacro assignInterfaceGhost24r()
 ! ****************************************************
 ! ***********  2D, ORDER=4, RECTANGULAR **************
 ! ****************************************************

 if( t.le.5*dt .or. debug.gt.3 )then
   if( it.le.2 )then
     write(*,'("macro: assignInterfaceGhost24r : it=",i6," t,dt=",2e10.2)') it,t,dt
   end if
 end if

 ! normal and tangent (for TZ forcing)
 an1=an1Cartesian
 an2=an2Cartesian
 tau1=-an2
 tau2= an1

   ! here is the matrix of coefficients for the unknowns u1(-1),v1(-1),u2(-1),v2(-1)
   ! Solve:
   !     
   !       A [ U ] = A [ U(old) ] - [ f ]
   !


   ! ORDER:  u1(-1), v1(-1), u2(-1), v2(-1), u1(-2), v1(-2), u2(-2), v2(-2)

   ! 0  [ u.x + v.y ] = 0
   a8(0,0) = -is*8.*rx1*dx141(axis1)     ! coeff of u1(-1) from [u.x+v.y] 
   a8(0,1) = -is*8.*ry1*dx141(axis1)     ! coeff of v1(-1) from [u.x+v.y] 
   a8(0,4) =  is*rx1*dx141(axis1)        ! u1(-2)
   a8(0,5) =  is*ry1*dx141(axis1)        ! v1(-2) 

   a8(0,2) =  js*8.*rx2*dx241(axis2)     ! coeff of u2(-1) from [u.x+v.y] 
   a8(0,3) =  js*8.*ry2*dx241(axis2) 
   a8(0,6) = -js*   rx2*dx241(axis2) 
   a8(0,7) = -js*   ry2*dx241(axis2) 

   ! 1  [ (u.xx + u.yy)/mu ] = 0
   a8(1,0) = 16.*dx142(axis1)/mu1         ! coeff of u1(-1) from [u.xx + u.yy]
   a8(1,1) = 0. 
   a8(1,4) =    -dx142(axis1)/mu1         ! coeff of u1(-2) from [u.xx + u.yy]
   a8(1,5) = 0. 

   a8(1,2) =-16.*dx242(axis2)/mu2         ! coeff of u2(-1) from [u.xx + u.yy]
   a8(1,3) = 0. 
   a8(1,6) =     dx242(axis2)/mu2         ! coeff of u2(-2) from [u.xx + u.yy]
   a8(1,7) = 0. 


   ! 2  [ (v.x - u.y)/mu ] =0 
   a8(2,0) =  is*8.*ry1*dx141(axis1)/mu1 
   a8(2,1) = -is*8.*rx1*dx141(axis1)/mu1     ! coeff of v1(-1) from [v.x - u.y] 
   a8(2,4) = -is*   ry1*dx141(axis1)/mu1 
   a8(2,5) =  is*   rx1*dx141(axis1)/mu1 

   a8(2,2) = -js*8.*ry2*dx241(axis2)/mu2
   a8(2,3) =  js*8.*rx2*dx241(axis2)/mu2
   a8(2,6) =  js*   ry2*dx241(axis2)/mu2
   a8(2,7) = -js*   rx2*dx241(axis2)/mu2

   ! 3  [ (v.xx+v.yy)*c^2 ] = 0
   dxx1by12i = 1./(12.*dx1(axis1)**2);
   dxx2by12i = 1./(12.*dx2(axis2)**2);

   a8(3,0) = 0.                      
   a8(3,1) = 16.*dxx1by12i *c1**2 ! coeff of v1(-1) from [(v.xx+v.yy)/eps]
   a8(3,2) = 0. 
   a8(3,3) =-16.*dxx2by12i *c2**2 ! coeff of v2(-1) from [(v.xx+v.yy)/eps]
   a8(3,4) = 0.                      
   a8(3,5) =    -dxx1by12i *c1**2 ! coeff of v1(-2) from [(v.xx+v.yy)/eps]
   a8(3,6) = 0. 
   a8(3,7) =     dxx2by12i *c2**2 ! coeff of v2(-2) from [(v.xx+v.yy)/eps]

   ! 4  [ (u.xx+u.yy).x + (v.xx+v.yy).y ] = 0
   ! *wdh*  Jan 18, 2021 -- remove cross-derivative terms 
   ! New: 
   !  [ c^2( u.xxx - v.yyy )] = 0 

   dxxx1by2i = 1./(dx1(axis1)**3*2); 
   dxxx2by2i = 1./(dx2(axis2)**3*2); 
   ! Order u1(-1), v1(-1), u2(-1), v2(-1), u1(-2), v1(-2), u2(-2), v2(-2), 
   a8(4,0)= ( is*rx1 *2.*dxxx1by2i )*c1**2/mu1 
   a8(4,1)= 0.
   a8(4,2)=-( js*rx2* 2.*dxxx2by2i )*c2**2/mu2 
   a8(4,3)= 0.
   a8(4,4)= (-is*rx1    *dxxx1by2i )*c1**2/mu1 
   a8(4,5)= 0.
   a8(4,6)=-(-js*rx2    *dxxx2by2i )*c2**2/mu2    
   a8(4,7)= 0.
 
   !-    a8(4,0)= ( is*rx1*2.*dx122(axis1)*dx112(axis1) )*c1**2 
   !-    a8(4,1)= ( is*ry1*2.*dx122(axis1)*dx112(axis1) )*c1**2
   !-    a8(4,2)=-( js*rx2*2.*dx222(axis2)*dx212(axis2) )*c2**2 
   !-    a8(4,3)=-( js*ry2*2.*dx222(axis2)*dx212(axis2) )*c2**2
   !-    a8(4,4)= (-is*rx1   *dx122(axis1)*dx112(axis1) )*c1**2  
   !-    a8(4,5)= (-is*ry1   *dx122(axis1)*dx112(axis1) )*c1**2
   !-    a8(4,6)=-(-js*rx2   *dx222(axis2)*dx212(axis2) )*c2**2   
   !-    a8(4,7)=-(-js*ry2   *dx222(axis2)*dx212(axis2) )*c2**2
 
   ! 5  [ {(Delta v).x - (Delta u).y}/eps ] =0  -> [ {(v.xxx+v.xyy)-(u.xxy+u.yyy)}/eps ] = 0
 
  ! use u.xxy -> -v.xyy
  ! 5a [ ( v.xxx + 2*v.xyy - u.yyy ) * c^2/mu ] = 0
  ! *wdh*  Jan 18, 2021 -- remove cross-derivative terms 
   a8(5,0)=-( is*ry1*2.*dx122(axis1)*dx112(axis1) ) * c1**2/mu1
   a8(5,1)= ( is*rx1*2.*dx122(axis1)*dx112(axis1) ) * c1**2/mu1
   a8(5,4)=-(-is*ry1   *dx122(axis1)*dx112(axis1) ) * c1**2/mu1
   a8(5,5)= (-is*rx1   *dx122(axis1)*dx112(axis1) ) * c1**2/mu1
 
   a8(5,2)= ( js*ry2*2.*dx222(axis2)*dx212(axis2) ) * c2**2/mu2 
   a8(5,3)=-( js*rx2*2.*dx222(axis2)*dx212(axis2) ) * c2**2/mu2
   a8(5,6)= (-js*ry2   *dx222(axis2)*dx212(axis2) ) * c2**2/mu2
   a8(5,7)=-(-js*rx2   *dx222(axis2)*dx212(axis2) ) * c2**2/mu2

   ! 6  [ Delta^2 u * c^2/mu ] = 0

   ! *wdh*  Jan 18, 2021 -- remove cross-derivative terms 
   a8(6,0) = -( 4./(dx1(axis1)**4) ) * c1**2/mu1
   a8(6,1) = 0.
   a8(6,4) =  ( 1./(dx1(axis1)**4) ) * c1**2/mu1
   a8(6,5) = 0.

   a8(6,2) =  ( 4./(dx2(axis2)**4) ) * c2**2/mu2
   a8(6,3) = 0.
   a8(6,6) =  (-1./(dx2(axis2)**4) ) * c2**2/mu2
   a8(6,7) = 0.

   ! 7  [ (Delta^2 v) * c^4 ] = 0 
   ! *wdh*  Jan 18, 2021 -- remove cross-derivative terms 
   a8(7,0) = 0.
   a8(7,1) =  -(4./(dx1(axis1)**4) ) * c1**4 
   a8(7,4) = 0.
   a8(7,5) =   (1./(dx1(axis1)**4) ) * c1**4 

   a8(7,2) = 0.
   a8(7,3) =   (4./(dx2(axis2)**4) ) * c2**4 
   a8(7,6) = 0.
   a8(7,7) =  (-1./(dx2(axis2)**4) ) * c2**4 


   if( debug>0)then
     write(*,*) "42r: Matrix a8"
     do n=0,7
       write(*,'(8(1pe10.2))') (a8(n,nn),nn=0,7)
     end do 
   end if 

 do m2=0,7
   do m1=0,7
     a8f(m1,m2)=a8(m1,m2)  ! holds factored version
   end do
 end do

 ! factor the matrix
 numberOfEquations=8
 call dgeco( a8f(0,0), 8, 8, ipivot8(0),rcond,work(0))

 !write(debugFile,'(" --> 24r: 4th-order rect.: rcond=",e10.2)') rcond


  ! ------------------------------------------
  ! ---- form the matrix for computing Hz ----
  ! ------------------------------------------

  ! 1: [ w.n/eps ] = 0
  a0 = dx141(axis1)/eps1
  b0 = dx241(axis2)/eps2
  a4h(0,0) = -is*8.*a0
  a4h(0,2) =  is*   a0
  a4h(0,1) =  js*8.*b0
  a4h(0,3) = -js*   b0

  ! 2: [ lap(w)/eps ] = 0 
  aLap0=16.*dx142(axis1)  ! coeff of w1(-1) 
  aLap1=-1.*dx142(axis1)  ! coeff of w1(-2)
  bLap0=16.*dx242(axis2)  ! coeff of w2(-1) 
  bLap1=-1.*dx242(axis2)  ! coeff of w2(-1) 

  a4h(1,0) = aLap0/eps1    ! coeff of w1(-1) 
  a4h(1,2) = aLap1/eps1    ! coeff of w1(-2)
  a4h(1,1) =-bLap0/eps2    ! coeff of w2(-1) 
  a4h(1,3) =-bLap1/eps2    ! coeff of w2(-1) 

  ! 3:  [ (an1*(w.xx+w.yy).x + an2.(w.xx+w.yy).y)/eps**2 ] = 0
  !  a4h(2,0)= (an1*aLapX0+an2*bLapY0)/eps1**2  ! coeff of w1(-1) 
  !  a4h(2,1)=-(an1*cLapX0+an2*dLapY0)/eps2**2  ! coeff of w2(-1)
  !  a4h(2,2)= (an1*aLapX1+an2*bLapY1)/eps1**2  ! coeff of w1(-2)
  !  a4h(2,3)=-(an1*cLapX1+an2*dLapY1)/eps2**2  ! coeff of w2(-2)
  a4h(2,0)=  is*(  1./(dx1(axis1)**3) +1./(dx1(axis1)*dx1(axis1p1)**2) )/eps1**2  ! coeff of w1(-1) aLapX0
  a4h(2,2)=  is*( -.5/(dx1(axis1)**3)                                  )/eps1**2  ! coeff of w1(-2) aLapX1

  a4h(2,1)= -js*(  1./(dx2(axis2)**3) +1./(dx2(axis2)*dx2(axis2p1)**2) )/eps2**2  ! coeff of w2(-1) cLapX0 
  a4h(2,3)= -js*( -.5/(dx2(axis2)**3)                                  )/eps2**2  ! coeff of w2(-2) cLapX1

  ! 4 [ lapSq(w)/eps**2 ] = 0   [ w_xxxx + 2 * w_xxyy + w_yyyy ]
  aLapSq0= ( -4./(dx1(axis1)**4) -4./(dx1(axis1)**2 * dx1(axis1p1)**2 ) )
  aLapSq1= (  1./(dx1(axis1)**4) )
  bLapSq0= ( -4./(dx2(axis2)**4) -4./(dx2(axis2)**2 * dx2(axis2p1)**2 ) )
  bLapSq1= (  1./(dx2(axis2)**4) )
  a4h(3,0) = aLapSq0/eps1**2
  a4h(3,2) = aLapSq1/eps1**2
  a4h(3,1) =-bLapSq0/eps2**2
  a4h(3,3) =-bLapSq1/eps2**2

  do m2=0,3
    do m1=0,3
      a4hf(m1,m2)=a4h(m1,m2)  ! holds factored version
    end do
  end do

  ! write(*,'(" a4h=",4(e9.2,1x))') ((a4h(i,j),j=0,3),i=0,3)

  ! factor the matrix
  call dgeco( a4hf(0,0), 4, 4, ipivot4h(0),rcond,work(0))
  ! write(*,'("rcond=",e12.4)') rcond
   

 beginLoopsMask2d() ! =============== start loops =======================

   ! first evaluate the equations we want to solve with the wrong values at the ghost points:
   getJumpOrder4Macro()

   !      write(debugFile,'(" --> 4th: j1,j2=",2i4," u1xx,u1yy,u2xx,u2yy=",4e10.2)') j1,j2,u1xx42r(i1,i2,i3,ex),\
   !          u1yy42r(i1,i2,i3,ex),u2xx42r(j1,j2,j3,ex),u2yy42r(j1,j2,j3,ex)
   !      write(debugFile,'(" --> 4th: i1,i2=",2i4," f(start)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7)


   q(0) = u1(i1-is1,i2-is2,i3,ex)
   q(1) = u1(i1-is1,i2-is2,i3,ey)
   q(2) = u2(j1-js1,j2-js2,j3,ex)
   q(3) = u2(j1-js1,j2-js2,j3,ey)

   q(4) = u1(i1-2*is1,i2-2*is2,i3,ex)
   q(5) = u1(i1-2*is1,i2-2*is2,i3,ey)
   q(6) = u2(j1-2*js1,j2-2*js2,j3,ex)
   q(7) = u2(j1-2*js1,j2-2*js2,j3,ey)

   !      write(debugFile,'(" --> 4th: i1,i2=",2i4," q=",8e10.2)') i1,i2,q(0),q(1),q(2),q(3),q(4),q(5),q(6),q(7)

   if( debug.gt.0 )then
     write(*,'(" -->    24r: i1,i2=",2i4," RHS(A)=",8(1pe12.4))') i1,i2,(f(n),n=0,7)
   end if

   ! subtract off the contributions from the initial (wrong) values at the ghost points:
   do n=0,7
     f(n) = (a8(n,0)*q(0)+a8(n,1)*q(1)+a8(n,2)*q(2)+a8(n,3)*q(3)+\
             a8(n,4)*q(4)+a8(n,5)*q(5)+a8(n,6)*q(6)+a8(n,7)*q(7)) - f(n)
   end do

   ! if( .true. )then
   !    write(*,'("24r: i1,i2=",2i4," RHS f= ",8(1pe10.2))') i1,i2, (f(n),n=0,7)
   ! end if
   
   ! solve A Q = F

   job=0
   ! numberOfEquations=8
   call dgesl( a8f(0,0), 8, 8, ipivot8(0), f(0), job)

   !write(debugFile,'(" --> 4th: i1,i2=",2i4," f(solve)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7)

  if( debug>0 .and. twilightZone.eq.1 )then
    ! check errors
    call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, ex, evv(0) )
    call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, ey, evv(1) )
  
    call ogderiv(ep, 0,0,0,0, xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1),0.,t, ex, evv(2) )
    call ogderiv(ep, 0,0,0,0, xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1),0.,t, ey, evv(3) )
  
    call ogderiv(ep, 0,0,0,0, xy1(i1-2*is1,i2-2*is2,i3,0),xy1(i1-2*is1,i2-2*is2,i3,1),0.,t, ex, evv(4) )
    call ogderiv(ep, 0,0,0,0, xy1(i1-2*is1,i2-2*is2,i3,0),xy1(i1-2*is1,i2-2*is2,i3,1),0.,t, ey, evv(5) )
  
    call ogderiv(ep, 0,0,0,0, xy2(j1-2*js1,j2-2*js2,j3,0),xy2(j1-2*js1,j2-2*js2,j3,1),0.,t, ex, evv(6) )
    call ogderiv(ep, 0,0,0,0, xy2(j1-2*js1,j2-2*js2,j3,0),xy2(j1-2*js1,j2-2*js2,j3,1),0.,t, ey, evv(7) )
  
    write(*,'("24r: Errors in u1(-1), v1(-1), u2(-1), v2(-1), u1(-2), v1(-2), u2(-2), v2(-2)")') 
  
    maxErr=0.
    do n=0,7
      maxErr =max(maxErr,abs(evv(n)-f(n)))
    end do
    write(*,'("24r: i1,i2=",2i4," err= ",8e8.1," -> maxErr=",e8.1)') i1,i2, (abs(evv(n)-f(n)),n=0,7),maxErr
  
  
  end if


   
   if( useJacobiUpdate.eq.0 )then
     u1(i1-is1,i2-is2,i3,ex)=f(0)
     u1(i1-is1,i2-is2,i3,ey)=f(1)
     u2(j1-js1,j2-js2,j3,ex)=f(2)
     u2(j1-js1,j2-js2,j3,ey)=f(3)

     u1(i1-2*is1,i2-2*is2,i3,ex)=f(4)
     u1(i1-2*is1,i2-2*is2,i3,ey)=f(5)
     u2(j1-2*js1,j2-2*js2,j3,ex)=f(6)
     u2(j1-2*js1,j2-2*js2,j3,ey)=f(7)
   else
     ! Jacobi-update
     wk1(i1-is1,i2-is2,i3,ex)    =f(0)
     wk1(i1-is1,i2-is2,i3,ey)    =f(1)
     wk2(j1-js1,j2-js2,j3,ex)    =f(2)
     wk2(j1-js1,j2-js2,j3,ey)    =f(3)

     wk1(i1-2*is1,i2-2*is2,i3,ex)=f(4)
     wk1(i1-2*is1,i2-2*is2,i3,ey)=f(5)
     wk2(j1-2*js1,j2-2*js2,j3,ex)=f(6)
     wk2(j1-2*js1,j2-2*js2,j3,ey)=f(7)
   end if


 !-  if( .false. .or. debug.gt.3 )then ! re-evaluate
 !-
 !-    ! This is still not correct since the cross terms should use the SOA values
 !-
 !-    if( useJacobiUpdate.eq.1 )then
 !-     ! Temporarily assign to check residuals 
 !-     u1(i1-is1,i2-is2,i3,ex)     = wk1(i1-is1,i2-is2,i3,ex)    
 !-     u1(i1-is1,i2-is2,i3,ey)     = wk1(i1-is1,i2-is2,i3,ey)    
 !-     u2(j1-js1,j2-js2,j3,ex)     = wk2(j1-js1,j2-js2,j3,ex)    
 !-     u2(j1-js1,j2-js2,j3,ey)     = wk2(j1-js1,j2-js2,j3,ey)    
 !-                                                               
 !-     u1(i1-2*is1,i2-2*is2,i3,ex) = wk1(i1-2*is1,i2-2*is2,i3,ex)
 !-     u1(i1-2*is1,i2-2*is2,i3,ey) = wk1(i1-2*is1,i2-2*is2,i3,ey)
 !-     u2(j1-2*js1,j2-2*js2,j3,ex) = wk2(j1-2*js1,j2-2*js2,j3,ex)
 !-     u2(j1-2*js1,j2-2*js2,j3,ey) = wk2(j1-2*js1,j2-2*js2,j3,ey)
 !-   end if
 !-   
 !-     getJumpOrder4Macro()
 !-
 !-   if( useJacobiUpdate.eq.1 )then
 !-     ! reset for jacobi update
 !-     wk1(i1-is1,i2-is2,i3,ex)     = u1(i1-is1,i2-is2,i3,ex)         
 !-     wk1(i1-is1,i2-is2,i3,ey)     = u1(i1-is1,i2-is2,i3,ey)      
 !-     wk2(j1-js1,j2-js2,j3,ex)     = u2(j1-js1,j2-js2,j3,ex)      
 !-     wk2(j1-js1,j2-js2,j3,ey)     = u2(j1-js1,j2-js2,j3,ey)      
 !-                                                                 
 !-     wk1(i1-2*is1,i2-2*is2,i3,ex) = u1(i1-2*is1,i2-2*is2,i3,ex)  
 !-     wk1(i1-2*is1,i2-2*is2,i3,ey) = u1(i1-2*is1,i2-2*is2,i3,ey)  
 !-     wk2(j1-2*js1,j2-2*js2,j3,ex) = u2(j1-2*js1,j2-2*js2,j3,ex)  
 !-     wk2(j1-2*js1,j2-2*js2,j3,ey) = u2(j1-2*js1,j2-2*js2,j3,ey)  
 !-   end if 
 !-
 !-   write(*,'(" 42r: residuals: i1,i2=",2i4," res=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7) 
 !-   ! write(debugFile,'(" --> 4th: i1,i2=",2i4," f(re-eval)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7) 
 !-   ! '
 !-  end if

   ! -------------------------------------------------------
   ! solve for Hz         *fixed* *wdh* June 24, 2016
   !  [ w.n/eps ] = 0
   !  [ lap(w)/eps ] = 0
   !  [ lap(w).n/eps**2 ] = 0
   !  [ lapSq(w)/eps**2 ] = 0

   ! first evaluate the equations we want to solve with the wrong values at the ghost points:
   evalMagneticDerivs2dOrder4()
   evalMagneticField2dJumpOrder4()



   ! form the matrix for computing Hz

   ! 1: [ w.n/eps ] = 0
   a0 = dx141(axis1)/eps1
   b0 = dx241(axis2)/eps2
   a4h(0,0) = -is*8.*a0
   a4h(0,2) =  is*   a0
   a4h(0,1) =  js*8.*b0
   a4h(0,3) = -js*   b0

   ! 2: [ lap(w)/eps ] = 0 
   aLap0=16.*dx142(axis1)  ! coeff of w1(-1) 
   aLap1=-1.*dx142(axis1)  ! coeff of w1(-2)
   bLap0=16.*dx242(axis2)  ! coeff of w2(-1) 
   bLap1=-1.*dx242(axis2)  ! coeff of w2(-1) 

   a4h(1,0) = aLap0/eps1    ! coeff of w1(-1) 
   a4h(1,2) = aLap1/eps1    ! coeff of w1(-2)
   a4h(1,1) =-bLap0/eps2    ! coeff of w2(-1) 
   a4h(1,3) =-bLap1/eps2    ! coeff of w2(-1) 

   ! 3:  [ (an1*(w.xx+w.yy).x + an2.(w.xx+w.yy).y)/eps**2 ] = 0
   !  a4h(2,0)= (an1*aLapX0+an2*bLapY0)/eps1**2  ! coeff of w1(-1) 
   !  a4h(2,1)=-(an1*cLapX0+an2*dLapY0)/eps2**2  ! coeff of w2(-1)
   !  a4h(2,2)= (an1*aLapX1+an2*bLapY1)/eps1**2  ! coeff of w1(-2)
   !  a4h(2,3)=-(an1*cLapX1+an2*dLapY1)/eps2**2  ! coeff of w2(-2)
   a4h(2,0)=  is*(  1./(dx1(axis1)**3) +1./(dx1(axis1)*dx1(axis1p1)**2) )/eps1**2  ! coeff of w1(-1) aLapX0
   a4h(2,2)=  is*( -.5/(dx1(axis1)**3)                                  )/eps1**2  ! coeff of w1(-2) aLapX1

   a4h(2,1)= -js*(  1./(dx2(axis2)**3) +1./(dx2(axis2)*dx2(axis2p1)**2) )/eps2**2  ! coeff of w2(-1) cLapX0 
   a4h(2,3)= -js*( -.5/(dx2(axis2)**3)                                  )/eps2**2  ! coeff of w2(-2) cLapX1

   ! 4 [ lapSq(w)/eps**2 ] = 0   [ w_xxxx + 2 * w_xxyy + w_yyyy ]
   aLapSq0= ( -4./(dx1(axis1)**4) -4./(dx1(axis1)**2 * dx1(axis1p1)**2 ) )
   aLapSq1= (  1./(dx1(axis1)**4) )
   bLapSq0= ( -4./(dx2(axis2)**4) -4./(dx2(axis2)**2 * dx2(axis2p1)**2 ) )
   bLapSq1= (  1./(dx2(axis2)**4) )
   a4h(3,0) = aLapSq0/eps1**2
   a4h(3,2) = aLapSq1/eps1**2
   a4h(3,1) =-bLapSq0/eps2**2
   a4h(3,3) =-bLapSq1/eps2**2

   q(0) = u1(i1-is1,i2-is2,i3,hz)
   q(1) = u2(j1-js1,j2-js2,j3,hz)
   q(2) = u1(i1-2*is1,i2-2*is2,i3,hz)
   q(3) = u2(j1-2*js1,j2-2*js2,j3,hz)

   ! subtract off the contributions from the wrong values at the ghost points:
   do n=0,3
     f(n) = (a4h(n,0)*q(0)+a4h(n,1)*q(1)+a4h(n,2)*q(2)+a4h(n,3)*q(3)) - f(n)
   end do

   ! write(*,'(" a4h=",4(e9.2,1x))') ((a4h(i,j),j=0,3),i=0,3)

   ! factor the matrix
   ! numberOfEquations=4
   call dgeco( a4h(0,0), 4, 4, ipivot4h(0),rcond,work(0))

   ! write(*,'("rcond=",e12.4)') rcond

   ! solve
   job=0
   call dgesl( a4h(0,0), 4, 4, ipivot4h(0), f(0), job)

   if( useJacobiUpdate.eq.0 )then
     u1(i1-  is1,i2-  is2,i3,hz)=f(0)
     u2(j1-  js1,j2-  js2,j3,hz)=f(1)
     u1(i1-2*is1,i2-2*is2,i3,hz)=f(2)
     u2(j1-2*js1,j2-2*js2,j3,hz)=f(3)
   else
     ! Jacobi update -- save answer in work space
     wk1(i1-  is1,i2-  is2,i3,hz)=f(0)
     wk2(j1-  js1,j2-  js2,j3,hz)=f(1)
     wk1(i1-2*is1,i2-2*is2,i3,hz)=f(2)
     wk2(j1-2*js1,j2-2*js2,j3,hz)=f(3)
   end if



!-
!-
!-
!-   q(0) = u1(i1-is1,i2-is2,i3,hz)
!-   q(1) = u2(j1-js1,j2-js2,j3,hz)
!-   q(2) = u1(i1-2*is1,i2-2*is2,i3,hz)
!-   q(3) = u2(j1-2*js1,j2-2*js2,j3,hz)
!-
!-   ! subtract off the contributions from the wrong values at the ghost points:
!-   do n=0,3
!-     f(n) = (a4h(n,0)*q(0)+a4h(n,1)*q(1)+a4h(n,2)*q(2)+a4h(n,3)*q(3)) - f(n)
!-   end do
!-
!-   ! ---- solve  ----
!-   job=0
!-   numberOfEquations=4
!-   call dgesl( a4hf(0,0), numberOfEquations, numberOfEquations, ipivot4h(0), f(0), job)
!-
!-   if( useJacobiUpdate.eq.0 )then
!-     u1(i1-  is1,i2-  is2,i3,hz)=f(0)
!-     u2(j1-  js1,j2-  js2,j3,hz)=f(1)
!-     u1(i1-2*is1,i2-2*is2,i3,hz)=f(2)
!-     u2(j1-2*js1,j2-2*js2,j3,hz)=f(3)
!-   else
!-     ! Jacobi update -- save answer in work space
!-     wk1(i1-  is1,i2-  is2,i3,hz)=f(0)
!-     wk2(j1-  js1,j2-  js2,j3,hz)=f(1)
!-     wk1(i1-2*is1,i2-2*is2,i3,hz)=f(2)
!-     wk2(j1-2*js1,j2-2*js2,j3,hz)=f(3)
!-   end if

   !-   if( .false. .and. debug.gt.0 )then ! re-evaluate
   !-
   !-    call ogderiv(ep, 0,0,0,0, xy1(i1-is1,i2-is2,i3,0),xy1(i1-is1,i2-is2,i3,1),0.,t, hz, we0  )
   !-    call ogderiv(ep, 0,0,0,0, xy1(i1-2*is1,i2-2*is2,i3,0),xy1(i1-2*is1,i2-2*is2,i3,1),0.,t, hz, we1  )
   !-    write(*,'(" w1(-1),w1(-2)=",2e11.3," err=",2e11.3)') f(0),f(2),f(0)-we0,f(2)-we1
   !-
   !-    call ogderiv(ep, 0,0,0,0, xy2(j1-js1,j2-js2,j3,0),xy2(j1-js1,j2-js2,j3,1),0.,t, hz, we2  )
   !-    call ogderiv(ep, 0,0,0,0, xy2(j1-2*js1,j2-2*js2,j3,0),xy2(j1-2*js1,j2-2*js2,j3,1),0.,t, hz, we3  )
   !-    write(*,'(" w2(-1),w2(-2)=",2e11.3," err=",2e11.3)') f(1),f(3),f(1)-we2,f(3)-we3
   !-
   !-    evalMagneticDerivs2dOrder4()
   !-    evalMagneticField2dJumpOrder4()
   !-
   !-    write(*,'(" --> 4r th: i1,i2=",2i4," hz-f(re-eval)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3)
   !-      ! '
   !-
   !-    u1(i1-is1,i2-is2,i3,hz)=we0
   !-    u2(j1-js1,j2-js2,j3,hz)=we2
   !-    u1(i1-2*is1,i2-2*is2,i3,hz)=we1
   !-    u2(j1-2*js1,j2-2*js2,j3,hz)=we3
   !-
   !-   end if


  endLoopsMask2d()
 ! =============== end loops =======================
      

 if( useJacobiUpdate.ne.0 )then
   ! Jacobi-update: now fill in values 
   beginLoopsMask2d() 
     u1(i1-is1,i2-is2,i3,ex)=wk1(i1-is1,i2-is2,i3,ex)
     u1(i1-is1,i2-is2,i3,ey)=wk1(i1-is1,i2-is2,i3,ey)
     u2(j1-js1,j2-js2,j3,ex)=wk2(j1-js1,j2-js2,j3,ex)
     u2(j1-js1,j2-js2,j3,ey)=wk2(j1-js1,j2-js2,j3,ey)

     u1(i1-2*is1,i2-2*is2,i3,ex)=wk1(i1-2*is1,i2-2*is2,i3,ex)
     u1(i1-2*is1,i2-2*is2,i3,ey)=wk1(i1-2*is1,i2-2*is2,i3,ey)
     u2(j1-2*js1,j2-2*js2,j3,ex)=wk2(j1-2*js1,j2-2*js2,j3,ex)
     u2(j1-2*js1,j2-2*js2,j3,ey)=wk2(j1-2*js1,j2-2*js2,j3,ey)

     u1(i1-  is1,i2-  is2,i3,hz)=wk1(i1-  is1,i2-  is2,i3,hz)
     u2(j1-  js1,j2-  js2,j3,hz)=wk2(j1-  js1,j2-  js2,j3,hz)
     u1(i1-2*is1,i2-2*is2,i3,hz)=wk1(i1-2*is1,i2-2*is2,i3,hz)
     u2(j1-2*js1,j2-2*js2,j3,hz)=wk2(j1-2*js1,j2-2*js2,j3,hz)
   endLoopsMask2d()
 end if


   
#endMacro

! --------------------------------------------------------------------------
! Macro: Evaluate the jump conditions in 2D, order=4
! --------------------------------------------------------------------------
#beginMacro eval2dJumpOrder4()
 f(0)=(u1x+v1y) - \
      (u2x+v2y)
 f(1)=(an1*u1Lap+an2*v1Lap) - \
      (an1*u2Lap+an2*v2Lap)
 f(2)=(v1x-u1y) - \
      (v2x-u2y)
 f(3)=(tau1*u1Lap+tau2*v1Lap)/eps1 - \
      (tau1*u2Lap+tau2*v2Lap)/eps2
 f(4)=(u1xxx+u1xyy+v1xxy+v1yyy) - \
      (u2xxx+u2xyy+v2xxy+v2yyy)
 f(5)=((v1xxx+v1xyy)-(u1xxy+u1yyy))/eps1 - \
      ((v2xxx+v2xyy)-(u2xxy+u2yyy))/eps2
 if( setDivergenceAtInterfaces.eq.0 )then
  f(6)=(an1*u1LapSq+an2*v1LapSq)/eps1 - \
        (an1*u2LapSq+an2*v2LapSq)/eps2
 else
  f(6)=(u1x+v1y)
 end if
 f(7)=(tau1*u1LapSq+tau2*v1LapSq)/eps1**2 - \
      (tau1*u2LapSq+tau2*v2LapSq)/eps2**2
     
 if( twilightZone.eq.1 )then
   call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexx )
   call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyy )
   call ogderiv(ep, 0,2,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexx )
   call ogderiv(ep, 0,0,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyy )

   call ogderiv(ep, 0,2,1,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxy )
   call ogderiv(ep, 0,0,3,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyyy )

   call ogderiv(ep, 0,3,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexxx )
   call ogderiv(ep, 0,1,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexyy )

   call ogderiv(ep, 0,4,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxxx )
   call ogderiv(ep, 0,2,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, uexxyy )
   call ogderiv(ep, 0,0,4,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ex, ueyyyy )

   call ogderiv(ep, 0,4,0,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexxxx )
   call ogderiv(ep, 0,2,2,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, vexxyy )
   call ogderiv(ep, 0,0,4,0, xy1(i1,i2,i3,0),xy1(i1,i2,i3,1),0.,t, ey, veyyyy )

   ueLap = uexx + ueyy
   veLap = vexx + veyy
   ueLapSq = uexxxx + 2.*uexxyy + ueyyyy
   veLapSq = vexxxx + 2.*vexxyy + veyyyy

   f(3) = f(3) - ( tau1*ueLap +tau2*veLap )*(1./eps1-1./eps2)
   f(5) = f(5) - ((vexxx+vexyy)-(uexxy+ueyyy))*(1./eps1-1./eps2)
   if( setDivergenceAtInterfaces.eq.0 )then
     f(6) = f(6) - (an1*ueLapSq+an2*veLapSq)*(1./eps1-1./eps2)
   end if
   f(7) = f(7) - (tau1*ueLapSq+tau2*veLapSq)*(1./eps1**2 - 1./eps2**2)
 end if
#endMacro

! here are the macros from deriv.maple (file=derivMacros.h)
! wdh: July 2019 -- these are really 2nd-order accurate approximations: 

#defineMacro lapCoeff4a(is,dr,ds) ( (-2/3.*rxx*is-2/3.*ryy*is)/dr+(4/3.*rx**2+4/3.*ry**2)/dr**2 )

#defineMacro lapCoeff4b(is,dr,ds) ( (1/12.*rxx*is+1/12.*ryy*is)/dr+(-1/12.*rx**2-1/12.*ry**2)/dr**2 )

#defineMacro xLapCoeff4a(is,dr,ds) ( (-1/2.*rxyy*is-1/2.*rxxx*is+(sy*(ry*sx*is+sy*rx*is)+3*rx*sx**2*is+ry*sy*sx*is)/ds**2)/dr+(2*ry*rxy+3*rx*rxx+ryy*rx)/dr**2+(ry**2*rx*is+rx**3*is)/dr**3 )

#defineMacro xLapCoeff4b(is,dr,ds) ( (-1/2.*rx**3*is-1/2.*ry**2*rx*is)/dr**3 )

#defineMacro yLapCoeff4a(is,dr,ds) ( (-1/2.*ryyy*is-1/2.*rxxy*is+(3*ry*sy**2*is+ry*sx**2*is+2*sy*rx*sx*is)/ds**2)/dr+(2*rxy*rx+ry*rxx+3*ry*ryy)/dr**2+(ry**3*is+ry*rx**2*is)/dr**3 )

#defineMacro yLapCoeff4b(is,dr,ds) ( (-1/2.*ry*rx**2*is-1/2.*ry**3*is)/dr**3 )

#defineMacro lapSqCoeff4a(is,dr,ds) ( (-1/2.*rxxxx*is-rxxyy*is-1/2.*ryyyy*is+(2*sy*(2*rxy*sx*is+2*rx*sxy*is)+2*ry*(2*sxy*sx*is+sy*sxx*is)+7*rx*sxx*sx*is+sy*(3*ry*syy*is+3*sy*ryy*is)+sx*(3*rx*sxx*is+3*rxx*sx*is)+sx*(2*rxx*sx*is+2*rx*sxx*is)+2*sy*(2*rx*sxy*is+ry*sxx*is+2*rxy*sx*is+sy*rxx*is)+7*ry*sy*syy*is+rxx*sx**2*is+4*ry*sxy*sx*is+4*syy*rx*sx*is+2*ryy*sx**2*is+ryy*sy**2*is+sy*(2*sy*ryy*is+2*ry*syy*is))/ds**2)/dr+(3*ryy**2+3*rxx**2+4*rxy**2+4*ry*rxxy+4*rx*rxxx+4*ry*ryyy+2*ryy*rxx+4*rx*rxyy+(2*ry*(-4*sy*rx*sx-2*ry*sx**2)-12*ry**2*sy**2+2*sy*(-2*sy*rx**2-4*ry*rx*sx)-12*rx**2*sx**2)/ds**2)/dr**2+(6*ry**2*ryy*is+4*ry*rxy*rx*is+2*ry*(ry*rxx*is+2*rxy*rx*is)+6*rxx*rx**2*is+2*ryy*rx**2*is)/dr**3+(-8*ry**2*rx**2-4*ry**4-4*rx**4)/dr**4 )

#defineMacro lapSqCoeff4b(is,dr,ds) ( (-3*rxx*rx**2*is-ryy*rx**2*is-2*ry*rxy*rx*is-3*ry**2*ryy*is+2*ry*(-rxy*rx*is-1/2.*ry*rxx*is))/dr**3+(rx**4+2*ry**2*rx**2+ry**4)/dr**4 )



! ----------------------------------------------------------------------------------
!  Macro:
!    Evaluate the interface equations for checking the coefficients
! ----------------------------------------------------------------------------------
#beginMacro evalInterfaceEquations24c()
 ! evalDerivs2dOrder4()
 evalDerivs2dOrder4()
 ! first evaluate the equations we want to solve with the wrong values at the ghost points:
 eval2dJumpOrder4() 
#endMacro

! --------------------------------------------------------------------------
! Macro: Assign interface ghost values, DIM=2, ORDER=4, GRID=Curvilinear
! 
! --------------------------------------------------------------------------
#beginMacro assignInterfaceGhost24c()

 ! ****************************************************
 ! ***********  2D, ORDER=4, CURVILINEAR **************
 ! ****************************************************

 if( .true. .or. t.le.5*dt .or. debug.gt.3 )then
   write(*,'("macro: assignInterfaceGhost24c : t,dt=",2e10.2)') t,dt
 end if


 err=0.
 nn=-1 ! counts points on the interface
 ! =============== start loops ======================
 beginLoopsMask2d() 

     nn=nn+1

     ! here is the normal (assumed to be the same on both sides)
     an1=rsxy1(i1,i2,i3,axis1,0)   ! normal (an1,an2)
     an2=rsxy1(i1,i2,i3,axis1,1)
     aNorm=max(epsx,sqrt(an1**2+an2**2))
     an1=an1/aNorm
     an2=an2/aNorm
     tau1=-an2
     tau2= an1

     ! evalDerivs2dOrder4()
     evalDerivs2dOrder4()
     ! first evaluate the equations we want to solve with the wrong values at the ghost points:
     eval2dJumpOrder4()


     if( debug.gt.7 ) write(debugFile,'(" --> 4cth: j1,j2=",2i4," u1xx,u1yy,u2xx,u2yy=",4e10.2)') j1,j2,u1xx,\
     u1yy,u2xx,u2yy
     ! '
      if( debug.gt.3 ) write(debugFile,'(" --> 4cth: i1,i2=",2i4," f(start)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7)
     ! '



     ! here is the matrix of coefficients for the unknowns u1(-1),v1(-1),u2(-1),v2(-1)
     ! Solve:
     !     
     !       A [ U ] = A [ U(old) ] - [ f ]
     !      u1r4(i1,i2,i3,kd)=(8.*(u1(i1+1,i2,i3,kd)-u1(i1-1,i2,i3,kd))-(u1(
     !     & i1+2,i2,i3,kd)-u1(i1-2,i2,i3,kd)))*dr114(0)
     !      u1x42(i1,i2,i3,kd)= rsxy1(i1,i2,i3,0,0)*u1r4(i1,i2,i3,kd)+rsxy1(
     !     & i1,i2,i3,1,0)*u1s4(i1,i2,i3,kd)
     !      u1y42(i1,i2,i3,kd)= rsxy1(i1,i2,i3,0,1)*u1r4(i1,i2,i3,kd)+rsxy1(
     !     & i1,i2,i3,1,1)*u1s4(i1,i2,i3,kd)
     !          a4(0,0) = -is*rsxy1(i1,i2,i3,axis1,0)/(2.*dr1(axis1))    ! coeff of u1(-1) from [u.x+v.y] 
     !          a4(0,1) = -is*rsxy1(i1,i2,i3,axis1,1)/(2.*dr1(axis1))    ! coeff of v1(-1) from [u.x+v.y] 
     !
     !          a4(2,0) =  is*rsxy1(i1,i2,i3,axis1,1)/(2.*dr1(axis1))   ! coeff of u1(-1) from [v.x - u.y] 
     !          a4(2,1) = -is*rsxy1(i1,i2,i3,axis1,0)/(2.*dr1(axis1))   ! coeff of v1(-1) from [v.x - u.y] 
     !
     !          a4(0,2) =  js*rsxy2(j1,j2,j3,axis2,0)/(2.*dr2(axis2))    ! coeff of u2(-1) from [u.x+v.y] 
     !          a4(0,3) =  js*rsxy2(j1,j2,j3,axis2,1)/(2.*dr2(axis2))    ! coeff of v2(-1) from [u.x+v.y] 
     !
     !          a4(2,2) = -js*rsxy2(j1,j2,j3,axis2,1)/(2.*dr2(axis2))   ! coeff of u2(-1) from [v.x - u.y] 
     !          a4(2,3) =  js*rsxy2(j1,j2,j3,axis2,0)/(2.*dr2(axis2))   ! coeff of v2(-1) from [v.x - u.y] 


     ! write(debugFile,'(" interface:E: initialized,it=",2i4)') initialized,it
     if( .false. .or. (initialized.eq.0 .and. it.eq.1) )then
       ! form the matrix (and save factor for later use)

       ! Equation 0: 
       ! 0  [ u.x + v.y ] = 0
       aa8(0,0,0,nn) = -is*8.*rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)     ! coeff of u1(-1) from [u.x+v.y] 
       aa8(0,1,0,nn) = -is*8.*rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)     ! coeff of v1(-1) from [u.x+v.y] 
       aa8(0,4,0,nn) =  is*   rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)     ! u1(-2)
       aa8(0,5,0,nn) =  is*   rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)     ! v1(-2) 

       aa8(0,2,0,nn) =  js*8.*rsxy2(j1,j2,j3,axis2,0)*dr214(axis2)     ! coeff of u2(-1) from [u.x+v.y] 
       aa8(0,3,0,nn) =  js*8.*rsxy2(j1,j2,j3,axis2,1)*dr214(axis2)  
       aa8(0,6,0,nn) = -js*   rsxy2(j1,j2,j3,axis2,0)*dr214(axis2) 
       aa8(0,7,0,nn) = -js*   rsxy2(j1,j2,j3,axis2,1)*dr214(axis2)  

     ! 1  [ u.xx + u.yy ] = 0
     ! this macro comes from deriv.maple
     ! return the coefficient of u(-1) in uxxx+uxyy
     !#defineMacro lapCoeff4a(is,dr,ds) ((-1/3.*rxx*is-1/3.*ryy*is)/dr+(4/3.*rx**2+4/3.*ry**2)/dr**2)
     
     ! return the coefficient of u(-2) in uxxx+uxyy
     !#defineMacro lapCoeff4b(is,dr,ds) ((1/24.*rxx*is+1/24.*ryy*is)/dr+(-1/12.*rx**2-1/12.*ry**2)/dr**2 )

       ! optimize me ** June 27, 2016: 
       setJacobian( aj1, axis1)

       dr0=dr1(axis1)
       ds0=dr1(axis1p1)
       aLap0 = lapCoeff4a(is,dr0,ds0)
       aLap1 = lapCoeff4b(is,dr0,ds0)

       setJacobian( aj2, axis2)
       dr0=dr2(axis2)
       ds0=dr2(axis2p1)
       bLap0 = lapCoeff4a(js,dr0,ds0)
       bLap1 = lapCoeff4b(js,dr0,ds0)

      if( debug.gt.8 )then
       aa8(1,0,0,nn) = 16.*dx142(axis1)         ! coeff of u1(-1) from [u.xx + u.yy]
       aa8(1,4,0,nn) =    -dx142(axis1)         ! coeff of u1(-2) from [u.xx + u.yy]
        write(debugFile,'(" 4th: lap4: aLap0: rect=",e12.4," curv=",e12.4)') aLap0,aa8(1,0,0,nn)
        ! '
        write(debugFile,'(" 4th: lap4: aLap1: rect=",e12.4," curv=",e12.4)') aLap1,aa8(1,4,0,nn)
        ! '
      end if

      ! Equation 1:
      aa8(1,0,0,nn) = an1*aLap0       ! coeff of u1(-1) from [n.(u.xx + u.yy)]
      aa8(1,1,0,nn) = an2*aLap0 
      aa8(1,4,0,nn) = an1*aLap1       ! coeff of u1(-2) from [n.(u.xx + u.yy)]
      aa8(1,5,0,nn) = an2*aLap1  
       
      aa8(1,2,0,nn) =-an1*bLap0       ! coeff of u2(-1) from [n.(u.xx + u.yy)]
      aa8(1,3,0,nn) =-an2*bLap0
      aa8(1,6,0,nn) =-an1*bLap1       ! coeff of u2(-2) from [n.(u.xx + u.yy)]
      aa8(1,7,0,nn) =-an2*bLap1

      ! Equation 2: 
      ! 2  [ v.x - u.y ] =0 
      !          a8(2,0) =  is*8.*ry1*dx114(axis1)
      !          a8(2,1) = -is*8.*rx1*dx114(axis1)    ! coeff of v1(-1) from [v.x - u.y] 
      !          a8(2,4) = -is*   ry1*dx114(axis1)
      !          a8(2,5) =  is*   rx1*dx114(axis1)
      !          a8(2,2) = -js*8.*ry2*dx214(axis2)
      !          a8(2,3) =  js*8.*rx2*dx214(axis2)
      !          a8(2,6) =  js*   ry2*dx214(axis2)
      !          a8(2,7) = -js*   rx2*dx214(axis2)

       aa8(2,0,0,nn) =  is*8.*rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)    
       aa8(2,1,0,nn) = -is*8.*rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)    
       aa8(2,4,0,nn) = -is*   rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)       
       aa8(2,5,0,nn) =  is*   rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)       

       aa8(2,2,0,nn) = -js*8.*rsxy2(j1,j2,j3,axis2,1)*dr214(axis2)  
       aa8(2,3,0,nn) =  js*8.*rsxy2(j1,j2,j3,axis2,0)*dr214(axis2)    
       aa8(2,6,0,nn) =  js*   rsxy2(j1,j2,j3,axis2,1)*dr214(axis2)  
       aa8(2,7,0,nn) = -js*   rsxy2(j1,j2,j3,axis2,0)*dr214(axis2) 

       ! 3  [ tau.(uv.xx+uv.yy)/eps ] = 0
       aa8(3,0,0,nn) =tau1*aLap0/eps1
       aa8(3,1,0,nn) =tau2*aLap0/eps1
       aa8(3,4,0,nn) =tau1*aLap1/eps1
       aa8(3,5,0,nn) =tau2*aLap1/eps1

       aa8(3,2,0,nn) =-tau1*bLap0/eps2
       aa8(3,3,0,nn) =-tau2*bLap0/eps2
       aa8(3,6,0,nn) =-tau1*bLap1/eps2
       aa8(3,7,0,nn) =-tau2*bLap1/eps2


       ! 4  [ (u.xx+u.yy).x + (v.xx+v.yy).y ] = 0

      setJacobian( aj1, axis1)

      ! dr1a(0:2) = dsBig in tangential directions if avoidInterfaceIterations=1
      dr0=dr1a(axis1)
      ds0=dr1a(axis1p1)
      ! if( avoidInterfaceIterations.eq.1 )then
       ! lag cross terms (do not put into the matrix)
      !  ds0=dsBig
      ! end if
      aLapX0 = xLapCoeff4a(is,dr0,ds0)
      aLapX1 = xLapCoeff4b(is,dr0,ds0)

      bLapY0 = yLapCoeff4a(is,dr0,ds0)
      bLapY1 = yLapCoeff4b(is,dr0,ds0)

      setJacobian( aj2, axis2)

      ! dr2a(0:2) = dsBig in tangential directions if avoidInterfaceIterations=1
      dr0=dr2a(axis2)
      ds0=dr2a(axis2p1)
      ! if( avoidInterfaceIterations.eq.1 )then
       ! lag cross terms (do not put into the matrix)
      !  ds0=dsBig
      ! end if
      cLapX0 = xLapCoeff4a(js,dr0,ds0)
      cLapX1 = xLapCoeff4b(js,dr0,ds0)

      dLapY0 = yLapCoeff4a(js,dr0,ds0)
      dLapY1 = yLapCoeff4b(js,dr0,ds0)


      ! 4  [ (u.xx+u.yy).x + (v.xx+v.yy).y ] = 0
      if( debug.gt.8 )then
      aa8(4,0,0,nn)= ( is*rx1*2.*dx122(axis1)*dx112(axis1)+is*rx1*2.*dx122(1)/(2.*dx1(0)))
      aa8(4,1,0,nn)= ( is*ry1*2.*dx122(axis1)*dx112(axis1)+is*ry1*2.*dx122(0)/(2.*dx1(1)))
      aa8(4,4,0,nn)= (-is*rx1   *dx122(axis1)*dx112(axis1) )  
      aa8(4,5,0,nn)= (-is*ry1   *dx122(axis1)*dx112(axis1))
        write(debugFile,'(" 4th: xlap4: aLapX0: rect=",e12.4," curv=",e12.4)') aLapX0,aa8(4,0,0,nn)
        write(debugFile,'(" 4th: xlap4: aLapX1: rect=",e12.4," curv=",e12.4)') aLapX1,aa8(4,4,0,nn)
        write(debugFile,'(" 4th: ylap4: bLapY0: rect=",e12.4," curv=",e12.4)') bLapY0,aa8(4,1,0,nn)
        write(debugFile,'(" 4th: ylap4: bLapY1: rect=",e12.4," curv=",e12.4)') bLapY1,aa8(4,5,0,nn)
        ! '
      end if

      aa8(4,0,0,nn)= aLapX0
      aa8(4,1,0,nn)= bLapY0
      aa8(4,4,0,nn)= aLapX1
      aa8(4,5,0,nn)= bLapY1

      aa8(4,2,0,nn)=-cLapX0
      aa8(4,3,0,nn)=-dLapY0
      aa8(4,6,0,nn)=-cLapX1
      aa8(4,7,0,nn)=-dLapY1

      ! 5  [ {(Delta v).x - (Delta u).y}/eps ] =0  -> [ {(v.xxx+v.xyy)-(u.xxy+u.yyy)}/eps ] = 0

      aa8(5,0,0,nn)=-bLapY0/eps1
      aa8(5,1,0,nn)= aLapX0/eps1
      aa8(5,4,0,nn)=-bLapY1/eps1
      aa8(5,5,0,nn)= aLapX1/eps1

      aa8(5,2,0,nn)= dLapY0/eps2
      aa8(5,3,0,nn)=-cLapX0/eps2
      aa8(5,6,0,nn)= dLapY1/eps2
      aa8(5,7,0,nn)=-cLapX1/eps2


       ! 6  [ n.Delta^2 u/eps ] = 0

       ! assign rx,ry,rxx,rxy,... 

       setJacobian( aj1, axis1)

       ! dr1a(0:2) = dsBig in tangential directions if avoidInterfaceIterations=1
       dr0=dr1a(axis1)
       ds0=dr1a(axis1p1)
       ! if( avoidInterfaceIterations.eq.1 )then
        ! lag cross terms (do not put into the matrix)
       !  ds0=dsBig
       ! end if
       aLapSq0 = lapSqCoeff4a(is,dr0,ds0)
       aLapSq1 = lapSqCoeff4b(is,dr0,ds0)

       if( debug.gt.8 )then
         aa8(6,0,0,nn) = -(4./(dx1(axis1)**4) +4./(dx1(0)**2*dx1(1)**2) )
         aa8(6,4,0,nn) =   1./(dx1(axis1)**4)
         write(debugFile,'(" 4th: lapSq: aLapSq0: rect=",e12.4," curv=",e12.4)') aLapSq0,aa8(6,0,0,nn)
         ! '
         write(debugFile,'(" 4th: lapSq: aLapSq1: rect=",e12.4," curv=",e12.4)') aLapSq1,aa8(6,4,0,nn)
         ! '
       end if

       if( setDivergenceAtInterfaces.eq.0 )then
        aa8(6,0,0,nn) = an1*aLapSq0/eps1
        aa8(6,1,0,nn) = an2*aLapSq0/eps1
        aa8(6,4,0,nn) = an1*aLapSq1/eps1
        aa8(6,5,0,nn) = an2*aLapSq1/eps1 
       end if

       setJacobian( aj2, axis2)

       ! dr2a(0:2) = dsBig in tangential directions if avoidInterfaceIterations=1
       dr0=dr2a(axis2)
       ds0=dr2a(axis2p1)
       ! if( avoidInterfaceIterations.eq.1 )then
       !  ! lag cross terms (do not put into the matrix)
       !  ds0=dsBig
       ! end if
       bLapSq0 = lapSqCoeff4a(js,dr0,ds0)
       bLapSq1 = lapSqCoeff4b(js,dr0,ds0)

       if( setDivergenceAtInterfaces.eq.0 )then
        aa8(6,2,0,nn) = -an1*bLapSq0/eps2
        aa8(6,3,0,nn) = -an2*bLapSq0/eps2
        aa8(6,6,0,nn) = -an1*bLapSq1/eps2
        aa8(6,7,0,nn) = -an2*bLapSq1/eps2
       end if

       if( setDivergenceAtInterfaces.eq.1 )then
         ! Set div(E)=0 
        aa8(6,0,0,nn) = -is*8.*rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)     ! coeff of u1(-1) from [u.x+v.y] 
        aa8(6,1,0,nn) = -is*8.*rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)     ! coeff of v1(-1) from [u.x+v.y] 
        aa8(6,4,0,nn) =  is*   rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)     ! u1(-2)
        aa8(6,5,0,nn) =  is*   rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)     ! v1(-2) 

        aa8(6,2,0,nn) = 0.
        aa8(6,3,0,nn) = 0.
        aa8(6,6,0,nn) = 0.
        aa8(6,7,0,nn) = 0.
       end if 

       ! 7  [ tau.Delta^2 v/eps^2 ] = 0 
       aa8(7,0,0,nn) = tau1*aLapSq0/eps1**2
       aa8(7,1,0,nn) = tau2*aLapSq0/eps1**2
       aa8(7,4,0,nn) = tau1*aLapSq1/eps1**2
       aa8(7,5,0,nn) = tau2*aLapSq1/eps1**2

       aa8(7,2,0,nn) = -tau1*bLapSq0/eps2**2
       aa8(7,3,0,nn) = -tau2*bLapSq0/eps2**2
       aa8(7,6,0,nn) = -tau1*bLapSq1/eps2**2
       aa8(7,7,0,nn) = -tau2*bLapSq1/eps2**2

       ! save a copy of the matrix
       do n2=0,7
       do n1=0,7
         aa8(n1,n2,1,nn)=aa8(n1,n2,0,nn)
       end do
       end do

       numberOfEquations=8

       ! --- check matrix coefficients by delta function approach ----
       !- comment out to speed up compilation 
       !- if( checkCoeff.eq.1 )then
       !-  do n2=0,7
       !-  do n1=0,7
       !-    a8(n1,n2)=aa8(n1,n2,0,nn)
       !-  end do
       !-  end do                
       !-  checkCoefficients(i1,i2,i3, j1,j2,j3,numberOfEquations,a8,evalInterfaceEquations24c )
       !- end if

       if( saveCoeff.eq.1 )then
        ! Macro from interfaceMacros.h : 
        saveCoefficients(i1,i2,i3, j1,j2,j3,numberOfEquations,am,evalInterfaceEquations24c )
       end if

       ! solve A Q = F
       ! factor the matrix
       call dgeco( aa8(0,0,0,nn), numberOfEquations, numberOfEquations, ipvt8(0,nn),rcond,work(0))

       if( debug.gt.3 ) write(debugFile,'(" --> 4cth: i1,i2=",2i4," rcond=",e10.2)') i1,i2,rcond
       ! '
     end if


     q(0) = u1(i1-is1,i2-is2,i3,ex)
     q(1) = u1(i1-is1,i2-is2,i3,ey)
     q(2) = u2(j1-js1,j2-js2,j3,ex)
     q(3) = u2(j1-js1,j2-js2,j3,ey)

     q(4) = u1(i1-2*is1,i2-2*is2,i3,ex)
     q(5) = u1(i1-2*is1,i2-2*is2,i3,ey)
     q(6) = u2(j1-2*js1,j2-2*js2,j3,ex)
     q(7) = u2(j1-2*js1,j2-2*js2,j3,ey)

      if( debug.gt.4 ) write(debugFile,'(" --> 4cth: i1,i2=",2i4," q=",8e10.2)') i1,i2,(q(n),n=0,7)

     ! subtract off the contributions from the initial (wrong) values at the ghost points:
     do n=0,7
       f(n) = (aa8(n,0,1,nn)*q(0)+aa8(n,1,1,nn)*q(1)+aa8(n,2,1,nn)*q(2)+aa8(n,3,1,nn)*q(3)+\
               aa8(n,4,1,nn)*q(4)+aa8(n,5,1,nn)*q(5)+aa8(n,6,1,nn)*q(6)+aa8(n,7,1,nn)*q(7)) - f(n)
     end do

                          ! '

     ! solve A Q = F
     job=0
     numberOfEquations=8
     call dgesl( aa8(0,0,0,nn), numberOfEquations, numberOfEquations, ipvt8(0,nn), f(0), job)

     if( debug.gt.4 )then
      write(debugFile,'(" --> 4cth: i1,i2=",2i4," f(solve)=",8e10.2)') i1,i2,(f(n),n=0,7)
      write(debugFile,'(" --> 4cth: i1,i2=",2i4,"      f-q=",8e10.2)') i1,i2,(f(n)-q(n),n=0,7)
     end if
     ! '

     if( useJacobiUpdate.eq.0 )then
       u1(i1-is1,i2-is2,i3,ex)=(1.-omega)*u1(i1-is1,i2-is2,i3,ex) + omega*f(0)
       u1(i1-is1,i2-is2,i3,ey)=(1.-omega)*u1(i1-is1,i2-is2,i3,ey) + omega*f(1)
       u2(j1-js1,j2-js2,j3,ex)=(1.-omega)*u2(j1-js1,j2-js2,j3,ex) + omega*f(2)
       u2(j1-js1,j2-js2,j3,ey)=(1.-omega)*u2(j1-js1,j2-js2,j3,ey) + omega*f(3)

       u1(i1-2*is1,i2-2*is2,i3,ex)=(1.-omega)*u1(i1-2*is1,i2-2*is2,i3,ex) + omega*f(4)
       u1(i1-2*is1,i2-2*is2,i3,ey)=(1.-omega)*u1(i1-2*is1,i2-2*is2,i3,ey) + omega*f(5)
       u2(j1-2*js1,j2-2*js2,j3,ex)=(1.-omega)*u2(j1-2*js1,j2-2*js2,j3,ex) + omega*f(6)
       u2(j1-2*js1,j2-2*js2,j3,ey)=(1.-omega)*u2(j1-2*js1,j2-2*js2,j3,ey) + omega*f(7)
     else
       ! Jacobi-update
       wk1(i1-is1,i2-is2,i3,ex)=(1.-omega)*u1(i1-is1,i2-is2,i3,ex) + omega*f(0)
       wk1(i1-is1,i2-is2,i3,ey)=(1.-omega)*u1(i1-is1,i2-is2,i3,ey) + omega*f(1)
       wk2(j1-js1,j2-js2,j3,ex)=(1.-omega)*u2(j1-js1,j2-js2,j3,ex) + omega*f(2)
       wk2(j1-js1,j2-js2,j3,ey)=(1.-omega)*u2(j1-js1,j2-js2,j3,ey) + omega*f(3)

       wk1(i1-2*is1,i2-2*is2,i3,ex)=(1.-omega)*u1(i1-2*is1,i2-2*is2,i3,ex) + omega*f(4)
       wk1(i1-2*is1,i2-2*is2,i3,ey)=(1.-omega)*u1(i1-2*is1,i2-2*is2,i3,ey) + omega*f(5)
       wk2(j1-2*js1,j2-2*js2,j3,ex)=(1.-omega)*u2(j1-2*js1,j2-2*js2,j3,ex) + omega*f(6)
       wk2(j1-2*js1,j2-2*js2,j3,ey)=(1.-omega)*u2(j1-2*js1,j2-2*js2,j3,ey) + omega*f(7)
     end if

     ! compute the maximum change in the solution for this iteration
     do n=0,7
       err=max(err,abs(q(n)-f(n)))
     end do

    if( debug.gt.0 )then ! re-evaluate

     evalDerivs2dOrder4()
     eval2dJumpOrder4()

     if( debug.gt.3 ) write(debugFile,'(" --> 4cth: i1,i2=",2i4," f(re-eval)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7)
       ! '
    end if

     ! ******************************************************
     ! solve for Hz
     !  [ w.n/eps ] = 0
     !  [ lap(w)/eps ] = 0
     !  [ lap(w).n/eps**2 ] = 0
     !  [ lapSq(w)/eps**2 ] = 0

     ! first evaluate the equations we want to solve with the wrong values at the ghost points:
     evalMagneticDerivs2dOrder4()
     evalMagneticField2dJumpOrder4()

     if( .false. .or. (initialized.eq.0 .and. it.eq.1) )then
       ! form the matrix for computing Hz (and save factor for later use)

       ! 1: [ w.n/eps ] = 0
       a0 = (an1*rsxy1(i1,i2,i3,axis1,0)+an2*rsxy1(i1,i2,i3,axis1,1))*dr114(axis1)/eps1
       b0 = (an1*rsxy2(j1,j2,j3,axis2,0)+an2*rsxy2(j1,j2,j3,axis2,1))*dr214(axis2)/eps2
       aa4(0,0,0,nn) = -is*8.*a0
       aa4(0,2,0,nn) =  is*   a0
       aa4(0,1,0,nn) =  js*8.*b0
       aa4(0,3,0,nn) = -js*   b0

       ! 2: [ lap(w)/eps ] = 0 
       aa4(1,0,0,nn) = aLap0/eps1
       aa4(1,2,0,nn) = aLap1/eps1
       aa4(1,1,0,nn) =-bLap0/eps2
       aa4(1,3,0,nn) =-bLap1/eps2

       ! 3  [ (an1*(w.xx+w.yy).x + an2.(w.xx+w.yy).y)/eps**2 ] = 0
       aa4(2,0,0,nn)= (an1*aLapX0+an2*bLapY0)/eps1**2
       aa4(2,2,0,nn)= (an1*aLapX1+an2*bLapY1)/eps1**2
       aa4(2,1,0,nn)=-(an1*cLapX0+an2*dLapY0)/eps2**2
       aa4(2,3,0,nn)=-(an1*cLapX1+an2*dLapY1)/eps2**2

       ! 4 [ lapSq(w)/eps**2 ] = 0 
       aa4(3,0,0,nn) = aLapSq0/eps1**2
       aa4(3,2,0,nn) = aLapSq1/eps1**2
       aa4(3,1,0,nn) =-bLapSq0/eps2**2
       aa4(3,3,0,nn) =-bLapSq1/eps2**2

       ! save a copy of the matrix
       do n2=0,3
       do n1=0,3
         aa4(n1,n2,1,nn)=aa4(n1,n2,0,nn)
       end do
       end do

       ! factor the matrix
       numberOfEquations=4
       call dgeco( aa4(0,0,0,nn), numberOfEquations, numberOfEquations, ipvt4(0,nn),rcond,work(0))
     end if

     q(0) = u1(i1-is1,i2-is2,i3,hz)
     q(1) = u2(j1-js1,j2-js2,j3,hz)
     q(2) = u1(i1-2*is1,i2-2*is2,i3,hz)
     q(3) = u2(j1-2*js1,j2-2*js2,j3,hz)

     ! subtract off the contributions from the wrong values at the ghost points:
     do n=0,3
       f(n) = (aa4(n,0,1,nn)*q(0)+aa4(n,1,1,nn)*q(1)+aa4(n,2,1,nn)*q(2)+aa4(n,3,1,nn)*q(3)) - f(n)
     end do
     ! solve
     numberOfEquations=4
     job=0
     call dgesl( aa4(0,0,0,nn), numberOfEquations, numberOfEquations, ipvt4(0,nn), f(0), job)

     if( useJacobiUpdate.eq.0 )then
       u1(i1-  is1,i2-  is2,i3,hz)=(1.-omega)*u1(i1-  is1,i2-  is2,i3,hz) + omega*f(0)
       u2(j1-  js1,j2-  js2,j3,hz)=(1.-omega)*u2(j1-  js1,j2-  js2,j3,hz) + omega*f(1)
       u1(i1-2*is1,i2-2*is2,i3,hz)=(1.-omega)*u1(i1-2*is1,i2-2*is2,i3,hz) + omega*f(2)
       u2(j1-2*js1,j2-2*js2,j3,hz)=(1.-omega)*u2(j1-2*js1,j2-2*js2,j3,hz) + omega*f(3)
     else
       ! Jacobi update -- save answer in work space
       wk1(i1-  is1,i2-  is2,i3,hz)=(1.-omega)*u1(i1-  is1,i2-  is2,i3,hz) + omega*f(0)
       wk2(j1-  js1,j2-  js2,j3,hz)=(1.-omega)*u2(j1-  js1,j2-  js2,j3,hz) + omega*f(1)
       wk1(i1-2*is1,i2-2*is2,i3,hz)=(1.-omega)*u1(i1-2*is1,i2-2*is2,i3,hz) + omega*f(2)
       wk2(j1-2*js1,j2-2*js2,j3,hz)=(1.-omega)*u2(j1-2*js1,j2-2*js2,j3,hz) + omega*f(3)
     end if

    ! compute the maximum change in the solution for this iteration
    do n=0,3
      err=max(err,abs(q(n)-f(n)))
    end do

    if( debug.gt.0 )then ! re-evaluate

     evalMagneticDerivs2dOrder4()
     evalMagneticField2dJumpOrder4()

     if( debug.gt.3 ) write(debugFile,'(" --> 4cth: i1,i2=",2i4," hz-f(re-eval)=",8e10.2)') i1,i2,f(0),f(1),f(2),f(3)
       ! '
    end if



     ! ***********************

     ! u1(i1-is1,i2-is2,i3,hz)=u2(j1+js1,j2+js2,j3,hz) 
     ! u2(j1-js1,j2-js2,j3,hz)=u1(i1+is1,i2+is2,i3,hz)
     ! u1(i1-2*is1,i2-2*is2,i3,hz)=u2(j1+2*js1,j2+2*js2,j3,hz) 
     ! u2(j1-2*js1,j2-2*js2,j3,hz)=u1(i1+2*is1,i2+2*is2,i3,hz)

 endLoopsMask2d()
 ! =============== end loops =======================
      
  if( checkCoeff.eq.1 )then
    write(*,'("+++++ I24c: check coeff in interface: max(diff) = ",1pe8.2)') coeffDiff
  end if


 if( useJacobiUpdate.ne.0 )then
   ! Jacobi-update: now fill in values 
   beginLoopsMask2d() 
     u1(i1-is1,i2-is2,i3,ex)=wk1(i1-is1,i2-is2,i3,ex)
     u1(i1-is1,i2-is2,i3,ey)=wk1(i1-is1,i2-is2,i3,ey)
     u2(j1-js1,j2-js2,j3,ex)=wk2(j1-js1,j2-js2,j3,ex)
     u2(j1-js1,j2-js2,j3,ey)=wk2(j1-js1,j2-js2,j3,ey)

     u1(i1-2*is1,i2-2*is2,i3,ex)=wk1(i1-2*is1,i2-2*is2,i3,ex)
     u1(i1-2*is1,i2-2*is2,i3,ey)=wk1(i1-2*is1,i2-2*is2,i3,ey)
     u2(j1-2*js1,j2-2*js2,j3,ex)=wk2(j1-2*js1,j2-2*js2,j3,ex)
     u2(j1-2*js1,j2-2*js2,j3,ey)=wk2(j1-2*js1,j2-2*js2,j3,ey)

     u1(i1-  is1,i2-  is2,i3,hz)=wk1(i1-  is1,i2-  is2,i3,hz)
     u2(j1-  js1,j2-  js2,j3,hz)=wk2(j1-  js1,j2-  js2,j3,hz)
     u1(i1-2*is1,i2-2*is2,i3,hz)=wk1(i1-2*is1,i2-2*is2,i3,hz)
     u2(j1-2*js1,j2-2*js2,j3,hz)=wk2(j1-2*js1,j2-2*js2,j3,hz)
   endLoopsMask2d()
 end if

#endMacro


! --------------------------------------------------------------------------
! Macro: EXTRAPOLATE interface ghost values, DIM=2, ORDER=2
! --------------------------------------------------------------------------
#beginMacro extrapolateGhost2dOrder2()
  if( solveForE.ne.0 )then
   beginGhostLoops2d()
     u1(i1-is1,i2-is2,i3,ex)=extrap3(u1,i1,i2,i3,ex,is1,is2,is3)
     u1(i1-is1,i2-is2,i3,ey)=extrap3(u1,i1,i2,i3,ey,is1,is2,is3)
     u1(i1-is1,i2-is2,i3,hz)=extrap3(u1,i1,i2,i3,hz,is1,is2,is3)


     u2(j1-js1,j2-js2,j3,ex)=extrap3(u2,j1,j2,j3,ex,js1,js2,js3)
     u2(j1-js1,j2-js2,j3,ey)=extrap3(u2,j1,j2,j3,ey,js1,js2,js3)
     u2(j1-js1,j2-js2,j3,hz)=extrap3(u2,j1,j2,j3,hz,js1,js2,js3)

     if( dispersive.ne.noDispersion )then
      do jv=0,numberOfPolarizationVectors1-1
        do n=0,nd-1
          pc = n + jv*nd 
          p1(i1-is1,i2-is2,i3,pc)=extrap3(p1,i1,i2,i3,pc,is1,is2,is3)
        end do
      end do
      do jv=0,numberOfPolarizationVectors2-1
        do n=0,nd-1
          pc = n + jv*nd 
          p2(j1-js1,j2-js2,j3,pc)=extrap3(p2,j1,j2,j3,pc,js1,js2,js3)
        end do
      end do
     end if

    if (nonlinearModel1 .ne. noNonlinearModel) then

      do na = 0,numberOfAtomicLevels1-1
        q1(i1  -is1,i2  -is2,i3,na)=extrap3(q1,i1    ,i2    ,i3,na,is1,is2,is3)
        q1(i1-2*is1,i2-2*is2,i3,na)=extrap3(q1,i1-is1,i2-is2,i3,na,is1,is2,is3)
      enddo
    end if
    
    if (nonlinearModel2 .ne. noNonlinearModel) then
      do na = 0,numberOfAtomicLevels2-1
        q2(j1  -js1,j2  -js2,j3,na)=extrap3(q2,j1    ,j2    ,j3,na,js1,js2,js3)
        q2(j1-2*js1,j2-2*js2,j3,na)=extrap3(q2,j1-js1,j2-js2,j3,na,js1,js2,js3)
      enddo
    endif
   endLoops2d()

  end if
#endMacro

! --------------------------------------------------------------------------
! Macro: EXTRAPOLATE interface ghost values, DIM=2, ORDER=2=4
! --------------------------------------------------------------------------
#beginMacro extrapolateGhost2dOrder4()
if( .true. )then
 beginGhostLoops2d()

  ! ---- extrapolate to order 5 -----

  ! extrap to order 5 so exact for degree 4 *wdh* 2015/06/29
  u1(i1-is1,i2-is2,i3,ex)=extrap5(u1,i1,i2,i3,ex,is1,is2,is3)
  u1(i1-is1,i2-is2,i3,ey)=extrap5(u1,i1,i2,i3,ey,is1,is2,is3)
  u1(i1-is1,i2-is2,i3,hz)=extrap5(u1,i1,i2,i3,hz,is1,is2,is3)

  u2(j1-js1,j2-js2,j3,ex)=extrap5(u2,j1,j2,j3,ex,js1,js2,js3)
  u2(j1-js1,j2-js2,j3,ey)=extrap5(u2,j1,j2,j3,ey,js1,js2,js3)
  u2(j1-js1,j2-js2,j3,hz)=extrap5(u2,j1,j2,j3,hz,js1,js2,js3)

  ! --- also extrap 2nd line for now
  u1(i1-2*is1,i2-2*is2,i3,ex)=extrap5(u1,i1-is1,i2-is2,i3,ex,is1,is2,is3)
  u1(i1-2*is1,i2-2*is2,i3,ey)=extrap5(u1,i1-is1,i2-is2,i3,ey,is1,is2,is3)
  u1(i1-2*is1,i2-2*is2,i3,hz)=extrap5(u1,i1-is1,i2-is2,i3,hz,is1,is2,is3)

  u2(j1-2*js1,j2-2*js2,j3,ex)=extrap5(u2,j1-js1,j2-js2,j3,ex,js1,js2,js3)
  u2(j1-2*js1,j2-2*js2,j3,ey)=extrap5(u2,j1-js1,j2-js2,j3,ey,js1,js2,js3)
  u2(j1-2*js1,j2-2*js2,j3,hz)=extrap5(u2,j1-js1,j2-js2,j3,hz,js1,js2,js3)

  if( dispersive.ne.noDispersion )then
   do jv=0,numberOfPolarizationVectors1-1
     do n=0,nd-1
       pc = n + jv*nd 
       p1(i1  -is1,i2  -is2,i3,pc)=extrap5(p1,i1    ,i2    ,i3,pc,is1,is2,is3)
       p1(i1-2*is1,i2-2*is2,i3,pc)=extrap5(p1,i1-is1,i2-is2,i3,pc,is1,is2,is3)

       if( .false. .and. twilightZone.eq.1 )then
         ! *** TEST ****
         ! call ogderiv(ep, 0,0,0,0, xy1(i1      ,i2      ,i3,0),xy1(i1      ,i2      ,i3,1),0.,t,pc+pxc, p1(i1      ,i2      ,i3,pc)   )
         call ogderiv(ep, 0,0,0,0, xy1(i1-  is1,i2-  is2,i3,0),xy1(i1-  is1,i2-  is2,i3,1),0.,t,pc+pxc, p1(i1-  is1,i2-  is2,i3,pc)   )
         call ogderiv(ep, 0,0,0,0, xy1(i1-2*is1,i2-2*is2,i3,0),xy1(i1-2*is1,i2-2*is2,i3,1),0.,t,pc+pxc, p1(i1-2*is1,i2-2*is2,i3,pc)   )
       end if


     end do
   end do
   do jv=0,numberOfPolarizationVectors2-1
     do n=0,nd-1
       pc = n + jv*nd 
       p2(j1  -js1,j2  -js2,j3,pc)=extrap5(p2,j1    ,j2    ,j3,pc,js1,js2,js3)
       p2(j1-2*js1,j2-2*js2,j3,pc)=extrap5(p2,j1-js1,j2-js2,j3,pc,js1,js2,js3)

       if( .false. .and. twilightZone.eq.1 )then
         ! *** TEST ****
         ! call ogderiv(ep, 0,0,0,0, xy2(j1      ,j2      ,j3,0),xy2(j1      ,j2      ,j3,1),0.,t,pc+pxc, p2(j1      ,j2      ,j3,pc)   )
         call ogderiv(ep, 0,0,0,0, xy2(j1-  js1,j2-  js2,j3,0),xy2(j1-  js1,j2-  js2,j3,1),0.,t,pc+pxc, p2(j1-  js1,j2-  js2,j3,pc)   )
         call ogderiv(ep, 0,0,0,0, xy2(j1-2*js1,j2-2*js2,j3,0),xy2(j1-2*js1,j2-2*js2,j3,1),0.,t,pc+pxc, p2(j1-2*js1,j2-2*js2,j3,pc)   )
       end if

     end do
   end do
  end if

  if (nonlinearModel1 .ne. noNonlinearModel) then
    do na = 0,numberOfAtomicLevels1-1
      q1(i1  -is1,i2  -is2,i3,na)=extrap5(q1,i1    ,i2    ,i3,na,is1,is2,is3)
      q1(i1-2*is1,i2-2*is2,i3,na)=extrap5(q1,i1-is1,i2-is2,i3,na,is1,is2,is3)
    enddo
  end if
  
  if (nonlinearModel2 .ne. noNonlinearModel) then
    do na = 0,numberOfAtomicLevels2-1
      q2(j1  -js1,j2  -js2,j3,na)=extrap5(q2,j1    ,j2    ,j3,na,js1,js2,js3)
      q2(j1-2*js1,j2-2*js2,j3,na)=extrap5(q2,j1-js1,j2-js2,j3,na,js1,js2,js3)
    enddo
  endif

 endLoops2d()
else

 ! ---- extrapolate to order 4 -----

 beginGhostLoops2d()

  u1(i1-is1,i2-is2,i3,ex)=extrap4(u1,i1,i2,i3,ex,is1,is2,is3)
  u1(i1-is1,i2-is2,i3,ey)=extrap4(u1,i1,i2,i3,ey,is1,is2,is3)
  u1(i1-is1,i2-is2,i3,hz)=extrap4(u1,i1,i2,i3,hz,is1,is2,is3)

  u2(j1-js1,j2-js2,j3,ex)=extrap4(u2,j1,j2,j3,ex,js1,js2,js3)
  u2(j1-js1,j2-js2,j3,ey)=extrap4(u2,j1,j2,j3,ey,js1,js2,js3)
  u2(j1-js1,j2-js2,j3,hz)=extrap4(u2,j1,j2,j3,hz,js1,js2,js3)

  ! --- also extrap 2nd line for now
  u1(i1-2*is1,i2-2*is2,i3,ex)=extrap4(u1,i1-is1,i2-is2,i3,ex,is1,is2,is3)
  u1(i1-2*is1,i2-2*is2,i3,ey)=extrap4(u1,i1-is1,i2-is2,i3,ey,is1,is2,is3)
  u1(i1-2*is1,i2-2*is2,i3,hz)=extrap4(u1,i1-is1,i2-is2,i3,hz,is1,is2,is3)

  u2(j1-2*js1,j2-2*js2,j3,ex)=extrap4(u2,j1-js1,j2-js2,j3,ex,js1,js2,js3)
  u2(j1-2*js1,j2-2*js2,j3,ey)=extrap4(u2,j1-js1,j2-js2,j3,ey,js1,js2,js3)
  u2(j1-2*js1,j2-2*js2,j3,hz)=extrap4(u2,j1-js1,j2-js2,j3,hz,js1,js2,js3)

  if( dispersive.ne.noDispersion )then
   do jv=0,numberOfPolarizationVectors1-1
     do n=0,nd-1
       pc = n + jv*nd 
       p1(i1  -is1,i2  -is2,i3,pc)=extrap4(p1,i1    ,i2    ,i3,pc,is1,is2,is3)
       p1(i1-2*is1,i2-2*is2,i3,pc)=extrap4(p1,i1-is1,i2-is2,i3,pc,is1,is2,is3)
     end do
   end do
   do jv=0,numberOfPolarizationVectors2-1
     do n=0,nd-1
       pc = n + jv*nd 
       p2(j1  -js1,j2  -js2,j3,pc)=extrap4(p2,j1    ,j2   ,j3,pc,js1,js2,js3)
       p2(j1-2*js1,j2-2*js2,j3,pc)=extrap4(p2,j1-js1,j2-js2,j3,pc,js1,js2,js3)
     end do
   end do
  end if

  if (nonlinearModel1 .ne. noNonlinearModel) then
    do na = 0,numberOfAtomicLevels1-1
      q1(i1  -is1,i2  -is2,i3,na)=extrap4(q1,i1    ,i2    ,i3,na,is1,is2,is3)
      q1(i1-2*is1,i2-2*is2,i3,na)=extrap4(q1,i1-is1,i2-is2,i3,na,is1,is2,is3)
    enddo
  end if
  
  if (nonlinearModel2 .ne. noNonlinearModel) then
    do na = 0,numberOfAtomicLevels2-1
      q2(j1  -js1,j2  -js2,j3,na)=extrap4(q2,j1    ,j2    ,j3,na,js1,js2,js3)
      q2(j1-2*js1,j2-2*js2,j3,na)=extrap4(q2,j1-js1,j2-js2,j3,na,js1,js2,js3)
    enddo
  endif

 endLoops2d()
end if
#endMacro

! --------------------------------------------------------------------------
! Macro: EXTRAPOLATE interface ghost values, DIM=3, ORDER=2
! --------------------------------------------------------------------------
#beginMacro extrapolateGhost3dOrder2()
  beginGhostLoops3d()
     u1(i1-is1,i2-is2,i3-is3,ex)=extrap3(u1,i1,i2,i3,ex,is1,is2,is3)
     u1(i1-is1,i2-is2,i3-is3,ey)=extrap3(u1,i1,i2,i3,ey,is1,is2,is3)
     u1(i1-is1,i2-is2,i3-is3,ez)=extrap3(u1,i1,i2,i3,ez,is1,is2,is3)

     u2(j1-js1,j2-js2,j3-js3,ex)=extrap3(u2,j1,j2,j3,ex,js1,js2,js3)
     u2(j1-js1,j2-js2,j3-js3,ey)=extrap3(u2,j1,j2,j3,ey,js1,js2,js3)
     u2(j1-js1,j2-js2,j3-js3,ez)=extrap3(u2,j1,j2,j3,ez,js1,js2,js3)

     if( dispersive.ne.noDispersion )then
      do jv=0,numberOfPolarizationVectors1-1
        do n=0,nd-1
          pc = n + jv*nd 
          p1(i1-is1,i2-is2,i3-is3,pc)=extrap3(p1,i1,i2,i3,pc,is1,is2,is3)
        end do
      end do
      do jv=0,numberOfPolarizationVectors2-1
        do n=0,nd-1
          pc = n + jv*nd 
          p2(j1-js1,j2-js2,j3-js3,pc)=extrap3(p2,j1,j2,j3,pc,js1,js2,js3)
        end do
      end do
     end if

  endLoops3d()
#endMacro


!  -- this next include file holds macros for assigning interface in 3D order 2 
! eval3dJumpOrder2()
! evalInterfaceEquations23c()
! assignInterfaceGhost23c()
! initializeInterfaceVariablesMacro(LABEL)
! setIndexBoundsExtraGhost()
! resetIndexBounds()  
#Include "interfaceMacros3d.h"


! ==============================================================================
! Macro: get index bounds that include ghost points 
!  Output: ng1a,ng1b,ng2a,ng2b,ng3a,ng3b
!  Output: mg1a,mg1b,mg2a,mg2b,mg3a,mg3b
! ==============================================================================
#beginMacro getGhostBounds( numGhost )
  ng1a=n1a
  ng1b=n1b
  ng2a=n2a
  ng2b=n2b
  ng3a=n3a
  ng3b=n3b
  if( side1.eq.0 )then
    ng1a=ng1a-is1*numGhost
    ng2a=ng2a-is2*numGhost
    ng3a=ng3a-is3*numGhost
  else
    ng1b=ng1b-is1*numGhost
    ng2b=ng2b-is2*numGhost
    ng3b=ng3b-is3*numGhost
  end if
  
  ! grid2
  mg1a=m1a
  mg1b=m1b
  mg2a=m2a
  mg2b=m2b
  mg3a=m3a
  mg3b=m3b
  if( side2.eq.0 )then
    mg1a=mg1a-js1*numGhost
    mg2a=mg2a-js2*numGhost
    mg3a=mg3a-js3*numGhost
  else
    mg1b=mg1b-js1*numGhost
    mg2b=mg2b-js2*numGhost
    mg3b=mg3b-js3*numGhost
  end if

#endMacro          

!================================================================================================
! Macro  2D ORDER=2 RECTANGULAR
!================================================================================================
#beginMacro assignInterfaceMacro22r(MODEL)

#perl $DIM=2; $GRIDTYPE="rectangular"; $ORDER=2;

  if( .false. .and. useForcing.ne.0 )then 
    ! finish me 
    stop 7715
  end if

  !-  ! just copy values from ghost points for now
  !-  beginLoopsMask2d()
  !-    u1(i1-is1,i2-is2,i3,ex)=u2(j1+js1,j2+js2,j3,ex)
  !-    u1(i1-is1,i2-is2,i3,ey)=u2(j1+js1,j2+js2,j3,ey)
  !-    u1(i1-is1,i2-is2,i3,hz)=u2(j1+js1,j2+js2,j3,hz) 
  !-  endLoopsMask2d()

  ! ---- first satisfy the jump conditions on the boundary --------
  !    [ eps n.u ] = 0
  !    [ tau.u ] = 0
  if( assignInterfaceValues.eq.1 )then
      boundaryJumpConditions(2,rectangular)
  end if

  ! initialization step: assign first ghost line by extrapolation

  ! NOTE: assign ghost points outside the ends (for periodic only??)

  ! ***WHY IS THIS HERE AND WHY ISN'T U2 SET TOO? *************************************

  ! ----- assign ghost using jump conditions -----
  if( assignInterfaceGhostValues.eq.1 )then

    ! initialization step: assign first ghost line by extrapolation
    extrapolateGhost2dOrder2()

    ! Macro to assign ghost values:
    if( dispersive.eq.0 )then
      #If #MODEL eq "none"
       assignInterfaceGhost22r()
      #End
    else if( useNonlinearModel.eq.0 )then
      ! dispersive case
      #If #MODEL eq "gdm"
       assignDispersiveInterfaceGhost22r()
      #End 
   else
      ! nonlinear dispersive case
      #If #MODEL eq "mla"
       assignNonlinearInterfaceGhost22r()
      #End 
    end if    

    ! fixup values on ends *wdh* June 22, 2016
    if( .false. )then
      fixupInterfaceEndValues(2,rectangular,u1,side1,axis1,axis1p1,axis1p2,boundaryCondition1,gridIndexRange1,dx1,dr1)
      fixupInterfaceEndValues(2,rectangular,u2,side2,axis2,axis2p1,axis2p2,boundaryCondition2,gridIndexRange2,dx2,dr2)
    end if

    ! opt periodic update
    periodicUpdate2d(u1,boundaryCondition1,gridIndexRange1,side1,axis1)
    periodicUpdate2d(u2,boundaryCondition2,gridIndexRange2,side2,axis2)
  end if
#endMacro

        
!================================================================================================
! Macro  2D ORDER=2 CURVILINEAR
!================================================================================================
#beginMacro assignInterfaceMacro22c(MODEL)

#perl $DIM=2; $GRIDTYPE="curvilinear"; $ORDER=2; 

  ! ---- first satisfy the jump conditions on the boundary --------
  !    [ eps n.u ] = 0
  !    [ tau.u ] = 0

  if( assignInterfaceValues.eq.1 )then
    boundaryJumpConditions(2,curvilinear)
  end if

 ! ----- assign ghost using jump conditions -----
 if( assignInterfaceGhostValues.eq.1 )then

  ! initialization step: assign first ghost line by extrapolation
  extrapolateGhost2dOrder2()

  ! Macro to assign ghost values:
  if( dispersive.eq.0 )then
    #If #MODEL eq "none"
      assignInterfaceGhost22c()
    #End
  else if( useNonlinearModel.eq.0 )then
    ! dispersive case
    #If #MODEL eq "gdm"
      assignDispersiveInterfaceGhost22c()
    #End 
  else
    ! nonlinear model
    #If #MODEL eq "mla"
      assignNonlinearInterfaceGhost22c()
    #End 
  end if

  ! now make sure that div(u)=0 etc.
  !2          if( .false. )then
  !2         beginLoops2d() ! =============== start loops =======================
  !2
  !2           ! 0  [ u.x + v.y ] = 0
  !2           ! first evaluate the equations we want to solve with the wrong values at the ghost points:
  !2           divu=u1x22(i1,i2,i3,ex)+u1y22(i1,i2,i3,ey)
  !2           a0=-is*rsxy1(i1,i2,i3,axis1,0)*dr112(axis1)
  !2           a1=-is*rsxy1(i1,i2,i3,axis1,1)*dr112(axis1)
  !2           aNormSq=a0**2+a1**2
  !2           ! now project:  a.uNew = a.uOld - div  ->  (div-a.uOld)+a.uNew = div(uNew) = 0
  !2           u1(i1-is1,i2-is2,i3,ex)=u1(i1-is1,i2-is2,i3,ex)-divu*a0/aNormSq
  !2           u1(i1-is1,i2-is2,i3,ey)=u1(i1-is1,i2-is2,i3,ey)-divu*a1/aNormSq
  !2
  !2           divu=u2x22(j1,j2,j3,ex)+u2y22(j1,j2,j3,ey)
  !2           a0=-js*rsxy2(j1,j2,j3,axis2,0)*dr212(axis2) 
  !2           a1=-js*rsxy2(j1,j2,j3,axis2,1)*dr212(axis2) 
  !2           aNormSq=a0**2+a1**2
  !2
  !2           u2(j1-js1,j2-js2,j3,ex)=u2(j1-js1,j2-js2,j3,ex)-divu*a0/aNormSq
  !2           u2(j1-js1,j2-js2,j3,ey)=u2(j1-js1,j2-js2,j3,ey)-divu*a1/aNormSq
  !2
  !2           if( debug.gt.0 )then
  !2             write(debugFile,'(" --> 2cth: eval div1,div2=",2e10.2)') u1x22(i1,i2,i3,ex)+u1y22(i1,i2,i3,ey),u2x22(j1,j2,j3,ex)+u2y22(j1,j2,j3,ey)
  !2           end if
  !2         endLoops2d()
  !2          end if

  ! periodic update **** THIS WON T WORK IN PARALLEL
  periodicUpdate2d(u1,boundaryCondition1,gridIndexRange1,side1,axis1)
  periodicUpdate2d(u2,boundaryCondition2,gridIndexRange2,side2,axis2)

 end if ! end assignInterfaceGhostValues

else if( .false. .and. orderOfAccuracy.eq.4 )then

  ! for testing -- just assign from the other ghost points

  beginLoops2d()
    u1(i1-is1,i2-is2,i3,ex)=u2(j1+js1,j2+js2,j3,ex)
    u1(i1-is1,i2-is2,i3,ey)=u2(j1+js1,j2+js2,j3,ey)
    u1(i1-is1,i2-is2,i3,hz)=u2(j1+js1,j2+js2,j3,hz) 

    u2(j1-js1,j2-js2,j3,ex)=u1(i1+is1,i2+is2,i3,ex)
    u2(j1-js1,j2-js2,j3,ey)=u1(i1+is1,i2+is2,i3,ey)
    u2(j1-js1,j2-js2,j3,hz)=u1(i1+is1,i2+is2,i3,hz)

    u1(i1-2*is1,i2-2*is2,i3,ex)=u2(j1+2*js1,j2+2*js2,j3,ex)
    u1(i1-2*is1,i2-2*is2,i3,ey)=u2(j1+2*js1,j2+2*js2,j3,ey)
    u1(i1-2*is1,i2-2*is2,i3,hz)=u2(j1+2*js1,j2+2*js2,j3,hz) 

    u2(j1-2*js1,j2-2*js2,j3,ex)=u1(i1+2*is1,i2+2*is2,i3,ex)
    u2(j1-2*js1,j2-2*js2,j3,ey)=u1(i1+2*is1,i2+2*is2,i3,ey)
    u2(j1-2*js1,j2-2*js2,j3,hz)=u1(i1+2*is1,i2+2*is2,i3,hz)

  endLoops2d()
#endMacro

         
!================================================================================================
! Macro  2D ORDER=4 RECTANGULAR
!================================================================================================
#beginMacro assignInterfaceMacro24r(MODEL)
         
#perl $DIM=2; $GRIDTYPE="rectangular"; $ORDER=4;
  
  ! --------------- 4th Order Rectangular ---------------


  !- ! **TEMP**
  !- alphaP1=0.
  !- alphaP2=0.
  !-write(*,'(" ***TEMP Setting alphaP1=alphaP2=0")') 


  ! if( useForcing.ne.0 )then 
  !   ! finish me 
  !   stop 7716
  ! end if
  ! ***** fix these for [mu] != 0 ****
  if( mu1.ne.mu2 )then
    stop 9924
  end if


  ! ---- first satisfy the jump conditions on the boundary --------
  !    [ eps n.u ] = 0
  !    [ tau.u ] = 0
  if( assignInterfaceValues.eq.1 )then
    boundaryJumpConditions(2,rectangular)
  end if

  ! here are the real jump conditions for the ghost points
  ! 0  [ u.x + v.y ] = 0
  ! 1  [ u.xx + u.yy ] = 0
  ! 2  [ v.x - u.y ] =0 
  ! 3  [ (v.xx+v.yy)/eps ] = 0
  ! 4  [ (u.xx+u.yy).x + (v.xx+v.yy).y ] = 0  OR [ (u.xx).x + (v.xx).y ] = 0 OR  [ (u.yy).x + (v.yy).y ] = 0 
  ! 5  [ {(Delta v).x - (Delta u).y}/eps ] =0  -> [ {(v.xxx+v.xyy)-(u.xxy+u.yyy)}/eps ] = 0
  ! 6  [ Delta^2 u/eps ] = 0
  ! 7  [ Delta^2 v/eps^2 ] = 0 


  ! ----- assign ghost using jump conditions -----
  if( assignInterfaceGhostValues.eq.1 )then
 
    ! initialization step: assign two ghost lines by extrapolation
    extrapolateGhost2dOrder4()
 
    orderOfAccuracy=2 ! temporarily set (for checkCoeff only?)
 
    if( t.lt. 3.*dt .and. debug.gt.0 )then
      ! This next perl command will cause macro derivatives to be computed to order=2
#perl $ORDER=2;
       write(*,'(" **** STAGE I: ASSIGN GHOST TO 2ND ORDER FOR 4TH ORDER RECTANGUAR INTERFACE (residuals Order=2)****")')
    end if 


    ! in parallel we add extra points in the tangential direction on parallel boundaries
    ! (otherwise we would use extrapolated values which is probably ok) 
    setIndexBoundsExtraGhost()

   ! Macro to assign ghost values:
   if( dispersive.eq.0 )then
     #If #MODEL eq "none"
       assignInterfaceGhost22r( NO_MAG_FIELD )
     #End 
   else if( useNonlinearModel.eq.0 )then
     ! dispersive case
     #If #MODEL eq "gdm"
       assignDispersiveInterfaceGhost22r( NO_MAG_FIELD )
     #End 
   else
     ! nonlinear dispersive case
     #If #MODEL eq "mla"
       assignNonlinearInterfaceGhost22r()
     #End 
   end if    
   resetIndexBounds()         
 
   orderOfAccuracy=4 ! reset 
 
    ! This next perl command will reset the macro derivatives to be computed to order=4
#perl $ORDER=4;

 
   ! Macro to assign ghost values:
   if( dispersive.eq.0 )then
     #If #MODEL eq "none"
       assignInterfaceGhost24r()
     #End
   else if( useNonlinearModel.eq.0 )then
     ! dispersive case
     #If #MODEL eq "gdm"
       ! *new* Feb 1, 2021
       assignDispersiveInterfaceGhost24r()
     #End 
   else
     ! nonlinear dispersive case
     #If #MODEL eq "mla"
       write(*,*) "Finish assignNonlinearInterfaceGhost24r()"
       stop 2222
     #End 
   end if    
   
   ! fixup corner points 
   ! if( .false. )then
   !   fixupInterfaceEndValues(2,rectangular,u1,side1,axis1,axis1p1,axis1p2,boundaryCondition1,gridIndexRange1,dx1,dr1)
   !   fixupInterfaceEndValues(2,rectangular,u2,side2,axis2,axis2p1,axis2p2,boundaryCondition2,gridIndexRange2,dx2,dr2)
   ! end if
 
   ! periodic update
   periodicUpdate2d(u1,boundaryCondition1,gridIndexRange1,side1,axis1)
   periodicUpdate2d(u2,boundaryCondition2,gridIndexRange2,side2,axis2)

 end if ! assign ghost

#endMacro 



!================================================================================================
! Macro  2D ORDER=4 CURVILINEAR
!================================================================================================
#beginMacro assignInterfaceMacro24c(MODEL)


#perl $DIM=2; $GRIDTYPE="curvilinear"; $ORDER=4;
  
  ! --------------- 4th Order Curvilinear ---------------

  ! ***** fix these for [mu] != 0 ****
  if( mu1.ne.mu2 )then
    stop 9925
  end if

  ! write(*,'("START: p1=",(15(e10.2,1x)))') (((p1(i1,i2,i3,0),i1=nd1a,nd1b),i2=nd2a,nd2b),i3=nd3a,nd3b)

  ! ---- first satisfy the jump conditions on the boundary --------
  !    [ eps n.u ] = 0
  !    [ tau.u ] = 0
  !    [ w ] = 0 
  if( assignInterfaceValues.eq.1 )then
    boundaryJumpConditions(2,curvilinear)
  end if


 ! ----- assign ghost using jump conditions -----
 if( assignInterfaceGhostValues.eq.1 )then

  ! here are the real jump conditions for the ghost points
  ! 0  [ u.x + v.y ] = 0
  ! 1  [ n.(uv.xx + uv.yy) ] = 0
  ! 2  [ v.x - u.y ] =0 
  ! 3  [ tau.(v.xx+v.yy)/eps ] = 0
  ! 4  [ (u.xx+u.yy).x + (v.xx+v.yy).y ] = 0  OR [ (u.xx).x + (v.xx).y ] = 0 OR  [ (u.yy).x + (v.yy).y ] = 0 
  ! 5  [ {(Delta v).x - (Delta u).y}/eps ] =0  -> [ {(v.xxx+v.xyy)-(u.xxy+u.yyy)}/eps ] = 0
  ! 6  [ n.Delta^2 uv/eps ] = 0
  ! 7  [ tau.Delta^2 uv/eps^2 ] = 0 



  ! initialization step: assign first ghost line by extrapolation
  ! NOTE: assign ghost points outside the ends

  
  extrapolateGhost2dOrder4()

  if( avoidInterfaceIterations.eq.1 )then

    ! ---- STAGE I: assign first ghost to 2nd-order accuracy -----

    ! Note: checkCoeff fails below for 2nd-order coeff's (they are correct)
    ! Check coeff is OK if we set the next line, but then accuracy degrades to 2 !! why?
    !!  perl $DIM=2; $GRIDTYPE="curvilinear"; $ORDER=2;


    if( t.lt. 3.*dt .and. debug.gt.0 )then
      write(*,'(" **** STAGE I: ASSIGN GHOST TO 2ND ORDER FOR 4TH ORDER CURV INTERFACE (residual order=4)****")')

     ! Use 4th-order accurate residuals in SOA update, otheriwse accuracy degrades to 3rd order for PMIC
     ! perl $ORDER=2; 
     ! write(*,'(" **** STAGE I: ASSIGN GHOST TO 2ND ORDER FOR 4TH ORDER CURV INTERFACE (residual order=2)****")')

    end if 
    orderOfAccuracy=2 ! temporarily set (for checkCoeff only?)

    ! in parallel we add extra points in the tangential direction on parallel boundaries
    ! (otherwise we would use extrapolated values which is probably ok) 

    setIndexBoundsExtraGhost()  
    if( dispersive.eq.0 )then
      #If #MODEL eq "none"
        assignInterfaceGhost22c( NO_MAG_FIELD )
      #End 
    else if( useNonlinearModel.eq.0 )then
      ! dispersive case
      #If #MODEL eq "gdm"
        assignDispersiveInterfaceGhost22c()
      #End 
    else
      ! nonlinear dispersive case
      #If #MODEL eq "mla"
        assignNonlinearInterfaceGhost22c()
      #End 
    end if
    resetIndexBounds()         

    orderOfAccuracy=4 ! reset 
  end if

#perl $DIM=2; $GRIDTYPE="curvilinear"; $ORDER=4;

  if( debug.gt.3 )then

    ! macro to get bounds including ghost points: ng1a,ng1b,... mg1a,mg1b, 
    setIndexBoundsExtraGhost()
    getGhostBounds( numGhost )
    resetIndexBounds()         

    nd4a=0
    nd4b=0
    n4a=0
    n4b=0
    write(label,'("mask1 : interface3d.f After stage 1 (order=2 update) t=",e10.2)') t 
    pdiff = checkParallelFortranArrayInt(label, \
                  nd1a, nd1b, nd2a, nd2b, nd3a, nd3b, nd4a, nd4b, \
                  ng1a, ng1b, ng2a, ng2b, ng3a, ng3b, n4a, n4b,\
                  mask1, \
                  len(label) )

    write(label,'("mask2 : interface3d.f After stage 1 (order=2 update) t=",e10.2)') t 
    md4a=0
    md4b=0
    m4a=0
    m4b=0
    pdiff = checkParallelFortranArrayInt(label, \
                  md1a, md1b, md2a, md2b, md3a, md3b, md4a, md4b, \
                  mg1a, mg1b, mg2a, mg2b, mg3a, mg3b, m4a, m4b,\
                  mask2, \
                  len(label) )

    nd4a=0
    nd4b=2*nd-1
    n4a=0
    n4b=2*nd-1
    write(label,'("rsxy1 : interface3d.f After stage 1 (order=2 update) t=",e10.2)') t 
    pdiff = checkParallelFortranArrayReal(label, \
                  nd1a, nd1b, nd2a, nd2b, nd3a, nd3b, nd4a, nd4b, \
                  ng1a, ng1b, ng2a, ng2b, ng3a, ng3b, n4a, n4b,\
                  rsxy1, \
                  len(label) )

    write(label,'("rsxy2 : interface3d.f After stage 1 (order=2 update) t=",e10.2)') t 
    md4a=0
    md4b=2*nd-1
    m4a=0
    m4b=2*nd-1
    pdiff = checkParallelFortranArrayReal(label, \
                  md1a, md1b, md2a, md2b, md3a, md3b, md4a, md4b, \
                  mg1a, mg1b, mg2a, mg2b, mg3a, mg3b, m4a, m4b,\
                  rsxy2, \
                  len(label) )


    write(label,'("u1 : interface3d.f After stage 1 (order=2 update) t=",e10.2)') t 
    ! fix me: -- use number of components 
    nd4a=0
    nd4b=2
    n4a=0
    n4b=2
    pdiff = checkParallelFortranArrayReal(label, \
                  nd1a, nd1b, nd2a, nd2b, nd3a, nd3b, nd4a, nd4b, \
                  ng1a, ng1b, ng2a, ng2b, ng3a, ng3b, n4a, n4b,\
                  u1, \
                  len(label) )


    write(label,'("u2 : interface3d.f After stage 1 (order=2 update) t=",e10.2)') t 
    ! fix me: 
    md4a=0
    md4b=2
    m4a=0
    m4b=2
    pdiff = checkParallelFortranArrayReal(label, \
                  md1a, md1b, md2a, md2b, md3a, md3b, md4a, md4b, \
                  mg1a, mg1b, mg2a, mg2b, mg3a, mg3b, m4a, m4b,\
                  u2, \
                  len(label) )

  end if

  ! Assign polarization vectors on ghost lines
  ! if( .false. )then
  !   ! THIS IS NOT USED CURRENTLY -- was created to fix a bug that was caused by a wrong alphaP
  !   assignPolarizationOnGhostOrder4()
  ! end if
  ! if( .false. )then 
  !   ! Smooth P on the interface (for dispersive)
  !   ! THIS IS NOT USED CURRENTLY -- was created to fix a bug that was caused by a wrong alphaP
  !   ! *wd* tested for dielectric cyl -- improves P but not really enough ***Aug 7, 2019 ***
  !   smoothInterfaceP()
  ! end if

  ! write(debugFile,'(">>> interface: order=4 initialized=",i4)') initialized

  ! *********************************************************
  ! **************** begin interface iteration **************

  ! ---- STAGE II: assign two ghost to 4th-order accuracy -----

  errOld=1.
  ratioAve=0.
  do it=1,nit 

   ! Macro to assign ghost values:
   if( dispersive.eq.0 )then
     #If #MODEL eq "none"
       assignInterfaceGhost24c()
     #End
   else if (useNonlinearModel.eq.0) then
     ! dispersive case
     #If #MODEL eq "gdm"
       assignDispersiveInterfaceGhost24c()
     #End
   else
     ! nonlinear dispersive case
     #If #MODEL eq "mla"
       assignNonlinearInterfaceGhost24c()
     #End
   end if    

   ! fixup corner points 
   ! if( .false. )then
   !   fixupInterfaceEndValues(2,curvilinear,u1,side1,axis1,axis1p1,axis1p2,boundaryCondition1,gridIndexRange1,dx1,dr1)
   !   fixupInterfaceEndValues(2,curvilinear,u2,side2,axis2,axis2p1,axis2p2,boundaryCondition2,gridIndexRange2,dx2,dr2)
   ! end if

   periodicUpdate2d(u1,boundaryCondition1,gridIndexRange1,side1,axis1)
   periodicUpdate2d(u2,boundaryCondition2,gridIndexRange2,side2,axis2)

   if( it.eq.1 )then
     errRatio=1.
   else
     errRatio=err/errOld
     ratioAve=ratioAve+errRatio
   end if 
   errOld=err

   if( (t.le.5*dt .and. debug.gt.0 ) .or. debug.gt.3 )then
    if( it.eq.1 )then
      write(*,'("interface2d : t=",e10.3," (grid1,grid2)=(",i3,",",i3,"), it=",i3,", err=",e10.2,"           (omega=",f4.2,")")') t,grid1,grid2,it,err,omega
    else
      write(*,'("interface2d : t=",e10.3," (grid1,grid2)=(",i3,",",i3,"), it=",i3,", err=",e10.2," rate=",f5.2," (omega=",f4.2,")")') t,grid1,grid2,it,err,errRatio,omega
    end if
   end if

   if( debug.gt.0 )then 
     write(debugFile,'("interface2d : t=",e10.3," (grid1,grid2)=(",i3,",",i3,"), it=",i3,", err=",e10.2," rate=",f5.2," (omega=",f4.2,")")') t,grid1,grid2,it,err,errRatio,omega
   end if

   if( it.eq.1 )then
     checkCoeff=0 ! turn off check coeff after 1 iteration
  end if
  
   numberOfIterations=it
   if( err.lt.absoluteErrorTolerance )then
     exit
   end if

  end do 

  ipar(43)= numberOfIterations  ! returned value 
  rpar(22)=ratioAve/(numberOfIterations-1)
  rpar(23) = err !  maxFinalResidual : return value 

  ! ***************** end interface iteration ****************
  ! **********************************************************


  ! now make sure that div(u)=0 etc.
  if( .false. )then
!*         beginLoops2d() ! =============== start loops =======================

    ! 0  [ u.x + v.y ] = 0
!           a8(0,0) = -is*8.*rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)     ! coeff of u1(-1) from [u.x+v.y] 
!           a8(0,1) = -is*8.*rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)     ! coeff of v1(-1) from [u.x+v.y] 
!           a8(0,4) =  is*   rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)     ! u1(-2)
!           a8(0,5) =  is*   rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)     ! v1(-2) 

!           a8(0,2) =  js*8.*rsxy2(j1,j2,j3,axis2,0)*dr214(axis2)     ! coeff of u2(-1) from [u.x+v.y] 
!           a8(0,3) =  js*8.*rsxy2(j1,j2,j3,axis2,1)*dr214(axis2)  
!           a8(0,6) = -js*   rsxy2(j1,j2,j3,axis2,0)*dr214(axis2) 
!           a8(0,7) = -js*   rsxy2(j1,j2,j3,axis2,1)*dr214(axis2) 

    ! first evaluate the equations we want to solve with the wrong values at the ghost points:
!*           divu=u1x42(i1,i2,i3,ex)+u1y42(i1,i2,i3,ey)
!*           a0=is*   rsxy1(i1,i2,i3,axis1,0)*dr114(axis1)
!*           a1=is*   rsxy1(i1,i2,i3,axis1,1)*dr114(axis1)
!*           aNormSq=a0**2+a1**2
!*           ! now project:  a.uNew = a.uOld - div  ->  (div-a.uOld)+a.uNew = div(uNew) = 0
!*           u1(i1-2*is1,i2-2*is2,i3,ex)=u1(i1-2*is1,i2-2*is2,i3,ex)-divu*a0/aNormSq
!*           u1(i1-2*is1,i2-2*is2,i3,ey)=u1(i1-2*is1,i2-2*is2,i3,ey)-divu*a1/aNormSq
!*
!*           divu=u2x42(j1,j2,j3,ex)+u2y42(j1,j2,j3,ey)
!*           a0=js*   rsxy2(j1,j2,j3,axis2,0)*dr214(axis2) 
!*           a1=js*   rsxy2(j1,j2,j3,axis2,1)*dr214(axis2) 
!*           aNormSq=a0**2+a1**2
!*
!*           u2(j1-2*js1,j2-2*js2,j3,ex)=u2(j1-2*js1,j2-2*js2,j3,ex)-divu*a0/aNormSq
!*           u2(j1-2*js1,j2-2*js2,j3,ey)=u2(j1-2*js1,j2-2*js2,j3,ey)-divu*a1/aNormSq
!*
!*           if( debug.gt.0 )then
!*             divu=u1x42(i1,i2,i3,ex)+u1y42(i1,i2,i3,ey)
!*              write(debugFile,'(" --> 4cth: eval div1,div2=",2e10.2)') u1x42(i1,i2,i3,ex)+u1y42(i1,i2,i3,ey),u2x42(j1,j2,j3,ex)+u2y42(j1,j2,j3,ey)
!*           end if
!*         endLoops2d()


 end if ! ----- end assign ghost using jump conditions -----


end if
#endMacro


!================================================================================================
! Macro  3D ORDER=2 CURVILINEAR
!================================================================================================
#beginMacro assignInterfaceMacro32c(MODEL)

 if( solveForH .ne.0 )then
   stop 3017
 end if

#perl $DIM=3; $GRIDTYPE="curvilinear"; $ORDER=2; 

 if( .false. )then
   beginGhostLoops3d()
    write(debugFile,'(" -->START v1(",i2,":",i2,",",i2,",",i2,") =",3f9.4)') i1-1,i1+1,i2,i3,u1(i1-1,i2,i3,ey),u1(i1,i2,i3,ey),u1(i1+1,i2,i3,ey)
    ! '
   endLoops3d()
 end if

  ! ---- first satisfy the jump conditions on the boundary --------
  !    [ eps n.u ] = 0
  !    [ tau.u ] = 0
  if( assignInterfaceValues.eq.1 )then
    boundaryJumpConditions(3,curvilinear)
  end if

 if( .false. )then
   beginGhostLoops3d()
    write(debugFile,'(" -->JUMP v1(",i2,":",i2,",",i2,",",i2,") =",3f9.4)') i1-1,i1+1,i2,i3,u1(i1-1,i2,i3,ey),u1(i1,i2,i3,ey),u1(i1+1,i2,i3,ey)
    ! '
   endLoops3d()
 end if

 ! ----- assign ghost using jump conditions -----
 if( assignInterfaceGhostValues.eq.1 )then

  ! initialization step: assign first ghost line by extrapolation
  ! NOTE: assign ghost points outside the ends
  if( .true. )then
    extrapolateGhost3dOrder2()
  end if

  if( .false. )then
   ! just copy values from ghost points for now -- this will be the true soln if eps1=eps2 and grids match
   beginLoops3d()
    u1(i1-is1,i2-is2,i3-is3,ex)=u2(j1+js1,j2+js2,j3+js3,ex)
    u1(i1-is1,i2-is2,i3-is3,ey)=u2(j1+js1,j2+js2,j3+js3,ey)
    u1(i1-is1,i2-is2,i3-is3,ez)=u2(j1+js1,j2+js2,j3+js3,ez) 
    u2(j1-js1,j2-js2,j3-js3,ex)=u1(i1+is1,i2+is2,i3+is3,ex)
    u2(j1-js1,j2-js2,j3-js3,ey)=u1(i1+is1,i2+is2,i3+is3,ey)
    u2(j1-js1,j2-js2,j3-js3,ez)=u1(i1+is1,i2+is2,i3+is3,ez)
   endLoops3d()
  end if

 if( .false. )then
   beginGhostLoops3d()
    write(debugFile,'(" -->EXTRAP v1(",i2,":",i2,",",i2,",",i2,") =",3f9.4)') i1-1,i1+1,i2,i3,u1(i1-1,i2,i3,ey),u1(i1,i2,i3,ey),u1(i1+1,i2,i3,ey)
    ! '
   endLoops3d()
 end if


   ! Macro to assign ghost values:
   if( dispersive.eq.0 )then
     #If #MODEL eq "none"
       assignInterfaceGhost23c()
     #End 
   else if( useNonlinearModel.eq.0 )then
     ! dispersive case
     #If #MODEL eq "gdm"
       assignDispersiveInterfaceGhost23c()
     #End 
   else
     ! nonlinear model
     #If #MODEL eq "mla"
       assignNonlinearInterfaceGhost23c()
     #End 
   end if    


  ! periodic update
  periodicUpdate3d(u1,boundaryCondition1,gridIndexRange1,side1,axis1)
  periodicUpdate3d(u2,boundaryCondition2,gridIndexRange2,side2,axis2)

 end if ! end assignInterfaceGhostValues
#endMacro


! ====================================================================================================
!   Main macro to generate separate interface files
!   NAME: name of subroutine
!   DIM,ORDER,GRIDTYPE : number of dimensions, order of accuracy, grid-type
!   MODEL: none, gdm, mla
! ====================================================================================================
#beginMacro INTERFACE(NAME,DIM,ORDER,GRIDTYPE,MODEL)
subroutine NAME( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                               gridIndexRange1, u1,u1n,u1m, wk1, mask1,rsxy1, xy1, p1,p1n,p1m, q1,q1n,q1m, boundaryCondition1, \
                               md1a,md1b,md2a,md2b,md3a,md3b,\
                               gridIndexRange2, u2,u2n,u2m, wk2, mask2,rsxy2, xy2, p2,p2n,p2m, q2,q2n,q2m, boundaryCondition2, \
                               ipar, rpar, \
                               aa2,aa4,aa8, ipvt2,ipvt4,ipvt8, \
                               ierr )
! ===================================================================================
!  Interface boundary conditions for Maxwells Equations in 3D.
!
!  gridType : 0=rectangular, 1=curvilinear
!
!  u1: solution on the domain 1 ("left") of the interface
!  u2: solution on the domain 2 ("right") of the interface
!
!  u1n,u1m: past time solutions on domain 1 
!  u2n,u2m: past time solutions on domain 2
!
!  p1: polarization vectors on domain 1 (for dispersive models)
!  p2: polarization vectors on domain 2 (for dispersive models)
! 
!  wk1,wk2 : work-space for jacobi update of ghost values 
!
!  aa2,aa4,aa8 : real work space arrays that must be saved from call to call
!  ipvt2,ipvt4,ipvt8: integer work space arrays that must be saved from call to call
! ===================================================================================

implicit none

      integer nd, \
              nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, \
              md1a,md1b,md2a,md2b,md3a,md3b, \
              n1a,n1b,n2a,n2b,n3a,n3b,  \
              m1a,m1b,m2a,m2b,m3a,m3b,  \
              ierr

      ! ------- arrays for domain 1 -------------
      real u1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real u1n(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real u1m(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real wk1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)

      ! polarization vectors
      real p1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real p1n(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real p1m(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)

      ! nonlinear variables 
      real q1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real q1n(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      real q1m(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)

      integer mask1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      real rsxy1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
      real xy1(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
      integer gridIndexRange1(0:1,0:2),boundaryCondition1(0:1,0:2)

      ! ------- arrays for domain 2 -------------
      real u2(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real u2n(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real u2m(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real wk2(md1a:md1b,md2a:md2b,md3a:md3b,0:*)

      ! polarization vectors
      real p2(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real p2n(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real p2m(md1a:md1b,md2a:md2b,md3a:md3b,0:*)

      ! nonlinear variables 
      real q2(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real q2n(md1a:md1b,md2a:md2b,md3a:md3b,0:*)
      real q2m(md1a:md1b,md2a:md2b,md3a:md3b,0:*)

      integer mask2(md1a:md1b,md2a:md2b,md3a:md3b)
      real rsxy2(md1a:md1b,md2a:md2b,md3a:md3b,0:nd-1,0:nd-1)
      real xy2(md1a:md1b,md2a:md2b,md3a:md3b,0:nd-1)
      integer gridIndexRange2(0:1,0:2),boundaryCondition2(0:1,0:2)

      integer ipar(0:*),numberOfInterfaceIterationsUsed
      real rpar(0:*)

      ! work space arrays that must be saved from call to call:
      real aa2(0:1,0:1,0:1,0:*),aa4(0:3,0:3,0:1,0:*),aa8(0:7,0:7,0:1,0:*)
      integer ipvt2(0:1,0:*), ipvt4(0:3,0:*), ipvt8(0:7,0:*)

!     --- local variables ----
      
      integer side1,axis1,grid1,side2,axis2,grid2,gridType,orderOfAccuracy,orderOfExtrapolation,useForcing,\
        ex,ey,ez,hx,hy,hz,useWhereMask,debug,solveForE,solveForH,axis1p1,axis1p2,axis2p1,axis2p2,nn,n1,n2,\
        twilightZone
      real dx1(0:2),dr1(0:2),dx2(0:2),dr2(0:2)
      real dr1a(0:2), dr2a(0:2)

      real dxxx1by2i, dxxx2by2i, dxx1by12i, dxx2by12i

      real t,ep,dt,eps1,mu1,c1,eps2,mu2,c2,epsmu1,epsmu2,eta1,eta2,eta1i,eta2i
      real cSq1,cSq2,dtSq
      real absoluteErrorTolerance,relativeErrorTolerance,omega
      integer axisp1,axisp2,i1,i2,i3,is1,is2,is3,j1,j2,j3,js1,js2,js3,ks1,ks2,ks3,is,js,it,nit,k1,k2,k3,i,j
      integer i1m,i2m,i3m,j1m,j2m,j3m,i1p,i2p,i3p,j1p,j2p,j3p
      integer ii1,ii2,ii3,numberOfIterations
      integer interfaceOption,interfaceEquationsOption,initialized,forcingOption
      integer assignInterfaceValues,assignInterfaceGhostValues,setDivergenceAtInterfaces
      integer numGhost,numGhost2,giveDiv
      ! grid1
      integer ns1a,ns1b,ns2a,ns2b,ns3a,ns3b  ! save n1a,n1b,...
      integer ne1a,ne1b,ne2a,ne2b,ne3a,ne3b  ! one extra ghost for 4th-order Stage I order2 
      integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
      integer ng1a,ng1b,ng2a,ng2b,ng3a,ng3b  ! for ghost too    
      ! grid2
      integer ms1a,ms1b,ms2a,ms2b,ms3a,ms3b  ! save m1a,m1b,...
      integer me1a,me1b,me2a,me2b,me3a,me3b  ! one extra ghost for 4th-order Stage I order2 
      integer mm1a,mm1b,mm2a,mm2b,mm3a,mm3b
      integer mg1a,mg1b,mg2a,mg2b,mg3a,mg3b  ! for ghost too 
      integer m1,m2,mm

      integer internalGhostBC

      real rx1,ry1,rz1,rx2,ry2,rz2

      real aLap0,aLap1,bLap0,bLap1,aLapX0,aLapX1,bLapY0,bLapY1,cLapX0,cLapX1,dLapY0,dLapY1,aLapSq0,aLapSq1,bLapSq0,bLapSq1
      real a0,a1,b0,b1,cc0,cc1,d0,d1,dr0,ds0
      real aNormSq,divu,dive

      real epsRatio,an1,an2,an3,aNorm,ua,ub,uc,nDotU
      real epsx

      real tau1,tau2,clap1,clap2,u1Lap,v1Lap,w1Lap,u2Lap,v2Lap,w2Lap,an1Cartesian,an2Cartesian,an3Cartesian
      real u1LapSq,v1LapSq,u2LapSq,v2LapSq,w1LapSq,w2LapSq


      integer np1a,np1b,np2a,np2b,np3a,np3b,diff(0:2)

      real rx,ry,rxx,rxy,ryy,rxxx,rxxy,rxyy,ryyy,rxxxx,rxxyy,ryyyy
      real sx,sy,sxx,sxy,syy,sxxx,sxxy,sxyy,syyy,sxxxx,sxxyy,syyyy

!     real rv1x(0:2),rv1y(0:2),rv1xx(0:2),rv1xy(0:2),rv1yy(0:2),rv1xxx(0:2),rv1xxy(0:2),rv1xyy(0:2),rv1yyy(0:2),\
!          rv1xxxx(0:2),rv1xxyy(0:2),rv1yyyy(0:2)
!     real sv1x(0:2),sv1y(0:2),sv1xx(0:2),sv1xy(0:2),sv1yy(0:2),sv1xxx(0:2),sv1xxy(0:2),sv1xyy(0:2),sv1yyy(0:2),\
!          sv1xxxx(0:2),sv1xxyy(0:2),sv1yyyy(0:2)
!     real rv2x(0:2),rv2y(0:2),rv2xx(0:2),rv2xy(0:2),rv2yy(0:2),rv2xxx(0:2),rv2xxy(0:2),rv2xyy(0:2),rv2yyy(0:2),\
!          rv2xxxx(0:2),rv2xxyy(0:2),rv2yyyy(0:2)
!     real sv2x(0:2),sv2y(0:2),sv2xx(0:2),sv2xy(0:2),sv2yy(0:2),sv2xxx(0:2),sv2xxy(0:2),sv2xyy(0:2),sv2yyy(0:2),\
!          sv2xxxx(0:2),sv2xxyy(0:2),sv2yyyy(0:2)

      integer numberOfEquations,job
      real a2(0:1,0:1),a4(0:3,0:3),a6(0:5,0:5),a8(0:7,0:7),a12(0:11,0:11),q(0:11),qOld(0:11),f(0:11),rcond,work(0:11)
      real a2f(0:1,0:1), a4f(0:3,0:3), a8f(0:7,0:7)
      integer ipvt(0:11), ipivot2(0:1), ipivot4(0:3), ipivot8(0:7)
      real a2h(0:1,0:1), a2hf(0:1,0:1), a4h(0:3,0:3), a4hf(0:3,0:3)
      integer ipivot2h(0:1), ipivot4h(0:3)
      logical first

      real err,errOld,errRatio,ratioAve
      integer debugFile,myid,parallel
      character*20 debugFileName

      ! for new evaluation method:
      real u1x,u1y,u1z,u1xx,u1xy,u1yy,u1xz,u1yz,u1zz
      real u2x,u2y,u2z,u2xx,u2xy,u2yy,u2xz,u2yz,u2zz

      real v1x,v1y,v1z,v1xx,v1xy,v1yy,v1xz,v1yz,v1zz
      real v2x,v2y,v2z,v2xx,v2xy,v2yy,v2xz,v2yz,v2zz

      real w1x,w1y,w1z,w1xx,w1xy,w1yy,w1xz,w1yz,w1zz
      real w2x,w2y,w2z,w2xx,w2xy,w2yy,w2xz,w2yz,w2zz

      real u1nx,u1ny,u1nz,u1nxx,u1nxy,u1nyy,u1nxz,u1nyz,u1nzz,u1nLap
      real v1nx,v1ny,v1nz,v1nxx,v1nxy,v1nyy,v1nxz,v1nyz,v1nzz,v1nLap

      real u2nx,u2ny,u2nz,u2nxx,u2nxy,u2nyy,u2nxz,u2nyz,u2nzz,u2nLap
      real v2nx,v2ny,v2nz,v2nxx,v2nxy,v2nyy,v2nxz,v2nyz,v2nzz,v2nLap

      real p1x,p1y,p1z,p1xx,p1xy,p1yy,p1xz,p1yz,p1zz,p1Lap
      real p1nx,p1ny,p1nz,p1nxx,p1nxy,p1nyy,p1nxz,p1nyz,p1nzz,p1nLap
      real p2x,p2y,p2z,p2xx,p2xy,p2yy,p2xz,p2yz,p2zz,p2Lap
      real p2nx,p2ny,p2nz,p2nxx,p2nxy,p2nyy,p2nxz,p2nyz,p2nzz,p2nLap

      real u1xxx,u1xxy,u1xyy,u1yyy, u1xxz,u1xzz,u1zzz, u1yyz, u1yzz
      real u2xxx,u2xxy,u2xyy,u2yyy, u2xxz,u2xzz,u2zzz, u2yyz, u2yzz
      real v1xxx,v1xxy,v1xyy,v1yyy, v1xxz,v1xzz,v1zzz, v1yyz, v1yzz
      real v2xxx,v2xxy,v2xyy,v2yyy, v2xxz,v2xzz,v2zzz, v2yyz, v2yzz
      real w1xxx,w1xxy,w1xyy,w1yyy, w1xxz,w1xzz,w1zzz, w1yyz, w1yzz
      real w2xxx,w2xxy,w2xyy,w2yyy, w2xxz,w2xzz,w2zzz, w2yyz, w2yzz

      real u1xxxx,u1xxyy,u1yyyy, u1xxzz,u1zzzz, u1yyzz
      real u2xxxx,u2xxyy,u2yyyy, u2xxzz,u2zzzz, u2yyzz
      real v1xxxx,v1xxyy,v1yyyy, v1xxzz,v1zzzz, v1yyzz
      real v2xxxx,v2xxyy,v2yyyy, v2xxzz,v2zzzz, v2yyzz
      real w1xxxx,w1xxyy,w1yyyy, w1xxzz,w1zzzz, w1yyzz
      real w2xxxx,w2xxyy,w2yyyy, w2xxzz,w2zzzz, w2yyzz

      real rxx1(0:2,0:2,0:2), rxx2(0:2,0:2,0:2)

      real dx112(0:2),dx122(0:2),dx212(0:2),dx222(0:2),dx141(0:2),dx142(0:2),dx241(0:2),dx242(0:2)
      real dr114(0:2),dr214(0:2)

      real cem1,divE1,curlE1x,curlE1y,curlE1z,nDotCurlE1,nDotLapE1
      real cem2,divE2,curlE2x,curlE2y,curlE2z,nDotCurlE2,nDotLapE2
      real c1x,c1y,c1z
      real c2x,c2y,c2z

      ! these are for the exact solution from TZ flow: 
      real ue,ve,we, we0,we1,we2,we3
      real uex,uey,uez, vex,vey,vez, wex,wey,wez, hex,hey,hez, evv(0:11), errv(0:11), maxErr
      real uexx,ueyy,uezz, vexx,veyy,vezz, wexx,weyy,wezz
      real ueLap, veLap, weLap
      real curlEex,curlEey,curlEez,nDotCurlEe,nDotLapEe
      real uexxx,uexxy,uexyy,ueyyy
      real vexxx,vexxy,vexyy,veyyy
      real wexxx,wexxy,wexyy,weyyy
      real uexxxx,uexxyy,ueyyyy,ueLapSq
      real vexxxx,vexxyy,veyyyy,veLapSq
      real wexxxx,wexxyy,weyyyy,weLapSq

      integer iv(0:2),ksv(0:2),sidea

      ! for impedance projection 
      integer useImpedanceInterfaceProjection
      real  ex1,ey1,ez1, hz1, ex2,ey2,ez2, hz2, nDotE1, nDotE2, epsNDotEI,  nDotEI, nDotE1I, nDotE2I
      real  exI, eyI, ezI, hzI, g1,g2, nDotEe

      ! boundary conditions parameters
      #Include "bcDefineFortranInclude.h"
 
      integer rectangular,curvilinear
      parameter(\
        rectangular=0,\
        curvilinear=1)

      ! Dispersion models
      integer noDispersion,drude,gdm
      parameter( noDispersion=0, drude=1, gdm=2 )

      ! Nonlinear models
      #Include "nonlinearModelsFortranInclude.h"
      ! integer nonlinearModel

      
      ! forcing options
      #Include "forcingDefineFortranInclude.h"

      ! Known solution options
      #Include "knownSolutionFortranInclude.h"
      integer knownSolutionOption

      integer useJacobiUpdate
      integer dispersionModel1, dispersionModel2, dispersive, jv, pxc
      integer gdmParOption
      integer maxNumberOfParameters,maxNumberOfPolarizationVectors,maxPolarizationComponents
      parameter( maxNumberOfParameters=4, maxNumberOfPolarizationVectors=20, maxPolarizationComponents=20*3 )
      integer numberOfPolarizationVectors1
      real gdmPar1(0:maxNumberOfParameters-1,0:maxNumberOfPolarizationVectors-1)
      real a0v1,a1v1,b0v1,b1v1

      integer numberOfPolarizationVectors2
      real gdmPar2(0:maxNumberOfParameters-1,0:maxNumberOfPolarizationVectors-1)
      real a0v2,a1v2,b0v2,b1v2

      integer numberOfTimeDerivatives
      real evals(0:2),evalse(0:2),dpdm
      real pvals(0:maxPolarizationComponents-1),pvalse(0:maxPolarizationComponents-1)
      real pvalsm(0:maxPolarizationComponents-1),pvalsp(0:maxPolarizationComponents-1)
     
      real pvc(0:maxNumberOfPolarizationVectors-1),pvm(0:maxNumberOfPolarizationVectors-1),fpv(0:maxNumberOfPolarizationVectors-1)
      real rhspv(0:maxNumberOfPolarizationVectors-1)
      real betav(0:maxNumberOfPolarizationVectors-1)
      real beta,fe,evm,pSum,rhsE,rhsP,tm
      real uet,uett
      integer addForcing

      ! variables for dispersive models
      real alphaP1,alphaP2
      real fp1(0:2), fp2(0:2)
      integer ec,pc,pce
      real pv,pvt,pvtt
      real ev,evt,evtt
      real Bk, Ck
      real Csum, beta1,beta2, c2Sum
      real fev1(0:2), fpSum1(0:2), fpv1(0:2,0:maxNumberOfPolarizationVectors-1)
      real fev2(0:2), fpSum2(0:2), fpv2(0:2,0:maxNumberOfPolarizationVectors-1)
      real es(0:2), est(0:2), estt(0:2), esxx(0:2), esyy(0:2), eszz(0:2)
      real pe(0:2), pet(0:2), pett(0:2), pettSum1(0:2), pettSum2(0:2)
      real p0,p0t,p0tt

      real p1v(0:2), p2v(0:2), D1v(0:2), D2v(0:2)
      real p1ev(0:2), p2ev(0:2)
      real nDotD1,nDotD2, nDotP1, nDotP2, nDotP1e,nDotP2e, nDotDe, nDotDI
      real nDotFp1, nDotFp2
      real betac1,betac2

      ! variables for 4th-order GDM interface
      real c2PttLE,c2PttE,c2PttEm,c2PttP,c2PttPm,c2PttfE,c2PttfP
      real c4PttLE,c4PttE,c4PttEm,c4PttP,c4PttPm,c4PttfE,c4PttfP
      real c4PttLLE,c4PttLP,c4PttLEm,c4PttLPm,c4PttLfE,c4PttLfP
      real c4PttfEt,c4PttfEtt,c4PttfPt,c4PttfPtt
      real c2EtLE,c2EtE,c2EtEm,c2EtP,c2EtPm,c2EtfE,c2EtfP
      real c2PtLE,c2PtE,c2PtEm,c2PtP,c2PtPm,c2PtfE,c2PtfP

      real c2PttttLE,c2PttttE,c2PttttEm,c2PttttP,c2PttttPm,c2PttttLLE,c2PttttLEm,c2PttttLP,c2PttttLPm
      real c2PttttfE,c2PttttfP,c2PttttfEt,c2PttttfPt,c2PttttfEtt,c2PttttfPtt,c2PttttLfe,c2PttttLfP

      real c2PttEsum1, c2PttEsum2, c2PttLEsum1, c2PttLEsum2
      real c4PttLEsum1, c4PttLLEsum1, c4PttLEsum2, c4PttLLEsum2
      real c2PttttLEsum1, c2PttttLLEsum1, c2PttttLEsum2, c2PttttLLEsum2

      real coeffLap1,coeffLapSq1,coeffLap2,coeffLapSq2

      integer ismooth,nsmooth
      real eqnCoeff,eqnCoeffb 
      real curl1um1,curl1vm1,curl1um2,curl1vm2
      real curl2um1,curl2vm1,curl2um2,curl2vm2


      real evn,pvn,evec(0:2),pvec(0:2,0:maxNumberOfPolarizationVectors-1)
      real ptv(0:2,0:maxNumberOfPolarizationVectors-1),pttv(0:2,0:maxNumberOfPolarizationVectors-1),ptttv(0:2,0:maxNumberOfPolarizationVectors-1),pttttv(0:2,0:maxNumberOfPolarizationVectors-1)
      real alpha,d4,LPn,LP,LPm
      real LE(0:2)
      real LE1(0:2),LE1m(0:2),LLE1(0:2), LEx1(0:2),LEy1(0:2)
      real LE2(0:2),LE2m(0:2),LLE2(0:2), LEx2(0:2),LEy2(0:2) 

      real LfE1(0:2),fEt1(0:2),fEtt1(0:2)
      real LfP1(0:2,0:maxNumberOfPolarizationVectors-1),fPt1(0:2,0:maxNumberOfPolarizationVectors-1)
      real fPtt1(0:2,0:maxNumberOfPolarizationVectors-1)

      real LfE2(0:2),fEt2(0:2),fEtt2(0:2)
      real LfP2(0:2,0:maxNumberOfPolarizationVectors-1),fPt2(0:2,0:maxNumberOfPolarizationVectors-1)
      real fPtt2(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevtt1(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevtt2(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevttL1(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevttL2(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevttx1(0:2,0:maxNumberOfPolarizationVectors-1),pevtty1(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevttx2(0:2,0:maxNumberOfPolarizationVectors-1),pevtty2(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevttSum1(0:2),pevttxSum1(0:2),pevttySum1(0:2)
      real pevttSum2(0:2),pevttxSum2(0:2),pevttySum2(0:2)
      real pevttt1(0:2,0:maxNumberOfPolarizationVectors-1),pevttt2(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevtttt1(0:2,0:maxNumberOfPolarizationVectors-1),pevtttt2(0:2,0:maxNumberOfPolarizationVectors-1)
      real pevttLSum1(0:2),pevttLSum2(0:2),pevttttSum1(0:2),pevttttSum2(0:2)

      real petttSum

      real esttt(0:2),estxx(0:2),estyy(0:2),esttxx(0:2),esttyy(0:2),esxxxx(0:2),esxxyy(0:2),esyyyy(0:2)
      real esttx(0:2),estty(0:2),esxxx(0:2),esxyy(0:2),esxxy(0:2),esyyy(0:2),esx(0:2),esy(0:2),estx(0:2),esty(0:2)
      real pettt(0:2),pexx(0:2),peyy(0:2),petxx(0:2),petyy(0:2),pettxx(0:2),pettyy(0:2)
      real pettx(0:2),petty(0:2),pex(0:2),pey(0:2),petx(0:2),pety(0:2)

      real estttt(0:2),petttt(0:2)
      real esL,estL,esttL,esLL,esLx,esLy
      real peL,petL,pettL,ptta,ptttta

      real pvx,pvy,pvz, pvnx,pvny,pvnz, pttxa,pttya,pttza, Lptta
      real fPttx1(0:2), fPtty1(0:2), fPttx2(0:2), fPtty2(0:2), fLPtt1(0:2), fLPtt2(0:2), fPtttt1(0:2), fPtttt2(0:2)
      real evx1(0:2),evy1(0:2),evnx1(0:2),evny1(0:2)
      real evx2(0:2),evy2(0:2),evnx2(0:2),evny2(0:2)
      real fevx1(0:2),fevy1(0:2),fevz1(0:2)
      real fevx2(0:2),fevy2(0:2),fevz2(0:2)
      real fpvx1(0:2,0:maxNumberOfPolarizationVectors-1),fpvy1(0:2,0:maxNumberOfPolarizationVectors-1)
      real fpvx2(0:2,0:maxNumberOfPolarizationVectors-1),fpvy2(0:2,0:maxNumberOfPolarizationVectors-1)

      ! For checking coefficients by delta approach: 
      real u1s(-5:5,-5:5,-5:5,0:2), u2s(-5:5,-5:5,-5:5,0:2)
      real coeffDiff, dsBig
      integer checkCoeff, saveCoeff, coeffFile, k, avoidInterfaceIterations
      integer hw1,hw2,hw3
      real f0(0:11),delta

      ! for saving coefficients
      real am(12,500)
      integer ieqn,ja
      integer i1a,i1b,i1c,i2a,i2b,i2c,i3a,i3b,i3c
      integer j1a,j1b,j1c,j2a,j2b,j2c,j3a,j3b,j3c


      ! ----- multilevel atomic model -----
      integer useNonlinearModel
      integer nonlinearModel1,numberOfAtomicLevels1,maxPar1,numPolar1
      integer nonlinearModel2,numberOfAtomicLevels2,maxPar2,numPolar2
      integer na,nce
      real q0,q0t,q0tt,q0ttt,q0tttt,q0xx,q0yy,q0x,q0y
      real pnec1,prc1,peptc1
      real pnec2,prc2,peptc2
      integer maxPar
      parameter( maxPar=20 )
      real nlPar1(0:maxPar-1,0:maxPar-1,0:2)
      real nlPar2(0:maxPar-1,0:maxPar-1,0:2)
      real fnv(0:maxPar-1),fnv1(0:maxPar-1),fnv2(0:maxPar-1)
      real fntv(0:maxPar-1),fntv1(0:maxPar-1),fntv2(0:maxPar-1)
      real fnttv(0:maxPar-1),fnttv1(0:maxPar-1),fnttv2(0:maxPar-1)
      real fntttv(0:maxPar-1),fntttv1(0:maxPar-1),fntttv2(0:maxPar-1)
      real qv(0:maxPar-1),qvn(0:maxPar-1),qvm(0:maxPar-1)
      real qt(0:maxPar-1),qtt(0:maxPar-1),qttt(0:maxPar-1),qtttt(0:maxPar-1)
      real qex(0:maxPar-1),qey(0:maxPar-1),qeLap(0:maxPar-1)

      real q1x,q1y,q1Lap,q1xx,q1yy,q1xy
      real q2x,q2y,q2Lap,q2xx,q2yy,q2xy
      real qvx,qvy,qvLap

      real evx0,evy0,pv0,ev0,evLap
      
      real checkParallelFortranArrayReal, checkParallelFortranArrayInt, pdiff
      integer numParallelGhost
      integer nd4a,nd4b,n4a,n4b
      integer md4a,md4b,m4a,m4b
      character*180 label


!     --- start statement function ----
! .......statement functions for GDM parameters
      a0v1(jv) = gdmPar1(0,jv)
      a1v1(jv) = gdmPar1(1,jv)
      b0v1(jv) = gdmPar1(2,jv)
      b1v1(jv) = gdmPar1(3,jv)

      a0v2(jv) = gdmPar2(0,jv)
      a1v2(jv) = gdmPar2(1,jv)
      b0v2(jv) = gdmPar2(2,jv)
      b1v2(jv) = gdmPar2(3,jv)

      ! ..... statement functions for multilevel atomic model
      ! pnec  = polarizationNECoefficients
      ! prc   = populationRelaxationCoefficients
      ! peptc = populationEPtCoefficients
      pnec1(m1,m2)  = nlPar1(m1,m2,0)
      prc1(m1,m2)   = nlPar1(m1,m2,1)
      peptc1(m1,m2) = nlPar1(m1,m2,2)

      pnec2(m1,m2)  = nlPar2(m1,m2,0)
      prc2(m1,m2)   = nlPar2(m1,m2,1)
      peptc2(m1,m2) = nlPar2(m1,m2,2)


      integer kd,m,n
!     real rx,ry,rz,sx,sy,sz,tx,ty,tz
!*      declareDifferenceNewOrder2(u1,rsxy1,dr1,dx1,RX)
!*      declareDifferenceNewOrder2(u2,rsxy2,dr2,dx2,RX)

!*      declareDifferenceNewOrder4(u1,rsxy1,dr1,dx1,RX)
!*      declareDifferenceNewOrder4(u2,rsxy2,dr2,dx2,RX)

!.......statement functions for jacobian
!     rx(i1,i2,i3)=rsxy1(i1,i2,i3,0,0)
!     ry(i1,i2,i3)=rsxy1(i1,i2,i3,0,1)
!     rz(i1,i2,i3)=rsxy1(i1,i2,i3,0,2)
!     sx(i1,i2,i3)=rsxy1(i1,i2,i3,1,0)
!     sy(i1,i2,i3)=rsxy1(i1,i2,i3,1,1)
!     sz(i1,i2,i3)=rsxy1(i1,i2,i3,1,2)
!     tx(i1,i2,i3)=rsxy1(i1,i2,i3,2,0)
!     ty(i1,i2,i3)=rsxy1(i1,i2,i3,2,1)
!     tz(i1,i2,i3)=rsxy1(i1,i2,i3,2,2) 


!     The next macro call will define the difference approximation statement functions
!*      defineDifferenceNewOrder2Components1(u1,rsxy1,dr1,dx1,RX)
!*      defineDifferenceNewOrder2Components1(u2,rsxy2,dr2,dx2,RX)

!*      defineDifferenceNewOrder4Components1(u1,rsxy1,dr1,dx1,RX)
!*      defineDifferenceNewOrder4Components1(u2,rsxy2,dr2,dx2,RX)

      declareTemporaryVariables(2,2)
      declareParametricDerivativeVariables(uu1,3) 
      declareParametricDerivativeVariables(uu2,3) 
      declareParametricDerivativeVariables(vv1,3)   ! declare temp variables uu, uur, uus, ...
      declareParametricDerivativeVariables(vv2,3) 
      declareParametricDerivativeVariables(ww1,3)   ! declare temp variables uu, uur, uus, ...
      declareParametricDerivativeVariables(ww2,3) 
      declareJacobianDerivativeVariables(aj1,3)     ! declareJacobianDerivativeVariables(aj,DIM)
      declareJacobianDerivativeVariables(aj2,3)     ! declareJacobianDerivativeVariables(aj,DIM)

!............... end statement functions

      ierr=0

      side1                =ipar(0)
      axis1                =ipar(1)
      grid1                =ipar(2)
      n1a                  =ipar(3)
      n1b                  =ipar(4)
      n2a                  =ipar(5)
      n2b                  =ipar(6)
      n3a                  =ipar(7)
      n3b                  =ipar(8)

      side2                =ipar(9)
      axis2                =ipar(10)
      grid2                =ipar(11)
      m1a                  =ipar(12)
      m1b                  =ipar(13)
      m2a                  =ipar(14)
      m2b                  =ipar(15)
      m3a                  =ipar(16)
      m3b                  =ipar(17)

      gridType             =ipar(18)
      orderOfAccuracy      =ipar(19)
      orderOfExtrapolation =ipar(20)  ! maximum allowable order of extrapolation
      useForcing           =ipar(21)
      ex                   =ipar(22)
      ey                   =ipar(23)
      ez                   =ipar(24)
      hx                   =ipar(25)
      hy                   =ipar(26)
      hz                   =ipar(27)
      solveForE            =ipar(28)
      solveForH            =ipar(29)
      useWhereMask         =ipar(30)
      debug                =ipar(31)
      nit                  =ipar(32)
      interfaceOption      =ipar(33)
      initialized          =ipar(34)
      myid                 =ipar(35)
      parallel             =ipar(36)
      forcingOption        =ipar(37)
      interfaceEquationsOption  =ipar(38)
      assignInterfaceValues     =ipar(39)
      assignInterfaceGhostValues=ipar(40)
      setDivergenceAtInterfaces =ipar(41)
      ! *new* *wdh* June 28, 2016
      !  useImpedanceInterfaceProjection=0: OLD way 
      !  useImpedanceInterfaceProjection=1: new way using impedance weighting (see maxwell.pdf)
      useImpedanceInterfaceProjection=ipar(42)
      ! numberOfInterfaceIterationsUsed = ipar(43)  ! returned value 
      ipar(43)=0
      
      dispersionModel1    = ipar(44)
      dispersionModel2    = ipar(45)
      pxc                 = ipar(46)
      knownSolutionOption = ipar(47)
      useJacobiUpdate     = ipar(48)

      nonlinearModel1     = ipar(49)
      nonlinearModel2     = ipar(50)
      numParallelGhost    = ipar(51)

      internalGhostBC     = ipar(52)  ! bc value for internal parallel boundaries 

      dx1(0)                =rpar(0)
      dx1(1)                =rpar(1)
      dx1(2)                =rpar(2)
      dr1(0)                =rpar(3)
      dr1(1)                =rpar(4)
      dr1(2)                =rpar(5)

      dx2(0)                =rpar(6)
      dx2(1)                =rpar(7)
      dx2(2)                =rpar(8)
      dr2(0)                =rpar(9)
      dr2(1)                =rpar(10)
      dr2(2)                =rpar(11)

      t                    =rpar(12)
      ep                   =rpar(13) ! pointer for exact solution
      dt                   =rpar(14)
      eps1                 =rpar(15)
      mu1                  =rpar(16)
      c1                   =rpar(17)
      eps2                 =rpar(18)
      mu2                  =rpar(19)
      c2                   =rpar(20)
      omega                =rpar(21)

      ! rpar(22) : averageInterfaceConvergenceRate : return value 
      ! rpar(23) : maxFinalResidual : return value 
     
      relativeErrorTolerance = rpar(24)
      absoluteErrorTolerance = rpar(25)

      ! absoluteErrorTolerance=1.e-10  ! fix me -- need a relative tol
      ! absoluteErrorTolerance=1.e-15  ! fix me -- need a relative tol

      cSq1=c1**2
      cSq2=c2**2
      dtSq=dt**2

      eta1=sqrt(mu1/eps1) ! electrical impedance
      eta2=sqrt(mu2/eps2) ! electrical impedance
      eta1i=1./eta1
      eta2i=1./eta2

      epsmu1=eps1*mu1
      epsmu2=eps2*mu2

      twilightZone=useForcing

      ! For updating P on ghost using PDE: 
      addForcing=0 ! fix me *******************************
      if( twilightZone.ne.0 )then
        addForcing=twilightZoneForcing
      end if

      avoidInterfaceIterations=1  ! option to avoid interface iterations. *new* July 6 2019 
      dsBig = 1.e20               ! Large value for tangential grid spacing to zero out mixed derivatives
      if( avoidInterfaceIterations.eq.1 )then     
        nit=1
        omega=1.    ! do not under-relax iterations

        axis1p1=mod(axis1+1,3)
        axis1p2=mod(axis1+2,3)
        axis2p1=mod(axis2+1,3)
        axis2p2=mod(axis2+2,3)

        ! dr1a(0:2) = sets grid spacing in tangential directions to dsBig 
        dr1a(axis1  )=dr1(axis1)
        dr1a(axis1p1)=dsBig
        dr1a(axis1p2)=dsBig

        ! dr2a(0:2) = sets grid spacing in tangential directions to dsBig 
        dr2a(axis2  )=dr2(axis2)
        dr2a(axis2p1)=dsBig
        dr2a(axis2p2)=dsBig

      end if


      checkCoeff=0 ! 0 ! 1  ! if non-zero then check coefficients in interface equations using delta approach
      if( t.gt.1.5*dt )then
         checkCoeff=0    ! turn off for t>0 
      end if 
      coeffDiff=0.
      saveCoeff=0  ! 1 : save coefficients in the interface equations to a file
      coeffFile=20  ! file for saving coefficients
      ieqn=-1      ! counts equations
      if( saveCoeff.eq.1 .and. initialized.eq.0 .and. assignInterfaceGhostValues.eq.1 )then
        open (coeffFile,file='interfaceCoeff.dat',status='unknown',form='formatted')
        write(coeffFile,'("! Coefficients in the interface equations")') 
        write(coeffFile,'("! nd,orderOfAccuracy")') 
        write(coeffFile,'(2(i6,1x))') nd,orderOfAccuracy
        write(coeffFile,'(9(i6,1x))') side1,axis1,grid1, n1a,n1b,n2a,n2b,n3a,n3b
        write(coeffFile,'(9(i6,1x))') side2,axis2,grid2, m1a,m1b,m2a,m2b,m3a,m3b
      end if

      debugFile=10
      if( initialized.eq.0 .and. debug.gt.0 )then
        ! open debug files
        ! open (debugFile,file=filen,status='unknown',form='formatted')
        if( myid.lt.10 )then
          write(debugFileName,'("mxi",i1,".fdebug")') myid
        else
          write(debugFileName,'("mxi",i2,".fdebug")') myid
        end if
        write(*,*) 'interface3d: myid=',myid,' open debug file:',debugFileName
        open (debugFile,file=debugFileName,status='unknown',form='formatted')
        ! '
        ! INQUIRE(FILE=filen, EXIST=filex)
      end if

      if( t.le. 1.5*dt .and. debug.gt.0 )then
        write(*,'(" +++++++++cgmx interface3d t=",e9.2," dt=",e9.2," nit=",i3," ++++++++")') t,dt,nit
           ! '
        write(*,'("  ... nd=",i2," gridType=",i2," order=",i2," debug=",i3,", ex=",i2)') nd,gridType,orderOfAccuracy,debug,ex
        write(*,'("  ... assignInterface=",i2," assignGhost=",i2)') assignInterfaceValues,assignInterfaceGhostValues
        write(*,'("  ... useJacobiUpdate=",i2," numParallelGhost=",i2)') useJacobiUpdate,numParallelGhost
        write(*,'("  ... setDivergenceAtInterfaces=",i2)') setDivergenceAtInterfaces
        write(*,'("  ... useImpedanceInterfaceProjection=",i2)') useImpedanceInterfaceProjection
        write(*,'("  ... avoidInterfaceIterations=",i2)') avoidInterfaceIterations
        write(*,'("  ... useImpedanceInterfaceProjection=",i2)') useImpedanceInterfaceProjection
        write(*,'("  ... interface its (4th-order) relativeTol=",e12.3," absoluteTol=",e12.3)') relativeErrorTolerance,absoluteErrorTolerance
        write(*,'("  ... bc1=",6i6)') ((boundaryCondition1(i1,i2),i1=0,1),i2=0,nd-1)
        write(*,'("  ... bc2=",6i6)') ((boundaryCondition2(i1,i2),i1=0,1),i2=0,nd-1)
        write(*,'("  ... internalGhostBC=",i6)') internalGhostBC

      end if

      if( t.lt.1.5*dt .and. debug.gt.0 )then
        write(debugFile,'(" +++++++++cgmx interface3d t=",e9.2," ++++++++")') t
           ! '
        write(debugFile,'(" interface3d: nd=",i2," gridType=",i2)') nd,gridType
        write(debugFile,'("  ... nd=",i2," gridType=",i2," order=",i2," debug=",i3)') nd,gridType,orderOfAccuracy,debug
        write(debugFile,'("  ... assignInterface=",i2," assignGhost=",i2)') assignInterfaceValues,assignInterfaceGhostValues
      end if

      if( abs(c1*c1-1./(mu1*eps1)).gt. 1.e-10 )then
        write(debugFile,'(" interface3d:ERROR: c1,eps1,mu1=",3e10.2," not consistent")') c1,eps1,mu1
           ! '
        stop 11
      end if
      if( abs(c2*c2-1./(mu2*eps2)).gt. 1.e-10 )then
        write(debugFile,'(" interface3d:ERROR: c2,eps2,mu2=",3e10.2," not consistent")') c2,eps2,mu2
           ! '
        stop 11
      end if

      if( .false. )then
        write(debugFile,'(" interface3d: eps1,eps2=",2f10.5," c1,c2=",2f10.5)') eps1,eps2,c1,c2
           ! '
      end if

      if( nit.lt.0 .or. nit.gt.100 )then
        write(debugFile,'(" interfaceBC: ERROR: nit=",i9)') nit
        nit=max(1,min(100,nit))
      end if

      if( debug.gt.1 )then
        write(debugFile,'("********************************************************************** ")')
        write(debugFile,'(" interface3d: **START** t=",e10.2)') t
        write(debugFile,'(" interface3d: **START** grid1=",i4," side1,axis1=",2i2," bc=",6i3)') grid1,side1,axis1,\
           boundaryCondition1(0,0),boundaryCondition1(1,0),boundaryCondition1(0,1),boundaryCondition1(1,1),boundaryCondition1(0,2),boundaryCondition1(1,2)
           ! '
        write(debugFile,'(" interface3d: **START** grid2=",i4," side2,axis2=",2i2," bc=",6i3)') grid2,side2,axis2,\
           boundaryCondition2(0,0),boundaryCondition2(1,0),boundaryCondition2(0,1),boundaryCondition2(1,1),boundaryCondition2(0,2),boundaryCondition2(1,2)
           ! '
        write(debugFile,'("n1a,n1b,...=",6i5)') n1a,n1b,n2a,n2b,n3a,n3b
        write(debugFile,'("m1a,m1b,...=",6i5)') m1a,m1b,m2a,m2b,m3a,m3b

      end if
      if( debug.gt.8 )then
       write(debugFile,'("start u1=",(3i4,1x,3e11.2))') (((i1,i2,i3,(u1(i1,i2,i3,m),m=0,2),i1=nd1a,nd1b),i2=nd2a,nd2b),i3=nd3a,nd3b)
       write(debugFile,'("start u2=",(3i4,1x,3e11.2))') (((i1,i2,i3,(u2(i1,i2,i3,m),m=0,2),i1=md1a,md1b),i2=md2a,md2b),i3=md3a,md3b)
      end if
     

      dispersive=0 ! >0 implies at least one side is dispersive
      gdmParOption=1 ! scale a0 and a1 parameters by eps
      if( dispersionModel1.ne.noDispersion )then
        dispersive=dispersive+1
  
        ! get the gdm parameters
        !   gdmPar(0:3,jv) = (a0,a1,b0,b1) 
        call getGDMParameters( grid1,alphaP1,gdmPar1,numberOfPolarizationVectors1, maxNumberOfParameters,maxNumberOfPolarizationVectors,gdmParOption )

        if( t.le. 1.5*dt .and. debug.gt.0 )then
          ! ---- Dispersive Maxwell ----
          write(*,'("--interface3d-- dispersionModel1=",i4," grid1=",i4," pxc=",i4)') dispersionModel1,grid1,pxc
          write(*,'("--interface3d-- GDM: numberOfPolarizationVectors1=",i4," alphaP1=",e8.2)') numberOfPolarizationVectors1,alphaP1
          do jv=0,numberOfPolarizationVectors1-1
            write(*,'("--interface3d-- GDM: eqn=",i3," a0,a1,b0,b1=",4(1p,e10.2))') jv,a0v1(jv),a1v1(jv),b0v1(jv),b1v1(jv)
          end do 
        end if
      else
        numberOfPolarizationVectors1=0
      end if

      if( dispersionModel2.ne.noDispersion )then
        dispersive=dispersive+1

        ! get the gdm parameters
        !   gdmPar(0:3,jv) = (a0,a1,b0,b1) 
        call getGDMParameters( grid2,alphaP2,gdmPar2,numberOfPolarizationVectors2, maxNumberOfParameters,maxNumberOfPolarizationVectors,gdmParOption )
        if( t.le. 1.5*dt .and. debug.gt.0 )then
          ! ---- Dispersive Maxwell ----
          write(*,'("--interface3d-- dispersionModel2=",i4," grid2=",i4)') dispersionModel2,grid2
          write(*,'("--interface3d-- GDM: numberOfPolarizationVectors2=",i4," alphaP2=",e8.2)') numberOfPolarizationVectors2,alphaP2

          do jv=0,numberOfPolarizationVectors2-1
            write(*,'("--interface3d-- GDM: eqn=",i3," a0,a1,b0,b1=",4(1p,e10.2))') jv,a0v2(jv),a1v2(jv),b0v2(jv),b1v2(jv)
          end do 
        end if

        ! write(*,'(" interface: FINISH ME")') 
        ! stop 1111
      else
        numberOfPolarizationVectors2=0
      end if

      useNonlinearModel=0
      
      if( nonlinearModel1 .ne. noNonlinearModel )then
        write(*,'("--interface3d-- nonlinearModel1=",i4," (1=multilevelAtomic)")') nonlinearModel1
        useNonlinearModel=1
        call getMultilevelAtomicParameters( grid1, nlPar1, maxPar, maxPar, numPolar1, numberOfAtomicLevels1 )
        if( numPolar1.ne.numberOfPolarizationVectors1 )then
          write(*,'(" interface3d:ERROR: numberOfPolarizationVectors1 does not match numPolar1 from nonlinear model!!")')
          stop 8888
        end if
     
        write(*,'("multilevelAtomic: numberOfPolarizationVectors1=",i4,"  numberOfAtomicLevels1=",i4)') numberOfPolarizationVectors1, numberOfAtomicLevels1
        write(*,'("polarizationNECoefficients1:")')
        do m1=0,numberOfPolarizationVectors1-1
          write(*,'( 10(e12.3,1x) )') (pnec1(m1,m2),m2=0,numberOfAtomicLevels1-1)
        end do 
     
        write(*,'("populationRelaxationCoefficients1:")')
        do m1=0,numberOfAtomicLevels1-1
          write(*,'( 10(e12.3,1x) )') (prc1(m1,m2),m2=0,numberOfAtomicLevels1-1)
        end do 
     
        write(*,'("populationEPtCoefficients1:")')
        do m1=0,numberOfAtomicLevels1-1
          write(*,'( 10(e12.3,1x) )') (peptc1(m1,m2),m2=0,numberOfPolarizationVectors1-1)
        end do 
      end if 

      if( nonlinearModel2 .ne. noNonlinearModel )then
        useNonlinearModel=1
        write(*,'("--interface3d-- nonlinearModel2=",i4," (1=multilevelAtomic)")') nonlinearModel2
        call getMultilevelAtomicParameters( grid2, nlPar2, maxPar, maxPar, numPolar2, numberOfAtomicLevels2 )
        if( numPolar2.ne.numberOfPolarizationVectors2 )then
          write(*,'(" interface3d:ERROR: numberOfPolarizationVectors2 does not match numPolar2 from nonlinear model!!")')
          stop 9999
        end if
     
        write(*,'("multilevelAtomic: numberOfPolarizationVectors2=",i4,"  numberOfAtomicLevels2=",i4)') numberOfPolarizationVectors2, numberOfAtomicLevels2
        write(*,'("polarizationNECoefficients2:")')
        do m1=0,numberOfPolarizationVectors2-1
          write(*,'( 10(e12.3,1x) )') (pnec2(m1,m2),m2=0,numberOfAtomicLevels2-1)
        end do 
     
        write(*,'("populationRelaxationCoefficients2:")')
        do m1=0,numberOfAtomicLevels2-1
          write(*,'( 10(e12.3,1x) )') (prc2(m1,m2),m2=0,numberOfAtomicLevels2-1)
        end do 
     
        write(*,'("populationEPtCoefficients2:")')
        do m1=0,numberOfAtomicLevels2-1
          write(*,'( 10(e12.3,1x) )') (peptc2(m1,m2),m2=0,numberOfPolarizationVectors2-1)
        end do 
      end if 


      epsx=1.e-20  ! fix this 

      ! --- init various variables and loop bounds ----
      initializeInterfaceVariablesMacro(interface3d)

      rx1=0.
      ry1=0.
      rz1=0.
      if( axis1.eq.0 )then
        rx1=1.
      else if( axis1.eq.1 )then
        ry1=1.
      else 
        rz1=1.
      endif

      rx2=0.
      ry2=0.
      rz2=0.
      if( axis2.eq.0 )then
        rx2=1.
      else if( axis2.eq.1 )then
        ry2=1.
      else 
        rz2=1.
      endif

      ! first time through check that the mask's are consistent
      ! For now we require the masks to both be positive at the same points on the interface
      ! We assign pts where both mask1 and mask2 are discretization pts.
      ! If mask1>0 and mask2<0 then we just leave the extrapolated values in u1 and u2 .  
      if( initialized.eq.0 )then
       if( nd.eq.2 )then
        ! check the consistency of the mask arrays
        beginLoops2d()
          m1 = mask1(i1,i2,i3)
          m2 = mask2(j1,j2,j3)
          if( (m1.gt.0 .and. m2.eq.0) .or. (m1.eq.0 .and. m2.gt.0) )then
            write(debugFile,'(" interface3d:ERROR: mask1 and mask2 do not agree. One is >0 and one =0 ")')
             ! '
            stop 1111
          end if 
        endLoops2d()

       else if( nd.eq.3 )then
        ! check the consistency of the mask arrays
        beginLoops3d()
          m1 = mask1(i1,i2,i3)
          m2 = mask2(j1,j2,j3)
          if( (m1.gt.0 .and. m2.eq.0) .or. (m1.eq.0 .and. m2.gt.0) )then
            write(debugFile,'(" interface3d:ERROR: mask1 and mask2 do not agree. One is >0 and one =0")')
             ! '
            stop 1111
          end if 
        endLoops3d()

       end if
       if( debug.gt.0 )then
         write(debugFile,'("cgmx:interface3d: The mask arrays for grid1=",i3," and grid2=",i3," were found to be consistent")') grid1,grid2
         ! ' 
       end if
      end if

      if( nd.eq.2 .and. orderOfAccuracy.eq.2 .and. gridType.eq.rectangular )then
 
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #If #GRIDTYPE eq "rectangular"
        #If #DIM eq "2"
        #If #ORDER eq "2"
        
         ! ************************************
         ! ***** 2d rectangular 2nd-order *****
         ! ************************************

         assignInterfaceMacro22r(MODEL)


        #End
        #End
        #End
        ! End rectangular, 2D, order 2
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       else if( nd.eq.2 .and. orderOfAccuracy.eq.2 .and. gridType.eq.curvilinear )then

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #If #GRIDTYPE eq "curvilinear"
        #If #DIM eq "2"
        #If #ORDER eq "2"

         ! *******************************
         ! ***** 2d curvilinear case *****
         ! *******************************

         assignInterfaceMacro22c(MODEL)

         
        #End
        #End
        #End
        ! End curvilinear, 2D, order 2
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       else if( nd.eq.2 .and. orderOfAccuracy.eq.4 .and. gridType.eq.rectangular )then

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #If #GRIDTYPE eq "rectangular"
        #If #DIM eq "2"
        #If #ORDER eq "4"


         ! ************************************
         ! ***** 2d rectangular 4th-order *****
         ! ************************************

         assignInterfaceMacro24r(MODEL)

       

        #End
        #End
        #End
        ! End rectangular, 2D, order 4
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


       else if( nd.eq.2 .and. orderOfAccuracy.eq.4 .and. gridType.eq.curvilinear )then

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #If #GRIDTYPE eq "curvilinear"
        #If #DIM eq "2"
        #If #ORDER eq "4"
        

         ! ************************************
         ! ***** 2d rectangular 4th-order *****
         ! ************************************

         assignInterfaceMacro24c(MODEL)

        #End
        #End
        #End
        ! End curvilinear, 2D, order 4
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

         
       else if( nd.eq.3 .and. orderOfAccuracy.eq.2 .and. gridType.eq.curvilinear )then

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        #If #GRIDTYPE eq "curvilinear"
        #If #DIM eq "3"
        #If #ORDER eq "2"
        
         
         ! ***********************************************
         ! ***** 3D curvilinear case -- second-order *****
         ! ***********************************************

         assignInterfaceMacro32c(MODEL)
        

        #End
        #End
        #End
        ! End rectangular, 3D, order 2
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


       else if( nd.eq.3 .and. orderOfAccuracy.eq.4 .and. gridType.eq.curvilinear )then

         ! called elsewhere 
         stop 4562
     !-         call interfaceOpt3dOrder4( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
     !-                               gridIndexRange1, u1,u1n,u1m,wk1, mask1,rsxy1, xy1, p1,p1n,p1m, boundaryCondition1, \
     !-                               md1a,md1b,md2a,md2b,md3a,md3b,\
     !-                               gridIndexRange2, u2,u2n,u2m,wk2, mask2,rsxy2, xy2, p2,p2n,p2m, boundaryCondition2, \
     !-                               ipar, rpar, \
     !-                               aa2,aa4,aa8, ipvt2,ipvt4,ipvt8, \
     !-                               ierr )

       else
         if( nd.eq.3 .and. gridType.eq.rectangular )then
           write(*,'("interface3d: ERROR: 3d rectangular not implemented for interfaces")') 
         else 
           write(debugFile,'("interface3d: ERROR: unknown options nd,order=",2i3)') nd,orderOfAccuracy
           write(*,'("interface3d: ERROR: unknown options nd,order,gridType=",3i3)') nd,orderOfAccuracy,gridType
         end if
         stop 3214
       end if

      return
      end
#endMacro
! ================================= end interface macro ====================================      





#beginMacro buildFile(NAME,DIM,ORDER,GRIDTYPE,MODEL)
#beginFile NAME.f90
 INTERFACE(NAME,DIM,ORDER,GRIDTYPE,MODEL)
#endFile
#endMacro

! ***************************************************************************************************
! **************************  Build different interface files ****************************************
! ***************************************************************************************************

!** Note: comment out these next lines to avoid compiling files while developing one version 

buildFile(interfaceMx2dOrder2r,2,2,rectangular,none)
buildFile(interfaceMx2dOrder2c,2,2,curvilinear,none)
buildFile(interfaceMx2dOrder4r,2,4,rectangular,none)
buildFile(interfaceMx2dOrder4c,2,4,curvilinear,none)
buildFile(interfaceMx3dOrder2c,3,2,curvilinear,none)
!- 
!- 
!- ! --- GDM versions ---
buildFile(interfaceMxGDM2dOrder2r,2,2,rectangular,gdm)
buildFile(interfaceMxGDM2dOrder2c,2,2,curvilinear,gdm)
buildFile(interfaceMxGDM2dOrder4r,2,4,rectangular,gdm)
buildFile(interfaceMxGDM2dOrder4c,2,4,curvilinear,gdm)
buildFile(interfaceMxGDM3dOrder2c,3,2,curvilinear,gdm)
!- 
!- ! --- MLA versions ---
buildFile(interfaceMxMLA2dOrder2r,2,2,rectangular,mla)
buildFile(interfaceMxMLA2dOrder2c,2,2,curvilinear,mla)
buildFile(interfaceMxMLA2dOrder4r,2,4,rectangular,mla)
buildFile(interfaceMxMLA2dOrder4c,2,4,curvilinear,mla)
buildFile(interfaceMxMLA3dOrder2c,3,2,curvilinear,mla)


! -----------------------------------------------------------------------------------------------
! Macro to call a given interface routine.
!  Do this since the arguments lists are the same for all cases
! -----------------------------------------------------------------------------------------------
#beginMacro callRoutine( NAME )
  call NAME( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
             gridIndexRange1, u1,u1n,u1m, wk1, mask1,rsxy1, xy1, p1,p1n,p1m, q1,q1n,q1m, boundaryCondition1, \
             md1a,md1b,md2a,md2b,md3a,md3b,\
             gridIndexRange2, u2,u2n,u2m, wk2, mask2,rsxy2, xy2, p2,p2n,p2m, q2,q2n,q2m, boundaryCondition2, \
             ipar, rpar, \
             aa2,aa4,aa8, ipvt2,ipvt4,ipvt8, \
             ierr )
#endMacro
                           
! -----------------------------------------------------------------------------------------------
! Macro to call the approrpiate interface routine.
! -----------------------------------------------------------------------------------------------
#beginMacro callInterfaceRoutine( SUFFIX )
  if( dispersionModel1.eq.noDispersion .and. dispersionModel2.eq.noDispersion )then

    callRoutine( interfaceMx ## SUFFIX )

  else if( dispersionModel1.ne.noDispersion .or. dispersionModel2.ne.noDispersion )then

    ! -- GDM ---
    callRoutine( interfaceMxGDM ## SUFFIX )

  else if( nonlinearModel1 .ne. noNonlinearModel .or. nonlinearModel2 .ne. noNonlinearModel )then

    ! --- MLA ---
    callRoutine( interfaceMxMLA ## SUFFIX )

  else 
    stop 9876

  end if                  
#endMacro 

    
! ==============================================================================================================
!  This subroutine calls the appropriate interface routine
! ==============================================================================================================
  subroutine interfaceOpt( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                               gridIndexRange1, u1,u1n,u1m, wk1, mask1,rsxy1, xy1, p1,p1n,p1m, q1,q1n,q1m, boundaryCondition1, \
                               md1a,md1b,md2a,md2b,md3a,md3b,\
                               gridIndexRange2, u2,u2n,u2m, wk2, mask2,rsxy2, xy2, p2,p2n,p2m, q2,q2n,q2m, boundaryCondition2, \
                               ipar, rpar, \
                               aa2,aa4,aa8, ipvt2,ipvt4,ipvt8, \
                               ierr )

  implicit real (a-h,o-z)

  integer gridType,orderOfAccuracy
  integer ipar(0:*)

  integer rectangular,curvilinear
  parameter(\
    rectangular=0,\
    curvilinear=1)

  ! Dispersion models
  integer noDispersion,drude,gdm
  parameter( noDispersion=0, drude=1, gdm=2 )
  integer dispersionModel1, dispersionModel2

  ! Nonlinear models
  #Include "nonlinearModelsFortranInclude.h"
  integer nonlinearModel1, nonlinearModel2
  

  gridType             =ipar(18)
  orderOfAccuracy      =ipar(19)

  dispersionModel1    = ipar(44)
  dispersionModel2    = ipar(45)

  nonlinearModel1     = ipar(49)
  nonlinearModel2     = ipar(50)
  

  if( nd.eq.2. .and. orderOfAccuracy.eq.2 .and. gridType.eq.rectangular )then

    callInterfaceRoutine( 2dOrder2r )

  else if( nd.eq.2. .and. orderOfAccuracy.eq.2 .and. gridType.eq.curvilinear )then

    callInterfaceRoutine( 2dOrder2c )

  else if( nd.eq.2. .and. orderOfAccuracy.eq.4 .and. gridType.eq.rectangular )then

    callInterfaceRoutine( 2dOrder4r )

  else if( nd.eq.2. .and. orderOfAccuracy.eq.4 .and. gridType.eq.curvilinear )then

    callInterfaceRoutine( 2dOrder4c )

  else if( nd.eq.3. .and. orderOfAccuracy.eq.2 .and. gridType.eq.curvilinear )then

    callInterfaceRoutine( 3dOrder2c )

  else if( nd.eq.3 .and. orderOfAccuracy.eq.4 .and. gridType.eq.curvilinear )then

    ! this 3d 4th-order version is in interface3dOrder4.bf:

    ! OLD: mxInterface3dOrder4 NOTE: NOT q1,q2, ...
    !-     call mxInterface3dOrder4( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
    !-                           gridIndexRange1, u1,u1n,u1m,wk1, mask1,rsxy1, xy1, p1,p1n,p1m, boundaryCondition1, \
    !-                           md1a,md1b,md2a,md2b,md3a,md3b,\
    !-                           gridIndexRange2, u2,u2n,u2m,wk2, mask2,rsxy2, xy2, p2,p2n,p2m, boundaryCondition2, \
    !-                           ipar, rpar, \
    !-                           aa2,aa4,aa8, ipvt2,ipvt4,ipvt8, \
    !-                           ierr )

    ! NEW: interfaceOpt3dOrder4
    ! write(*,'(" ipar(18)=",i4)') ipar(18)
    call interfaceOpt3dOrder4( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                          gridIndexRange1, u1,u1n,u1m,wk1, mask1,rsxy1, xy1, p1,p1n,p1m, q1,q1n,q1m, boundaryCondition1, \
                          md1a,md1b,md2a,md2b,md3a,md3b,\
                          gridIndexRange2, u2,u2n,u2m,wk2, mask2,rsxy2, xy2, p2,p2n,p2m, q2,q2n,q2m, boundaryCondition2, \
                          ipar, rpar, \
                          aa2,aa4,aa8, ipvt2,ipvt4,ipvt8, \
                          ierr )

  else

    if( nd.eq.3 .and. gridType.eq.rectangular )then
      write(*,'("interfaceOpt: ERROR: 3d rectangular not implemented for interfaces")') 
    else 
      write(*,'("interfaceOpt: ERROR: unknown options nd,order,gridType=",3i3)') nd,orderOfAccuracy,gridType
    end if
    stop 3214


  end if




  return
  end                          
