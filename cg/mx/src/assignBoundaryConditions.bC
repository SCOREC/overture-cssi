#include "Maxwell.h"
#include "DispersiveMaterialParameters.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "RadiationBoundaryCondition.h"
#include "ParallelUtility.h"

#define bcOptMaxwell EXTERN_C_NAME(bcoptmaxwell)
#define abcMaxwell EXTERN_C_NAME(abcmaxwell)
#define bcSymmetry EXTERN_C_NAME(bcsymmetry)
#define exmax EXTERN_C_NAME(exmax)
#define adjustForIncident EXTERN_C_NAME(adjustforincident)

#define ForBoundary(side,axis)   for( int axis=0; axis<cg.numberOfDimensions(); axis++ ) \
                                 for( int side=0; side<=1; side++ )
extern "C"
{
      void bcOptMaxwell(const int&nd,
      const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
      const int&ndf1a,const int&ndf1b,const int&ndf2a,const int&ndf2b,const int&ndf3a,const int&ndf3b,
      const int & gid, const int & dimension,
      const real&u, const real&f, const int&mask, const real&rsxy, const real&xy, const real&v, const real&p,
      const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );

      void abcMaxwell(const int&nd,
      const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
      const int&ndf1a,const int&ndf1b,const int&ndf2a,const int&ndf2b,const int&ndf3a,const int&ndf3b,
      const int & gid,
      const real&u, const real&un, const real&f, const int&mask, const real&rsxy, const real&xy,
      const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );

      void bcSymmetry(const int&nd,
      const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
      const int & gid,
      const real&u, const int&mask, const real&rsxy, const real&xy,
      const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );

      void adjustForIncident(const int&nd,
      const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
      const int & gid,
      const real&um, const real&u, const real&un, const int&mask, const real&rsxy, const real&xy,
      const real& initialConditionBoundingBox,
      const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );

  void exmax(double&Ez,double&Bx,double&By,const int &nsources,const double&xs,const double&ys,
           const double&tau,const double&var,const double&amp, const double&a,
           const double&x,const double&y,const double&time);
}

#define pmlMaxwell EXTERN_C_NAME(pmlmaxwell)

extern "C"
{
 void pmlMaxwell(const int&nd,
      const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
      const int&ndf1a,const int&ndf1b,const int&ndf2a,const int&ndf2b,const int&ndf3a,const int&ndf3b,
      const int & gid, const int & dim,
      const real&um, const real&u, const real&un, 
      const int&ndra1a,const int&ndra1b,const int&ndra2a,const int&ndra2b,const int&ndra3a,const int&ndra3b,
      const real&vram, const real&vra, const real&vran, const real&wram, const real&wra, const real&wran, 
      const int&ndrb1a,const int&ndrb1b,const int&ndrb2a,const int&ndrb2b,const int&ndrb3a,const int&ndrb3b,
      const real&vrbm, const real&vrb, const real&vrbn, const real&wrbm, const real&wrb, const real&wrbn, 
      const int&ndsa1a,const int&ndsa1b,const int&ndsa2a,const int&ndsa2b,const int&ndsa3a,const int&ndsa3b,
      const real&vsam, const real&vsa, const real&vsan, const real&wsam, const real&wsa, const real&wsan, 
      const int&ndsb1a,const int&ndsb1b,const int&ndsb2a,const int&ndsb2b,const int&ndsb3a,const int&ndsb3b,
      const real&vsbm, const real&vsb, const real&vsbn, const real&wsbm, const real&wsb, const real&wsbn, 
      const int&ndta1a,const int&ndta1b,const int&ndta2a,const int&ndta2b,const int&ndta3a,const int&ndta3b,
      const real&vtam, const real&vta, const real&vtan, const real&wtam, const real&wta, const real&wtan, 
      const int&ndtb1a,const int&ndtb1b,const int&ndtb2a,const int&ndtb2b,const int&ndtb3a,const int&ndtb3b,
      const real&vtbm, const real&vtb, const real&vtbn, const real&wtbm, const real&wtb, const real&wtbn, 
      const real&f, const int&mask, const real&rsxy, const real&xy,
      const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );
}


static FILE *localDebugFile=NULL;

#define updateghostboundaries EXTERN_C_NAME(updateghostboundaries)
#define updateghostandperiodic EXTERN_C_NAME(updateghostandperiodic)

extern "C"
{

/* This function is used to update ghost boundaries of a P++ array from fortran  */
void
updateghostboundaries(realArray *&pu )
{
  // cfprintf(localDebugFile,"**** updateGhostBoundaries called from fortran pu=%i...\n",pu);
  // const realSerialArray & uu = (*pu).getLocalArrayWithGhostBoundaries();
  // ::display(uu,"u before (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");

  (*pu).updateGhostBoundaries();

  // Communication_Manager::Sync();
  // ::display(uu,"u after (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");
  // Communication_Manager::Sync();
}

void
updateghostandperiodic(realMappedGridFunction *&pu )
{
  // cfprintf(localDebugFile,"**** updateGhostBoundaries called from fortran pu=%i...\n",pu);
  // const realSerialArray & uu = (*pu).getLocalArrayWithGhostBoundaries();
  // ::display(uu,"u before (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");

  (*pu).periodicUpdate();
  (*pu).updateGhostBoundaries();

  // Communication_Manager::Sync();
  // ::display(uu,"u after (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");
  // Communication_Manager::Sync();
} 
}

static Maxwell *cgmxPointer=NULL; // for getGDMPolarizationParameters

#define getGDMPolarizationParameters EXTERN_C_NAME(getgdmpolarizationparameters)
extern "C"
{

// ================================================================================
///  \brief Return the gdm parameters polarizarion chir(i), chii(i) 
/// \param grid (input) : return parameters for this grid 
/// \param chir(0:maxNumberOfPolarizationVectors), chii(0:maxNumberOfPolarizationVectors): output
// ================================================================================
void getGDMPolarizationParameters( int & grid, real *chir, real *chii, const int & maxNumberOfPolarizationVectors )
{
  assert( cgmxPointer != NULL );

  CompositeGrid *&cgp = cgmxPointer->cgp;
  assert( cgp!=NULL );
  CompositeGrid & cg= *cgp;

  const int domain = cg.domainNumber(grid);
  const DispersiveMaterialParameters & dmp =  cgmxPointer->getDomainDispersiveMaterialParameters(domain);

  assert( dmp.numberOfPolarizationVectors>0 );
  assert( dmp.numberOfPolarizationVectors<= maxNumberOfPolarizationVectors );
  // assert( dmp.chir0.getLength(0)>=dmp.numberOfPolarizationVectors );
  // assert( dmp.chii0.getLength(0)>=dmp.numberOfPolarizationVectors );
  if(  dmp.chir0.getLength(0)>=dmp.numberOfPolarizationVectors &&
       dmp.chii0.getLength(0)>=dmp.numberOfPolarizationVectors )
  {
    for( int iv=0; iv<dmp.numberOfPolarizationVectors; iv++ )
    {
      chir[iv] = dmp.chir0(iv);
      chii[iv] = dmp.chii0(iv);
    }
  }
  else
  {
    for( int iv=0; iv<dmp.numberOfPolarizationVectors; iv++ )
    {
      chir[iv] = 0.;
      chii[iv] = 0.;
    }
  }
  
#undef gdmVar  
}

}

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)


// ==================================================
// ============= include forcing macros =============
// ==================================================
#Include "forcing.h"

// Macros for the annulus eigenfunction exact solution
#Include "annulusEigenFunction.h"

// Macros for the plane material interface:
#Include "planeMaterialInterface.h"
 definePlaneMaterialInterfaceMacros(C)

// Macros for dispersive waves
#Include "dispersionMacros.h"

// =============================================================================================================
// /Description:
//    Compute a new gridIndexRange, dimension
//             and boundaryCondition array that will be valid for the local grid on a processor.
// 
//    Set the gid to match the ends of the local array.
//    Set the bc(side,axis) to -1 (periodic) for internal boundaries between processors
//
// NOTES: In parallel we cannot assume the rsxy array is defined on all ghost points -- it will not
// be set on the extra ghost points put at the far ends of the array. -- i.e. internal boundary ghost 
// points will be set but not external
// =============================================================================================================
static void
getLocalBoundsAndBoundaryConditions( const realMappedGridFunction & a, 
                                     IntegerArray & gidLocal, 
                                     IntegerArray & dimensionLocal, 
                                     IntegerArray & bcLocal )
{

  MappedGrid & mg = *a.getMappedGrid();
  
  const IntegerArray & dimension = mg.dimension();
  const IntegerArray & gid = mg.gridIndexRange();
  const IntegerArray & bc = mg.boundaryCondition();
  
  gidLocal = gid;
  bcLocal = bc;
  dimensionLocal=dimension;
  
  for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
  {
//      printF(" axis=%i gidLocal(0,axis)=%i a.getLocalBase(axis)=%i  dimension(0,axis)=%i\n",axis,gidLocal(0,axis),
//                        a.getLocalBase(axis),dimension(0,axis));
//      printF(" axis=%i gidLocal(1,axis)=%i a.getLocalBound(axis)=%i dimension(0,axis)=%i\n",axis,gidLocal(1,axis),
//                        a.getLocalBound(axis),dimension(1,axis));
    if( a.getLocalBase(axis) == a.getBase(axis) ) 
    {
      assert( dimension(0,axis)==a.getLocalBase(axis) );
      gidLocal(0,axis) = gid(0,axis); 
      dimensionLocal(0,axis) = dimension(0,axis); 
    }
    else
    {
      gidLocal(0,axis) = a.getLocalBase(axis)+a.getGhostBoundaryWidth(axis);
      dimensionLocal(0,axis) = a.getLocalBase(axis); 
      // for internal ghost mark as periodic since these behave in the same was as periodic
      // ** we cannot mark as "0" since the mask may be non-zero at these points and assignBC will 
      // access points out of bounds
      bcLocal(0,axis) = -1; // bc(0,axis)>=0 ? 0 : -1;
    }
    
    if( a.getLocalBound(axis) == a.getBound(axis) ) 
    {
      assert( dimension(1,axis) == a.getLocalBound(axis) );
      
      gidLocal(1,axis) = gid(1,axis); 
      dimensionLocal(1,axis) = dimension(1,axis); 
    }
    else
    {
      gidLocal(1,axis) = a.getLocalBound(axis)-a.getGhostBoundaryWidth(axis);
      dimensionLocal(1,axis) = a.getLocalBound(axis);
      // for internal ghost mark as periodic since these behave in the same was as periodic
      bcLocal(1,axis) = -1; // bc(1,axis)>=0 ? 0 : -1;
    }
    
  }
}


// ================================================================================================
//   Get the bounds of valid interior points when there are boundaries with the PML BC
//
// /extra : an additional offset (e.g. to check errors use extra=pmlErrorOffset)
// /Return value: true if this is a PML grid and the Index Iv was changed.
// ================================================================================================
bool Maxwell::
getBoundsForPML( MappedGrid & mg, Index Iv[3], int extra /* =0 */ )
{
  bool usePML = (mg.boundaryCondition(0,0)==abcPML || mg.boundaryCondition(1,0)==abcPML ||
		 mg.boundaryCondition(0,1)==abcPML || mg.boundaryCondition(1,1)==abcPML ||
		 mg.boundaryCondition(0,2)==abcPML || mg.boundaryCondition(1,2)==abcPML);
  
  if( !usePML ) return false;
  
  // Here is the box where we apply the interior equations when there is a PML
  Iv[2]=Range(mg.gridIndexRange(0,2),mg.gridIndexRange(1,2));
  for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
  {
    int na=mg.gridIndexRange(0,axis);
    if( mg.boundaryCondition(0,axis)==abcPML )
      na+=numberLinesForPML+extra;
    int nb=mg.gridIndexRange(1,axis);
    if( mg.boundaryCondition(1,axis)==abcPML )
      nb-=numberLinesForPML+extra;
    Iv[axis]=Range(na,nb);
  }

  return usePML;
}

// ================================================================================================
//   Adjust the bounds to account for the PML (i.e. do not include PML points in the bounds)
//
// /extra : an additional offset (e.g. to check errors use extra=pmlErrorOffset)
// /Return value: true if this is a PML grid and the Index Iv was changed.
// ================================================================================================
bool Maxwell::
adjustBoundsForPML( MappedGrid & mg, Index Iv[3], int extra /* =0 */ )
{
  bool usePML = (mg.boundaryCondition(0,0)==abcPML || mg.boundaryCondition(1,0)==abcPML ||
		 mg.boundaryCondition(0,1)==abcPML || mg.boundaryCondition(1,1)==abcPML ||
		 mg.boundaryCondition(0,2)==abcPML || mg.boundaryCondition(1,2)==abcPML);
  
  if( !usePML ) return false;

  for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
  {
    int na=Iv[axis].getBase();
    if( mg.boundaryCondition(0,axis)==abcPML )
      na+=numberLinesForPML+extra;
    int nb=Iv[axis].getBound();
    if( mg.boundaryCondition(1,axis)==abcPML )
      nb-=numberLinesForPML+extra;
    Iv[axis]=Range(na,nb);
  }

  return usePML;
}


// *************************************************************
// ************* PML boundary conditions ***********************
// *************************************************************
#beginMacro applyPML()
  assert( cgp!=NULL );
  CompositeGrid & cg= *cgp;

  realMappedGridFunction & un = u;    // u[next];
  // realMappedGridFunction & uu = uOld; // u[current];
  
  const int prev= (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;
	
  // realMappedGridFunction & um =mgp!=NULL ? fields[prev] : cgfields[prev][grid];

  Range all;

  // ::display(um(all,all,all,hz),"um before pml BC's","%9.2e ");
  // ::display(u(all,all,all,hz) ,"u  before pml BC's","%9.2e ");
  // ::display(un(all,all,all,hz),"un before pml BC's","%9.2e ");

  // *********** In parallel we need to allocate local arrays **********
  //   *** We then need to define a ghost boundary update for these serial arrays ***

  // We should do this:  PML(n,side,axis,grid) -> time level n : vwpml(I1,I2,I3,0:1) <- store v,w in this array 

  // current way: 
  // PML(n,m,side,axis,grid)      n=time-level, m=v,w 
  const int numberOfPMLFunctions=2;  //  v and w
int numberOfComponentsPML;
  if( method==nfdtd )
    numberOfComponentsPML=3;
  else if( method==sosup )
    numberOfComponentsPML=6;
  else if( method==bamx )
  {
    numberOfComponentsPML = (numberOfDimensions==3 || solveForAllFields) ? 6 : 3;
    printF("BAMX: apply PML condition: t=%9.3e, current=%d\n",t,current);
  }
  else
  {
    OV_ABORT("apply PML condition: unknown method");
  }



  #define PML(n,m,side,axis,grid) vpml[(n)+numberOfTimeLevels*(m+numberOfPMLFunctions*(side+2*(axis+3*(grid))))]
  #define VPML(n,side,axis,grid) PML(n,0,side,axis,grid)
  #define WPML(n,side,axis,grid) PML(n,1,side,axis,grid)
  if( vpml==NULL )
  {
    // *** No need to allocate PML arrays for all grids !! ***
    vpml= new RealArray [cg.numberOfComponentGrids()*3*2*numberOfTimeLevels*numberOfPMLFunctions];

    // pmlWasIntitialized[grid] = true if the PML arrays were allocated for this grid
    int *& pmlWasIntitialized =  dbase.put<int*>("pmlWasInitialized");
    pmlWasIntitialized= new int[cg.numberOfComponentGrids()];   // who will delete this ?
    for( int g=0; g<cg.numberOfComponentGrids(); g++ )
      pmlWasIntitialized[g]=false;
  }

  // pmlWasIntitialized[grid] = true if the PML arrays were allocated for this grid
  int *& pmlWasIntitialized =dbase.get<int*>("pmlWasInitialized");
  if( !pmlWasIntitialized[grid] )
  {
    pmlWasIntitialized[grid]=true;
    printF(" ****** assignBC: allocate vpml arrays grid=%i, numberOfTimeLevels=%i numberOfPMLFunctions=%i ***** \n",
	 grid,numberOfTimeLevels,numberOfPMLFunctions);

    const int numGhost = orderOfAccuracyInSpace/2;  // we need ghost values in the PML functions *wdh* 2011/12/02
    for( int side=0; side<=1; side++ )
    {
      for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
      {
        if( mg.boundaryCondition(side,axis)==abcPML )
        {
	  for( int m=0; m<numberOfPMLFunctions; m++ )  // ********* FIX ********
	    for( int n=0; n<numberOfTimeLevels; n++ )
	    {
  		  
	      RealArray & vw = PML(n,m,side,axis,grid);
	      int ndr[2][3];
	      for( int dir=0; dir<3; dir++ )
	      {
		ndr[0][dir]=mg.dimension(0,dir);
		ndr[1][dir]=mg.dimension(1,dir);
	      }
  		  
	      if( side==0 )
	      {
		ndr[0][axis]=mg.dimension(side,axis);
		ndr[1][axis]=mg.gridIndexRange(side,axis)+numberLinesForPML-1 +numGhost;
	      }
	      else
	      {
		ndr[0][axis]=mg.gridIndexRange(side,axis)-numberLinesForPML+1 -numGhost;
		ndr[1][axis]=mg.dimension(side,axis);
	      }
		  

	      // RealArray a;
	      // a.redim(Range(-2,10),Range(0,0));
		  
	      vw .redim(Range(ndr[0][0],ndr[1][0]),
			Range(ndr[0][1],ndr[1][1]),
			Range(ndr[0][2],ndr[1][2]),numberOfComponentsPML);  // ********* FIX ********

	      vw=0.;
	    }
	}
      }
    }
  } // end if pmlWasInitialized

 #ifdef USE_PPP
  realSerialArray uum; getLocalArrayWithGhostBoundaries(um,uum);
  realSerialArray uu;  getLocalArrayWithGhostBoundaries(uOld,uu);
  realSerialArray uun; getLocalArrayWithGhostBoundaries(un,uun);

 #else
  const realSerialArray & uum = um;
  const realSerialArray & uu  = uOld;
  const realSerialArray & uun = un;

 #endif

  const realSerialArray & vram = VPML(prev   ,0,0,grid); 
  const realSerialArray & vrbm = VPML(prev   ,1,0,grid); 
  const realSerialArray & vsam = VPML(prev   ,0,1,grid); 
  const realSerialArray & vsbm = VPML(prev   ,1,1,grid); 
  const realSerialArray & vtam = VPML(prev   ,0,2,grid); 
  const realSerialArray & vtbm = VPML(prev   ,1,2,grid); 

  const realSerialArray & vra  = VPML(current,0,0,grid); 
  const realSerialArray & vrb  = VPML(current,1,0,grid); 
  const realSerialArray & vsa  = VPML(current,0,1,grid); 
  const realSerialArray & vsb  = VPML(current,1,1,grid); 
  const realSerialArray & vta  = VPML(current,0,2,grid); 
  const realSerialArray & vtb  = VPML(current,1,2,grid); 
						   
  const realSerialArray & vran = VPML(next   ,0,0,grid); 
  const realSerialArray & vrbn = VPML(next   ,1,0,grid); 
  const realSerialArray & vsan = VPML(next   ,0,1,grid); 
  const realSerialArray & vsbn = VPML(next   ,1,1,grid); 
  const realSerialArray & vtan = VPML(next   ,0,2,grid); 
  const realSerialArray & vtbn = VPML(next   ,1,2,grid); 


  const realSerialArray & wram = WPML(prev   ,0,0,grid); 
  const realSerialArray & wrbm = WPML(prev   ,1,0,grid); 
  const realSerialArray & wsam = WPML(prev   ,0,1,grid); 
  const realSerialArray & wsbm = WPML(prev   ,1,1,grid); 
  const realSerialArray & wtam = WPML(prev   ,0,2,grid); 
  const realSerialArray & wtbm = WPML(prev   ,1,2,grid); 

  const realSerialArray & wra  = WPML(current,0,0,grid); 
  const realSerialArray & wrb  = WPML(current,1,0,grid); 
  const realSerialArray & wsa  = WPML(current,0,1,grid); 
  const realSerialArray & wsb  = WPML(current,1,1,grid); 
  const realSerialArray & wta  = WPML(current,0,2,grid); 
  const realSerialArray & wtb  = WPML(current,1,2,grid); 
						   
  const realSerialArray & wran = WPML(next   ,0,0,grid); 
  const realSerialArray & wrbn = WPML(next   ,1,0,grid); 
  const realSerialArray & wsan = WPML(next   ,0,1,grid); 
  const realSerialArray & wsbn = WPML(next   ,1,1,grid); 
  const realSerialArray & wtan = WPML(next   ,0,2,grid); 
  const realSerialArray & wtbn = WPML(next   ,1,2,grid); 

  real *umptr, *uuptr, *unptr;   
  umptr=uum.getDataPointer();
  uuptr= uu.getDataPointer();  
  unptr=uun.getDataPointer();

  if( debug & 4 )
  {
    ::display(um(all,all,all,hz),sPrintF("um (Hz) before pml BC's grid=%i t=%e",grid,t),debugFile,"%9.2e ");
    ::display(uu(all,all,all,hz),sPrintF("u  (Hz) before pml BC's grid=%i t=%e",grid,t),debugFile,"%9.2e ");
    ::display(un(all,all,all,hz),sPrintF("un (Hz) before pml BC's grid=%i t=%e",grid,t),debugFile,"%9.2e ");
  }

  // Here is the box outside of which the PML equations are applied.

  getBoundsForPML(mg,Iv);

  int includeGhost=0;
  bool ok = ParallelUtility::getLocalArrayBounds(uOld,uu,I1,I2,I3,includeGhost);
  if( ok )
  {
    ipar[2] =I1.getBase();
    ipar[3] =I1.getBound();
    ipar[4] =I2.getBase();
    ipar[5] =I2.getBound();
    ipar[6] =I3.getBase();
    ipar[7] =I3.getBound();

    assert( dx[0]>0. );
	
    int bc0=-1;  // not used
    // ** for( int m=0; m<3; m++ )
    const int firstComponent=ipar[12];  // normally ex (or ext)
    for( int m=0; m<numberOfComponentsPML; m++ )
    {
	ipar[12]=firstComponent+m; // assign this component

	pmlMaxwell( mg.numberOfDimensions(), 
		    uu.getBase(0),uu.getBound(0),
		    uu.getBase(1),uu.getBound(1),
		    uu.getBase(2),uu.getBound(2),
		    ff.getBase(0),ff.getBound(0),
		    ff.getBase(1),ff.getBound(1),
		    ff.getBase(2),ff.getBound(2),
		    *gid.getDataPointer(),
		    *dim.getDataPointer(),
		    *umptr, *uuptr, *unptr, 
		    // vra (left)
		    vra.getBase(0),vra.getBound(0),vra.getBase(1),vra.getBound(1),vra.getBase(2),vra.getBound(2),
		    *vram.getDataPointer(),*vra.getDataPointer(),*vran.getDataPointer(),
		    *wram.getDataPointer(),*wra.getDataPointer(),*wran.getDataPointer(),
		    // vrb (right)
		    vrb.getBase(0),vrb.getBound(0),vrb.getBase(1),vrb.getBound(1),vrb.getBase(2),vrb.getBound(2),
		    *vrbm.getDataPointer(),*vrb.getDataPointer(),*vrbn.getDataPointer(),
		    *wrbm.getDataPointer(),*wrb.getDataPointer(),*wrbn.getDataPointer(),
		    // vsa (bottom)
		    vsa.getBase(0),vsa.getBound(0),vsa.getBase(1),vsa.getBound(1),vsa.getBase(2),vsa.getBound(2),
		    *vsam.getDataPointer(),*vsa.getDataPointer(),*vsan.getDataPointer(),
		    *wsam.getDataPointer(),*wsa.getDataPointer(),*wsan.getDataPointer(),
		    // vsb 
		    vsb.getBase(0),vsb.getBound(0),vsb.getBase(1),vsb.getBound(1),vsb.getBase(2),vsb.getBound(2),
		    *vsbm.getDataPointer(),*vsb.getDataPointer(),*vsbn.getDataPointer(),
		    *wsbm.getDataPointer(),*wsb.getDataPointer(),*wsbn.getDataPointer(),
		    // vta
		    vta.getBase(0),vta.getBound(0),vta.getBase(1),vta.getBound(1),vta.getBase(2),vta.getBound(2),
		    *vtam.getDataPointer(),*vta.getDataPointer(),*vtan.getDataPointer(),
		    *wtam.getDataPointer(),*wta.getDataPointer(),*wtan.getDataPointer(),
		    // vtb 
		    vtb.getBase(0),vtb.getBound(0),vtb.getBase(1),vtb.getBound(1),vtb.getBase(2),vtb.getBound(2),
		    *vtbm.getDataPointer(),*vtb.getDataPointer(),*vtbn.getDataPointer(),
		    *wtbm.getDataPointer(),*wtb.getDataPointer(),*wtbn.getDataPointer(),
		    *fptr,*maskptr,*rxptr, *xyptr,
		    bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
	  
    }  // end m
    ipar[12]=firstComponent; // reset 
  }
  
  if( debug & 4 )
  {
    ::display(um(all,all,all,hz),sPrintF("um (Hz) after pml BC's grid=%i t=%e",grid,t),debugFile,"%9.2e ");
    ::display(uu(all,all,all,hz),sPrintF("u  (Hz) after pml BC's grid=%i t=%e",grid,t),debugFile,"%9.2e ");
    ::display(un(all,all,all,hz),sPrintF("un (Hz) after pml BC's grid=%i t=%e",grid,t),debugFile,"%9.2e ");
  }
    
#endMacro


// =============================================================================================
// Macro to apply optimized versions of BC's
//
// OPTION: OPTION==field           : apply BC's to the fied variables Ex, Ey, ...
//         OPTION==timeDerivatives : apply BCs to the time-derivatives of the field (for SOSUP) 
//         OPTION==polarization    : apply BC's to the polarization vectors
// =============================================================================================
#beginMacro optimizedBoundaryConditionsMacro(OPTION)

// *wdh* 2011/12/02 -- this next line was wrong -- side and axis are not correct here.
// *wdh* getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);

// I1,I2,I3 are not used I don't think. We do check that there are any points on this processor
getIndex(mg.gridIndexRange(),I1,I2,I3);
bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
if( ok && useOpt )
{
  // use optimised boundary conditions
  int ipar[40];
  real rpar[60];

  int gridType = isRectangular ? 0 : 1;
  int orderOfExtrapolation=orderOfAccuracyInSpace+1;  // not used
  int useWhereMask=false;

  int bcOrderOfAccuracy=orderOfAccuracyInSpace;
  if( method==sosup && orderOfAccuracyInSpace==6 )
  {
    // NOTE: for now apply 4th order BC's for sosup order 6 on curvilinear grids:
    if( !isRectangular )
      bcOrderOfAccuracy=4;
  }

  realArray f;

  #If #OPTION eq "field"
    if( useChargeDensity )
    {
      // evaluate rho on the boundary to use with the div(eps*E)=rho BC
  
      assert( pRho!=NULL );
      
      getChargeDensity( t,(*pRho)[grid] );  // do this for now -- evaluate every where ****************
  
      f.reference((*pRho)[grid]);
  
    } 
  #End


  ipar[0] =0;
  ipar[1] =0;
  ipar[2] =I1.getBase();  // not used ???
  ipar[3] =I1.getBound();
  ipar[4] =I2.getBase();
  ipar[5] =I2.getBound();
  ipar[6] =I3.getBase();
  ipar[7] =I3.getBound();
  ipar[8] =gridType;
  ipar[9] =bcOrderOfAccuracy;
  ipar[10]=orderOfExtrapolation;
  ipar[11]=useForcing;
  #If #OPTION eq "field"
    // apply BCs to field variables
    ipar[12]=ex;
    ipar[13]=ey;
    ipar[14]=ez;
    ipar[15]=hx;
    ipar[16]=hy;
    ipar[17]=hz;
  #Elif #OPTION eq "timeDerivatives"
    // apply BCs to time-derivatives
    ipar[12]=ext;
    ipar[13]=eyt;
    ipar[14]=ezt;
    ipar[15]=hxt;
    ipar[16]=hyt;
    ipar[17]=hzt;
  #Elif #OPTION eq "polarization"
    // apply BCs to polarization vectors
    ipar[12]=pxc;
    ipar[13]=pyc;
    ipar[14]=pzc;
    ipar[15]=qxc;
    ipar[16]=qyc;
    if( numberOfDimensions==2 )
      ipar[17]=hz;  // for now apply BCs to Hz again here 
    else
      ipar[17]=qzc;
  #Else
    OV_ABORT("ERROR -- unknown option=OPTION");
  #End
  ipar[18]=useWhereMask;
  ipar[19]=grid;
  #ifdef USE_PPP
    ipar[20]= 0; // turn off debugging info in parallel -- this can cause trouble
  #else
    ipar[20]= debug; 
  #endif
  ipar[21]=(int)forcingOption;

  ipar[22]=pmlPower;
  ipar[23]=0;  // do not have pml routine assign interior points too

  ipar[24]=(int)useChargeDensity;

  ipar[25]= adjustFarFieldBoundariesForIncidentField(grid);
  // ipar[26]=bcOpt;  // assigned below
  // int bcSymmetryOption=0;     // 0=even symmetry, 1=even-odd symmetry
  int bcSymmetryOption=1;     // This is the proper symmetry condition *wdh* Sept 6, 2016
  ipar[27]= bcSymmetryOption;
  ipar[28]=myid;

  // -- fieldOption: used for SOSUP to apply BCs to the field or its time-derivative  
  int fieldOption=0;  // apply BCs to field variables
#If #OPTION eq "timeDerivatives"
  fieldOption=1; // apply BCs to time-derivatives
#End
  ipar[29]=fieldOption;

  int numberOfGhostLines = orderOfAccuracyInSpace/2;
  if( addedExtraGhostLine ) numberOfGhostLines++;  // sosup uses one extra ghost line
  ipar[30]=numberOfGhostLines;  // for symmetry BC in bcSymmetry

  // field we subtract off the incident field over this many points next to the boundary.
  // This value should take into account the width of extrapolation used at far-fields
  // For order=2: we may extrap first ghost using 1 -3 3 1 
  // For order=4: we may extrap first ghost using 1 -4 6 -4 1
  int widthForAdjustFieldsForIncident=orderOfAccuracyInSpace/2+1; 
  if( orderOfAccuracyInSpace>2 )
    widthForAdjustFieldsForIncident+=1;  // *wdh* ABC 4th-order corners needs 1 more 
  ipar[31]=widthForAdjustFieldsForIncident;
  
  ipar[32]=boundaryForcingOption;

  // supply polarizationOption for dispersive models *wdh* May 29, 2017
int polarizationOption=0;
#If #OPTION eq "polarization"
  polarizationOption=1; // apply BCs to the polarization vector
#End
  ipar[33]=polarizationOption;
  ipar[34]=localDispersionModel;
  ipar[35]=dbase.get<int>("smoothBoundingBox"); // 1= smooth the IC at the bounding box edge

  ipar[36] = numberOfPolarizationVectors;

  int incidentFieldType=0; // plane wave incident field   
  if( initialConditionOption==gaussianPlaneWave )  
    incidentFieldType=1;
  
  ipar[37]= incidentFieldType;  

  ipar[38] = solveForAllFields;

  rpar[0]=dx[0];       // for Cartesian grids          
  rpar[1]=dx[1];                
  rpar[2]=dx[2];                
  rpar[3]=mg.gridSpacing(0);
  rpar[4]=mg.gridSpacing(1);
  rpar[5]=mg.gridSpacing(2);
  rpar[6]=t;
  rpar[7]=(real &)tz;  // twilight zone pointer
  rpar[8]=dt;
  rpar[9]=c;
  rpar[10]=eps;
  rpar[11]=mu;
  rpar[12]=kx; // for plane wave scattering
  rpar[13]=ky;
  rpar[14]=kz;
  rpar[15]=slowStartInterval;

  rpar[16]=pmlLayerStrength;
  realArray *pu = &u;
  rpar[17]=(real&)(pu);  // pass pointer to u for calling updateGhostBoundaries

  rpar[20]=pwc[0];  // coeff. for plane wave solution
  rpar[21]=pwc[1];
  rpar[22]=pwc[2];
  rpar[23]=pwc[3];
  rpar[24]=pwc[4];
  rpar[25]=pwc[5];
  
  rpar[26]=xab[0][0];   // for Cartesian grids     
  rpar[27]=xab[0][1];
  rpar[28]=xab[0][2];

  // Chirped plane-wave parameters
  const ChirpedArrayType & cpw = dbase.get<ChirpedArrayType>("chirpedParameters");
  rpar[29]=cpw(0); // ta 
  rpar[30]=cpw(1); // tb 
  rpar[31]=cpw(2); // alpha
  rpar[32]=cpw(3); // beta
  rpar[33]=cpw(4); // amp
  rpar[34]=cpw(5); // x0
  rpar[35]=cpw(6); // y0
  rpar[36]=cpw(7); // z0
  
  // Dispersion parameters:
  real sr=0.,si=0.;  // Re(s), Im(s) in exp(s*t) 
  real chir[10], chii[10], chiSumr, chiSumi;   // For P = eps*chi(s)*E 
  if( localDispersionModel !=noDispersion && 
      ( boundaryForcingOption!=noBoundaryForcing || assignPlaneWaveBoundaryCondition)
        ) 
  {
    // We need s=(sr,si) for boundary forcing of dispersive models     
    const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz);
    DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
    dmp.evaluateDispersionRelation( c,kk, sr, si, chir,chii,chiSumr,chiSumi ); 
    if( t<=3.*dt )
      printF("--MX--BC dispersion: s=(%12.4e,%12.4e)\n",sr,si);
 
  }
  rpar[37]=sr;
  rpar[38]=si;
  rpar[39]=eps*chir[0];  // *FIX ME*
  rpar[40]=eps*chii[0];

  rpar[41]=dmp.alphaP;
  
  
  // Guassian plane wave parameters
  if( initialConditionOption==gaussianPlaneWave )
  {
    rpar[50]=x0GaussianPlaneWave;
    rpar[51]=y0GaussianPlaneWave;
    rpar[52]=z0GaussianPlaneWave;
    rpar[53]=betaGaussianPlaneWave;
  }
  
  

  // fprintf(pDebugFile,"**** pu= %i, %i...\n",&u,pu);



#ifdef USE_PPP 
  realSerialArray uu;    getLocalArrayWithGhostBoundaries(u,uu);
  realSerialArray uuOld; getLocalArrayWithGhostBoundaries(uOld,uuOld);
  intSerialArray  mask;  getLocalArrayWithGhostBoundaries(mg.mask(),mask);
  realSerialArray rx;    if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg.inverseVertexDerivative(),rx);
  realSerialArray xy;    if( centerNeeded ) getLocalArrayWithGhostBoundaries(mg.center(),xy);
  realSerialArray ff;    getLocalArrayWithGhostBoundaries(f,ff); 


  if( debug & 4 )
  {
    fprintf(pDebugFile,"\n **** grid=%i p=%i assignBC: gid=[%i,%i][%i,%i][%i,%i] bc=[%i,%i][%i,%i][%i,%i]"
	    " bcg=[%i,%i][%i,%i][%i,%i]******\n\n",grid,Communication_Manager::My_Process_Number,
	    gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2),
	    bc(0,0),bc(1,0),bc(0,1),bc(1,1),bc(0,2),bc(1,2),
	    bcg(0,0),bcg(1,0),bcg(0,1),bcg(1,1),bcg(0,2),bcg(1,2));
	  
	  
    fprintf(pDebugFile,"\n **** uu=[%i,%i] xy=[%i,%i] rsxy=[%i,%i]\n",
	    uu.getBase(0),uu.getBound(0),xy.getBase(0),xy.getBound(0),rx.getBase(0),rx.getBound(0));
	  
  }
	
#else
  const realSerialArray & uu    = u;
  const realSerialArray & uuOld = uOld;
  const realSerialArray & ff    = f;
  const intSerialArray  & mask  = mg.mask();

  const realSerialArray & rx = !isRectangular? mg.inverseVertexDerivative() : uu;
  const realSerialArray & xy = centerNeeded ? mg.center() : uu;
  const IntegerArray & gid = mg.gridIndexRange();
  const IntegerArray & dim = mg.dimension();
  const IntegerArray & bc = mg.boundaryCondition();
	
  if( debug & 1 )
  {
    const IntegerArray & bcg = mg.boundaryCondition();
    fprintf(pDebugFile,"\n **** grid=%i p=%i assignBC: gid=[%i,%i][%i,%i][%i,%i] bc=[%i,%i][%i,%i][%i,%i]"
	    " bcg=[%i,%i][%i,%i][%i,%i]******\n\n",grid,Communication_Manager::My_Process_Number,
	    gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2),
	    bc(0,0),bc(1,0),bc(0,1),bc(1,1),bc(0,2),bc(1,2),
	    bcg(0,0),bcg(1,0),bcg(0,1),bcg(1,1),bcg(0,2),bcg(1,2));
  }
	
#endif
        

  real *uptr   = uu.getDataPointer();
  real *fptr   = ff.getDataPointer();
  int *maskptr = mask.getDataPointer();
  real *rxptr  = rx.getDataPointer();
  real *xyptr  = centerNeeded ? xy.getDataPointer() : uptr;
  assert( xyptr!=NULL );

  real *ppv = numberOfPolarizationVectors>0 ? pLocal.getDataPointer() : uptr;

  if( !isRectangular )
  {
    // display(mg.inverseVertexDerivative(),"inverseVertexDerivative","%7.4f ");
    // displayMask(mg.mask());
	
  }


  // Do this for now -- assumes all sides are PML
      
  bool usePML = (mg.boundaryCondition(0,0)==abcPML || mg.boundaryCondition(1,0)==abcPML ||
		 mg.boundaryCondition(0,1)==abcPML || mg.boundaryCondition(1,1)==abcPML ||
		 mg.boundaryCondition(0,2)==abcPML || mg.boundaryCondition(1,2)==abcPML);
      
  const int bc0=-1;  // do all boundaries.
  int ierr=0;

  // *wdh* 090509 -- symmetry BC's (like a straight PEC wall)
  int bcOption=0;     // 0=assign all faces, 1=assign corners and edges
  ipar[26]=bcOption;
  bcSymmetry( mg.numberOfDimensions(), 
	      uu.getBase(0),uu.getBound(0),
	      uu.getBase(1),uu.getBound(1),
	      uu.getBase(2),uu.getBound(2),
	      *gid.getDataPointer(),
	      *uptr, *maskptr,*rxptr, *xyptr,
	      bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );


  // *** need to fix gridIndex Range and bc ***********************

  if( debug & 4 )
  {
    ::display(uu,sPrintF("uu before bcOptMaxwell, grid=%i, t=%e",grid,t),pDebugFile,"%8.1e ");
  }
      
  // Allocate Workspace for the fourth-order curvilinear PEC BC's
  const bool boundaryConditionWorkSpaceNeeded=(
    orderOfAccuracyInSpace==4 && !isRectangular &&
    (bc(0,0)==perfectElectricalConductor || 
     bc(1,0)==perfectElectricalConductor || 
     bc(0,1)==perfectElectricalConductor || 
     bc(1,1)==perfectElectricalConductor ||
     bc(0,2)==perfectElectricalConductor || 
     bc(1,2)==perfectElectricalConductor
      )
    );


  // ---- Array v is used for the Jacobit update of the boundary conditions when we need to iterate -----
  RealArray v; 
  real *vptr = uu.getDataPointer();  // default value when not used 
  if( boundaryConditionWorkSpaceNeeded )
  {
    if( t < 2.*dt )
    {
      printF("CGMX:AssignBC:INFO: allocate work-space for 4th-order curvilinear PEC BC\n");
    }
    
    v.redim(uu); // we could maybe use some of the forcing functions as work space ****** FIX ME ***
    vptr = v.getDataPointer();
    
  }
  

  // ***** NOTE: PEC boundary values are set in cornersMx routines *******
  bcOptMaxwell( mg.numberOfDimensions(), 
		uu.getBase(0),uu.getBound(0),
		uu.getBase(1),uu.getBound(1),
		uu.getBase(2),uu.getBound(2),
		ff.getBase(0),ff.getBound(0),
		ff.getBase(1),ff.getBound(1),
		ff.getBase(2),ff.getBound(2),
		*gid.getDataPointer(),*dim.getDataPointer(),
		*uptr,*fptr,*maskptr,*rxptr, *xyptr, *vptr, *ppv,
		bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
 
  if( debug & 4  ) ::display(uu,sPrintF("uu after bcOptMaxwell, grid=%i, t=%e",grid,t),pDebugFile,"%8.1e ");

  real *uOldptr = uuOld.getDataPointer();
      

  // Here we subtract off the incident field on points near non-reflecting boundaries
  // that also have an incoming incident field. Then the NRBC only operates on the scattered 
  // field portion of the total field.
  
  // Later on below we add the incident field back on 

  realMappedGridFunction & um =mgp!=NULL ? fields[prev] : cgfields[prev][grid];
  #ifdef USE_PPP 
    realSerialArray uum;    getLocalArrayWithGhostBoundaries(um,uum);
  #else
    realSerialArray & uum =um;
  #endif
  const int adjustThreeLevels = usePML;
  if( adjustFarFieldBoundariesForIncidentField(grid) )
  {
    // printF(" ***** adjustFarFieldBoundariesForIncidentField for grid %i ********\n",grid);

    if( debug & 4 )
    {
      ::display(um(all,all,all,hz),sPrintF("um (Hz) before adjustForIncident grid=%i t=%e",grid,t),debugFile,"%9.2e ");
      ::display(uOld(all,all,all,hz),sPrintF("u  (Hz) before adjustForIncident grid=%i t=%e",grid,t),debugFile,"%9.2e ");
      ::display(u (all,all,all,hz),sPrintF("un (Hz) before adjustForIncident grid=%i t=%e",grid,t),debugFile,"%9.2e ");
    }

    ipar[25]=-1;  // subtract the incident field
    ipar[26]=numberLinesForPML;
    ipar[27]=adjustThreeLevels;
    ipar[28]=method;

    // parameters for tanh smoothing near bounding box front:
    // -- this must match the formula in getInitialConditions.bC
    const int & side = dbase.get<int>("boundingBoxDecaySide");
    const int & axis = dbase.get<int>("boundingBoxDecayAxis");
    real beta=boundingBoxDecayExponent/twoPi;
    real nv[3]={0.,0.,0.};  // normal to decay direction
    nv[axis]=2*side-1;
    // Damp near the point xv0[] on the front
    real xv0[3]={0.,0.,0.};  // normal to decay direction
    for( int dir=0; dir<numberOfDimensions; dir++ )
      xv0[dir] = .5*(initialConditionBoundingBox(1,dir)+initialConditionBoundingBox(0,dir));
    xv0[axis]=initialConditionBoundingBox(side,axis);

    rpar[29]=beta;
    rpar[30]=nv[0];
    rpar[31]=nv[1];
    rpar[32]=nv[2];
    rpar[33]=xv0[0];
    rpar[34]=xv0[1];
    rpar[35]=xv0[2];
    
    adjustForIncident( mg.numberOfDimensions(),  
		uu.getBase(0),uu.getBound(0),
		uu.getBase(1),uu.getBound(1),
		uu.getBase(2),uu.getBound(2),
		*gid.getDataPointer(),
		*uum.getDataPointer(), *uOldptr, *uptr, *maskptr,*rxptr, *xyptr,
		*initialConditionBoundingBox.getDataPointer(),
		bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
    ipar[25]=0;

    if( debug & 4 )
    {
      ::display(um(all,all,all,hz),sPrintF("um (Hz) after adjustForIncident grid=%i t=%e",grid,t),debugFile,"%9.2e ");
      ::display(uOld(all,all,all,hz),sPrintF("u  (Hz) after adjustForIncident grid=%i t=%e",grid,t),debugFile,"%9.2e ");
      ::display(u (all,all,all,hz),sPrintF("un (Hz) after adjustForIncident grid=%i t=%e",grid,t),debugFile,"%9.2e ");
    }
  }
  

  // Non-reflecting and Absorbing boundary conditions
  // ***NOTE*** symmetry corners and edges are assigned in this next routine *fix me*
  abcMaxwell( mg.numberOfDimensions(), 
	      uu.getBase(0),uu.getBound(0),
	      uu.getBase(1),uu.getBound(1),
	      uu.getBase(2),uu.getBound(2),
	      ff.getBase(0),ff.getBound(0),
	      ff.getBase(1),ff.getBound(1),
	      ff.getBase(2),ff.getBound(2),
	      *gid.getDataPointer(),
	      *uOldptr, *uptr, *fptr,*maskptr,*rxptr, *xyptr,
	      bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
 

  // ** we should probably assign the PML before all the other BC's since it is like an interior equation **
  //   ** but watch out for the adjustment for the incident field ***
  if( usePML )
  {
    applyPML();
  }
  
  // *wdh* 090509 -- symmetry CORNERS BC's (like a straight PEC wall)
  bcOption=1; // 1=assign corners and edges only
  ipar[26]=bcOption; 
  bcSymmetry( mg.numberOfDimensions(), 
	      uu.getBase(0),uu.getBound(0),
	      uu.getBase(1),uu.getBound(1),
	      uu.getBase(2),uu.getBound(2),
	      *gid.getDataPointer(),
	      *uptr, *maskptr,*rxptr, *xyptr,
	      bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );


  // ::display(u,"u after pml BC's","%9.2e ");
      
  // assign any radiation BC's
  for( int i=0; i<2; i++ )
  {
    // ** FIX ME for SOSUP ***
    if( radbcGrid[i]==grid )
    {
      RadiationBoundaryCondition::debug=debug;
      radiationBoundaryCondition[i].tz=tz; // fix this 
      radiationBoundaryCondition[i].assignBoundaryConditions( u,t,dt,uOld );
    }
      
  }
    
  if( adjustFarFieldBoundariesForIncidentField(grid) )
  {
    ipar[25]=+1;  // add back the incident field
    ipar[26]=numberLinesForPML;
    ipar[27]=adjustThreeLevels;
    adjustForIncident( mg.numberOfDimensions(),  
		uu.getBase(0),uu.getBound(0),
		uu.getBase(1),uu.getBound(1),
		uu.getBase(2),uu.getBound(2),
		*gid.getDataPointer(),
		*uum.getDataPointer(), *uOldptr, *uptr, *maskptr,*rxptr, *xyptr,
                *initialConditionBoundingBox.getDataPointer(),
		bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
    ipar[25]=0;
  }



} // end ok 
#endMacro    

// ============================================================================
// Macro to compute the (x,y) coordinates - optimized for rectangular grids
// ============================================================================
#beginMacro getCoordinates2d(i1,i2,i3,x,y,XX)
 if( isRectangular )
 {
   x = XC0(i1,i2,i3);
   y = XC1(i1,i2,i3);
 }
 else
 {
   x = XX(i1,i2,i3,0);
   y = XX(i1,i2,i3,1);
 }
#endMacro

// ============================================================================
// Macro to compute the (x,y,z) coordinates - optimized for rectangular grids
// ============================================================================
#beginMacro getCoordinates3d(i1,i2,i3,x,y,z,XX)
 if( isRectangular )
 {
   x = XC0(i1,i2,i3);
   y = XC1(i1,i2,i3);
   z = XC2(i1,i2,i3);
 }
 else
 {
   x = XX(i1,i2,i3,0);
   y = XX(i1,i2,i3,1);
   z = XX(i1,i2,i3,2);
 }
#endMacro



// ============================================================================
// Macro:  Assign the dirichlet (i.e. exact solution) BC for a plane wave or plane wave scattered field 
// ============================================================================
#beginMacro assignPlaneWaveBC()             
{
  if( knownSolution==NULL )
  {
    initializeKnownSolution();
  }
  const realArray & ug = (*knownSolution)[grid];

  const real cc0= cGrid(0)*sqrt( kx*kx+ky*ky ); // NOTE: use grid 0 values for multi-materials

  // const real cost = cos(-twoPi*cc0*t);
  // const real sint = sin(-twoPi*cc0*t);
  // const real dcost =  twoPi*cc0*sint;  // d(sin(..))/dt 
  // const real dsint = -twoPi*cc0*cost;  // d(sin(..))/dt 	    

  getKnownSolutionTimeCoefficients();


  if( debug & 4 ) printF("Set Dirichlet BC from known solution, grid,side,axis=%i,%i,%i\n",grid,side,axis);
	      
  // getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);

  // *wdh* 041013: Do not use the next line -- P++ problems
  // *wdh*   u(I1,I2,I3,C)=ug(I1,I2,I3,C)*sint+ug(I1,I2,I3,C+3)*cost;

#ifdef USE_PPP
  realSerialArray ugLocal; getLocalArrayWithGhostBoundaries(ug,ugLocal);
#else
  const realSerialArray & ugLocal = ug; 
#endif
  real *ugp = ugLocal.Array_Descriptor.Array_View_Pointer3;
  const int ugDim0=ugLocal.getRawDataSize(0);
  const int ugDim1=ugLocal.getRawDataSize(1);
  const int ugDim2=ugLocal.getRawDataSize(2);
#define UG(i0,i1,i2,i3) ugp[i0+ugDim0*(i1+ugDim1*(i2+ugDim2*(i3)))]
		
  int i1,i2,i3;
  if( numberOfDimensions==2 )
  {
    // ===== TWO DIMENSIONS -- KNOWN SOLUTION  =====
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
      U(i1,i2,i3,ex)=UG(i1,i2,i3,ex)*cEr + UG(i1,i2,i3,ex+3)*cEi;
      U(i1,i2,i3,ey)=UG(i1,i2,i3,ey)*cEr + UG(i1,i2,i3,ey+3)*cEi;
      U(i1,i2,i3,hz)=UG(i1,i2,i3,hz)*cHr + UG(i1,i2,i3,hz+3)*cHi;

      if( method==sosup )
      { // time derivatives: 
        U(i1,i2,i3,ext)=UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost;
        U(i1,i2,i3,eyt)=UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost;
        U(i1,i2,i3,hzt)=UG(i1,i2,i3,hz)*dsint+UG(i1,i2,i3,hz+3)*dcost;
      }
    }
    // -- dispersion model components --
    if( localDispersionModel!=noDispersion )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          // *fix* me for numberOfPolarizationVectors>1 
          pLocal(i1,i2,i3,pc  ) = UG(i1,i2,i3,ex)*cPr[iv] + UG(i1,i2,i3,ex+3)*cPi[iv];
          pLocal(i1,i2,i3,pc+1) = UG(i1,i2,i3,ey)*cPr[iv] + UG(i1,i2,i3,ey+3)*cPi[iv];
        }

      }
    }
  }
  else
  {
    // ===== THREE DIMENSIONS -- KNOWN SOLUTION  =====

    if( solveForElectricField )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        U(i1,i2,i3,ex)=UG(i1,i2,i3,ex)*cEr + UG(i1,i2,i3,ex+3)*cEi;
        U(i1,i2,i3,ey)=UG(i1,i2,i3,ey)*cEr + UG(i1,i2,i3,ey+3)*cEi;
        U(i1,i2,i3,ez)=UG(i1,i2,i3,ez)*cEr + UG(i1,i2,i3,ez+3)*cEi;

        if( method==sosup )
        { // time derivatives:
          U(i1,i2,i3,ext)=UG(i1,i2,i3,ex)*dsint + UG(i1,i2,i3,ex+3)*dcost;
          U(i1,i2,i3,eyt)=UG(i1,i2,i3,ey)*dsint + UG(i1,i2,i3,ey+3)*dcost;
          U(i1,i2,i3,ezt)=UG(i1,i2,i3,ez)*dsint + UG(i1,i2,i3,ez+3)*dcost;
        }
		  
      }

      // -- dispersion model components --
      if( localDispersionModel!=noDispersion )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            // *fix* me for numberOfPolarizationVectors>1 
            pLocal(i1,i2,i3,pc  ) = UG(i1,i2,i3,ex)*cPr[iv] + UG(i1,i2,i3,ex+3)*cPi[iv];
            pLocal(i1,i2,i3,pc+1) = UG(i1,i2,i3,ey)*cPr[iv] + UG(i1,i2,i3,ey+3)*cPi[iv];
            pLocal(i1,i2,i3,pc+2) = UG(i1,i2,i3,ez)*cPr[iv] + UG(i1,i2,i3,ez+3)*cPi[iv];
          }

        }
      }

    }
    if( solveForMagneticField )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        U(i1,i2,i3,hx)=UG(i1,i2,i3,hx)*cHr + UG(i1,i2,i3,hx+3)*cHi;
        U(i1,i2,i3,hy)=UG(i1,i2,i3,hy)*cHr + UG(i1,i2,i3,hy+3)*cHi;
        U(i1,i2,i3,hz)=UG(i1,i2,i3,hz)*cHr + UG(i1,i2,i3,hz+3)*cHi;
      }
    }
		
  }
#undef UG

  // extrapolate the ghostline
  // getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3); // ghost line
  // u(Ig1,Ig2,Ig3,C)=2.*u(Ig1+is1,Ig2+is2,Ig3,C)-u(Ig1+2*is1,Ig2+2*is2,Ig3,C);

  // u(Ig1,Ig2,Ig3,C)=2.*( ug(I1,I2,I3,C)*sint+ug(I1,I2,I3,C+3)*cost )
  //                       -u(Ig1+2*is1,Ig2+2*is2,Ig3,C);
	    
}
#endMacro 

// ============================================================================
// Macro: Assign BC's for Rod Sterling.
// ============================================================================
#beginMacro assignTwilightZoneBC()
{
              
  assert( tz!=NULL );
  OGFunction & e = *tz;
  Range C(ex,hz);

  if( solveForAllFields )
  {

    RealArray ue(I1,I2,I3,C);  // could avoid maybe 
    e.gd( ue, xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,C,t);
    uLocal(I1,I2,I3,C) = ue(I1,I2,I3,C);
    
  }
  else if( true )
  {
		
    int i1,i2,i3;
    if( mg.numberOfDimensions()==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        real x0 = X(i1,i2,i3,0);
        real y0 = X(i1,i2,i3,1);
        U(i1,i2,i3,ex) =e(x0,y0,0.,ex,t);
        U(i1,i2,i3,ey) =e(x0,y0,0.,ey,t);
        U(i1,i2,i3,hz) =e(x0,y0,0.,hz,t);
      }
      if( method==sosup )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          real x0 = X(i1,i2,i3,0);
          real y0 = X(i1,i2,i3,1);
          U(i1,i2,i3,ext) =e(x0,y0,0.,ext,t);
          U(i1,i2,i3,eyt) =e(x0,y0,0.,eyt,t);
          U(i1,i2,i3,hzt) =e(x0,y0,0.,hzt,t);
        }
      }
		  
    }
    else
    {
      assert( !solveForMagneticField ); // this case to do..
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        real x0 = X(i1,i2,i3,0);
        real y0 = X(i1,i2,i3,1);
        real z0 = X(i1,i2,i3,2);
        U(i1,i2,i3,ex) =e(x0,y0,z0,ex,t);
        U(i1,i2,i3,ey) =e(x0,y0,z0,ey,t);
        U(i1,i2,i3,ez) =e(x0,y0,z0,ez,t);
      }
      if( method==sosup )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          real x0 = X(i1,i2,i3,0);
          real y0 = X(i1,i2,i3,1);
          real z0 = X(i1,i2,i3,2);
          U(i1,i2,i3,ext) =e(x0,y0,z0,ext,t);
          U(i1,i2,i3,eyt) =e(x0,y0,z0,eyt,t);
          U(i1,i2,i3,ezt) =e(x0,y0,z0,ezt,t);
        }
      }
		  
    }
	      
  }
  else // old way -- trouble with PPP
  {
    u(I1,I2,I3,C)=e(mg,I1,I2,I3,C,t);
  }
	    
}

#endMacro

// ============================================================================
// Macro: Assign BC's for the Yee scheme
// ============================================================================
#beginMacro assignYeeBC()          
{
          
  if( mg.boundaryCondition(side,axis)==dirichlet )
  {
    // this is a fake BC where we give all variables equal to the true solution
	  
    if( option==1 )
    {
      getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
      getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1); // ghost line

      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
      if( !ok ) continue;
      ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
      if( !ok ) continue;

      realSerialArray xe(I1,I2,I3,mg.numberOfDimensions());
	    
      if( axis==0 )
      {
        // left or right side
        xe=.5*(xLocal(I1,I2+1,I3,all)+xLocal(I1,I2,I3,all));  // face center
        uLocal(I1,I2,I3,ey)=eyTrue(xe(I1,I2,I3,0),xe(I1,I2,I3,1),t+dtb2);

        // extrapolate ghost line values for plotting:
        uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);

        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
      }
      else if( axis==1 )
      {
        // bottom or top
        xe=.5*(xLocal(I1+1,I2,I3,all)+xLocal(I1,I2,I3,all));  // face center
        uLocal(I1,I2,I3,ex)=exTrue(xe(I1,I2,I3,0),xe(I1,I2,I3,1),t+dtb2);

        // extrapolate ghost line values for plotting:
        uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        if( side==1 )// adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);

      }
      else
      {
        throw "error";
      }
    }
    else
    {
      // BC for H 
      // there is no BC for H -- just extrapolate ghost line values for plotting
      if( side==0 ) 
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1);
      else // adjust for face-centredness
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
                
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
      if( !ok ) continue;

      uLocal(Ig1,Ig2,Ig3,hz)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,hz)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,hz);
//               uLocal(Ig1,Ig2,Ig3,hz)=3.*uLocal(Ig1+is1,Ig2+is2,Ig3,hz)-3.*uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,hz)+
//                                    uLocal(Ig1+3*is1,Ig2+3*is2,Ig3,hz);
	      
    }
  }
  else if( mg.boundaryCondition(side,axis)==perfectElectricalConductor ) 
  {
    // --- YEE ---
    // (1) tangential components of E are zero
    // (2) normal derivative of the normal component of E is zero ??
    // (3) normal component of magnetic field is zero

    if( option==1 )
    {
      getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
      getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1); // ghost line
	    
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
      if( !ok ) continue;
      ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
      if( !ok ) continue;

      if( axis==0 )
      {
        // left or right side
        uLocal(I1,I2,I3,ey)=0.;
        // extrapolate ghost line values for plotting:
        uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
      }
      else if( axis==1 )
      {
        // bottom or top
        uLocal(I1,I2,I3,ex)=0.;
        // extrapolate ghost line values for plotting:
        uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        if( side==1 )// adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
      }
      else
      {
        throw "error";
      }
    }
    else
    {
      // BC for H 
      // there is no BC for H -- just extrapolate ghost line values for plotting
      if( side==0 ) 
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1);
      else // adjust for face-centredness
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
                
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
      if( !ok ) continue;

      uLocal(Ig1,Ig2,Ig3,hz)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,hz)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,hz);
    }
  }
  else // bc
  {
    printF("applyBoundaryConditions:ERROR: unknown boundaryCondition(%i,%i)=%i\n",
           side,axis,mg.boundaryCondition(side,axis));
    Overture::abort("applyBoundaryConditions:ERROR");
  }
}
#endMacro

// ============================================================================
// Macro: Assign BC's for the DSI scheme
// ============================================================================
#beginMacro assignDsiBC()          
{
          
  if( mg.boundaryCondition(side,axis)==dirichlet )
  {
    // this is a fake BC where we give all variables equal to the true solution
    getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
    getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1); // ghost line

    bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
    if( !ok ) continue;
    ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
    if( !ok ) continue;

    realSerialArray xe(I1,I2,I3,mg.numberOfDimensions());
	    
    if( option==1 )
    {
      if( axis==0 )
      {
        // left or right side
        xe=.5*(xLocal(I1,I2+1,I3,all)+xLocal(I1,I2,I3,all));  // face center
        uLocal(I1,I2,I3,ex01)=exTrue(xe(I1,I2,I3,0),xe(I1,I2,I3,1),t+dtb2);
        uLocal(I1,I2,I3,ey01)=eyTrue(xe(I1,I2,I3,0),xe(I1,I2,I3,1),t+dtb2);

        // extrapolate ghost line values for plotting:
        uLocal(Ig1,Ig2,Ig3,ex01)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex01)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex01);
        uLocal(Ig1,Ig2,Ig3,ey01)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey01)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey01);

        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        uLocal(Ig1,Ig2,Ig3,ex10)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex10)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex10);
        uLocal(Ig1,Ig2,Ig3,ey10)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey10)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey10);
      }
      else if( axis==1 )
      {
        // bottom or top
        xe=.5*(xLocal(I1+1,I2,I3,all)+xLocal(I1,I2,I3,all));  // face center
        uLocal(I1,I2,I3,ex10)=exTrue(xe(I1,I2,I3,0),xe(I1,I2,I3,1),t+dtb2);
        uLocal(I1,I2,I3,ey10)=eyTrue(xe(I1,I2,I3,0),xe(I1,I2,I3,1),t+dtb2);

        uLocal(Ig1,Ig2,Ig3,ex10)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex10)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex10);
        uLocal(Ig1,Ig2,Ig3,ey10)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey10)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey10);
        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        uLocal(Ig1,Ig2,Ig3,ex01)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex01)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex01);
        uLocal(Ig1,Ig2,Ig3,ey01)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey01)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey01);

      }
      else
      {
        throw "error";
      }
    }
    else
    {
      // BC for H 
      // there is no BC for H -- just extrapolate ghost line values for plotting
      if( side==0 ) 
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1);
      else // adjust for face-centredness
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
                
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
      if( !ok ) continue;

      uLocal(Ig1,Ig2,Ig3,hz11)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,hz11)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,hz11);
    }
  }
  else if( mg.boundaryCondition(side,axis)==perfectElectricalConductor )
  {
    // ***** DSI : Perfect Electrical Conductor *****

    getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
    getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1); // ghost line
	    
    bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
    if( !ok ) continue;
    ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
    if( !ok ) continue;

    if( option==0 )
    {
      if( axis==0 )
      {
        // left or right side
        // tangential component is zero.
        uLocal(I1,I2,I3,ex)=0.;  // **** finish this ****
        uLocal(I1,I2,I3,ey)=0.;

        // extrapolate ghost line values for plotting:
        //		uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //		uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);

        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        //		uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //		uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
      }
      else if( axis==1 )
      {
        // bottom or top
        uLocal(I1,I2,I3,ex)=0.;
        uLocal(I1,I2,I3,ey)=0.;

        //uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        //		uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //		uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);

      }
      else
      {
        throw "error";
      }
    }
    else if(option==1)
    {
      if( axis==0 )
      {
        // left or right side
        // tangential component is zero.
        uLocal(I1,I2,I3,ex)=0.;  // **** finish this ****
        uLocal(I1,I2,I3,ey)=0.;
		    
        // extrapolate ghost line values for plotting:
        //uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
		    
        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        //uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
      }
      else if( axis==1 )
      {
        // bottom or top
        uLocal(I1,I2,I3,ex)=0.;
        uLocal(I1,I2,I3,ey)=0.;
		    
        //uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
        if( side==1 ) // adjust for face-centredness
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
        //uLocal(Ig1,Ig2,Ig3,ex)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ex)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ex);
        //uLocal(Ig1,Ig2,Ig3,ey)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3,ey)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3,ey);
		    
      }
      else
      {
        OV_ABORT("ERROR");
      }
    }
    else
    {
      // BC for H 
      // there is no BC for H -- just extrapolate ghost line values for plotting
      if( side==0 ) 
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1);
      else // adjust for face-centredness
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,0);
                
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,Ig1,Ig2,Ig3,includeGhost);
      if( !ok ) continue;

      uLocal(Ig1,Ig2,Ig3)=2.*uLocal(Ig1+is1,Ig2+is2,Ig3)-uLocal(Ig1+2*is1,Ig2+2*is2,Ig3);
    }
  }
  else if( mg.boundaryCondition(side,axis)>0 )
  {
    printF("applyBoundaryConditions:ERROR: unknown boundaryCondition(%i,%i)=%i\n",
           side,axis,mg.boundaryCondition(side,axis));
  }
}
#endMacro


// ============================================================================
// Macro: Assign BC's for a Dirichlet BC or plane Wave -- HOW IS THIS DIFFERENT FROM planeWaveBC ?? 
// ============================================================================
#beginMacro assignDirichletPlaneWaveBC()                 
{
  // printF("+++++ assignBC:  assignDirichletPlaneWaveBC\n");
  
  int i1,i2,i3;
  if( numberOfDimensions==2 )
  {
    if( method==bamx )
    {
      getBAPlaneWaveParametersMacro(BC);
      
      // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
      // real kv[3]={twoPi*kx,twoPi*ky,twoPi*kz}; // 
      // real sr,si,evr[6],evi[6];
      // RealArray chi;
      // DispersiveMaterialParameters::PolarizationEnum polarization =
      //   !solveForAllFields ?  DispersiveMaterialParameters::ExEyHzPolarization :
      //   DispersiveMaterialParameters::noPolarization;
      // dmp.getBianisotropicPlaneWaveSolution( kv, sr,si,evr,evi,chi,polarization );

      // printF("BA plane wave BC: s=%9.3e + %9.3e I evr=[%g,%g,%g,%g,%g,%g]\n",
      // 	     sr,si,evr[0],evr[1],evr[2],evr[3],evr[4],evr[5]);

      if( !solveForAllFields )
      {
	// TEz mode: 
	evr[2]=evr[5];  evi[2]=evi[5];
      }
	
      // const real expt  =exp(sr*t);
      RealArray kDotx(I1,I2,I3);
      kDotx = kv[0]*xLocal(I1,I2,I3,0) + kv[1]*xLocal(I1,I2,I3,1);
      for( int m=ex; m<=hz; m++ )
      {
	uLocal(I1,I2,I3,m) = (sin( kr*kDotx + si*t )*evr[m] +
	                      cos( kr*kDotx + si*t )*evi[m])*exp( sr*t - ki*kDotx);  
	// sin( kv[0]*xLocal(I1,I2,I3,0) +kv[1]*xLocal(I1,I2,I3,1) - omega*t )*ev[m];
      }

      if( dmp.isDispersiveMaterial() )
      {
	const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
	for( int m=0; m<numPolarizationTerms; m++ )
	{
	  pLocal(I1,I2,I3,m) = (sin( kr*kDotx + si*t )*chi(m,0) +
				cos( kr*kDotx + si*t )*chi(m,1) )*exp( sr*t - ki*kDotx);
	}
      }

    }

    else if( localDispersionModel==noDispersion )
    {
      // ---- NON DISPERSIVE ---
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        real x0,y0;
        getCoordinates2d(i1,i2,i3,x0,y0,X);

        U(i1,i2,i3,ex)=exTrue(x0,y0,t); 
        U(i1,i2,i3,ey)=eyTrue(x0,y0,t);
        U(i1,i2,i3,hz)=hzTrue(x0,y0,t);
        // printF("new:BC: i=%i,%i,%i x=(%6.3f,%6.3f) u=(%8.2e,%8.2e,%8.2e)\n",i1,i2,i3,X(i1,i2,i3,0),X(i1,i2,i3,1),U(i1,i2,i3,ex),U(i1,i2,i3,ey),U(i1,i2,i3,hz));
      }
      if( method==sosup )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          real x0,y0;
          getCoordinates2d(i1,i2,i3,x0,y0,X);
          U(i1,i2,i3,ext) =extTrue(x0,y0,t);
          U(i1,i2,i3,eyt) =eytTrue(x0,y0,t);
          U(i1,i2,i3,hzt) =hztTrue(x0,y0,t);
        }
      }
    }
    else
    {
      // --- DISPERSIVE ---
      DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);

      const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz);
      real sr, si, chir[10],chii[10],chiSumr,chiSumi;
      dmp.evaluateDispersionRelation( c,kk, sr, si, chir,chii,chiSumr,chiSumi ); 
      if( t<=3.*dt )
        printF("--MX--Dirichlet BC dispersion: s=(%12.4e,%12.4e)\n",sr,si);

      real expt=exp(sr*t);
      real ct = cos(si*t)*expt, st=sin(si*t)*expt;
      // Hz = (i/s) * (-1) * (kx*Ey - ky*Ex )/mu
      real hFactor = -twoPi*( kx*pwc[1] - ky*pwc[0] )/mu;
      real sNormSq = sr*sr+si*si;
      //  hr + i*hi = (i/s)*hfactor
      real hr = hFactor*si/sNormSq;
      real hi = hFactor*sr/sNormSq;

      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        real x0,y0;
        getCoordinates2d(i1,i2,i3,x0,y0,X);
        real xi = twoPi*(kx*x0+ky*y0);
        real cx=cos(xi), sx=sin(xi);
                    
        // real amp=cx*ct-sx*st;  *wdh* 2018/01/28 
        // solution is sin( k*x + si*t)*exp(sr*t) *wdh* 2018/01/28 
        real amp=sx*ct+cx*st;
        U(i1,i2,i3,ex)=pwc[0]*amp;
        U(i1,i2,i3,ey)=pwc[1]*amp;
        // real amph = (hr*ct-hi*st)*cx - (hr*st+hi*ct)*sx;
        real amph = (hr*ct-hi*st)*sx + (hr*st+hi*ct)*cx;
        U(i1,i2,i3,hz)=amph;
                      
        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          // amp=(chir[iv]*ct-chii[iv]*st)*cx - (chir[iv]*st+chii[iv]*ct)*sx;
          amp=eps*( (chir[iv]*ct-chii[iv]*st)*sx + (chir[iv]*st+chii[iv]*ct)*cx );
          pLocal(i1,i2,i3,pc  ) = pwc[0]*amp;
          pLocal(i1,i2,i3,pc+1) = pwc[1]*amp;
        }

        // U(i1,i2,i3,pxc) =pwc[0]*amp;
        // U(i1,i2,i3,pyc) =pwc[1]*amp;

      }
    }

  }
  else
  {
    // ------------ THREE DIMENSIONS ------------

    if( method==bamx )
    {
      getBAPlaneWaveParametersMacro(BC);
      
      // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
      // real kv[3]={twoPi*kx,twoPi*ky,twoPi*kz}; // 
      // real sr,si,evr[6],evi[6];
      // RealArray chi;
      // dmp.getBianisotropicPlaneWaveSolution( kv, sr,si,evr,evi,chi );

      // printF("BA plane wave BC 3D: s=%9.3e + %9.3e I evr=[%g,%g,%g,%g,%g,%g] evi=[%g,%g,%g,%g,%g,%g]\n",
      // 	     sr,si,evr[0],evr[1],evr[2],evr[3],evr[4],evr[5],evi[1],evi[2],evi[3],evi[4],evi[5]);

      // const real expt  =exp(sr*t);
      RealArray kDotx(I1,I2,I3);
      kDotx = kv[0]*xLocal(I1,I2,I3,0) + kv[1]*xLocal(I1,I2,I3,1) + kv[2]*xLocal(I1,I2,I3,2);

      for( int m=ex; m<=hz; m++ )
      {
	uLocal(I1,I2,I3,m) = (sin( kr*kDotx + si*t )*evr[m] +
	                      cos( kr*kDotx + si*t )*evi[m])*exp( sr*t - ki*kDotx);

 	// uLocal(I1,I2,I3,m) = sin( kv[0]*xLocal(I1,I2,I3,0) +kv[1]*xLocal(I1,I2,I3,1) +kv[2]*xLocal(I1,I2,I3,2) + si*t )*evr[m];
      }
      if( dmp.isDispersiveMaterial() )
      {
	const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
	for( int m=0; m<numPolarizationTerms; m++ )
	{
	  pLocal(I1,I2,I3,m) = (sin( kr*kDotx + si*t )*chi(m,0) +
				cos( kr*kDotx + si*t )*chi(m,1) )*exp( sr*t - ki*kDotx);
	}
      }

    }
    else if( localDispersionModel==noDispersion )
    {
      if( solveForElectricField )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          real x0,y0,z0;
          getCoordinates3d(i1,i2,i3,x0,y0,z0,X);

          U(i1,i2,i3,ex)=exTrue3d(x0,y0,z0,t);
          U(i1,i2,i3,ey)=eyTrue3d(x0,y0,z0,t);
          U(i1,i2,i3,ez)=ezTrue3d(x0,y0,z0,t);
        }
        if( method==sosup )
        {
          FOR_3D(i1,i2,i3,I1,I2,I3)
          {
            real x0,y0,z0;
            getCoordinates3d(i1,i2,i3,x0,y0,z0,X);

            U(i1,i2,i3,ext) =extTrue3d(x0,y0,z0,t);
            U(i1,i2,i3,eyt) =eytTrue3d(x0,y0,z0,t);
            U(i1,i2,i3,ezt) =eztTrue3d(x0,y0,z0,t);

          }
        }
      }
    }
    else
    {
      // --- DISPERSIVE ---
      DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);

      const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz );
      real sr, si, chir[10],chii[10], chiSumr,chiSumi;
      dmp.evaluateDispersionRelation( c,kk, sr, si, chir,chii,chiSumr,chiSumi ); 
      if( t<=3.*dt )
        printF("--MX--Dirichlet BC dispersion: s=(%12.4e,%12.4e)\n",sr,si);

      real expt=exp(sr*t);
      real ct = cos(si*t)*expt, st=sin(si*t)*expt;

      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        real x0,y0,z0;
        getCoordinates3d(i1,i2,i3,x0,y0,z0,X);

        real xi = twoPi*(kx*x0+ky*y0+kz*z0);
        real cx=cos(xi), sx=sin(xi);
                    
        // real amp=cx*ct-sx*st;  *wdh* 2018/01/28 
        // solution is sin( k*x + si*t)*exp(sr*t) *wdh* 2018/01/28 
        real amp=sx*ct+cx*st;

        U(i1,i2,i3,ex)=pwc[0]*amp;
        U(i1,i2,i3,ey)=pwc[1]*amp;
        U(i1,i2,i3,ez)=pwc[2]*amp;
                      
        // --- errors in polarization vectors 3D ---
        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          // amp=(chir[iv]*ct-chii[iv]*st)*cx - (chir[iv]*st+chii[iv]*ct)*sx;
          amp= eps*( (chir[iv]*ct-chii[iv]*st)*sx + (chir[iv]*st+chii[iv]*ct)*cx );
          pLocal(i1,i2,i3,pc  ) = pwc[0]*amp;
          pLocal(i1,i2,i3,pc+1) = pwc[1]*amp;
          pLocal(i1,i2,i3,pc+2) = pwc[2]*amp;
        }

      }
    }

    if( solveForMagneticField && method!=bamx )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        real x0,y0,z0;
        getCoordinates3d(i1,i2,i3,x0,y0,z0,X);

        U(i1,i2,i3,hx)=hxTrue3d(x0,y0,z0,t);
        U(i1,i2,i3,hy)=hyTrue3d(x0,y0,z0,t);
        U(i1,i2,i3,hz)=hzTrue3d(x0,y0,z0,t);
      }
		    
    }
  }
}
#endMacro



// ================================================================================================================
/// \brief Apply boundary conditions.
///
///  \param option: option=1 : apply BC's to E at t+dt/2; option=2 : apply BC's to H at t+dt, option=3 : apply all BC's
///
// ================================================================================================================
void Maxwell::
assignBoundaryConditions( int option, int grid, real t, real dt, realMappedGridFunction & u, 
			  realMappedGridFunction & uOld, int current )
// Note: uOld = u[current]
{
  assert( method!=yee );

  real time0=getCPU();
  const int np = max(1,Communication_Manager::numberOfProcessors());

  localDebugFile=pDebugFile;
  
  const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;

  c = cGrid(grid);
  eps = epsGrid(grid);
  mu = muGrid(grid);

  const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);

  MappedGrid & mg = *u.getMappedGrid();
  MappedGridOperators & mgop = mgp!=NULL ? *op : (*cgop)[grid];
  
  const int numberOfDimensions = mg.numberOfDimensions();
  
  cgmxPointer = this; // for getGMDParameters 

  const int useForcing = forcingOption==twilightZoneForcing;

  const BoundaryForcingEnum & boundaryForcingOption =dbase.get<BoundaryForcingEnum>("boundaryForcingOption");

  const int & solveForAllFields = dbase.get<int>("solveForAllFields");

  // total number of polarization components per grid 
  const IntegerArray & totalNumberOfPolarizationComponents =
    parameters.dbase.get<IntegerArray>("totalNumberOfPolarizationComponents");

  const int & useSosupDissipation = parameters.dbase.get<int>("useSosupDissipation");
  bool addBAMXDissipation = method==bamx && artificialDissipation>0.;
  bool addedExtraGhostLine = method==sosup || addBAMXDissipation || (method==nfdtd && useSosupDissipation);
  
  // Do we need the grid points: 
  // const bool centerNeeded=(useForcing || forcingOption==planeWaveBoundaryForcing ||  // **************** fix this 
  //                          initialConditionOption==gaussianPlaneWave || 
  //                          initialConditionOption==planeWaveInitialCondition ||  // for ABC + incident field fix 
  //                          initialConditionOption==planeMaterialInterfaceInitialCondition ||
  //                          initialConditionOption==annulusEigenfunctionInitialCondition  ||
  //                          method==yee || 
  //                          method==dsi );
  bool centerNeeded = vertexArrayIsNeeded( grid );

  if( centerNeeded )
  {
    if( (true || debug & 1) && t<2.*dt ) 
      printF("\n --MX-BC--  CREATE VERTEX grid=%i ---\n\n",grid);
    mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex );
  }
  else
  {
    if( (true || debug & 1) && t<2.*dt ) 
      printF("\n --MX-BC--  VERTEX ARRAY NOT NEEDED grid=%i ---\n\n",grid);
  }
  

  const realArray & x = mg.center();

  Range all;
  const real dtb2=dt*.5;
  BoundaryConditionParameters bcParams;            

  const bool isRectangular = mg.isRectangular();
  real dx[3]={0.,0.,0.}; //

  real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      dx[dir]=dvx[dir];
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
	xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular (Cartesian) grids:
  #undef XC
  #define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

#define XC0(i0,i1,i2) (xab[0][0]+dvx[0]*(i0-iv0[0]))
#define XC1(i0,i1,i2) (xab[0][1]+dvx[1]*(i1-iv0[1]))
#define XC2(i0,i1,i2) (xab[0][2]+dvx[2]*(i2-iv0[2]))

  Range C(ex,hz);

  bool debugGhost=false; // ***TEMP*** June 1, 2016 -- debugging SOSUP
  
  CompositeGrid & cg = *(cgfields[next].getCompositeGrid());
  const int numberOfComponentGrids = cg.numberOfComponentGrids();

  // --- Get Arrays for the dispersive model ----
  const DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
  const int numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;      
  // Keep a local dispersionModel for this grid: (some grids may not have dispersion)
  DispersionModelEnum localDispersionModel = numberOfPolarizationVectors>0 ? dispersionModel : noDispersion;


  if( mg.getGridType()==MappedGrid::structuredGrid )
  {
    // ***********************
    // *** structured grid ***
    // ***********************

    if( debugGhost && grid==1 )
    {
      fprintf(debugFile,"\n --DBG--- setting u[1](-1,-1,0,ey)=-999.\n");
      u(-1,-1,0,ey)=-999.;
    }
    
    if( debug & 4 )
    {
      ::display(u,sPrintF("u at Start of assignBC, grid=%i t=%e",grid,t),debugFile,"%8.1e ");
    }

    #ifdef USE_PPP
     realSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
     realSerialArray xLocal; if( centerNeeded ) getLocalArrayWithGhostBoundaries(x,xLocal);
    #else
     const realSerialArray & uLocal = u;
     const realSerialArray & xLocal = centerNeeded ? x : uLocal;
    #endif
  

    realMappedGridFunction & pv = getDispersionModelMappedGridFunction( grid,next );

    RealArray pLocal;
    if( numberOfPolarizationVectors>0 )
    {
      OV_GET_SERIAL_ARRAY(real, pv,pLoc);
      pLocal.reference(pLoc);
      // ::display(pLocal,"pLocal");
    }

    const IntegerArray & bcg = mg.boundaryCondition();
    IntegerArray gid, dim, bc;
    getLocalBoundsAndBoundaryConditions( u, gid, dim, bc );

    if( forcingOption==magneticSinusoidalPointSource )
    { 
      // this is a "hard" source -- the solution is specified

      const IntegerArray & gid = mg.gridIndexRange();
      int i1=gid(0,0)+(gid(1,0)-gid(0,0))/2;
      int i2=gid(0,1)+(gid(1,1)-gid(0,1))/2;
      int i3=gid(0,2)+(gid(1,2)-gid(0,2))/2;
	  
      if( i1>=uLocal.getBase(0) && i1<=uLocal.getBound(0) &&
          i2>=uLocal.getBase(1) && i2<=uLocal.getBound(1) &&
          i3>=uLocal.getBase(2) && i3<=uLocal.getBound(2) )
      {
	uLocal(i1,i2,i3,hz)=sin(twoPi*frequency*(t+dt));
      }
      
    }

    Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
    Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];

    // do this for now for corners:  **** fix ****  Is this needed any more ?
    Range C(ex,hz);


    if( FALSE )
    {
      // TESTING -- ADDING A 3RD GHOST LINE CAN CAUSE ERRORS ???
      ForBoundary(side,axis)
      {
        // --- PUT BOGUS VALUES ----
        int ghostStart=3;
        int ghostEnd=mg.numberOfGhostPoints(side,axis);
        for( int ghost=ghostStart; ghost<=ghostEnd; ghost++ )
        {
          printF("TESTING : SET GHOST LINE %i to BOGUS for (grid,side,axis)=(%i,%i,%i)\n",ghost,grid,side,axis);
          getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,ghost);
          uLocal(Ig1,Ig2,Ig3,C)=Mapping::bogus;
          // uLocal(Ig1,Ig2,Ig3,C)=0.;
        }
      }
      
    }
    


    bool useOpt=true; //  && bcOption!=Maxwell::useAllDirichletBoundaryConditions;  // don't do parallel for now

    const int includeGhost=1;
    bool assignPlaneWaveBoundaryCondition=false;
    
    for( int axis=axis1; axis<mg.numberOfDimensions(); axis++ )
    {
      for( int side=Start; side<=End; side++ )
      {
        const int bc0 = bc(side,axis);

        const int is1= axis==axis1 ? (side==0 ? 1 : -1) : 0 ;
	const int is2= axis==axis2 ? (side==0 ? 1 : -1) : 0 ;
        // printF("applyBC (side,axis)=(%i,%i) t=%e bc=%i\n",side,axis,t,mg.boundaryCondition(side,axis));

        if( bc0<=0 )
          continue;
	
        // *wdh* 041018 
        // const int ng=orderOfAccuracyInSpace/2;
        // const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
        const int ng=0, ng3=0;  // *wdh* 041018 assign BC's on ghost points too

                
	if( method==nfdtd || method==sosup  || method==bamx )
	{
          // *****************************************************************
          // **************** NFDTD Method ***********************************
          // *****************************************************************

	  if( mg.boundaryCondition(side,axis)==dirichlet ||
              mg.boundaryCondition(side,axis)==planeWaveBoundaryCondition ) 
	  {
            assignPlaneWaveBoundaryCondition=mg.boundaryCondition(side,axis)==planeWaveBoundaryCondition;

	    // this is a fake BC where we give all variables equal to the true solution
	    // assign all variables, vertex centred
  
              // printF("method==nfdtd:applyBC dirichlet to (side,axis)=(%i,%i) t=%e\n",side,axis,t);
	    
	    int numberOfGhostLines = orderOfAccuracyInSpace/2;
            if( addedExtraGhostLine ) numberOfGhostLines++;  // sosup uses one extra ghost line
	    
	    int extra=numberOfGhostLines;
	    getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3,extra);

            // for now assign dirichlet at ghost lines too.
	    Iv[axis] = side==0 ? Range(Iv[axis].getBase()-numberOfGhostLines,Iv[axis].getBound()) : 
	      Range(Iv[axis].getBase(),Iv[axis].getBound()+numberOfGhostLines);
	      
            if( mg.boundaryCondition(side,axis)==interfaceBoundaryCondition )
	    { // do not include the boundary
              Iv[axis] = side==0 ? Range(Iv[axis].getBase(),Iv[axis].getBound()-1) : 
		                   Range(Iv[axis].getBase()+1,Iv[axis].getBound());
	    }
	    
	    bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
	    if( !ok ) continue;

	    real *up = uLocal.Array_Descriptor.Array_View_Pointer3;
	    const int uDim0=uLocal.getRawDataSize(0);
	    const int uDim1=uLocal.getRawDataSize(1);
	    const int uDim2=uLocal.getRawDataSize(2);
#undef U
#define U(i0,i1,i2,i3) up[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]
	    real *xp = xLocal.Array_Descriptor.Array_View_Pointer3;
	    const int xDim0=xLocal.getRawDataSize(0);
	    const int xDim1=xLocal.getRawDataSize(1);
	    const int xDim2=xLocal.getRawDataSize(2);
#undef X
#define X(i0,i1,i2,i3) xp[i0+xDim0*(i1+xDim1*(i2+xDim2*(i3)))]

            
	    if( initialConditionOption==planeWaveInitialCondition ||
                mg.boundaryCondition(side,axis)==planeWaveBoundaryCondition ||
                initialConditionOption==planeMaterialInterfaceInitialCondition ||
                initialConditionOption==gaussianIntegralInitialCondition ||
                initialConditionOption==annulusEigenfunctionInitialCondition ||
                knownSolutionOption==userDefinedKnownSolution )
	    {
	      if( debug & 16 )
	      {
		printF("Dirichlet:BC: (grid,side,axis)=(%i,%i,%i) assign BC: I1,I2,I3=[%i,%i][%i,%i][%i,%i] \n",
                       grid,side,axis,I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound());
	      }
	      if( initialConditionOption==planeMaterialInterfaceInitialCondition )
	      {
#defineMacro XEP(i1,i2,i3,m) X(i1,i2,i3,m)
		setPlaneMaterialInterfaceMacro(boundaryCondition,I1,I2,I3);
		if( debug & 8 )
		{
		  ::display(u(I1,I2,I3,ey),sPrintF("After PMIBC: grid=%i,side=%i,axis=%i t=%e",grid,side,axis,t),debugFile,"%8.1e ");
		}
	      }
	      else if( initialConditionOption==gaussianIntegralInitialCondition )
	      {
		getGaussianIntegralSolution(boundary,UEX,UEY,UHZ,t,I1,I2,I3);
	      }
	      else if( initialConditionOption==annulusEigenfunctionInitialCondition )
	      {
		annulusEigenFunction(boundaryCondition,I1,I2,I3);
	      }
	      else if( knownSolutionOption==userDefinedKnownSolution )
	      {

                int numberOfTimeDerivatives=0;
                CompositeGrid & cg = *(cgfields[next].getCompositeGrid());
		getUserDefinedKnownSolution( next, t, cg,grid, u,pv,I1,I2,I3,numberOfTimeDerivatives);
 
	      }
	      else
	      { //planeWaveInitialCondition or planeWaveBoundaryCondition
		  
                assignDirichletPlaneWaveBC();

              }
                
	      
              // printF(" assign BC: I1,I2,I3=[%i,%i][%i,%i][%i,%i] \n",
              //            I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound());

              // display(u(I1,I2,I3,C),"u(I1,I2,I3,C) after BC new:");

	    
	    } // end if( initialConditionOption==planeWaveInitialCondition || ...
	    else if( forcingOption==twilightZoneForcing )
	    {
              assignTwilightZoneBC();

	    }
	    else if( initialConditionOption==gaussianPlaneWave )
	    {
	      realSerialArray xi;
	      xi=kx*(xLocal(I1,I2,I3,0)-x0GaussianPlaneWave)+ky*(xLocal(I1,I2,I3,1)-y0GaussianPlaneWave) -cc*t;

	      uLocal(I1,I2,I3,hz)=hzGaussianPulse(xi); 
	      uLocal(I1,I2,I3,ex)=uLocal(I1,I2,I3,hz)*(-ky/(eps*cc));
	      uLocal(I1,I2,I3,ey)=uLocal(I1,I2,I3,hz)*( kx/(eps*cc));
	    }
            else if( boundaryForcingOption==planeWaveBoundaryForcing ||
                     initialConditionOption==planeWaveScatteredFieldInitialCondition )
	    {
              // --- Assign the dirichlet (i.e. exact solution) BC for a plane wave or plane wave scattered field ---

              assignPlaneWaveBC();
            }
            
            else if( true )
            {
              uLocal(I1,I2,I3,C)=0.;
            }
            else
            {
              OV_ABORT("Maxwell::assignBoundaryConditions:dirichlet unknown forcing option");
            }

	  } // end if( bc(side,axis)==dirichlet || bc(side,axis)==planeWaveBoundaryCondition ) 
	  
	  else if( mg.boundaryCondition(side,axis)==perfectElectricalConductor )
	  {
            // =================================================================================
            // =========== NOTE: PEC BOUNDARY CONDITIONS ARE ASSIGNED IN MXCORNERS =============
            // =================================================================================

            assert( useOpt );
	    
	  }
          else if( mg.boundaryCondition(side,axis)==symmetry )
	  {
	    if( FALSE ) // *WDH* June 16, 2016
	    {
	      // THIS IS AN OLD INCORRECT SYMMETRY BC -- only did even symmetry
	      // Symmetry conditions are now performed elsewhere in bcSymmetry 

	      if( t<=2*dt )
	      {
		printF("Apply symmetry BC on (side,axis)=(%i,%i) t=%8.2e is1,is2=(%i,%i)\n"
		       " ************ This symmetry BC should not be used any more! *********\n",
		       side,axis,t,is1,is2);
	      }

	      //              Range V(ex,ey);
	      //              mgop.applyBoundaryCondition(u,V,BCTypes::vectorSymmetry,symmetry,0.,t);
	      //              Range H(hz,hz);
	      //              mgop.applyBoundaryCondition(u,H,BCTypes::evenSymmetry,symmetry,0.,t);
	      Range C(ex,hz);
	      mgop.applyBoundaryCondition(u,C,BCTypes::evenSymmetry,symmetry,0.,t);
	      if( orderOfAccuracyInSpace==4 )
	      {
		bcParams.ghostLineToAssign=2;
		mgop.applyBoundaryCondition(u,C,BCTypes::evenSymmetry,symmetry,0.,t,bcParams);
	      }

	      if( orderOfAccuracyInSpace!=2 && orderOfAccuracyInSpace!=4 )
	      {
		printF("cgmx: assignBC: symmetry BC : ERROR: orderOfAccuracyInSpace=%i\n",orderOfAccuracyInSpace);
		OV_ABORT("FINISH ME");
	      }
	    }
	    
	  }
          else if( mg.boundaryCondition(side,axis)==interfaceBoundaryCondition )
	  {
            // do nothing here
	  }
          else if( (mg.boundaryCondition(side,axis)>=abcEM2 && mg.boundaryCondition(side,axis)<=abc5) ||
                    mg.boundaryCondition(side,axis)==rbcNonLocal || mg.boundaryCondition(side,axis)==rbcLocal )
	  {
            // do nothing here
	  }
	  else // bc== ?
	  {
	    printF("assignBoundaryConditions:ERROR: unknown boundaryCondition(%i,%i)=%i\n",
		   side,axis,mg.boundaryCondition(side,axis));
	    OV_ABORT("assignBoundaryConditions:ERROR");
	  }
	}
	else if( method==yee )
	{
          // *****************************************************************
          // **************** Yee Method *************************************
          // *****************************************************************

          assignYeeBC();

	}  // *********************** END YEE ************************
	
	else if( method==dsi )
	{
          // *****************************************************************
          // **************** DSI Method *************************************
          // *****************************************************************

          assignDsiBC();


	} // ************************** END DSI ************************************
	
	else
	{
	  printF("applyBoundaryConditions:ERROR: unknown boundaryCondition(%i,%i)=%i\n",
		 side,axis,mg.boundaryCondition(side,axis));
	  Overture::abort("applyBoundaryConditions:ERROR");
	}
	
      } // end side
    }  // end axis


    if( debug & 8 )
    {
      Index I1,I2,I3;
      getIndex(mg.dimension(),I1,I2,I3);      
      ::display(u(I1,I2,I3,ey),sPrintF("BC: Ey before optBC, grid=%i t=%e",grid,t),debugFile,"%8.1e ");
    }


    // *wdh* 041127 -- apply opt BC's after above dirichlet BC's ----

    if( debugGhost && grid==1 )
      fprintf(debugFile,"\n --DBG--- Before optBC: u[1](-1,-1,0,ey)=%8.2e\n",uLocal(-1,-1,0,ey));

    // *wdh* June 25, 2016 if( initialConditionOption!=planeMaterialInterfaceInitialCondition ) // *wdh* 080922
    if( true )
    {
      optimizedBoundaryConditionsMacro(field);

      if( method==sosup )
      {
        // -- apply BCs to the time derivatives of the field --
        optimizedBoundaryConditionsMacro(timeDerivatives);
      }

      if( FALSE && localDispersionModel != noDispersion )
      {
        // -- apply BCs to the polarization vector
        optimizedBoundaryConditionsMacro(polarization);
      }
      
      if( debugGhost && grid==1 )
	  fprintf(debugFile,"\n --DBG--- AFter optBC: u[1](-1,-1,0,ey)=%8.2e\n",uLocal(-1,-1,0,ey));
      
    }
  }
  else
  {
    // unstructured grid BC's
  }


  if( localDispersionModel != noDispersion )
  {
    // ---- apply BCs to the polarization vector ----

    // For now just extrapolate in space since P on the ghost are not used 

    // const DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
    // const int numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;      
    if( numberOfPolarizationVectors>0 )
    {
      realMappedGridFunction & p =  getDispersionModelMappedGridFunction( grid, next );
      // Range Pc = numberOfPolarizationVectors*numberOfDimensions;
      int numPolarizationTerms = numberOfPolarizationVectors*numberOfDimensions;
      if( method==bamx )
	numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;

      Range Pc = numPolarizationTerms;

      MappedGridOperators & mgop = mgp!=NULL ? *op : (*cgop)[grid];
      p.setOperators(mgop);

      int ghostStart=1, ghostEnd=orderOfAccuracyInSpace/2;
      BoundaryConditionParameters extrapParams;
      extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;  // what should this be ?
      extrapParams.extraInTangentialDirections=ghostEnd;
      for( int ghost=ghostStart; ghost<=ghostEnd; ghost++ )
      {
        extrapParams.ghostLineToAssign=ghost;
        p.applyBoundaryCondition(Pc,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);
      }

      if( true )
      {
        // Feb 9, 2018 -- added this: Is this needed?? *wdh*
        extrapParams.ghostLineToAssign=1;  // reset 
        extrapParams.numberOfCornerGhostLinesToAssign= ghostEnd+1;
        p.finishBoundaryConditions(extrapParams,Pc);
      }
      
    }

    // ** OLD ****
    // if( FALSE )
    // {
      
    //   // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
    //   Range Pc(pxc,pxc+numberOfDimensions-1);
    //   MappedGridOperators & mgop = mgp!=NULL ? *op : (*cgop)[grid];
    //   u.setOperators(mgop);

    //   int ghostStart=1, ghostEnd=orderOfAccuracyInSpace/2;
    //   BoundaryConditionParameters extrapParams;
    //   extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;  // what should this be ?
    //   extrapParams.extraInTangentialDirections=ghostEnd;
    //   for( int ghost=ghostStart; ghost<=ghostEnd; ghost++ )
    //   {
    //     extrapParams.ghostLineToAssign=ghost;
    //     u.applyBoundaryCondition(Pc,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);
    //   }
    // }
    
    
  }


  if( addedExtraGhostLine )
  {
    // Extrapolate an extra ghost line for the wider upwind stencil in SOSUP
    BoundaryConditionParameters extrapParams;

    int bcOrderOfAccuracy=orderOfAccuracyInSpace;
    if( method==sosup && orderOfAccuracyInSpace==6 )
    {
      // NOTE: for now apply 4th order BC's for sosup order 6
      bcOrderOfAccuracy=4;
    }

    const int ghostEnd = (orderOfAccuracyInSpace/2)+1;  // last ghost line for sosup stencil
    // NOTE: for now we impose at most 2 ghost lines with the 4th=order BC's 
    // first ghost line for sosup stencil: 
    //     ghostStart=2 for order=2
    //     ghostStart=3 for order>2   *fix me* when 6'th order BC's are implemented
    assert( bcOrderOfAccuracy<=4 );
    const int ghostStart= min(3,ghostEnd);              

    extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;  // what should this be ?

    extrapParams.extraInTangentialDirections=ghostEnd;

    Range Ca = cgfields[0][0].getLength(3); // all components

    MappedGridOperators & mgop = mgp!=NULL ? *op : (*cgop)[grid];
    u.setOperators(mgop);
    
    for( int ghost=ghostStart; ghost<=ghostEnd; ghost++ )
    {
      extrapParams.ghostLineToAssign=ghost;
      if( debug & 4 )
	printF("assignBC: sosup: extrap ghost-line %i to order %i\n",
	       extrapParams.ghostLineToAssign,extrapParams.orderOfExtrapolation);

      for( int axis=0; axis<mg.numberOfDimensions(); axis++ )for( int side=0; side<=1; side++ )
      {
	const int bc = mg.boundaryCondition(side,axis);
	if( bc!=dirichlet && bc!=symmetry && bc>=0 ) // **wdh* added bc>0 Nov. 26, 2019 -- may make no difference
	{
	  u.applyBoundaryCondition(Ca,BCTypes::extrapolate,BCTypes::boundary1+side+2*(axis),0.,t,extrapParams);
	}
      }
    }
    
  }

  

  if( debug & 8 )
  {
    Index I1,I2,I3;
    getIndex(mg.dimension(),I1,I2,I3);      
    ::display(u(I1,I2,I3,ey),sPrintF("BC: Ey after optBC, grid=%i t=%e",grid,t),debugFile,"%8.1e ");
  }

  if( debug & 4 )
  {
    ::display(u,sPrintF("u at end of assignBC, grid=%i t=%e",grid,t),debugFile,"%8.1e ");
  }

  timing(timeForBoundaryConditions)+=getCPU()-time0;
}

