// #define BOUNDS_CHECK


#include "Maxwell.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "RadiationBoundaryCondition.h"
#include "ParallelUtility.h"
#include "ParallelGridUtility.h"
#include "DispersiveMaterialParameters.h"
#include "CheckParallel.h"
#include "InterfaceMaxwell.h"
#include "GridStatistics.h"

#define interfaceMaxwell EXTERN_C_NAME(interfacemaxwell)
#define newInterfaceMaxwell EXTERN_C_NAME(newinterfacemaxwell)

// ***NOTE*** interface3dMaxwell is *RENAMED* interface3dMaxwell to interfaceOpt (new way) Jan 26, 2021 *wdh*
#define interface3dMaxwell EXTERN_C_NAME(interfaceopt)
// OLD: 
// #define interface3dMaxwell EXTERN_C_NAME(interface3dmaxwell)

extern "C"
{
void interfaceMaxwell( const int&nd, 
                       const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                       const int&gridIndexRange1, real&u1, const int&mask1,const real&rsxy1, const real&xy1, 
                       const int&boundaryCondition1, 
                       const int&md1a,const int&md1b,const int&md2a,const int&md2b,const int&md3a,const int&md3b,
                       const int&gridIndexRange2, real&u2, const int&mask2,const real&rsxy2, const real&xy2, 
                       const int&boundaryCondition2,
                       const int&ipar, const real&rpar, 
                       real&aa2, real&aa4, real&aa8, 
                       int&ipvt2, int&ipvt4, int&ipvt8,
                       int&ierr );

void newInterfaceMaxwell( const int&nd, 
                       const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                       const int&gridIndexRange1, real&u1, const int&mask1,const real&rsxy1, const real&xy1, 
                       const int&boundaryCondition1, 
                       const int&md1a,const int&md1b,const int&md2a,const int&md2b,const int&md3a,const int&md3b,
                       const int&gridIndexRange2, real&u2, const int&mask2,const real&rsxy2, const real&xy2, 
                       const int&boundaryCondition2,
                       const int&ipar, const real&rpar, int&ierr );

void interface3dMaxwell( const int&nd, 
                       const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                       const int&gridIndexRange1, 
                       real&u1, const real&u1n, const real&u1m, real& v1, 
                       const int&mask1,const real&rsxy1, const real&xy1, 
                       real&p1, const real&p1n, const real&p1m, 
                       real&q1, const real&q1n, const real&q1m, 
                       const int&boundaryCondition1, 
                       const int&md1a,const int&md1b,const int&md2a,const int&md2b,const int&md3a,const int&md3b,
                       const int&gridIndexRange2, 
                       real&u2, const real&u2n, const real&u2m, real & v2,
                       const int&mask2,const real&rsxy2, const real&xy2, 
                       real&p2, const real&p2n, const real&p2m,  
                       real&q2, const real&q2n, const real&q2m,  
                       const int&boundaryCondition2,
                       const int&ipar, const real&rpar, 
                       real&aa2, real&aa4, real&aa8, 
                       int&ipvt2, int&ipvt4, int&ipvt8,
                       int&ierr );

}


static CheckParallel *pCheckParallel=NULL;

// make these routines callable from Fortran (C linkage)
#define checkParallelFortranArrayReal EXTERN_C_NAME(checkparallelfortranarrayreal)
#define checkParallelFortranArrayInt  EXTERN_C_NAME(checkparallelfortranarrayint)
extern "C"
{

/* Use this routine to call CheckParallel from Fortran */
real checkParallelFortranArrayReal(char *label_,
                         int & nd1a, int & nd1b, int & nd2a, int & nd2b, int & nd3a, int & nd3b, int & nd4a, int & nd4b, 
                         int & n1a, int & n1b, int & n2a, int & n2b, int & n3a, int & n3b, int & n4a, int & n4b,
                         real & x_, 
                         int & labelLength )
{
  assert( pCheckParallel!=NULL );
  return checkParallelArrayReal( pCheckParallel, label_,
                             nd1a,  nd1b,  nd2a,  nd2b,  nd3a,  nd3b,  nd4a,  nd4b, 
                             n1a,  n1b,  n2a,  n2b,  n3a,  n3b,  n4a,  n4b,
                             x_, 
                             labelLength );
}

real checkParallelFortranArrayInt(char *label_,
                         int & nd1a, int & nd1b, int & nd2a, int & nd2b, int & nd3a, int & nd3b, int & nd4a, int & nd4b, 
                         int & n1a, int & n1b, int & n2a, int & n2b, int & n3a, int & n3b, int & n4a, int & n4b,
                         int & x_, 
                         int & labelLength )
{
  assert( pCheckParallel!=NULL );
  return checkParallelArrayInt( pCheckParallel, label_,
                             nd1a,  nd1b,  nd2a,  nd2b,  nd3a,  nd3b,  nd4a,  nd4b, 
                             n1a,  n1b,  n2a,  n2b,  n3a,  n3b,  n4a,  n4b,
                             x_, 
                             labelLength );
}


}


#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3IJD(i1,i2,i3,I1,I2,I3,j1,j2,j3,J1,J2,J3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
int J1Base =J1.getBase(),   J2Base =J2.getBase(),  J3Base =J3.getBase();  \
for(i3=I3Base,j3=J3Base; i3<=I3Bound; i3++,j3++) \
for(i2=I2Base,j2=J2Base; i2<=I2Bound; i2++,j2++) \
for(i1=I1Base,j1=J1Base; i1<=I1Bound; i1++,j1++)


#define FOR_4IJD(i1,i2,i3,i4,I1,I2,I3,I4,j1,j2,j3,j4,J1,J2,J3,J4) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(),  I4Base =I4.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(), I4Bound=I4.getBound(); \
int J1Base =J1.getBase(),   J2Base =J2.getBase(),  J3Base =J3.getBase(),  J4Base =J4.getBase();  \
for(i4=I4Base,j4=J4Base; i4<=I4Bound; i4++,j4++) \
for(i3=I3Base,j3=J3Base; i3<=I3Bound; i3++,j3++) \
for(i2=I2Base,j2=J2Base; i2<=I2Bound; i2++,j2++) \
for(i1=I1Base,j1=J1Base; i1<=I1Bound; i1++,j1++)

#define FOR_4IJ(i1,i2,i3,i4,I1,I2,I3,I4,j1,j2,j3,j4,J1,J2,J3,J4) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(),  I4Base =I4.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(), I4Bound=I4.getBound(); \
J1Base =J1.getBase(),   J2Base =J2.getBase(),  J3Base =J3.getBase(),  J4Base =J4.getBase();  \
for(i4=I4Base,j4=J4Base; i4<=I4Bound; i4++,j4++) \
for(i3=I3Base,j3=J3Base; i3<=I3Bound; i3++,j3++) \
for(i2=I2Base,j2=J2Base; i2<=I2Bound; i2++,j2++) \
for(i1=I1Base,j1=J1Base; i1<=I1Bound; i1++,j1++)

#define FOR_4IJD_WITH_STRIDE(i0,i1,i2,i3,indexi,j0,j1,j2,j3,indexj)\
      for( int i3=indexi[3][0],j3=indexj[3][0]; i3<=indexi[3][1]; i3+=indexi[3][2], j3+=indexj[3][2] )\
      for( int i2=indexi[2][0],j2=indexj[2][0]; i2<=indexi[2][1]; i2+=indexi[2][2], j2+=indexj[2][2] )\
      for( int i1=indexi[1][0],j1=indexj[1][0]; i1<=indexi[1][1]; i1+=indexi[1][2], j1+=indexj[1][2] )\
      for( int i0=indexi[0][0],j0=indexj[0][0]; i0<=indexi[0][1]; i0+=indexi[0][2], j0+=indexj[0][2] )


void Maxwell::
initializeInterfaces()
// =====================================================================================================
//   /Description:
//      Find the interfaces and initialize the work-space. 
// =====================================================================================================
{
  real time0=getCPU();
  if( true || debug & 4 )
    printF("initializeInterfaces....\n");
  

  // ************** THIS ROUTINE SHOULD USE THE ONE IN cg/mp/src/assignInterfaceConditions.C ****************

  assert( cgp!=NULL );
  CompositeGrid & cg= *cgp;
  const int numberOfDimensions = cg.numberOfDimensions();
  const int numberOfComponentGrids = cg.numberOfComponentGrids();

  int bcOrderOfAccuracy=orderOfAccuracyInSpace;
  if( method==sosup && orderOfAccuracyInSpace==6 )
  {
    // NOTE: for now apply 4th order BC's for sosup order 6
    bcOrderOfAccuracy=4;
  }

  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Jv[3], &J1=Jv[0], &J2=Jv[1], &J3=Jv[2];

  // --- The matched array is used to avoid checking faces that have already been matched ---
  //       matched(side,axis,grid)=1 if this face has been natched to another.
  IntegerArray matched(2,cg.numberOfDimensions(),cg.numberOfComponentGrids());
  matched=0;  
  
  int grid1;
  for( grid1=0; grid1<cg.numberOfComponentGrids(); grid1++ )
  {

    MappedGrid & mg1 = cg[grid1];
    const IntegerArray & bc1 = mg1.boundaryCondition();
    const IntegerArray & share1 = mg1.sharedBoundaryFlag();

    // check for interface boundary conditions
    for( int dir1=0; dir1<mg1.numberOfDimensions(); dir1++ )
    {
      for( int side1=0; side1<=1; side1++ )
      {
        if( bc1(side1,dir1)==interfaceBoundaryCondition && matched(side1,dir1,grid1)==0 )
        {
          bool interfaceFound=false;
          for( int grid2=grid1+1; grid2<cg.numberOfComponentGrids(); grid2++ ) // only check higher numbered grids
          {
            // When there are multiple domains, matching interfaces grids should not be in the same domain:
            if( cg.numberOfDomains()>1 && cg.domainNumber(grid1)==cg.domainNumber(grid2) )
              continue;

            MappedGrid & mg2 = cg[grid2];
            const IntegerArray & bc2 = mg2.boundaryCondition();
            const IntegerArray & share2 = mg2.sharedBoundaryFlag();

            for( int dir2=0; dir2<mg2.numberOfDimensions(); dir2++ )
            {
              for( int side2=0; side2<=1; side2++ )
              {
                if( bc2(side2,dir2)==interfaceBoundaryCondition &&
                    share1(side1,dir1)==share2(side2,dir2) && 
                    matched(side2,dir2,grid2)==0 && 
                    matched(side1,dir1,grid1)==0 )  
                {
                  // ********************************************
                  // **** potential interface found *************
                  // ********************************************

                  // ---- Check that the interfaces are close in space ---- *wdh* 2017/05/06 
                  Mapping & map1 = mg1.mapping().getMapping();
                  Mapping & map2 = mg2.mapping().getMapping();
                  
                  RealArray r1(1,3), x1(1,3), r2(1,3), x2(1,3); x1=0.; x2=0.;
                  r1=.5; r1(0,dir1)=side1;  // r-coords for a point on the middle of the face of grid1
                  map1.mapS(r1,x1);           // x coords on grid 1
                  r2=-1.;
                  map2.inverseMapS(x1,r2);    // r-coords on grid 2
                  map2.mapS(r2,x2);           // x-coords on grid 2
                  real rDist=fabs( r2(0,dir2)-side2 );
                  real xDist=fabs( x1(0,0)-x2(0,0) ) + fabs( x1(0,1)-x2(0,1) ) + fabs( x1(0,2)-x2(0,2) );
                  const RealArray & bb = map1.getBoundingBox();
                  real xNorm = fabs(bb(1,0)-bb(0,0)) + fabs(bb(1,1)-bb(0,1));
                  if( numberOfDimensions==3 ) xNorm +=  fabs(bb(1,2)-bb(0,2));

                  xDist /=max(REAL_MIN*100,xNorm);  // normalize x-distance 
                  

                  printF("--MX-- POTENTIAL Interface: %s=(grid1,side,dir1)=(%i,%i,%i) "
                         "AND %s=(grid2,side2,dir2)=(%i,%i,%i) share=%i\n",
                         (const char*)mg1.getName(),grid1,side1,dir1,
                         (const char*)mg2.getName(),grid2,side2,dir2,share1(side1,dir1));
                  printF(" grid1: r1=[%8.2e,%8.2e,%8.2e] x1=[%8.2e,%8.2e,%8.2e]\n"
                         " grid2: r2=[%8.2e,%8.2e,%8.2e] x2=[%8.2e,%8.2e,%8.2e] .. rDist=%8.2e xDist=%8.2e, xNorm=%8.2e\n",
                         r1(0,0),r1(0,1),r1(0,2), x1(0,0),x1(0,1),x1(0,2), 
                         r2(0,0),r2(0,1),r2(0,2), x2(0,0),x2(0,1),x2(0,2), rDist, xDist, xNorm);

                  // --- tolerances for surfaces to match ---
                  const real rTol=1.e-2;
                  const real xTol=1.e-5;
                   
                  if( rDist<rTol && xDist < xTol )
                  {
                    if( interfaceFound )
                    {
                      // -- ERROR a previous matching interface has already been found! ---

                      printF("initializeInterfaces:ERROR: A second valid interface match has been found:\n"
                             " (grid1,side1,dir1,share1)=(%i,%i,%i,%i) also matches"
                             " (grid2,side2,dir2,share2)=(%i,%i,%i,%i).\n"
                             " Matching interface grids should be marked with distinct share values.\n",
                             grid1,side1,dir1,share1(side1,dir1), grid2,side2,dir2,share2(side2,dir2));
                      OV_ABORT("error");
                    }

                    // ---- ADD an interface to the list ----
                    interfaceFound=true;
                    matched(side1,dir1,grid1)=1; // indicates these faces have been matched
                    matched(side2,dir2,grid2)=1;
                    
                    printF("--MX-- Interface found: %s=(grid1,side,dir1)=(%i,%i,%i) matches "
                           "%s=(grid2,side2,dir2)=(%i,%i,%i) share=%i\n",
                           (const char*)mg1.getName(),grid1,side1,dir1,
                           (const char*)mg2.getName(),grid2,side2,dir2,share1(side1,dir1));

                    // printF("interfaceInfo.size() = %d\n",interfaceInfo.size());
                    // int interfaceInfoSize=interfaceInfo.size();
                    // interfaceInfo.resize(interfaceInfoSize+1);
                    // interfaceInfo[interfaceInfoSize]=InterfaceInfo(grid1,side1,dir1, grid2,side2,dir2);
                    
                    interfaceInfo.push_back(InterfaceInfo(grid1,side1,dir1, grid2,side2,dir2));   

                    // InterfaceInfo & info12 = *(new InterfaceInfo(grid1,side1,dir1, grid2,side2,dir2));
                    // interfaceInfo.push_back(info12);
                  
                    // ***** Check that the valid points match on the interface ******
                    //   *wdh* 2015/08/11
                    const intArray & mask1 = mg1.mask();
                    const intArray & mask2 = mg2.mask();
                    OV_GET_SERIAL_ARRAY_CONST(int,mask1,mask1Local);
                    OV_GET_SERIAL_ARRAY_CONST(int,mask2,mask2Local);
                    // *wdh* Nov 29, 2020
                    // getBoundaryIndex(mg1.dimension(),side1,dir1,I1,I2,I3);
                    // getBoundaryIndex(mg2.dimension(),side2,dir2,J1,J2,J3);
                    // Fixed: check boundary points *wdh* Nov 29, 2020
                    getBoundaryIndex(mg1.gridIndexRange(),side1,dir1,I1,I2,I3);
                    getBoundaryIndex(mg2.gridIndexRange(),side2,dir2,J1,J2,J3);

                    if( debug & 8 )
                    {
                      fprintf(debugFile,"--MX-- Interface found: %s=(grid1,side,dir1)=(%i,%i,%i) matches "
                           "%s=(grid2,side2,dir2)=(%i,%i,%i) share=%i\n",
                           (const char*)mg1.getName(),grid1,side1,dir1,
                           (const char*)mg2.getName(),grid2,side2,dir2,share1(side1,dir1));

                      displayMask(mask1,"mask1",debugFile);
                      displayMask(mask2,"mask2",debugFile);

                      fflush(debugFile);
                    }

                    if( true)
                    {
                      // -- Check that interfaces have the same number of grid points -- 
                      const int d1=cg.domainNumber(grid1), d2=cg.domainNumber(grid2);
                      
                      for( int dir=1; dir<mg1.numberOfDimensions(); dir++ )
                      {
                        int dir1p = (dir1+dir) % mg1.numberOfDimensions();
                        int dir2p = (dir2+dir) % mg2.numberOfDimensions();
                        if( Iv[dir1p].getLength()!=Jv[dir2p].getLength() )
                        {
                          printF("initIterfaces:ERROR: The number of grid points on the two interfaces do not match\n"
                                 " (d1,grid1,side1,dir1,bc1)=(%i,%i,%i,%i,%i) Iv=[%i,%i][%i,%i][%i,%i]\n"
                                 " (d2,grid2,side2,dir2,bc2)=(%i,%i,%i,%i,%i) Jv=[%i,%i][%i,%i][%i,%i]\n",
                                 d1,grid1,side1,dir1,mg1.boundaryCondition(side1,dir1),
                                 I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound(),  
                                 d2,grid2,side2,dir2,mg2.boundaryCondition(side2,dir2),
                                 J1.getBase(),J1.getBound(),J2.getBase(),J2.getBound(),J3.getBase(),J3.getBound());
                          printF("grid names are [%s] and [%s]\n",(const char*)mg1.getName(),(const char*)mg2.getName());
                          OV_ABORT("error");
                        }
                      }
                      
                      
                      // printf("initInterfaces:ERROR: the mask arrays do not match on the interface. This is currently required.\n");
                      // printf("  Try re-generating the grid with more lines in the normal direction, this sometimes fixes this problem.\n");
                      // if( debug & 1 )
                      // {
                      //   fprintf(pDebugFile,"initInterfaces:ERROR: the mask arrays are not distributed in the same way on the interface. "
                      //           "This is currently required.\n");
                      //   ::display(mask1Local,"mask1Local",pDebugFile);
                      //   ::display(mask2Local,"mask2Local",pDebugFile);
                      //   fflush(pDebugFile);
                        
                      // }
                      
                      // fflush(0);
                      // OV_ABORT("ERROR: masks do not match at interfaces");

                    }

                    int includeGhost=1;
                    bool ok1 = ParallelUtility::getLocalArrayBounds(mask1,mask1Local,I1,I2,I3,includeGhost);
                    bool ok2 = ParallelUtility::getLocalArrayBounds(mask2,mask2Local,J1,J2,J3,includeGhost);

                    // This next check does not always work in parallel -- fix me -- could add check when we create 
                    // copies of the mask array *fix me*
                    if( ok1 && ok2 &&
                        I1.getLength()==J1.getLength() &&  
                        I2.getLength()==J2.getLength() &&
                        I3.getLength()==J3.getLength() 
                      )
                    {
                      // ---- The check for parallel is now done in getLocalInterfaceArrays macro ---
                      
                      // int maskDiff = max(abs(mask1Local(I1,I2,I3)-mask2Local(J1,J2,J3)));

                      // Check that both masks are discretization points (ignore isNeeded etc.) *wdh* Nov 29, 2020
                      int maskDiff = max( (mask1Local(I1,I2,I3) & MappedGrid::ISdiscretizationPoint) -
                                          (mask2Local(J1,J2,J3) & MappedGrid::ISdiscretizationPoint) );

                      if( maskDiff > 0 )
                      {
                        printF("       ERROR: the mask arrays do not match on the interface. This is currently required.\n");
                        printF("       Try re-generating the grid with more lines in the normal direction, this sometimes fixes this problem.\n");
                        printF("       See debug file for more info if debug &2 \n");
                        if( debug & 2 )
                        {
                          displayMask(mask1Local(I1,I2,I3),"mask1Local(I1,I2,I3)",pDebugFile);
                          displayMask(mask2Local(J1,J2,J3),"mask2Local(J1,J2,J3)",pDebugFile);
                          IntegerArray md(I1,I2,I3);
                          md = ( (mask1Local(I1,I2,I3) & MappedGrid::ISdiscretizationPoint) -
                                 (mask2Local(J1,J2,J3) & MappedGrid::ISdiscretizationPoint) );
                          where( md>0 )
                          {
                            md=1;
                          }
                          
                         ::display(md,"difference)",pDebugFile,"%2i ");

                          fprintf(pDebugFile,"       INFO: interface grid points match: mask arrays agree on the interface.\n\n");
                        }
                        OV_ABORT("ERROR");
                      }
                      else
                      {
                        printF("       INFO: interface grid points match: mask arrays agree on the interface.\n\n");
                        if( debug & 2 )
                        {
                          displayMask(mask1Local(I1,I2,I3),"mask1Local(I1,I2,I3)",pDebugFile);
                          displayMask(mask2Local(J1,J2,J3),"mask2Local(J1,J2,J3)",pDebugFile);

                          fprintf(pDebugFile,"       INFO: interface grid points match: mask arrays agree on the interface.\n\n");
                        }
                        
                      }
                    }
                  } // end if rDist < rTol and xDist < xTol 
                  
                }
              }
            }
          } // end for grid 2
          if( !interfaceFound )
          { // if no interface was found, check that we haven't found a match already: 
            for( int inter=0; inter < interfaceInfo.size(); inter++ )
            {
              InterfaceInfo & interface = interfaceInfo[inter]; 
              if( (grid1==interface.grid1 && side1==interface.side1 && dir1==interface.dir1) ||
                  (grid1==interface.grid2 && side1==interface.side2 && dir1==interface.dir2) )
              {
                interfaceFound=true;
                break;
              }
            }
            if( !interfaceFound )
            {
              printF("initializeInterfaces:ERROR: No matching interface found for (grid1,side,dir1)=(%i,%i,%i).\n",
                     grid1,side1,dir1);
              OV_ABORT("error");
            }
          }
        }
      }
    }
  }


  // Allocate space for each interface
  for( int inter=0; inter < interfaceInfo.size(); inter++ )
  {
    InterfaceInfo & interface = interfaceInfo[inter]; 

    const int grid1=interface.grid1, side1=interface.side1, dir1=interface.dir1;
    const int grid2=interface.grid2, side2=interface.side2, dir2=interface.dir2;
    
    MappedGrid & mg1 = cg[grid1];
    const IntegerArray & bc1 = mg1.boundaryCondition();
    const IntegerArray & share1 = mg1.sharedBoundaryFlag();

    MappedGrid & mg2 = cg[grid2];
    const IntegerArray & bc2 = mg2.boundaryCondition();
    const IntegerArray & share2 = mg2.sharedBoundaryFlag();
    
    const int extra=0; // orderOfAccuracyInSpace/2;
    getBoundaryIndex(mg1.dimension(),side1,dir1,I1,I2,I3,extra);
    getBoundaryIndex(mg2.dimension(),side2,dir2,J1,J2,J3,extra);

    intArray & mask1 = mg1.mask();
    intArray & mask2 = mg2.mask();
    #ifdef USE_PPP
     intSerialArray mask1Local; getLocalArrayWithGhostBoundaries(mask1,mask1Local);
     intSerialArray mask2Local; getLocalArrayWithGhostBoundaries(mask2,mask2Local);
    #else
     intSerialArray & mask1Local = mg1.mask();
     intSerialArray & mask2Local = mg2.mask();
    #endif

    int includeGhost=0;
    bool ok1 = ParallelUtility::getLocalArrayBounds(mask1,mask1Local,I1,I2,I3,includeGhost);
    bool ok2 = ParallelUtility::getLocalArrayBounds(mask2,mask2Local,J1,J2,J3,includeGhost);

//     if( ok1!=ok2 )
//     {
//       printf("Maxwell::initializeInterfaces:ERROR local array bounds do not match, myid=%i\n"
//              " grid1=%i (side1,dir1)=(%i,%i) mask1Local=[%i,%i][%i,%i][%i,%i]\n"
//              " grid2=%i (side2,dir2)=(%i,%i) mask2Local=[%i,%i][%i,%i][%i,%i]\n",
//              myid,grid1,side1,dir1,mask1Local.getBase(0),mask1Local.getBound(0),
//           mask1Local.getBase(1),mask1Local.getBound(1),
//           mask1Local.getBase(2),mask1Local.getBound(2),
//           grid2,side2,dir2,mask2Local.getBase(0),mask2Local.getBound(0),
//           mask2Local.getBase(1),mask2Local.getBound(1),
//           mask2Local.getBase(2),mask2Local.getBound(2));
//       Overture::abort("error");
//     }
    

//     if( I1.getLength()!=J1.getLength() || I2.getLength()!=J2.getLength() || I3.getLength()!=J3.getLength() )
//     {
//       printf("Maxwell::initializeInterfaces:ERROR: interface %i : the interfaces\n"
//              " do not have matching numbers of grid points. myid=%i\n",inter,myid);
//       Overture::abort("error");
//     }

    int ndf1=0, ndf2=0;
    if( ok1 )
      ndf1=I1.length()*I2.length()*I3.length();  // number of points on interface face 1
    if( ok2 )
      ndf2=J1.length()*J2.length()*J3.length();  // number of points on interface face 2
    
    interface.ndf1=ndf1; // number of points on face1 (is at most this value)
    interface.ndf2=ndf2;

    const int ndf=max(ndf1,ndf2);

    // allocate work-space
    int nrwk=0, niwk=0;
    if( bcOrderOfAccuracy==2 )
    {
      if( !( mg1.numberOfDimensions()==3 ) )  // new 3D doesn't use work-space yet
      {
        nrwk= 4*4*2*ndf;        // a4, matrix at each point is (4,4), we need 2 copies
        niwk=  4*ndf;            // ipvt
      }
    }
    else if( bcOrderOfAccuracy==4 )
    {
                    
      nrwk= (8*8*2*ndf +       // a8, matrix at each point is (8,8), we need 2 copies
             4*4*2*ndf );      // a4 (for Hz)
      niwk=  8*ndf + 4*ndf;    // ipvt8, ipvt4
                    
    }
    else
    {
    }
    nrwk=max(1,nrwk);
    interface.rwk = new real [nrwk];
    niwk=max(1,niwk);
    interface.iwk = new int [niwk];

    if( false )
      printF("**** Maxwell::initializeInterfaces: interface %i allocate rwk[%i], iwk[%i] ****\n",inter,nrwk,niwk);
                  
  }
  

  // ----- check for tall cells at interface -- these may cause instabilities for order=4 ----
  // *wdh* March 3, 2021
  //              |
  //              +---------+---
  //            /\|         |
  //     t-dist   | n-dist  |        tall-cell-ratio = n-dist/t-dist 
  //            \/+<------->+---
  //              |         |
  //              |         |
  //              +---------+---
  //              |         |
  //              |         |
  //              +---------+---
  //              |
  //              ^
  //           interface
  // 
  bool checkForTallCells = orderOfAccuracyInSpace>=4;
  if( checkForTallCells )
  {
    
     // check for cells with normal-dist/tangential-dist > tallCellRatioBound
     const real & tallCellRatioBound = dbase.get<real>("tallCellRatioBound");
     GridStatistics::checkForTallCells( cg,interfaceInfo,tallCellRatioBound );

  }
  else if( false && checkForTallCells )
  {
    // OLD WAY 
    printF("--- CHECK FOR TALL CELLS AT THE INTERFACE--- \n");

    // check for cells with normal-dist/tangential-dist > tallCellRatioBound
    const real & tallCellRatioBound = dbase.get<real>("tallCellRatioBound");
    
    real maxTallCellRatio=0.;     // worst tall-cell ratio
    int numTallTotal     =0;      // counts total number of tall cells exceeding bound
    int numPointsTotal   =0;      // total interface cells checked
    
    for( int inter=0; inter < interfaceInfo.size(); inter++ )
    {
      InterfaceInfo & interface = interfaceInfo[inter]; 
      for( int iside=0; iside<=1; iside++ )// two sides of the interface
      {
        int grid, side, dir;
        if( iside==0 )
        {
          grid=interface.grid1, side=interface.side1, dir=interface.dir1;
        }
        else
        {
          grid=interface.grid2, side=interface.side2, dir=interface.dir2;
        }
        MappedGrid & mg = cg[grid];
    
        intArray & mask = mg.mask();
        OV_GET_SERIAL_ARRAY(int,mask,maskLocal);

        mg.update( MappedGrid::THEvertex );  // *** FIX ME ***

        OV_GET_SERIAL_ARRAY(real,mg.vertex(),xLocal);
      
        const int extra=0; 
        getBoundaryIndex(mg.gridIndexRange(),side,dir,I1,I2,I3,extra);

        int includeGhost=0;
        bool ok1 = ParallelUtility::getLocalArrayBounds(mask,maskLocal,I1,I2,I3,includeGhost);
        if( ok1  )
        {
          int isv[3], &is1 = isv[0], &is2=isv[1], &is3=isv[2]; // normal index shift
          isv[0]=0; isv[1]=0; isv[2]=0;
          isv[dir]= 1-2*side;

          int dirp1 = (dir+1) % numberOfDimensions;
          int itv[3], &it1 = itv[0], &it2=itv[1], &it3=itv[2]; // tangential index shift
          itv[0]=0; itv[1]=0; itv[2]=0;
          itv[dirp1]= 1;

        
          real tallCellRatio=0.;  // worst TCR on this grid 
          int numTall=0;          // counts tall cells on this grid exceeding bound
          int numPoints=0;        // counts total points checked on this grid 
          if( numberOfDimensions==2 )
          {
            // tallCellRatio = normal-dist / tangential-dist 
            FOR_3D(i1,i2,i3,I1,I2,I3) 
            {
              if( maskLocal(i1,i2,i3)>0 )
              {
                // distance "normal" to the boundary for this point
                real nDist = sqrt( SQR( xLocal(i1+is1,i2+is2,i3+is3,0) - xLocal(i1,i2,i3,0) ) +
                                   SQR( xLocal(i1+is1,i2+is2,i3+is3,1) - xLocal(i1,i2,i3,1) )  );
                // tangential distance 
                real tDist = sqrt( SQR( xLocal(i1+it1,i2+it2,i3+it3,0) - xLocal(i1,i2,i3,0) ) +
                                   SQR( xLocal(i1+it1,i2+it2,i3+it3,1) - xLocal(i1,i2,i3,1) )  );
                tDist = max( tDist, REAL_MIN*1000.); // avoid division by zero

                numPoints++;
                real cellAspectRatio = nDist/tDist;
                if( cellAspectRatio > tallCellRatioBound )
                  numTall++;
                tallCellRatio = max( tallCellRatio, cellAspectRatio );
              }
            }
          
          }
          else if( numberOfDimensions==3 )
          {
            int dirp2 = (dir+2) % numberOfDimensions;
            int irv[3], &ir1 = irv[0], &ir2=irv[1], &ir3=irv[2]; // tangential index shift
            irv[0]=0; irv[1]=0; irv[2]=0;
            irv[dirp2]= 1;

            FOR_3D(i1,i2,i3,I1,I2,I3) 
            {
              if( maskLocal(i1,i2,i3)>0 )
              {
                // distance "normal" to the boundary for this point
                real nDist = sqrt( SQR( xLocal(i1+is1,i2+is2,i3+is3,0) - xLocal(i1,i2,i3,0) ) +
                                   SQR( xLocal(i1+is1,i2+is2,i3+is3,1) - xLocal(i1,i2,i3,1) ) +
                                   SQR( xLocal(i1+is1,i2+is2,i3+is3,2) - xLocal(i1,i2,i3,2) )  );

                // tangential distances
                real tDist1 = sqrt( SQR( xLocal(i1+it1,i2+it2,i3+it3,0) - xLocal(i1,i2,i3,0) ) +
                                    SQR( xLocal(i1+it1,i2+it2,i3+it3,1) - xLocal(i1,i2,i3,1) ) +
                                    SQR( xLocal(i1+it1,i2+it2,i3+it3,2) - xLocal(i1,i2,i3,2) )  );

                real tDist2 = sqrt( SQR( xLocal(i1+ir1,i2+ir2,i3+ir3,0) - xLocal(i1,i2,i3,0) ) +
                                    SQR( xLocal(i1+ir1,i2+ir2,i3+ir3,1) - xLocal(i1,i2,i3,1) ) +
                                    SQR( xLocal(i1+ir1,i2+ir2,i3+ir3,2) - xLocal(i1,i2,i3,2) )  );
                real tDist = max( min(tDist1,tDist2), REAL_MIN*1000.);

                numPoints++;                
                real cellAspectRatio = nDist/tDist;
                if( cellAspectRatio > tallCellRatioBound )
                  numTall++;

                tallCellRatio = max( tallCellRatio, cellAspectRatio );
              }
            }

          }
          else
          {
            OV_ABORT("numberOfDimensions!?");
          }
          numTall       = ParallelUtility::getSum( numTall );
          numPoints     = ParallelUtility::getSum( numPoints );
          tallCellRatio = ParallelUtility::getMaxValue( tallCellRatio );

          numTallTotal   += numTall;
          numPointsTotal += numPoints;
          maxTallCellRatio = max( maxTallCellRatio, tallCellRatio );

          
          real fractionBad = numTall/max(1.,numPoints);
          printF(" grid=%3d (side,dir)=(%d,%d) worst tallCellRatio=%9.3e, num bad=%5d (%5.1f %% of cells exceed ratio %4.2f) (name=%s)\n",
                 grid,side,dir,tallCellRatio,numTall,fractionBad*100,tallCellRatioBound, (const char*)mg.getName());
        }
        
      } // end for iside 
    } // for end interface

    real fractionBad = numTallTotal/max(1.,numPointsTotal);
    printF(" Maximum tall cell ratio=%8.2e (tallCellRatioBound=%g), total bad cells=%6d (%5.1f %% of %d points).\n",
           maxTallCellRatio,tallCellRatioBound,numTallTotal, 100.*fractionBad,numPointsTotal);

    if( maxTallCellRatio > tallCellRatioBound )
    {
      printF("\n");
      printF("ERROR: There are some cells at the interface that are too `tall' in the normal direction.\n");
      printF("This may cause instablilities for the fourth-order scheme.\n");
      printF("You should add more grid lines in the normal direction to the offending grids.\n");
      printF("Otherwise, increase the tallCellRatioBound if you want to run anyway at your own risk!\n\n");
      OV_ABORT("checkForTallCells:ERROR");
    }
    else
    {
      printF("\n >>> No tall cells exceeding the ratio %4.2f were found. <<<< \n\n",tallCellRatioBound);
    }
    

  } // end checkForTallCells
  
  




  timing(timeForInterfaceBC)+=getCPU()-time0;
}

// ==================================================================================================
// ------ This macro next assigns the local arrays that hold the interface values in parallel ------
// ==================================================================================================
#Include "getLocalInterfaceArraysMacro.h"


// ============================================================================
//   Assign the parameters for the optimized interface routines.
// 
//  OPTION: serial, parallel1, parallel2 
//    serial : solve on both grids simultaneously in serial
//    parallel1 : solve on grid 1 
//    parallel2 : solve on grid 2
// ============================================================================
#beginMacro assignOptParameters(OPTION,exa,eya,eza,hxa,hya,hza)

  // Each grid may or may not have dispersion model: 
  const DispersionModelEnum dispersionModel1 = dmp1.numberOfPolarizationVectors>0 ? dispersionModel : noDispersion;
  const DispersionModelEnum dispersionModel2 = dmp2.numberOfPolarizationVectors>0 ? dispersionModel : noDispersion;

  const int nonlinearModel1 = dmp1.getNonlinearModel();
  const int nonlinearModel2 = dmp2.getNonlinearModel();

  int ipar[]={ //
    side1, dir1, grid1,         // keep side1,dir1 since we don't reverse the points.
    #If #OPTION eq "parallel2"
      m1a,m1b,m2a,m2b,m3a,m3b,  // use grid2 dimensions for grid1 when we solve on grid2
    #Else
      n1a,n1b,n2a,n2b,n3a,n3b,
    #End
    side2, dir2, grid2,         //  keep side2,dir2 since we don't reverse the points.
    #If #OPTION eq "parallel1"
      n1a,n1b,n2a,n2b,n3a,n3b,  // use grid1 dimensions for grid2 when we solve on grid1
    #Else
      m1a,m1b,m2a,m2b,m3a,m3b,
    #End
    gridType,            
    bcOrderOfAccuracy,
    orderOfExtrapolation,
    useForcing,          
    exa,                  
    eya,                  
    eza,                  
    hxa ,                 
    hya,                  
    hza,                  
    (int)solveForElectricField,          
    (int)solveForMagneticField,          
    useWhereMask,       
    debug,
    numberOfIterationsForInterfaceBC,
    materialInterfaceOption,
    (int)interface.initialized,
    myid,
    parallel,
    (int)forcingOption,
    interfaceEquationsOption,
    (int)assignInterfaceValues,
    (int)assignInterfaceGhostValues,
    dbase.get<int>("setDivergenceAtInterfaces"),
    dbase.get<int>("useImpedanceInterfaceProjection"),
    0,   // numberOfInterfaceIterationsUsed : returned value ipar[43]
    dispersionModel1,   // ipar[44]
    dispersionModel2,   // ipar[45]
    pxc,                // ipar[46]
    knownSolutionOption,
    useJacobiUpdate,
    nonlinearModel1,      // ipar[49]
    nonlinearModel2,      // ipar[50]
    numParallelGhost,     // ipar[51]
    internalGhostBC,       // ipar[52]
    useUnifiedInterfaceMacros // ipar[53]
  };
                  
const real & rtolForInterfaceIterations = dbase.get<real>("rtolForInterfaceIterations");
const real & atolForInterfaceIterations = dbase.get<real>("atolForInterfaceIterations");

real rpar[]={ //
  dx1[0],
  dx1[1],
  dx1[2],
  mg1.gridSpacing(0),
  mg1.gridSpacing(1),
  mg1.gridSpacing(2),
  dx2[0],
  dx2[1],
  dx2[2],
  mg2.gridSpacing(0),
  mg2.gridSpacing(1),
  mg2.gridSpacing(2),
  t,    
  (real &)tz,  // twilight zone pointer
  dt,    
  epsGrid(grid1),
  muGrid(grid1),   
  cGrid(grid1),    
  epsGrid(grid2),  
  muGrid(grid2),   
  cGrid(grid2),
  omegaForInterfaceIteration,
  0., // return value averageInterfaceConvergenceRate
  0.,  // return value maxFinalResidual
  rtolForInterfaceIterations,
  atolForInterfaceIterations
};
#endMacro
// =============== end assignOptParameters() ==============


// ===============================================================================================
//   Call the optimized interface routines.
//
//  OPTION: serial, parallel1, parallel2 
//    serial : solve on both grids simultaneously in serial
//    parallel1 : solve on grid 1 
//    parallel2 : solve on grid 2
// ===============================================================================================
#beginMacro assignOptInterface(OPTION,ex,ey,ez,hx,hy,hz)

assignOptParameters(OPTION,ex,ey,ez,hx,hy,hz);

// work space: 
real *rwk=interface.rwk;
int *iwk=interface.iwk;
assert( rwk!=NULL && iwk!=NULL );
      
const int ndf = max(interface.ndf1,interface.ndf2); 

// assign pointers into the work spaces
int pa2=0,pa4=0,pa8=0, pipvt2=0,pipvt4=0,pipvt8=0;
if( bcOrderOfAccuracy==2 )
{
  if( !( mg1.numberOfDimensions()==3 ) )  // new 3D doesn't use work-space yet
  {
    pa2=0; 
    pa4=pa2 + 2*2*2*ndf;
    pa8=0;  // not used
        
    pipvt2=0;
    pipvt4=pipvt2 + 2*ndf; 
    pipvt8=0;
  }
}
else if( bcOrderOfAccuracy==4 )
{
  pa2=0; // not used
  pa4=0;
  pa8=pa4+4*4*2*ndf;
        
  pipvt2=0;
  pipvt4=0;
  pipvt8=pipvt4+4*ndf;
        
}

if( mg1.numberOfDimensions()==2 && !useNewInterfaceRoutines )
{
  // OLD interface routines
  interfaceMaxwell( mg1.numberOfDimensions(), 
                    #If #OPTION eq "parallel2"
                      u1CopyLocal.getBase(0),u1CopyLocal.getBound(0),
                      u1CopyLocal.getBase(1),u1CopyLocal.getBound(1),
                      u1CopyLocal.getBase(2),u1CopyLocal.getBound(2),
                      // note: use grid2 mesh data here  ASSUMES GRIDS MATCH *FIX ME*
                      // mg2.gridIndexRange(0,0), *u1CopyLocal.getDataPointer(), *mask2p,*prsxy2, *pxy2, bc2Local(0,0),
                      // fixed version: but note bc2Local 
                      mg2.gridIndexRange(0,0), *u1CopyLocal.getDataPointer(), *pmask1b,*prsxy1b, *pxy1b, bc2Local(0,0),
                    #Else
                      u1Local.getBase(0),u1Local.getBound(0),
                      u1Local.getBase(1),u1Local.getBound(1),
                      u1Local.getBase(2),u1Local.getBound(2),
                      mg1.gridIndexRange(0,0), *u1p, *mask1p,*prsxy1, *pxy1, bc1Local(0,0), 
                    #End
                    #If #OPTION eq "parallel1"
                      u2CopyLocal.getBase(0),u2CopyLocal.getBound(0),
                      u2CopyLocal.getBase(1),u2CopyLocal.getBound(1),
                      u2CopyLocal.getBase(2),u2CopyLocal.getBound(2),
                      // note: use grid1 mesh data here ASSUMES GRIDS MATCH *FIX ME*
                      // mg1.gridIndexRange(0,0), *u2CopyLocal.getDataPointer(), *mask1p,*prsxy1, *pxy1, bc1Local(0,0), 
                      // fixed version: but note bc1Local 
                      mg1.gridIndexRange(0,0), *u2CopyLocal.getDataPointer(), *pmask2b,*prsxy2b,*pxy2b, bc1Local(0,0),
                    #Else
                      u2Local.getBase(0),u2Local.getBound(0),
                      u2Local.getBase(1),u2Local.getBound(1),
                      u2Local.getBase(2),u2Local.getBound(2),
                      mg2.gridIndexRange(0,0), *u2p, *mask2p,*prsxy2, *pxy2, bc2Local(0,0), 
                    #End
                    ipar[0], rpar[0], 
                    rwk[pa2],rwk[pa4],rwk[pa8], iwk[pipvt2],iwk[pipvt4],iwk[pipvt8],
                    ierr );
}
else
{
  // new interface routines -- 2D versions are done here too
  interface3dMaxwell( mg1.numberOfDimensions(), 
                      #If #OPTION eq "parallel2"
                        u1CopyLocal.getBase(0),u1CopyLocal.getBound(0),
                        u1CopyLocal.getBase(1),u1CopyLocal.getBound(1),
                        u1CopyLocal.getBase(2),u1CopyLocal.getBound(2),
                        // note: use grid2 mesh data here  ASSUMES GRIDS MATCH *FIX ME*
                        // mg2.gridIndexRange(0,0), *u1CopyLocal.getDataPointer(), *mask2p,*prsxy2, *pxy2, bc2Local(0,0),
                        // fixed version: but note bc2Local 
                        mg2.gridIndexRange(0,0), 
                        *u1CopyLocal.getDataPointer(),   
                        // *u1np,
                        *u1nCopyLocal.getDataPointer(),
                        *u1mp, *v1bp, 
                        *pmask1b,*prsxy1b,*pxy1b, 
                        // *p1ptr,*p1nptr,
                        *p1CopyLocal.getDataPointer(), *p1nCopyLocal.getDataPointer(), *p1mptr,   
                        *q1CopyLocal.getDataPointer(), *q1nCopyLocal.getDataPointer(), *q1mptr,   
                        bc2Local(0,0),
                      #Else
                        // --- serial case ---
                        u1Local.getBase(0),u1Local.getBound(0),
                        u1Local.getBase(1),u1Local.getBound(1),
                        u1Local.getBase(2),u1Local.getBound(2),
                        mg1.gridIndexRange(0,0), 
                        *u1p, *u1np, *u1mp, *v1p,
                        *mask1p,*prsxy1, *pxy1, 
                        *p1ptr,*p1nptr,*p1mptr,  
                        *q1ptr,*q1nptr,*q1mptr,   
                        bc1Local(0,0), 
                      #End
                      #If #OPTION eq "parallel1"
                        u2CopyLocal.getBase(0),u2CopyLocal.getBound(0),
                        u2CopyLocal.getBase(1),u2CopyLocal.getBound(1),
                        u2CopyLocal.getBase(2),u2CopyLocal.getBound(2),
                        // note: use grid1 mesh data here ASSUMES GRIDS MATCH *FIX ME*
                        // mg1.gridIndexRange(0,0), *u2CopyLocal.getDataPointer(), *mask1p,*prsxy1, *pxy1, bc1Local(0,0),
                        // fixed version: but note bc1Local 
                        mg1.gridIndexRange(0,0), 
                        *u2CopyLocal.getDataPointer(),
                        // *u2np,
                        *u2nCopyLocal.getDataPointer(),
                        *u2mp, *v2bp,
                        *pmask2b,*prsxy2b,*pxy2b, 
                        // *p2ptr,*p2nptr,
                        *p2CopyLocal.getDataPointer(), *p2nCopyLocal.getDataPointer(), *p2mptr, 
                        *q2CopyLocal.getDataPointer(), *q2nCopyLocal.getDataPointer(), *q2mptr, 
                        bc1Local(0,0),
                      #Else
                        // --- serial case ---
                        u2Local.getBase(0),u2Local.getBound(0),
                        u2Local.getBase(1),u2Local.getBound(1),
                        u2Local.getBase(2),u2Local.getBound(2),
                        mg2.gridIndexRange(0,0), 
                        *u2p, *u2np, *u2mp, *v2p,
                        *mask2p,*prsxy2, *pxy2, 
                        *p2ptr,*p2nptr,*p2mptr, 
                        *q2ptr,*q2nptr,*q2mptr, 
                        bc2Local(0,0), 
                      #End
                      ipar[0], rpar[0], 
                      rwk[pa2],rwk[pa4],rwk[pa8], iwk[pipvt2],iwk[pipvt4],iwk[pipvt8],
                      ierr );
   

}
// sosup solves for E and E.t so we need to divide some counts by 2: 
const real numSolvesPerStep = method==sosup ? 2. : 1.;
interface.totalInterfaceIterations+=ipar[43]/numSolvesPerStep; // counts total number of interface iterations
interface.averageInterfaceConvergenceRate+=rpar[22]/numSolvesPerStep;
interface.maxFinalResidual=max(rpar[23],interface.maxFinalResidual);
interface.averageFinalResidual+=rpar[23]/numSolvesPerStep;  // keeps sums of residuals 
#endMacro
// ======================= end  assignOptInterface() ====================================



void Maxwell::
assignInterfaceBoundaryConditions( int current, real t, real dt, 
                                   bool assignInterfaceValues,
                                   bool assignInterfaceGhostValues )
// =====================================================================================================
/// \brief Assign the boundary conditions at the interface between two different materials
///
/// \param current (input) : current solution index, values are assigned on the "next" grid function.
/// \param t (input) : new time
/// \param dt (input) : current time-step
/// \param assignInterfaceValues (input) : if true, assign values on the interface itself to satisfy the
//                 jump conditions (this step is usually done as a first stage before assigning ghost values).
/// \param assignInterfaceGhostValues (input) : if true, assign host values next to the interface (this step
//     is usually done as a second stage, after assigning interface values). 
// =====================================================================================================
{
  if( !gridHasMaterialInterfaces ) return;

  real time0=getCPU();

  if( debug & 4 )
    fprintf(pDebugFile," **** assignInterfaceBoundaryConditions: START t=%8.2e dt=%8.2e\n",t,dt);

  checkArrays("assignInterfaceBoundaryConditions:start");

  if( interfaceInfo.size()==0 )
  {
    initializeInterfaces();
    if( interfaceInfo.size()==0 )
      gridHasMaterialInterfaces=false;  // there are no material interfaces *wdh* 090425

    

    if( false )
    {
      // *** TESTING ***
      // Here is the new class for assigning interfaces 
      InterfaceMaxwell interfaceMaxwell(*this);
      interfaceMaxwell.computeStencilCoefficients( current, t, dt);
    }
    
  }
                    

//FILE *debugFile2 = debugFile;

  assert( cgp!=NULL );
  CompositeGrid & cg= *cgp;
  const int numberOfDimensions = cg.numberOfDimensions();
  const int numberOfComponentGrids = cg.numberOfComponentGrids();

  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Jv[3], &J1=Jv[0], &J2=Jv[1], &J3=Jv[2];

  const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;

  // *** could iterate to solve the interface conditions for 4th order

  bool interpolateThisDomain=false;  // set to true if we need to interpolate again after setting the interface values
  
  bool reduceOrderOfAccuracyForSosup=true;

  CheckParallel & checkParallel = dbase.get<CheckParallel>("checkParallel");  // use to check parallel computations  
  pCheckParallel = &checkParallel;  // set pointer 

  int bcOrderOfAccuracy=orderOfAccuracyInSpace;
  if( reduceOrderOfAccuracyForSosup && method==sosup && orderOfAccuracyInSpace==6 )
  {
    // NOTE: for now apply 4th order BC's for sosup order 6
    bcOrderOfAccuracy=4;
  }

  //  ----------------------------------------------------------------------------
  //  ------------------------- loop over interfaces -----------------------------
  //  ----------------------------------------------------------------------------
  for( int inter=0; inter < interfaceInfo.size(); inter++ )
  {
    InterfaceInfo & interface = interfaceInfo[inter]; 

    const int grid1=interface.grid1, side1=interface.side1, dir1=interface.dir1;
    const int grid2=interface.grid2, side2=interface.side2, dir2=interface.dir2;
    
    MappedGrid & mg1 = cg[grid1];
    const IntegerArray & bc1 = mg1.boundaryCondition();
    const IntegerArray & share1 = mg1.sharedBoundaryFlag();

    MappedGrid & mg2 = cg[grid2];
    const IntegerArray & bc2 = mg2.boundaryCondition();
    const IntegerArray & share2 = mg2.sharedBoundaryFlag();

    realArray & u1 = cgfields[next][grid1];
    realArray & u2 = cgfields[next][grid2];

    realArray & u1n = cgfields[current][grid1];
    realArray & u2n = cgfields[current][grid2];

    realArray & u1m = cgfields[prev][grid1];
    realArray & u2m = cgfields[prev][grid2];


    const int numParallelGhost = u1.getGhostBoundaryWidth(0);

    IntegerArray bc1Local(2,3), bc2Local(2,3);

    const int internalGhostBC=-9876; // set bc at internal parallel ghost to this value 
     
    ParallelGridUtility::getLocalBoundaryConditions( cgfields[next][grid1],bc1Local,internalGhostBC );
    ParallelGridUtility::getLocalBoundaryConditions( cgfields[next][grid2],bc2Local,internalGhostBC  );
    // ::display(bc1Local,"bc1Local");
    // ::display(bc2Local,"bc2Local");


    const int extra=0; // orderOfAccuracyInSpace/2;
    getBoundaryIndex(mg1.gridIndexRange(),side1,dir1,I1,I2,I3,extra);
    getBoundaryIndex(mg2.gridIndexRange(),side2,dir2,J1,J2,J3,extra);
  
    // check that the number of points in the tangential directions match -- eventually we will fix this
    for( int dir=1; dir<mg1.numberOfDimensions(); dir++ )
    {
      int dir1p = (dir1+dir) % mg1.numberOfDimensions();
      int dir2p = (dir2+dir) % mg2.numberOfDimensions();
      if( Iv[dir1p].getLength()!=Jv[dir2p].getLength() )
      {
        printF("Cgmx::applyInterfaceBC:ERROR: The number of grid points on the two interfaces do not match\n"
               " (grid1,side1,dir1,bc1)=(%i,%i,%i,%i) Iv=[%i,%i][%i,%i][%i,%i]\n"
               " (grid2,side2,dir2,bc2)=(%i,%i,%i,%i) Jv=[%i,%i][%i,%i][%i,%i]\n",
               grid1,side1,dir1,mg1.boundaryCondition(side1,dir1),
               I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound(),  
               grid2,side2,dir2,mg2.boundaryCondition(side2,dir2),
               J1.getBase(),J1.getBound(),J2.getBase(),J2.getBound(),J3.getBase(),J3.getBound());
        printF("grid names are %s and %s\n",(const char*)mg1.getName(),(const char*)mg2.getName());
        OV_ABORT("error"); // this prints the file and line number and calls Overture::abort. 
      }

      // We need to interpolate the grid function if an interface has interpolation points on it:
      if( bc1(0,dir1p)==0 || bc1(1,dir1p)==0 )
      {
        interpolateThisDomain=true;
      }
      if( bc2(0,dir2p)==0 || bc2(1,dir2p)==0 )
      {
        interpolateThisDomain=true;
      }
    } // end for dir 
  

    intArray & mask1 = mg1.mask();
    intArray & mask2 = mg2.mask();
    OV_GET_SERIAL_ARRAY(int,mask1,mask1Local);
    OV_GET_SERIAL_ARRAY(int,mask2,mask2Local);

    // #ifdef USE_PPP
    //  intSerialArray mask1Local; getLocalArrayWithGhostBoundaries(mask1,mask1Local);
    //  intSerialArray mask2Local; getLocalArrayWithGhostBoundaries(mask2,mask2Local);
    // #else
    //  intSerialArray & mask1Local = mask1;
    //  intSerialArray & mask2Local = mask2;
    // #endif

    bool isRectangular1= mg1.isRectangular();
    real dx1[3]={0.,0.,0.}; //
    if( isRectangular1 )
      mg1.getDeltaX(dx1);

    bool isRectangular2= mg2.isRectangular();
    real dx2[3]={0.,0.,0.}; //
    if( isRectangular2 )
      mg2.getDeltaX(dx2);


    if( orderOfAccuracyInSpace >=4 && useNewInterfaceRoutines )
    { 

      if( numberOfDimensions==3 && interfaceEquationsOption==0 && ( !isRectangular1 || !isRectangular2) )
      {
        printF("--MX--assignInterface:WARNING: interfaceEquationsOption=0 is NOT recommended"
               " for order=4 in 3D (curvilinear)!! Use new routines: interfaceEquationsOption=1.\n");
        if( numberOfIterationsForInterfaceBC !=1 ) 
        {
          printF("--MX--assignInterface: ERROR numberOfIterationsForInterfaceBC=%i should be 1"
                 " for interfaceEquationsOption=0 (3D, order=4)\n",numberOfIterationsForInterfaceBC);
          printf("This is a fatal error to make sure that you really wanted to use interfaceEquationsOption=0 \n");
          OV_ABORT("error");
        }
        
      }

      // WARNING: Do not use the fourth-order rectangular grid interface conditions in interface3d.bf 
      //   since these require iterations which have not been implemented

      bool useFourthOrderRectangular = true;  // *wdh* Jan 18, 2021 -- this version now (being) implemented 
      
      if( !useFourthOrderRectangular )
      {
        if(  (isRectangular1 && isRectangular2) && t<= 1.5*dt  )
        {
          // printF("--MX-- assignInterfaceBC: INFO - using curvilinear version since iterations are required.\n");
          printF("--MX-- assignInterfaceBC: INFO - grids are rectangular but using curvilinear interface version ...\n"
                 "      ... for 4th-order since latest version not implemented for rectangular grids.\n");
        }
      
        isRectangular1=false;
        isRectangular2=false;
      }
      

    }

    // Extra check added *wdh* May 11, 2020
    if( numberOfDimensions==3 && (isRectangular1 || isRectangular2) )
    {
      if( t<= 1.5*dt  )
        printf("CGMX:assignInterfaceBCs: WARNING: 3D rectangular grids not implemented. Use curvilinear version instead\n");

      isRectangular1=false;
      isRectangular2=false;
      
    }
    

    if( !isRectangular1 )
    {
      mg1.update(MappedGrid::THEinverseVertexDerivative);
      mg2.update(MappedGrid::THEinverseVertexDerivative);
    }
                  
    assert(isRectangular1==isRectangular2);

    const bool centerNeeded = forcingOption==twilightZoneForcing;  // we need the grid points 

    // For dispersion materials, look up arrays of polarization vectors
    // The number of Pv vectors may be different on either side
    // --- Lookup info for the dispersion model ---
    const DispersiveMaterialParameters & dmp1 = getDispersiveMaterialParameters(grid1);
    const int numberOfPolarizationVectors1 = dmp1.numberOfPolarizationVectors; 

    const DispersiveMaterialParameters & dmp2 = getDispersiveMaterialParameters(grid2);
    const int numberOfPolarizationVectors2 = dmp2.numberOfPolarizationVectors; 

    const bool isDispersive = dmp1.isDispersiveMaterial() || dmp2.isDispersiveMaterial();
    if(  isDispersive && dispersionModel==noDispersion )
    {
      // Sanity check 
      printF("CgMx::assignInterfaceBC:ERROR: Some materials are dispersive but dispersionModel==noDispersion\n"
             "  Something is wrong here\n");
      OV_ABORT("ERROR");
    }
    


    // --- Get pointers to arrays for the dispersive model ----
    real tempValue;
    real *p1ptr = &tempValue;  // set default when not used
    real *p2ptr = &tempValue;  // set default when not used

    real *p1nptr = &tempValue;  // set default when not used
    real *p2nptr = &tempValue;  // set default when not used

    real *p1mptr = &tempValue;  // set default when not used
    real *p2mptr = &tempValue;  // set default when not used

    // real *p1ptr = u1Local.getDataPointer();  // set default when not used
    // real *p2ptr = u2Local.getDataPointer();  // set default when not used

    // real *p1nptr = u1Local.getDataPointer();  // set default when not used
    // real *p2nptr = u2Local.getDataPointer();  // set default when not used

    // real *p1mptr = u1Local.getDataPointer();  // set default when not used
    // real *p2mptr = u2Local.getDataPointer();  // set default when not used

    if( numberOfPolarizationVectors1>0 )
    {
      realMappedGridFunction & p1 = getDispersionModelMappedGridFunction( grid1,next );
      OV_GET_SERIAL_ARRAY(real,p1,p1Local);
      p1ptr=p1Local.getDataPointer();

      realMappedGridFunction & p1n = getDispersionModelMappedGridFunction( grid1,current );
      OV_GET_SERIAL_ARRAY(real,p1n,p1nLocal);
      p1nptr=p1nLocal.getDataPointer();

      realMappedGridFunction & p1m = getDispersionModelMappedGridFunction( grid1,prev );
      OV_GET_SERIAL_ARRAY(real,p1m,p1mLocal);
      p1mptr=p1mLocal.getDataPointer();
    }
    if( numberOfPolarizationVectors2>0 )
    {
      realMappedGridFunction & p2 = getDispersionModelMappedGridFunction( grid2,next );
      OV_GET_SERIAL_ARRAY(real,p2,p2Local);
      p2ptr=p2Local.getDataPointer();

      realMappedGridFunction & p2n = getDispersionModelMappedGridFunction( grid2,current );
      OV_GET_SERIAL_ARRAY(real,p2n,p2nLocal);
      p2nptr=p2nLocal.getDataPointer();

      realMappedGridFunction & p2m = getDispersionModelMappedGridFunction( grid2,prev );
      OV_GET_SERIAL_ARRAY(real,p2m,p2mLocal);
      p2mptr=p2mLocal.getDataPointer();
    }
    realArray & p1  = numberOfPolarizationVectors1>0 ? getDispersionModelMappedGridFunction( grid1,next ) : u1;
    realArray & p1n = numberOfPolarizationVectors1>0 ? getDispersionModelMappedGridFunction( grid1,current ) : u1n;
    
    realArray & p2  = numberOfPolarizationVectors2>0 ? getDispersionModelMappedGridFunction( grid2,next ) : u2;
    realArray & p2n = numberOfPolarizationVectors2>0 ? getDispersionModelMappedGridFunction( grid2,current ) : u2n;
    

    // --- Get pointers to arrays for the nonlinear model ----
    real *q1ptr = &tempValue;   // set default when not used
    real *q2ptr = &tempValue;   // set default when not used

    real *q1nptr = &tempValue;  // set default when not used
    real *q2nptr = &tempValue;  // set default when not used

    real *q1mptr = &tempValue;  // set default when not used
    real *q2mptr = &tempValue;  // set default when not used

    if( dmp1.isNonlinearMaterial() )
    {
      realMappedGridFunction & q1 = getNonlinearModelMappedGridFunction( grid1,next );
      OV_GET_SERIAL_ARRAY(real,q1,q1Local);
      q1ptr=q1Local.getDataPointer();

      realMappedGridFunction & q1n = getNonlinearModelMappedGridFunction( grid1,current );
      OV_GET_SERIAL_ARRAY(real,q1n,q1nLocal);
      q1nptr=q1nLocal.getDataPointer();

      realMappedGridFunction & q1m = getNonlinearModelMappedGridFunction( grid1,prev );
      OV_GET_SERIAL_ARRAY(real,q1m,q1mLocal);
      q1mptr=q1mLocal.getDataPointer();
    }
    if( dmp2.isNonlinearMaterial() )
    {
      realMappedGridFunction & q2 = getNonlinearModelMappedGridFunction( grid2,next );
      OV_GET_SERIAL_ARRAY(real,q2,q2Local);
      q2ptr=q2Local.getDataPointer();

      realMappedGridFunction & q2n = getNonlinearModelMappedGridFunction( grid2,current );
      OV_GET_SERIAL_ARRAY(real,q2n,q2nLocal);
      q2nptr=q2nLocal.getDataPointer();

      realMappedGridFunction & q2m = getNonlinearModelMappedGridFunction( grid2,prev );
      OV_GET_SERIAL_ARRAY(real,q2m,q2mLocal);
      q2mptr=q2mLocal.getDataPointer();
    }

    realArray & q1  = dmp1.isNonlinearMaterial() ? getNonlinearModelMappedGridFunction( grid1,next )    : u1;
    realArray & q1n = dmp1.isNonlinearMaterial() ? getNonlinearModelMappedGridFunction( grid1,current ) : u1n;
    
    realArray & q2  = dmp2.isNonlinearMaterial() ? getNonlinearModelMappedGridFunction( grid2,next )    : u2;
    realArray & q2n = dmp2.isNonlinearMaterial() ? getNonlinearModelMappedGridFunction( grid2,current ) : u2n;

    // ----------- PARALLEL COPY ---------
    //  Determine the local arrays that hold in the interface values.
    //  In parallel we build new local arrays with a copy of the values from the
    //  other side. 
    bool ok1=true, ok2=true;
    getLocalInterfaceArraysMacro();

    if( debug & 4 ) 
    {
      ::display(u1Local,sPrintF("u1Local before assignOptInterface grid1=%i, t=%8.2e",grid1,t),pDebugFile,"%9.2e ");
      ::display(u2Local,sPrintF("u2Local before assignOptInterface grid2=%i, t=%8.2e",grid2,t),pDebugFile,"%9.2e ");
    }
    if( debug & 4 )
    {
      checkParallel.checkDiff(u1Local,sPrintF("u1Local before assignOptInterface grid1=%i, t=%8.2e",grid1,t),pDebugFile);
      checkParallel.checkDiff(u2Local,sPrintF("u2Local before assignOptInterface grid2=%i, t=%8.2e",grid2,t),pDebugFile);
    }


    int n1a=I1.getBase(),n1b=I1.getBound(),
        n2a=I2.getBase(),n2b=I2.getBound(),
        n3a=I3.getBase(),n3b=I3.getBound();

    int m1a=J1.getBase(),m1b=J1.getBound(),
        m2a=J2.getBase(),m2b=J2.getBound(),
        m3a=J3.getBase(),m3b=J3.getBound();


    real temp;
    real *ptemp=&temp;

    int gridType = isRectangular1 ? 0 : 1;
    int orderOfExtrapolation=orderOfAccuracyInSpace+1;  // not used
    int useForcing = forcingOption==twilightZoneForcing;
    int useWhereMask=true;
    int parallel=0;
    #ifdef USE_PPP
      parallel=1;
    #endif

    real *u1p=u1Local.getDataPointer();
    real *u1np=u1nLocal.getDataPointer();
    real *u1mp=u1mLocal.getDataPointer();
    real *prsxy1=isRectangular1 ? ptemp : mg1.inverseVertexDerivative().getLocalArray().getDataPointer();
    real *pxy1= centerNeeded ? mg1.center().getLocalArray().getDataPointer() : ptemp; 
    int *mask1p=mask1Local.getDataPointer();

    real *u2p=u2Local.getDataPointer();
    real *u2np=u2nLocal.getDataPointer();
    real *u2mp=u2mLocal.getDataPointer();
    real *prsxy2=isRectangular2 ? ptemp : mg2.inverseVertexDerivative().getLocalArray().getDataPointer();
    real *pxy2= centerNeeded ? mg2.center().getLocalArray().getDataPointer() : ptemp; 
    int *mask2p=mask2Local.getDataPointer();

    #ifdef USE_PPP
     // pointers to copies of the interface geometry and mask data 
     int *pmask1b = interface.pmask1->getDataPointer();
     int *pmask2b = interface.pmask2->getDataPointer();
    
     real *prsxy1b = isRectangular1 ? ptemp : interface.prsxy1->getDataPointer();
     real *prsxy2b = isRectangular2 ? ptemp : interface.prsxy2->getDataPointer();
     
     real *pxy1b = !centerNeeded ? ptemp : interface.pxy1->getDataPointer();
     real *pxy2b = !centerNeeded ? ptemp : interface.pxy2->getDataPointer();
    #endif

    // Use unified interface macros from QX -- March 2021
    const int & useUnifiedInterfaceMacros = dbase.get<int>("useUnifiedInterfaceMacros");

     // We need some temp space for jacobi updates
    const int & useJacobiInterfaceUpdate = dbase.get<int>("useJacobiInterfaceUpdate");

    bool useJacobiUpdate=false;
    if( orderOfAccuracyInSpace==4 )
    {
      useJacobiUpdate = useJacobiInterfaceUpdate; 
    }
    RealArray v1,v2, v1b, v2b;
    real *v1p =u1p, *v2p =u2p; // default when not used
    real *v1bp=u1p, *v2bp=u2p; // default when not used
    if( useJacobiUpdate )
    {
      // --- allocate temp-space for Jacobi update -----

      // Do this for now -- we can optimize ----

      v1.redim(u1Local);         v2.redim(u2Local);
      v1p=v1.getDataPointer();   v2p=v2.getDataPointer();
      // Fix for parallel -- use u1Copy, u2Copy
      #ifdef USE_PPP
        v1b.redim(u1CopyLocal);         v2b.redim(u2CopyLocal);
        v1bp=v1b.getDataPointer();      v2bp=v2b.getDataPointer();
      #endif
    }



    int ierr=0;

    if( bcOrderOfAccuracy<6 )
    { 
      // ------------------------------------
      // ----- order of accuracy <= 4 -------
      // ------------------------------------

      // macro: 

      #ifdef USE_PPP
        assert( dir1==dir2 );
        // In parallel we solve the equations in serial on both sides of the interface
        if( ok1 )
        {
          orderOfExtrapolation=extrapolationWidth1+1;
          assignOptInterface(parallel1,ex,ey,ez,hx,hy,hz);
          if( method==sosup )
          { // for sosup we assign E.t
            assignOptInterface(parallel1,ext,eyt,ezt,hxt,hyt,hzt);
          }
          if( debug & 16 )
            ::display(u1Local,sPrintF("u1Local after assignOptInterface t=%8.2e",t),pDebugFile,"%5.2f ");
        }
        if( ok2 )
        {
          orderOfExtrapolation=extrapolationWidth2+1;
          assignOptInterface(parallel2,ex,ey,ez,hx,hy,hz);
          if( method==sosup )
          { // for sosup we assign E.t
            assignOptInterface(parallel2,ext,eyt,ezt,hxt,hyt,hzt);
          }
          if( debug & 16 )
            ::display(u1Local,sPrintF("u2Local after assignOptInterface t=%8.2e",t),pDebugFile,"%5.2f ");
        }
      #else
        // serial
        assignOptInterface(serial,ex,ey,ez,hx,hy,hz);
        if( method==sosup )
        { // for sosup we assign E.t
          // printF("Assign interface values for sosup: E.t at t=%9.3e\n",t);
          assignOptInterface(serial,ext,eyt,ezt,hxt,hyt,hzt);
        }
        
      #endif

      
    }
    else
    {
      // *** test the new interface routines for order of accuracy >= 6 

      printF("Call new interface routines for order=%i at t=%9.3e\n",orderOfAccuracyInSpace,t);

      assert( mg1.numberOfDimensions()==2 );

      // macro: 
      assignOptParameters(serial,ex,ey,ez,hx,hy,hz);

      newInterfaceMaxwell( mg1.numberOfDimensions(), 
                           u1Local.getBase(0),u1Local.getBound(0),
                           u1Local.getBase(1),u1Local.getBound(1),
                           u1Local.getBase(2),u1Local.getBound(2),
                           mg1.gridIndexRange(0,0), *u1p, *mask1p,*prsxy1, *pxy1, bc1(0,0), 
                           u2Local.getBase(0),u2Local.getBound(0),
                           u2Local.getBase(1),u2Local.getBound(1),
                           u2Local.getBase(2),u2Local.getBound(2),
                           mg2.gridIndexRange(0,0), *u2p, *mask2p,*prsxy2, *pxy2, bc2(0,0), 
                           ipar[0], rpar[0], ierr );

    }
                  
    // wait to set initialized=true until ghost values have been assigned the first time : 
    if( assignInterfaceGhostValues )
      interface.initialized=true;
    
    // In some cases we have an optimized periodic update implemented
    bool updatePeriodic = mg1.numberOfDimensions()==3; 
    #ifdef USE_PPP
      // in parallel we cannot use the optimized periodic update in the interface routines.
      updatePeriodic=true;
    #endif
    if(  updatePeriodic )
    {
      // printF("After assign interfaces: periodic update...\n");
      
      cgfields[next][grid1].periodicUpdate(); 
      cgfields[next][grid2].periodicUpdate();
      u1.updateGhostBoundaries(); // *wdh* 081127 
      u2.updateGhostBoundaries();
    }
    
    if( debug & 4 )
      fprintf(pDebugFile," **** After assigning interfaces t=%8.2e, tz=%i\n",t,(tz==NULL ? 0 : 1));
    
    if( debug & 4 ) 
    {
      if( tz!=NULL && pDebugFile!=NULL )
      {
        realArray & x1 = mg1.center();
        realArray & x2 = mg2.center();
        #ifdef USE_PPP
          realSerialArray x1Local; getLocalArrayWithGhostBoundaries(x1,x1Local);
          realSerialArray x2Local; getLocalArrayWithGhostBoundaries(x2,x2Local);
        #else
          realSerialArray & x1Local = x1;
          realSerialArray & x2Local = x2;
        #endif
                    
        OGFunction & e = *tz;
        Range E(ex,ex+numberOfDimensions-1);
        int isRectangular=0;
        getGhostIndex(mg1.gridIndexRange(),side1,dir1,I1,I2,I3);

        int includeGhost=0; 
        bool ok = ParallelUtility::getLocalArrayBounds(u1,u1Local,I1,I2,I3,includeGhost);
        if( ok )
        {
          realSerialArray err(I1,I2,I3,E);
          realSerialArray ue(I1,I2,I3,E);
                  
          // err=u1(I1,I2,I3,ex)-e(mg1,I1,I2,I3,ex,t);


          e.gd( ue  ,x1Local,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,E,t);
          err=u1Local(I1,I2,I3,E)-ue(I1,I2,I3,E);
          ::display(u1Local(I1,I2,I3,E),sPrintF("u1 (ghost) (grid1=%i) after interface, t=%e",grid1,t),pDebugFile,"%8.1e ");
          ::display(err,sPrintF("err in u1 (ghost) (grid1=%i) after interface, t=%e",grid1,t),pDebugFile,"%8.1e ");

          // getGhostIndex(mg1.gridIndexRange(),side1,dir1,I1,I2,I3,-1);
          // err=u1(I1,I2,I3,ex)-e(mg1,I1,I2,I3,ex,t);
          // ::display(err,sPrintF("err in u1 (ex,line 1) after interface, t=%e",t),pDebugFile,"%8.1e ");
        }
        

        getGhostIndex(mg2.gridIndexRange(),side2,dir2,I1,I2,I3);
        ok = ParallelUtility::getLocalArrayBounds(u2,u2Local,I1,I2,I3,includeGhost);
        if( ok )
        {
          realSerialArray err(I1,I2,I3,E);
          realSerialArray ue(I1,I2,I3,E);
         
          e.gd( ue  ,x2Local,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,E,t);
          err=u2Local(I1,I2,I3,E)-ue(I1,I2,I3,E);
          ::display(u2Local(I1,I2,I3,E),sPrintF("u2 (ghost) (grid2=%i) after interface, t=%e",grid2,t),pDebugFile,"%8.1e ");
          ::display(err,sPrintF("err in u2 (ghost) (grid2=%i) after interface, t=%e",grid2,t),pDebugFile,"%8.1e ");

          // err=u2(I1,I2,I3,ex)-e(mg2,I1,I2,I3,ex,t);
          // ::display(err,sPrintF("err in u2 (ex,ghost) after interface, t=%e",t),pDebugFile,"%8.1e ");
          // getGhostIndex(mg2.gridIndexRange(),side2,dir2,I1,I2,I3,-1);
          // err=u2(I1,I2,I3,ex)-e(mg2,I1,I2,I3,ex,t);
          // ::display(err,sPrintF("err in u2 (ex,line 1) after interface, t=%e",t),pDebugFile,"%8.1e ");
        }
        
      }
    }
    
    if( debug & 4 ) 
    {
      ::display(u1Local,sPrintF("u1Local after assignOptInterface grid1=%i, t=%8.2e",grid1,t),pDebugFile,"%9.2e ");
      ::display(u2Local,sPrintF("u2Local after assignOptInterface grid2=%i, t=%8.2e",grid2,t),pDebugFile,"%9.2e ");
    }
    if( debug & 4 )
    {
      checkParallel.checkDiff(u1Local,sPrintF("u1Local after assignOptInterface grid1=%i, t=%8.2e",grid1,t),pDebugFile);
      checkParallel.checkDiff(u2Local,sPrintF("u2Local after assignOptInterface grid2=%i, t=%8.2e",grid2,t),pDebugFile);
    }
    
  
  } // end for inter
  

  // This code is partially duplicated from assignBoundaryConditions.bC 
  const int & useSosupDissipation = parameters.dbase.get<int>("useSosupDissipation");
  if( method==sosup || 
      (method==nfdtd && useSosupDissipation) ) // Added Feb 8, 2018 *wdh* 
  {
    // Extrapolate an extra ghost line for the wider upwind stencil in SOSUP
    BoundaryConditionParameters extrapParams;

    const int ghostEnd = (orderOfAccuracyInSpace/2)+1;  // last ghost line for sosup stencil

    // NOTE: for now we impose at most 2 ghost lines with the 4th=order BC's 
    // first ghost line for sosup stencil: 
    //     ghostStart=2 for order=2
    //     ghostStart=3 for order>2   *fix me* when 6'th order BC's are implemented

    // NORMAL: fourth-order: ghostStart=3 and ghostEnd=3 
    assert( !reduceOrderOfAccuracyForSosup || bcOrderOfAccuracy<=4 );
    int ghostStart= min(3,ghostEnd);              
    if( !reduceOrderOfAccuracyForSosup )
      ghostStart=ghostEnd-1;

    extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;  // what should this be ?

    extrapParams.extraInTangentialDirections=ghostEnd;

    Range Ca = cgfields[0][0].getLength(3); // all components

    for( int grid=0; grid<numberOfComponentGrids; grid++ )
    {
      MappedGrid & mg = cg[grid];
      realMappedGridFunction & u = cgfields[next][grid];

      MappedGridOperators & mgop = mgp!=NULL ? *op : (*cgop)[grid];
      u.setOperators(mgop);

      bool hasInterface=false;
      for( int ghost=ghostStart; ghost<=ghostEnd; ghost++ )
      {
        extrapParams.ghostLineToAssign=ghost;
        if( (t <= 2.*dt && debug>0 ) || debug & 4 )
        {
          printF("assignInterface: assignInterfaceValues=%i assignInterfaceGhostValues=%i\n",
                 (int)assignInterfaceValues, (int)assignInterfaceGhostValues);
        }
        
        for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
          for( int side=0; side<=1; side++ )
          {
            const int bc = mg.boundaryCondition(side,axis);
            if( bc==interfaceBoundaryCondition )
            {
              if( (t <= 2.*dt && debug>0) || debug & 4 )
              {
                printF("assignInterface: sosup: grid=%i extrap ghost-line %i to order %i\n",
                       grid,extrapParams.ghostLineToAssign,extrapParams.orderOfExtrapolation);
              }
              hasInterface=true;
              u.applyBoundaryCondition(Ca,BCTypes::extrapolate,BCTypes::boundary1+side+2*(axis),0.,t,extrapParams);
            }
          }
      }

      if( hasInterface && ( true || 
               (bcOrderOfAccuracy==4 && orderOfAccuracyInSpace>4 ) || numberOfDimensions==3 ) )
        cgfields[next][grid].periodicUpdate(); // This is needed for some reason
    }
    
  }


  // **** NOTE: I think this is needed because we do not check the mask array when assigning
  //            interface points and thus over-write interpolation points.
  // -- this has been fixed for interface3d
  if( interpolateThisDomain && cg.numberOfDimensions()==2 && !useNewInterfaceRoutines )
  {
    if( true || debug & 8 )
      printF("\n ++++++++++  Cgmx:assignInterfaceBoundaryConditions: Interpolate after assigning the "
             "interface values next=%i t=%9.3e +++++++++++++++\n",next,t);
    cgfields[next].interpolate();
  }

  
  if( debug & 4 )
    printF("\n ++++++++++  Cgmx:assignInterfaceBoundaryConditions: DONE t=%8.2e +++++++++\n",t);
  
  timing(timeForInterfaceBC)+=getCPU()-time0;
  return;
}

