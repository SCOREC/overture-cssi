#include "Maxwell.h"
#include "DispersiveMaterialParameters.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "interpPoints.h"
#include "ShowFileReader.h"
#include "ParallelUtility.h"
#include "gridFunctionNorms.h"
#include "ReferenceSolution.h"

#define exmax EXTERN_C_NAME(exmax)
extern "C"
{

 void exmax(double&Ez,double&Bx,double&By,const int &nsources,const double&xs,const double&ys,
            const double&tau,const double&var,const double&amp, const double&a,
            const double&x,const double&y,const double&time);

}

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

// Define macros for forcing functions:
#Include "forcing.h"
#Include "annulusEigenFunction.h"
#Include "boxEigenFunction.h"

// Macros for the plane material interface:
#Include "planeMaterialInterface.h"
 definePlaneMaterialInterfaceMacros(C)

// Macros for dispersive waves
#Include "dispersionMacros.h"

// -------------------------------------------------------------------------------------------------------------
//! local function to compute errors for the staggered grid DSI schemes
// -------------------------------------------------------------------------------------------------------------
void
computeDSIErrors( Maxwell &mx, MappedGrid &mg, realArray &uh, realArray &uhp, realArray &ue, realArray &uep,
		  realArray &errh, realArray &erre, 
		  RealArray &solutionNorm, RealArray &maximumError )
{
  bool skipGhosts = true;
  ArraySimpleFixed<int,6,1,1,1> ml;
  ml = -1;

  real l2h_err,l2e_err;
  real nE, nH;
  l2h_err = l2e_err = 0;
  nE=nH=0;

  real maxDivE = 0, maxDivH = 0;
  if ( mg.getGridType()==MappedGrid::unstructuredGrid )
  {
      
    UnstructuredMapping & umap = (UnstructuredMapping &) mg.mapping().getMapping();
    int rDim = umap.getRangeDimension();

//       const realArray &verts = umap.getNodes();
//       const intArray  &edges = umap.getEntities(UnstructuredMapping::Edge);

    UnstructuredMappingIterator iter,iter_end;
    iter_end = umap.end( UnstructuredMapping::Edge, skipGhosts ); // true means skip ghosts
    for ( iter = umap.begin( UnstructuredMapping::Edge, skipGhosts );
	  iter!=iter_end;
	  iter++ )
    {
      assert(!umap.isGhost(UnstructuredMapping::Edge, *iter));
      int e = *iter;
      //	  if ( !umap.hasTag(UnstructuredMapping::Edge, e, "__bcnum ") )
    {
      for ( int c=0; c<ue.getLength(3); c++ )
      {
	solutionNorm(c) = max(solutionNorm(c), fabs(ue(e,0,0,c)));
	if ( maximumError(c)<fabs(erre(e,0,0,c)) )
	  ml[c] = e;
	maximumError(c) = max(maximumError(c), fabs(erre(e,0,0,c)));
	l2e_err += erre(e,0,0,c)*erre(e,0,0,c);
      }
      nE++;
    }
    //	  cout<<.5*(verts(edges(*iter,0),0)+verts(edges(*iter,1),0))<<"  "<<.5*(verts(edges(*iter,0),1)+verts(edges(*iter,1),1))<<"  "<<erre(*iter,0,0,0)<<endl;
    }
      
    l2e_err /= real(nE);

    int off = ue.getLength(3);
    iter_end = umap.end( UnstructuredMapping::Face, skipGhosts ); // true means skip ghosts
    for ( iter = umap.begin( UnstructuredMapping::Face, skipGhosts );
	  iter!=iter_end;
	  iter++ )
    {
      int f = *iter;
      assert(!umap.isGhost(UnstructuredMapping::Face, *iter));
      //	  if ( !umap.hasTag(UnstructuredMapping::Face, f, "__bcnum ") )
    {
      for ( int c=0; c<uh.getLength(3); c++ )
      {
	solutionNorm(off+c) = max(solutionNorm(off+c), fabs(uh(f,0,0,c)));
	if ( maximumError(off+c)<fabs(errh(f,0,0,c)) )
	  ml[off+c] = f;
	maximumError(off+c) = max(maximumError(off+c), fabs(errh(f,0,0,c)));
	l2h_err += errh(f,0,0,c)*errh(f,0,0,c);
      }
      nH++;
    }
    }
    l2h_err /= real(nH);
    maximumError(0) = sqrt(l2e_err);
    maximumError(off) = sqrt(l2h_err);
      
    iter_end = umap.end(UnstructuredMapping::Vertex);
    for ( iter=umap.begin(UnstructuredMapping::Vertex); iter!=iter_end; iter++ )
    {
      if ( !(iter.isGhost() || iter.isBC()) )
      {
	real divE = 0;
	UnstructuredMappingAdjacencyIterator aiter,aiter_end;
	aiter_end = umap.adjacency_end(iter, UnstructuredMapping::Edge);
	for ( aiter=umap.adjacency_begin(iter, UnstructuredMapping::Edge); aiter!=aiter_end; aiter++ )
	{
	  divE += aiter.orientation()*uep(*aiter,0,0);
	  if ( aiter.isBC() || aiter.isGhost() )
	  {
	    divE = 0;
	    break;
	  }
	}
	maxDivE = max(maxDivE,fabs(divE));
      }
	  
    }

    if (rDim==3)
    {
      iter_end = umap.end(UnstructuredMapping::Region);
      for ( iter=umap.begin(UnstructuredMapping::Region); iter!=iter_end; iter++ )
      {
	if ( !(iter.isGhost() || iter.isBC()) )
	{
	  real divH = 0;
	  UnstructuredMappingAdjacencyIterator aiter,aiter_end;
	  aiter_end = umap.adjacency_end(iter, UnstructuredMapping::Face);
	  for ( aiter=umap.adjacency_begin(iter, UnstructuredMapping::Face); aiter!=aiter_end; aiter++ )
	  {
	    divH += aiter.orientation()*uhp(*aiter,0,0);
	    if ( aiter.isBC() || aiter.isGhost() )
	    {
	      divH = 0;
	      break;
	    }
	  }
	  maxDivH = max(maxDivH,fabs(divH));
	}
	      
      }
    }

  }

  //  cout<<"max error locs "<<ml<<endl;
  //  cout<<"max Div E = "<<maxDivE<<endl;
  //  cout<<"max Div H = "<<maxDivH<<endl;
  mx.divEMax = maxDivE;
  mx.gradEMax = maxDivH; // use this spot for div H in the dsi code
  cout<<"max E error location "<<ml<<endl;
  maximumError.display("maximum error");
}

// =============================================================================================
// MACRO: Get errors for a plane wave solution
// =============================================================================================
#beginMacro getErrorsPlaneWave()     
{
  
  if( numberOfDimensions==2 )
  {

    if( method==bamx )
    {
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      getBAPlaneWaveParametersMacro(Errors)
      // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
      // real kv[3]={twoPi*kx,twoPi*ky,twoPi*kz}; // 

      // real sr,si,evr[6],evi[6];
      // RealArray chi;
      // DispersiveMaterialParameters::PolarizationEnum polarization =
      //   !solveForAllFields ?  DispersiveMaterialParameters::ExEyHzPolarization :
      //   DispersiveMaterialParameters::noPolarization;

      // DispersiveMaterialParameters::DispersionRelationOptionEnum & dispersionRelationComputeOption=
      // 	dbase.get<DispersiveMaterialParameters::DispersionRelationOptionEnum>("dispersionRelationComputeOption");
      // dmp.setDispersionRelationComputeOption( dispersionRelationComputeOption );
      // real kr=1., ki=0.;
      // if( dispersionRelationComputeOption==DispersiveMaterialParameters::computeComplexFrequency )
      // {
      // 	dmp.getBianisotropicPlaneWaveSolution( kv, sr,si,evr,evi,chi,polarization );
      // }
      // else
      // {
      // 	// compute the complex wave number given s 
       
      // 	sr = 0.; si= twoPi*sqrt( kx*kx + ky*ky + kz*kz ); // Choose s : do this for now *MUST MATCH OTHERS
      // 	kr = sr; ki= si;
	  
      // 	dmp.getBianisotropicPlaneWaveSolution( kv, kr,ki,evr,evi,chi,polarization );
      // 	printF(" Using k = %e + %e I\n",kr,ki);
      // }

      // // dmp.getBianisotropicPlaneWaveSolution( kv, sr,si,evr,evi,chi,polarization );

      // printF("BA plane wave: getErrors: s=%9.3e + %9.3e I, k=%9.3e + %9.3e I, evr=[%g,%g,%g,%g,%g,%g]\n",
      // 	     sr,si,kr,ki,evr[0],evr[1],evr[2],evr[3],evr[4],evr[5]);
      
      if( !solveForAllFields )
      {
	// TEz mode: 
	evr[2]=evr[5]; evi[2]=evi[5];
      }
	
      // const real expt  =exp(sr*tE);  
      RealArray kDotx(I1,I2,I3);
      kDotx =  kv[0]*xe +kv[1]*ye;
      for( int m=ex; m<=hz; m++ )
      {
	errLocal(I1,I2,I3,m) = uLocal(I1,I2,I3,m) -
	                     (sin( kr*kDotx + si*t )*evr[m] +
			      cos( kr*kDotx + si*t )*evi[m]) *exp( sr*t - ki*kDotx);  // ** could optimize **

	// errLocal(I1,I2,I3,m) = uLocal(I1,I2,I3,m) - sin( kv[0]*xe +kv[1]*ye - omega*t )*ev[m];
      }

      if( dmp.isDispersiveMaterial() )
      {
	
        const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
        for( int m=0; m<numPolarizationTerms; m++ )
        {
          errPolarization(Ie1,Ie2,Ie3,m) = pLocal(Ie1,Ie2,Ie3,m) -
                                    ( sin( kr*kDotx + si*t )*chi(m,0) +
                                      cos( kr*kDotx + si*t )*chi(m,1) )*exp( sr*t - ki*kDotx); // ** could optimize **
        }
	// printF("\n @@@@ getErr: BAMX plane wave: saved polarization errors at t=%8.2e, numPolarizationTerms=%d\n",t,numPolarizationTerms);
        
      }


    }
    else if( localDispersionModel == noDispersion )
    {
      erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-exTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-eyTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-hzTrue(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH);
    }
    else
    {
      // --- dispersive plane wave ---
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      // Dispersive material parameters
      // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);

      // evaluate the dispersion relation,  exp(i(k*x-omega*t))
      //    omega is complex 
      const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz);

      // *new way*
      assert( numberOfPolarizationVectors<10 );

      real sr,si,chir[10],chii[10], chiSumr,chiSumi;
      dmp.evaluateDispersionRelation( c,kk, sr, si, chir,chii,chiSumr,chiSumi ); 
      real expt=exp(sr*t);
      real ct = cos(si*t)*expt, st=sin(si*t)*expt;
      //  Hz = (i/s) * (-1) * (kx*Ey - ky*Ex )/mu
      real hFactor = - twoPi*( kx*pwc[1] - ky*pwc[0] )/mu;
      real sNormSq = sr*sr+si*si;
      //  hr + i*hi = (i/s)*hfactor
      real hr = hFactor*si/sNormSq;
      real hi = hFactor*sr/sNormSq;

      RealArray xi(Ie1,Ie2,Ie3), cx, sx, eHat(Ie1,Ie2,Ie3);
      xi = twoPi*(kx*xe(Ie1,Ie2,Ie3)+ky*ye(Ie1,Ie2,Ie3));
      cx=cos(xi); sx=sin(xi);
      // eHat = cx*ct - sx*st; *wdh* 2018/01/28 
      // solution is sin( k*x + si*t)*exp(sr*t) *wdh* 2018/01/28 
      eHat = sx*ct + cx*st;

      erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-pwc[0]*eHat;
      erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-pwc[1]*eHat;
      // errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-( (hr*ct-hi*st)*cx - (hr*st+hi*ct)*sx); *wdh* 2018/01/28 
      errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-( (hr*ct-hi*st)*sx + (hr*st+hi*ct)*cx);
      // -- dispersion model components --

      for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
      {
        const int pc= iv*numberOfDimensions;
        // eHat =(chir[iv]*ct-chii[iv]*st)*cx - (chir[iv]*st+chii[iv]*ct)*sx; // Phat 
        eHat = eps*( (chir[iv]*ct-chii[iv]*st)*sx + (chir[iv]*st+chii[iv]*ct)*cx ); // Phat 

        errPolarization(Ie1,Ie2,Ie3,pc  ) = pLocal(Ie1,Ie2,Ie3,pc  ) - pwc[0]*eHat;
        errPolarization(Ie1,Ie2,Ie3,pc+1) = pLocal(Ie1,Ie2,Ie3,pc+1) - pwc[1]*eHat;
      }


    }
	
    if( method==sosup )
    {
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      // printF(" errLocal = [%i,%i]\n",errLocal.getBase(3),errLocal.getBound(3));

      errLocal(Ie1,Ie2,Ie3,ext)  = uLocal(Ie1,Ie2,Ie3,ext)-extTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      errLocal(Ie1,Ie2,Ie3,eyt)  = uLocal(Ie1,Ie2,Ie3,eyt)-eytTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      errLocal(Ih1,Ih2,Ih3,hzt)  = uLocal(Ih1,Ih2,Ih3,hzt)-hztTrue(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH);

    }

  }
  else // 3D
  {

    if( method==bamx )
    {
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      getBAPlaneWaveParametersMacro(Errors)
      // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
      // real kv[3]={twoPi*kx,twoPi*ky,twoPi*kz}; // 

      // real sr,si,evr[6],evi[6];
      // RealArray chi;
      // dmp.getBianisotropicPlaneWaveSolution( kv, sr,si,evr,evi,chi );

      // printF("BA plane wave: getErrors: s=%9.3e + %9.3e I evr=[%g,%g,%g,%g,%g,%g]\n",
      // 	     sr,si,evr[0],evr[1],evr[2],evr[3],evr[4],evr[5]);

      // const real expt  =exp(sr*tE);  
      RealArray kDotx(I1,I2,I3);
      kDotx =  kv[0]*xe + kv[1]*ye + kv[2]*ze;

      for( int m=ex; m<=hz; m++ )
      {
	errLocal(I1,I2,I3,m) = uLocal(I1,I2,I3,m) -
	                     (sin( kr*kDotx + si*t )*evr[m] +
			      cos( kr*kDotx + si*t )*evi[m])*exp( sr*t - ki*kDotx); 
        
	// errLocal(I1,I2,I3,m) = uLocal(I1,I2,I3,m) - sin( kv[0]*xe +kv[1]*ye +kv[2]*ze - omega*tE )*ev[m];
      }

      if( dmp.isDispersiveMaterial() )
      {
        const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
        for( int m=0; m<numPolarizationTerms; m++ )
        {
          errPolarization(Ie1,Ie2,Ie3,m) = pLocal(Ie1,Ie2,Ie3,m) -
                                    ( sin( kr*kDotx + si*t )*chi(m,0) +
                                      cos( kr*kDotx + si*t )*chi(m,1) )*exp( sr*t - ki*kDotx); 
        }
        
      }


    }
    else if( solveForElectricField )
    {
      if( localDispersionModel == noDispersion )
      {
        erre(Ie1,Ie2,Ie3,ex)=ue(Ie1,Ie2,Ie3,ex)-exTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
        erre(Ie1,Ie2,Ie3,ey)=ue(Ie1,Ie2,Ie3,ey)-eyTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
        erre(Ie1,Ie2,Ie3,ez)=ue(Ie1,Ie2,Ie3,ez)-ezTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
      }
      else
      {
        // ---- Compute errors in DISPERSIVE plane wave ---
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz);

        assert( numberOfPolarizationVectors<10 );
        real sr,si,chir[10],chii[10],chiSumr,chiSumi;
        dmp.evaluateDispersionRelation( c,kk, sr, si, chir,chii,chiSumr,chiSumi ); 
        real expt=exp(sr*t);
        real ct = cos(si*t)*expt, st=sin(si*t)*expt;


        RealArray xi(Ie1,Ie2,Ie3), cx, sx, eHat(Ie1,Ie2,Ie3);
        xi = twoPi*(kx*xe(Ie1,Ie2,Ie3)+ky*ye(Ie1,Ie2,Ie3)+kz*ze(Ie1,Ie2,Ie3));
        cx=cos(xi); sx=sin(xi);
        // eHat = cx*ct - sx*st;// *wdh* 2018/01/28 
        // solution is sin( k*x + si*t)*exp(sr*t) *wdh* 2018/01/28
        eHat = sx*ct + cx*st;

        erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-pwc[0]*eHat;
        erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-pwc[1]*eHat;
        erre(Ie1,Ie2,Ie3,ez)  = ue(Ie1,Ie2,Ie3,ez)-pwc[2]*eHat;

        // --- POLARIZATION vectors ---
        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          // eHat =(chir[iv]*ct-chii[iv]*st)*cx - (chir[iv]*st+chii[iv]*ct)*sx; // Phat 
          eHat =eps*( (chir[iv]*ct-chii[iv]*st)*sx + (chir[iv]*st+chii[iv]*ct)*cx ); // Phat 

          errPolarization(Ie1,Ie2,Ie3,pc  ) = pLocal(Ie1,Ie2,Ie3,pc  ) - pwc[0]*eHat;
          errPolarization(Ie1,Ie2,Ie3,pc+1) = pLocal(Ie1,Ie2,Ie3,pc+1) - pwc[1]*eHat;
          errPolarization(Ie1,Ie2,Ie3,pc+2) = pLocal(Ie1,Ie2,Ie3,pc+2) - pwc[2]*eHat;
        }
        
      }
      
      if( method==sosup )
      {
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        // printF(" errLocal = [%i,%i]\n",errLocal.getBase(3),errLocal.getBound(3));

        errLocal(Ie1,Ie2,Ie3,ext)  = uLocal(Ie1,Ie2,Ie3,ext)-extTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
        errLocal(Ie1,Ie2,Ie3,eyt)  = uLocal(Ie1,Ie2,Ie3,eyt)-eytTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
        errLocal(Ie1,Ie2,Ie3,ezt)  = uLocal(Ie1,Ie2,Ie3,ezt)-eztTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);

      }

    }
    if( solveForMagneticField && method!=bamx )
    {
      errh(Ih1,Ih2,Ih3,hx)=uh(Ih1,Ih2,Ih3,hx)-hxTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
      errh(Ih1,Ih2,Ih3,hy)=uh(Ih1,Ih2,Ih3,hy)-hyTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
      errh(Ih1,Ih2,Ih3,hz)=uh(Ih1,Ih2,Ih3,hz)-hzTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
    }
  }
}

#endMacro

// =============================================================================================
// MACRO: Get errors for Rod Sterling
// =============================================================================================
#beginMacro getErrorsTwilightZone()
{
      
  assert( tz!=NULL );
  OGFunction & e = *tz;
  realArray & center = mg.center();
  // display(center,"center"); //ok
	    
  // display(ee,"exact solution for error computation");
	    
  Index J1,J2,J3;

  int i1,i2,i3;
  if( solveForAllFields )
  {
    printF("Get errors for all fields, t=%e\n",tE);
    
    assert( method==bamx );

    Index I1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
    Index I2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
    Index I3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

    Range C=numberOfComponents;
    bool isRectangular=false;
    OV_GET_SERIAL_ARRAY(real,cg[grid].vertex(),xLocal);
    OV_GET_SERIAL_ARRAY(real,(*cgerrp)[grid],errLocal);
    
    RealArray ue(I1,I2,I3,C);
    e.gd( ue, xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,C,tE);
    errLocal(I1,I2,I3,C) = uLocal(I1,I2,I3,C)- ue(I1,I2,I3,C);
    
  }

  if( mg.numberOfDimensions()==2 )
  {
    J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
    J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
    J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
    FOR_3D(i1,i2,i3,J1,J2,J3)
    {
      real x0 = XEP(i1,i2,i3,0);
      real y0 = XEP(i1,i2,i3,1);
      ERREX(i1,i2,i3)=UEX(i1,i2,i3)-e(x0,y0,0.,ex,tE);
      ERREY(i1,i2,i3)=UEY(i1,i2,i3)-e(x0,y0,0.,ey,tE);
    }
    if( method==sosup )
    {
      // Compute errors in the time derivative
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)- e(x0,y0,0.,ext,tE);
        errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)- e(x0,y0,0.,eyt,tE);
        errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)- e(x0,y0,0.,hzt,tH);
      }
    }
	

    J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
    J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
    J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
    FOR_3(i1,i2,i3,J1,J2,J3)
    {
      real x0 = XHP(i1,i2,i3,0);
      real y0 = XHP(i1,i2,i3,1);
      ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3)-e(x0,y0,0.,hz,tH);
    }

    if( localDispersionModel != noDispersion && method==nfdtd )
    {         
      // --- error in dispersion variables ---
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);

        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - e(x0,y0,0.,pxc+pc,tE);
          errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - e(x0,y0,0.,pyc+pc,tE);
        }

        // --- nonlinear model variables ---
        for( int na=0; na<numberOfAtomicLevels; na++ )
	{
          errNonlinear(i1,i2,i3,na) = qLocal(i1,i2,i3,na) - e(x0,y0,0.,nce+na,tE);
	}


      }
    }
    else if( localDispersionModel != noDispersion && method==bamx )
    {         
      // BAXM -- errors in polarization components
      // printF("getERR: BAMX: getErrTZ, numberOfPolarizationVectors=%d\n",numberOfPolarizationVectors);

      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);

        const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
        for( int m=0; m<numPolarizationTerms; m++ )
        {
          const int pc= hz + m + 1;  // TZ solution sits here 
          errPolarization(i1,i2,i3,m) = pLocal(i1,i2,i3,m)- e(x0,y0,0.,pc,tE);
        }

      }
    }

  }
  else // 3D
  {
    if( solveForElectricField ) 
    {
      J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        real z0 = XEP(i1,i2,i3,2);
        ERREX(i1,i2,i3)=UEX(i1,i2,i3)-e(x0,y0,z0,ex,tE);
        ERREY(i1,i2,i3)=UEY(i1,i2,i3)-e(x0,y0,z0,ey,tE);
        ERREZ(i1,i2,i3)=UEZ(i1,i2,i3)-e(x0,y0,z0,ez,tE);
      }
      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          real x0 = XEP(i1,i2,i3,0);
          real y0 = XEP(i1,i2,i3,1);
          real z0 = XEP(i1,i2,i3,2);
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)- e(x0,y0,z0,ext,tE);
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)- e(x0,y0,z0,eyt,tE);
          errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt)- e(x0,y0,z0,ezt,tE);
        }
      }

    }

    if( solveForMagneticField ) 
    {
      J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
      J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
      J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XHP(i1,i2,i3,0);
        real y0 = XHP(i1,i2,i3,1);
        real z0 = XHP(i1,i2,i3,2);
        ERRHX(i1,i2,i3)=UHX(i1,i2,i3)-e(x0,y0,z0,hx,tH);
        ERRHY(i1,i2,i3)=UHY(i1,i2,i3)-e(x0,y0,z0,hy,tH);
        ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3)-e(x0,y0,z0,hz,tH);
      }
      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          real x0 = XHP(i1,i2,i3,0);
          real y0 = XHP(i1,i2,i3,1);
          real z0 = XHP(i1,i2,i3,2);
          errLocal(i1,i2,i3,hxt) = uLocal(i1,i2,i3,hxt)- e(x0,y0,z0,hxt,tH);
          errLocal(i1,i2,i3,hyt) = uLocal(i1,i2,i3,hyt)- e(x0,y0,z0,hyt,tH);
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)- e(x0,y0,z0,hzt,tH);
        }
      }
    }

    if( localDispersionModel != noDispersion  && method==nfdtd )
    {         
      // --- error in dispersion variables ---
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        real z0 = XEP(i1,i2,i3,2);

        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          // *fix* me for numberOfPolarizationVectors>1 
          errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - e(x0,y0,z0,pxc+pc,tE);
          errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - e(x0,y0,z0,pyc+pc,tE);
          errPolarization(i1,i2,i3,pc+2) = pLocal(i1,i2,i3,pc+2) - e(x0,y0,z0,pzc+pc,tE);
        }
        // --- nonlinear model variables ---
        for( int na=0; na<numberOfAtomicLevels; na++ )
	{
          errNonlinear(i1,i2,i3,na) = qLocal(i1,i2,i3,na) -e(x0,y0,z0,nce+na,tE);
	}
      }
    } 
    else if( localDispersionModel != noDispersion && method==bamx )
    {         
      // BAXM -- errors in polarization components
      // printF("getERR: BAMX: getErrTZ, numberOfPolarizationVectors=%d\n",numberOfPolarizationVectors);

      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        real z0 = XEP(i1,i2,i3,2);

        const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
        for( int m=0; m<numPolarizationTerms; m++ )
        {
          const int pc= hz + m + 1;  // TZ solution sits here 
          errPolarization(i1,i2,i3,m) = pLocal(i1,i2,i3,m)- e(x0,y0,z0,pc,tE);
        }

      }
    }// end localDispersion Model 

  }

  if( debug & 4 ) 
  {
    display(erre(J1,J2,J3),sPrintF("getErrors: errE on grid %i at t=%e",grid,t),pDebugFile,"%9.2e "); 
    display(errh(J1,J2,J3),sPrintF("getErrors: errH on grid %i at t=%e",grid,t),pDebugFile,"%9.2e "); 
  }
}

#endMacro

// =============================================================================================
// MACRO: Get errors for a Gaussian plane wave
// =============================================================================================
#beginMacro getErrorsGaussianPlaneWave()
{
      
  printF("GET ERRORS for GaussianPlaneWave solveForAllFields=%d, t=%9.3e\n",solveForAllFields,tE);

  if( numberOfDimensions==2 && !solveForAllFields )
  {
    if( true )
    {
      // ** new way June 16, 2020 -- use plane-wave-coefficients to scale
      OV_GET_SERIAL_ARRAY(real,(*cgerrp)[grid],errLocal);
     
      realSerialArray xei(Ie1,Ie2,Ie3);
      xei= ( kx*(xe(Ie1,Ie2,Ie3)-x0GaussianPlaneWave) +
	     ky*(ye(Ie1,Ie2,Ie3)-y0GaussianPlaneWave) 
	     -cc*tE );
      RealArray gpw(Ie1,Ie2,Ie3);
      gpw(Ie1,Ie2,Ie3) = exp(-betaGaussianPlaneWave*((xei)*(xei)));

      errLocal(Ie1,Ie2,Ie3,ex) = uLocal(Ie1,Ie2,Ie3,ex) - gpw(Ie1,Ie2,Ie3) * pwc[0];
      errLocal(Ie1,Ie2,Ie3,ey) = uLocal(Ie1,Ie2,Ie3,ey) - gpw(Ie1,Ie2,Ie3) * pwc[1];
      errLocal(Ie1,Ie2,Ie3,hz) = uLocal(Ie1,Ie2,Ie3,hz) - gpw(Ie1,Ie2,Ie3) * pwc[5];

    }
    else
    {

      realSerialArray xei(Ie1,Ie2,Ie3),xhi(Ih1,Ih2,Ih3);
      //xi=kx*(x-x0GaussianPlaneWave)+ky*(y-y0GaussianPlaneWave) -cc*t;
      xei=kx*(xe(Ie1,Ie2,Ie3)-x0GaussianPlaneWave)+ky*(ye(Ie1,Ie2,Ie3)-y0GaussianPlaneWave) -cc*tE;
      xhi=kx*(xh(Ih1,Ih2,Ih3)-x0GaussianPlaneWave)+ky*(yh(Ih1,Ih2,Ih3)-y0GaussianPlaneWave) -cc*tH;

//             err(I1,I2,I3,hz)=hzGaussianPulse(xi);  // save Hz here temporarily

//             err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-err(I1,I2,I3,hz)*(-ky/(eps*cc));
//             err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-err(I1,I2,I3,hz)*( kx/(eps*cc));
// 	    err(I1,I2,I3,hz)-=u(I1,I2,I3,hz);
      realSerialArray hzei(Ie1,Ie2,Ie3);
      hzei = hzGaussianPulse(xei);
      erre(Ie1,Ie2,Ie3,ex)=ue(Ie1,Ie2,Ie3,ex)-hzei(Ie1,Ie2,Ie3)*(-ky/(eps*cc));
      erre(Ie1,Ie2,Ie3,ey)=ue(Ie1,Ie2,Ie3,ey)-hzei(Ie1,Ie2,Ie3)*( kx/(eps*cc));
      errh(Ih1,Ih2,Ih3,hz)=uh(Ih1,Ih2,Ih3,hz) - hzGaussianPulse(xhi(Ih1,Ih2,Ih3));
    }
    
  }
  else
  {
    // *new* May 16, 2020
    OV_GET_SERIAL_ARRAY(real,(*cgerrp)[grid],errLocal);
     
    realSerialArray xei(Ie1,Ie2,Ie3);
    if( numberOfDimensions==2 )
      xei=  kx*(xe(Ie1,Ie2,Ie3)-x0GaussianPlaneWave) +
	    ky*(ye(Ie1,Ie2,Ie3)-y0GaussianPlaneWave) 
            -cc*tE;
    else
      xei=  kx*(xe(Ie1,Ie2,Ie3)-x0GaussianPlaneWave) +
	    ky*(ye(Ie1,Ie2,Ie3)-y0GaussianPlaneWave) +
	    kz*(ze(Ie1,Ie2,Ie3)-z0GaussianPlaneWave)
            -cc*tE;

    RealArray gpw(Ie1,Ie2,Ie3);
    gpw(Ie1,Ie2,Ie3) = exp(-betaGaussianPlaneWave*((xei)*(xei)));

    errLocal(Ie1,Ie2,Ie3,ex) = uLocal(Ie1,Ie2,Ie3,ex) - gpw(Ie1,Ie2,Ie3) * pwc[0];
    errLocal(Ie1,Ie2,Ie3,ey) = uLocal(Ie1,Ie2,Ie3,ey) - gpw(Ie1,Ie2,Ie3) * pwc[1];
    errLocal(Ie1,Ie2,Ie3,ez) = uLocal(Ie1,Ie2,Ie3,ez) - gpw(Ie1,Ie2,Ie3) * pwc[2];

    if( solveForAllFields )
    {
      errLocal(Ie1,Ie2,Ie3,hx) = uLocal(Ie1,Ie2,Ie3,hx) - gpw(Ie1,Ie2,Ie3) * pwc[3];
      errLocal(Ie1,Ie2,Ie3,hy) = uLocal(Ie1,Ie2,Ie3,hy) - gpw(Ie1,Ie2,Ie3) * pwc[4];
      errLocal(Ie1,Ie2,Ie3,hz) = uLocal(Ie1,Ie2,Ie3,hz) - gpw(Ie1,Ie2,Ie3) * pwc[5];

    }
    

  }
  
}
#endMacro

// =============================================================================================
// MACRO: Get errors for a square or box eigenfunction
// =============================================================================================
#beginMacro getErrorsSquareEigenFunction()
{
  real fx=Pi*initialConditionParameters[0];
  real fy=Pi*initialConditionParameters[1];
  real fz=Pi*initialConditionParameters[2];
  real x0=initialConditionParameters[3];
  real y0=initialConditionParameters[4];
  real z0=initialConditionParameters[5];
  real omega;
  real a1=0., a2=0., a3=0.;  // Divergence free if a1+a2+a3=0
  if( numberOfDimensions==2 )
  {
    a1=1., a2=-1., a3=0.;  // For 2d, divergence free if a1+a2=0
    omega=c*sqrt(fx*fx+fy*fy);
    printF("--MX-ER-- box eigenfunction: fx=%g Pi, fy=%g Pi omega=%g Pi.\n",
           fx/Pi, fy/Pi, omega/Pi);
    // x0=-.5, y0=-.5;   // for the square [-.5,.5]x[-.5,.5] 
  }
  else
  {
    a1=1., a2=-2., a3=1.;  // For 3d, divergence free if a1+a2+a3=0
    omega=c*sqrt(fx*fx+fy*fy+fz*fz);
  }
	    
  // Behaviour in time for Ex is  phiEx(t), phiExt = time-derivative
  real phiEx, phiExt, phiPx[10];
  real phiEy, phiEyt, phiPy[10];
  real phiEz, phiEzt, phiPz[10];
  real phiHz, phiHzt;
  real phiHx, phiHy;
	  
  getBoxEigenfunctionCoefficients( tE, tH, omega );

  int i1,i2,i3;
  real xd,yd,zd;
  if( isRectangular )
  {

    if( numberOfDimensions==2 )
    {
      Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
      if( solveForAllFields )
      {
	OV_GET_SERIAL_ARRAY(real,(*cgerrp)[grid],errLocal);
	
	FOR_3D(i1,i2,i3,J1,J2,J3)
	{
	  real xde=X0(i1,i2,i3)-x0;
	  real yde=X1(i1,i2,i3)-y0;
	  // TEZ mode 
	  errLocal(i1,i2,i3,ex) = uLocal(i1,i2,i3,ex) - cos(fx*xde)*sin(fy*yde)*phiEx;  
	  errLocal(i1,i2,i3,ey) = uLocal(i1,i2,i3,ey) - sin(fx*xde)*cos(fy*yde)*phiEy;  
	  errLocal(i1,i2,i3,hz) = uLocal(i1,i2,i3,hz) - cos(fx*xde)*cos(fy*yde)*phiHz;

	  // TMZ mode:  (independent from TEz -- could have a different amplitude)
	  errLocal(i1,i2,i3,hx) = uLocal(i1,i2,i3,hx) - sin(fx*xde)*cos(fy*yde)*phiHx;  
	  errLocal(i1,i2,i3,hy) = uLocal(i1,i2,i3,hy) - cos(fx*xde)*sin(fy*yde)*phiHy;  
	  errLocal(i1,i2,i3,ez) = uLocal(i1,i2,i3,ez) - sin(fx*xde)*sin(fy*yde)*phiEz;
	}

      }
      else
      {
	J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
	J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
	J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
	FOR_3D(i1,i2,i3,J1,J2,J3)
	{
	  xd=X0(i1,i2,i3)-x0;
	  yd=X1(i1,i2,i3)-y0;

	  ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*phiHz;
	  // ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*cos(omega*tH);
	}

	J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
	J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
	J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

	FOR_3(i1,i2,i3,J1,J2,J3)
	{
	  xd=X0(i1,i2,i3)-x0;
	  yd=X1(i1,i2,i3)-y0;
	  ERREX(i1,i2,i3)=UEX(i1,i2,i3) - cos(fx*xd)*sin(fy*yd)*phiEx;  // Ex.t = Hz.y
	  ERREY(i1,i2,i3)=UEY(i1,i2,i3) - sin(fx*xd)*cos(fy*yd)*phiEy;  // Ey.t = - Hz.x
	  // ERREX(i1,i2,i3)=UEX(i1,i2,i3) - (-fy/omega)*cos(fx*xd)*sin(fy*yd)*sin(omega*tE);  // Ex.t = Hz.y
	  // ERREY(i1,i2,i3)=UEY(i1,i2,i3) - ( fx/omega)*sin(fx*xd)*cos(fy*yd)*sin(omega*tE);  // Ey.t = - Hz.x
	}
      }
      
      if( localDispersionModel!=noDispersion )
      {
        // -- dispersion model components --
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          xd=X0(i1,i2,i3)-x0;
          yd=X1(i1,i2,i3)-y0;
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - cos(fx*xd)*sin(fy*yd)*phiPx[iv];
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - sin(fx*xd)*cos(fy*yd)*phiPy[iv];
          }
        }
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          real xde=X0(i1,i2,i3)-x0;
          real yde=X1(i1,i2,i3)-y0;
          // time derivatives: 
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - cos(fx*xde)*sin(fy*yde)*phiExt;  // Ex.t
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - sin(fx*xde)*cos(fy*yde)*phiEyt;  // Ey.t
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - cos(fx*xde)*cos(fy*yde)*phiHzt;  // Hz.t 
          // errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-fy)*cos(fx*xde)*sin(fy*yde)*cos(omega*tE);  // Ex.t
          // errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - ( fx)*sin(fx*xde)*cos(fy*yde)*cos(omega*tE);  // Ey.t
          // errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - (-omega)*cos(fx*xde)*cos(fy*yde)*sin(omega*tH);  // Hz.t 
        }
      }
    } 
    else // 3D
    {

      Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        xd=X0(i1,i2,i3)-x0;
        yd=X1(i1,i2,i3)-y0;
        zd=X2(i1,i2,i3)-z0;

        ERREX(i1,i2,i3)=UEX(i1,i2,i3) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiEx;  // 
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiEy;  // 
        ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiEz;  // 

        // ERREX(i1,i2,i3)=UEX(i1,i2,i3) -  (a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        // ERREY(i1,i2,i3)=UEY(i1,i2,i3) -  (a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        // ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) -  (a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*cos(omega*tE);  // 
      }

      if( localDispersionModel!=noDispersion )
      {
        // -- dispersion model components --
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=X0(i1,i2,i3)-x0;
          yd=X1(i1,i2,i3)-y0;
          zd=X2(i1,i2,i3)-z0;
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiPx[iv];
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiPy[iv];
            errPolarization(i1,i2,i3,pc+2) = pLocal(i1,i2,i3,pc+2) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiPz[iv];
          }
        }
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=X0(i1,i2,i3)-x0;
          yd=X1(i1,i2,i3)-y0;
          zd=X2(i1,i2,i3)-z0;
          // time derivatives: 
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiExt;
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiEyt;
          errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiEzt;
          // errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-omega*a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*sin(omega*tE);
          // errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - (-omega*a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*sin(omega*tE);
          // errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt) - (-omega*a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*sin(omega*tE);
        }
      }
    }
  }
  else // curvilinear 
  {
    // curvilinear
    if( numberOfDimensions==2 )
    {
      Index J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
      Index J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
      Index J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));

      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        xd=XHP(i1,i2,i3,0)-x0;
        yd=XHP(i1,i2,i3,1)-y0;
        ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*phiHz;
        // ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*cos(omega*tH);
      }

      J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3(i1,i2,i3,J1,J2,J3)
      {
        xd=XEP(i1,i2,i3,0)-x0;
        yd=XEP(i1,i2,i3,1)-y0;
        ERREX(i1,i2,i3)=UEX(i1,i2,i3) - cos(fx*xd)*sin(fy*yd)*phiEx;  // Ex.t = Hz.y
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) - sin(fx*xd)*cos(fy*yd)*phiEy;  // Ey.t = - Hz.x
        // ERREX(i1,i2,i3)=UEX(i1,i2,i3) - (-fy/omega)*cos(fx*xd)*sin(fy*yd)*sin(omega*tE);  // Ex.t = Hz.y
        // ERREY(i1,i2,i3)=UEY(i1,i2,i3) - ( fx/omega)*sin(fx*xd)*cos(fy*yd)*sin(omega*tE);  // Ey.t = - Hz.x
      }
      if( localDispersionModel!=noDispersion )
      {
        // -- dispersion model components --
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=XEP(i1,i2,i3,0)-x0;
          yd=XEP(i1,i2,i3,1)-y0;
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - cos(fx*xd)*sin(fy*yd)*phiPx[iv];
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - sin(fx*xd)*cos(fy*yd)*phiPy[iv];
          }
        }
      }
\
      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=XEP(i1,i2,i3,0)-x0;
          yd=XEP(i1,i2,i3,1)-y0;
          // time derivatives: 
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-fy)*cos(fx*xd)*sin(fy*yd)*cos(omega*tE);  // Ex.t
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - ( fx)*sin(fx*xd)*cos(fy*yd)*cos(omega*tE);  // Ey.t
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - (-omega)*cos(fx*xd)*cos(fy*yd)*sin(omega*tH);  // Hz.t 
        }
      }

    } 
    else // 3D
    {
      Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        xd=XEP(i1,i2,i3,0)-x0;
        yd=XEP(i1,i2,i3,1)-y0;
        zd=XEP(i1,i2,i3,2)-z0;

        ERREX(i1,i2,i3)=UEX(i1,i2,i3) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiEx;  // 
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiEy;  // 
        ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiEz;  // 

        // ERREX(i1,i2,i3)=UEX(i1,i2,i3) -  (a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        // ERREY(i1,i2,i3)=UEY(i1,i2,i3) -  (a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        // ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) -  (a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*cos(omega*tE);  // 
      }


      if( localDispersionModel!=noDispersion )
      {
        // -- dispersion model components --
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=XEP(i1,i2,i3,0)-x0;
          yd=XEP(i1,i2,i3,1)-y0;
          zd=XEP(i1,i2,i3,2)-z0;

          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiPx[iv];
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiPy[iv];
            errPolarization(i1,i2,i3,pc+2) = pLocal(i1,i2,i3,pc+2) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiPz[iv];
          }
        }
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          xd=XEP(i1,i2,i3,0)-x0;
          yd=XEP(i1,i2,i3,1)-y0;
          zd=XEP(i1,i2,i3,2)-z0;

          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-omega*a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*sin(omega*tE);
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - (-omega*a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*sin(omega*tE);
          errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt) - (-omega*a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*sin(omega*tE);
        }
      }

    }

  }
}

#endMacro

// =============================================================================================
// MACRO: Get errors for various scattering exact solutions
// =============================================================================================
#beginMacro getErrorsScattering()
{
      
  const real cc0= cGrid(0)*sqrt( kx*kx+ky*ky ); // NOTE: use grid 0 values for multi-materials

  if( knownSolution==NULL )
  {
    initializeKnownSolution();
  }
  const realArray & ug = (*knownSolution)[grid];
  realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

  // The analytic solution assumed incident field was Ei = exp(i*k*x-i*w*t) 
  //     This gives solution
  //           Re(E)*cos(w*t) - Im(E)*sin(w*t) for Ei=cos(w*t)
  //      or   Re(E)*cos(w*t-pi/2) - Im(E)*sin(w*t-pi/2) for Ei=cos(w*t-pi/2)               
  //      i.e. Re(E)*sin(w*t) + Im(E)*cos(w*t) for Ei=sin(w*t)
  // Ex:
  Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
  Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);

#ifdef USE_PPP
  const realSerialArray & ugLocal = ug.getLocalArrayWithGhostBoundaries();
#else
  const realSerialArray & ugLocal = ug; 
#endif
  if( method==nfdtd || method==sosup  || method==bamx )
  { // do this with scalar indexing to avoid a possible bug in P++
    real *ugp = ugLocal.Array_Descriptor.Array_View_Pointer3;
    const int ugDim0=ugLocal.getRawDataSize(0);
    const int ugDim1=ugLocal.getRawDataSize(1);
    const int ugDim2=ugLocal.getRawDataSize(2);
#undef UG
#define UG(i0,i1,i2,i3) ugp[i0+ugDim0*(i1+ugDim1*(i2+ugDim2*(i3)))]

    // const real cost = cos(-twoPi*cc0*tH);  // *wdh* 050731 -- use cc0 
    // const real sint = sin(-twoPi*cc0*tH);
    // const real dcost =  twoPi*cc0*sint;  // d(sin(..))/dt 
    // const real dsint = -twoPi*cc0*cost;  // d(sin(..))/dt 

    getKnownSolutionTimeCoefficients();


    // adjust array dimensions for local arrays
    Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
    Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
    Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

    int i1,i2,i3;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        ERREX(i1,i2,i3) = UEX(i1,i2,i3)-(UG(i1,i2,i3,ex)*cEr + UG(i1,i2,i3,ex+3)*cEi);
        ERREY(i1,i2,i3) = UEY(i1,i2,i3)-(UG(i1,i2,i3,ey)*cEr + UG(i1,i2,i3,ey+3)*cEi);
        ERRHZ(i1,i2,i3) = UHZ(i1,i2,i3)-(UG(i1,i2,i3,hz)*cHr + UG(i1,i2,i3,hz+3)*cHi);
        if( method==sosup )
        { // errors in time derivatives:
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)-(UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost);
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)-(UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost);
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)-(UG(i1,i2,i3,hz)*dsint+UG(i1,i2,i3,hz+3)*dcost);
        }
      }

      // -- dispersion model components --
      if( localDispersionModel!=noDispersion )
      {
	if( method==bamx ) OV_ABORT("finish me");

        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            // *fix* me for numberOfPolarizationVectors>1 
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - (UG(i1,i2,i3,ex)*cPr[iv] + UG(i1,i2,i3,ex+3)*cPi[iv]);
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - (UG(i1,i2,i3,ey)*cPr[iv] + UG(i1,i2,i3,ey+3)*cPi[iv]);
          }
        }
      }
    }
    else  // --- 3D ----
    {
      if( solveForElectricField )
      {
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          ERREX(i1,i2,i3) = UEX(i1,i2,i3)-(UG(i1,i2,i3,ex)*cEr + UG(i1,i2,i3,ex+3)*cEi);
          ERREY(i1,i2,i3) = UEY(i1,i2,i3)-(UG(i1,i2,i3,ey)*cEr + UG(i1,i2,i3,ey+3)*cEi);
          ERREZ(i1,i2,i3) = UEZ(i1,i2,i3)-(UG(i1,i2,i3,ez)*cEr + UG(i1,i2,i3,ez+3)*cEi);
          if( method==sosup )
          { // errors in time derivatives:
            errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)-(UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost);
            errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)-(UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost);
            errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt)-(UG(i1,i2,i3,ez)*dsint+UG(i1,i2,i3,ez+3)*dcost);
          }
        }
      }
      if( solveForMagneticField || method==bamx )
      {
        const int hxr=hx+3, hyr=hy+3, hzr=hz+3; // offset into ug
        const int hxi=hx+6, hyi=hy+6, hzi=hz+6; // offset into ug
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          ERRHX(i1,i2,i3) = UHX(i1,i2,i3)-(UG(i1,i2,i3,hxr)*cHr+UG(i1,i2,i3,hxi)*cHi);
          ERRHY(i1,i2,i3) = UHY(i1,i2,i3)-(UG(i1,i2,i3,hyr)*cHr+UG(i1,i2,i3,hyi)*cHi);
          ERRHZ(i1,i2,i3) = UHZ(i1,i2,i3)-(UG(i1,i2,i3,hzr)*cHr+UG(i1,i2,i3,hzi)*cHi);
        }
      }
      // -- dispersion model components --
      if( localDispersionModel!=noDispersion )
      {
	if( method==bamx ) OV_ABORT("finish me");
	
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            // *fix* me for numberOfPolarizationVectors>1 
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - (UG(i1,i2,i3,ex)*cPr[iv] + UG(i1,i2,i3,ex+3)*cPi[iv]);
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - (UG(i1,i2,i3,ey)*cPr[iv] + UG(i1,i2,i3,ey+3)*cPi[iv]);
            errPolarization(i1,i2,i3,pc+2) = pLocal(i1,i2,i3,pc+2) - (UG(i1,i2,i3,ez)*cPr[iv] + UG(i1,i2,i3,ez+3)*cPi[iv]);
          }
          // errLocal(i1,i2,i3,pxc) = uLocal(i1,i2,i3,pxc) - (UG(i1,i2,i3,ex)*phiPs + UG(i1,i2,i3,ex+3)*phiPc);
          // errLocal(i1,i2,i3,pyc) = uLocal(i1,i2,i3,pyc) - (UG(i1,i2,i3,ey)*phiPs + UG(i1,i2,i3,ey+3)*phiPc);
          // errLocal(i1,i2,i3,pzc) = uLocal(i1,i2,i3,pzc) - (UG(i1,i2,i3,ez)*phiPs + UG(i1,i2,i3,ez+3)*phiPc);
        }
      }

    }
#undef UG
	      
  }
  else
  {
    real cost = cos(-twoPi*cc*tH);  // *wdh* 040626 add "-"
    real sint = sin(-twoPi*cc*tH);
    errh(Ih1,Ih2,Ih3,Ch)=uh(Ih1,Ih2,Ih3,Ch) - (ugLocal(Ih1,Ih2,Ih3,Ch)*sint+ugLocal(Ih1,Ih2,Ih3,Ch+3)*cost);

    cost = cos(-twoPi*cc*tE);  // *wdh* 040626 add "-"
    sint = sin(-twoPi*cc*tE);  // *wdh* 040626 add "-"
    erre(Ie1,Ie2,Ie3,Ce)=ue(Ie1,Ie2,Ie3,Ce) - (ugLocal(Ie1,Ie2,Ie3,Ce)*sint+ugLocal(Ie1,Ie2,Ie3,Ce+3)*cost);
	    
//              // err(I1,I2,I3,C)=fabs( u(I1,I2,I3,C) - (ug(I1,I2,I3,C)*sint+ug(I1,I2,I3,C+3)*cost) );
//              // ok err(I1,I2,I3,hz)=fabs( u(I1,I2,I3,hz) - (-ug(I1,I2,I3,hz)*sint)+ug(I1,I2,I3,hz+3)*cost));

//              err(I1,I2,I3,ex)=fabs( u(I1,I2,I3,ex) + (ug(I1,I2,I3,ex)*sint+ug(I1,I2,I3,ex+3)*cost) );
//              err(I1,I2,I3,ey)=fabs( u(I1,I2,I3,ey) + (ug(I1,I2,I3,ey)*sint+ug(I1,I2,I3,ey+3)*cost) );
//              // ok err(I1,I2,I3,ey)=fabs( u(I1,I2,I3,ey) - (-ug(I1,I2,I3,ey+3)*cost) );

//              err(I1,I2,I3,hz)=fabs( u(I1,I2,I3,hz) - (ug(I1,I2,I3,hz)*sint+ug(I1,I2,I3,hz+3)*cost));
  }

}

#endMacro






// =================================================================================================================
/// \brief Determine the errors.
// =================================================================================================================
void Maxwell::
getErrors( int current, real t, real dt )
{
  if( t<= 2*dt )
    printF("\n +++++ getErrors checkErrors=%d, knownSolutionOption=%d \n",(int)checkErrors,(int)knownSolutionOption);

  if( !checkErrors )
  {
    // Compute solution norms (used by the check file)  *wdh* Dec 21, 2019
    const bool getErrorNorms=false;
    getNorms( current, t, dt, getErrorNorms );
    
    return;
  }
  
  real time0=getCPU();
  
  const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Iav[3], &Ia1=Iav[0], &Ia2=Iav[1], &Ia3=Iav[2]; 
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2]; 
  Index Icv[3], &Ic1=Icv[0], &Ic2=Icv[1], &Ic3=Icv[2]; 

  const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;
  
  // printF(" >>>>>>>>getErrors: current=%i next=%i <<<<<<<<<<< \n",current,next);
  

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int numberOfComponentGrids = cg.numberOfComponentGrids();
  const int numberOfDimensions = cg.numberOfDimensions();

  // Range C(ex,hz);
  // const int numberOfComponents= cgfields[0][0].getLength(3);
  const int & numberOfComponents= dbase.get<int>("numberOfComponents");
  const int & solveForAllFields = dbase.get<int>("solveForAllFields");

  // total number of polarization components per grid 
  const IntegerArray & totalNumberOfPolarizationComponents =
    parameters.dbase.get<IntegerArray>("totalNumberOfPolarizationComponents");

  int & numberOfErrorComponents= dbase.get<int>("numberOfErrorComponents");

  numberOfErrorComponents=numberOfComponents;
  // const int epc = numberOfComponents;  // save P norm and errors in this component
  // if( localDispersionModel != noDispersion )
  // {
  //    numberOfErrorComponents++;  // save error in all polarization vectors 
  // }
  
  
  Range C=numberOfComponents;
  solutionNorm.redim(numberOfErrorComponents);  

  // When we compute the energy we also save energy, and delta(energy)
  int numErr=numberOfErrorComponents;
  if( computeEnergy )
    numErr+=2;
  
  // maximumError.redim(numberOfSequences); 
  maximumError.redim(numErr);

  if( method==nfdtd || method==yee || method==bamx )
  {
  }
  else if( method==sosup )
  {
  }
  else
  {
    if(numberOfDimensions==2)
    {
      solutionNorm.redim(3);
    }
    else
    {
      solutionNorm.redim(6);
    }
  }

  // maximumError=0.;
  // solutionNorm=1.;
  
  realCompositeGridFunction *uReference=NULL;

  if( compareToReferenceShowFile )
  {
    // *** NEW ****
    if( knownSolutionOption!=noKnownSolution )
    {
      printF("CgmX:ERROR: compareToReferenceShowFile=true but knownSolutionOption has been set -- FIX ME\n");
      OV_ABORT("error");
    }
    
    
    if( !dbase.has_key("referenceSolution")  )
    {
      ReferenceSolution *& referenceSolution = dbase.put<ReferenceSolution*>("referenceSolution");
      referenceSolution = new ReferenceSolution();
      referenceSolution->setShowFileName( nameOfReferenceShowFile );
    }
    ReferenceSolution & referenceSolution = *dbase.get<ReferenceSolution*>("referenceSolution");
    uReference = & (referenceSolution.getSolution( t,cg,C ) );

    if( false )
    {
      // ** OLD ****

      // This case is used for comparing absorbing BC's -- we compare the solution to a reference
      // solution that was computed on a bigger grid
      if( referenceShowFileReader==NULL )
      {
        referenceShowFileReader = new ShowFileReader(nameOfReferenceShowFile);
      }
	    
      CompositeGrid cgRef;
      realCompositeGridFunction uRef;
	    
      int solutionNumber = 1 + int( t/tPlot + .5); // fix this ******************************
      printF(" **** compareToReferenceShowFile: t=%f solutionNumber=%i\n",t,solutionNumber);
    
      referenceShowFileReader->getASolution(solutionNumber,cgRef,uRef);        // read in a grid and solution

      // This solution uReference will live on the smaller domain 
      Range all;
      uReference = new realCompositeGridFunction(cg,all,all,all,C);
      cg.update(MappedGrid::THEmask );
      cgRef.update(MappedGrid::THEmask );
      interpolateAllPoints( uRef,*uReference );  // interpolate uReference from uRef
    }
    
  }

  maximumError=0.;  // max error over all grids
  solutionNorm=0.;
  
  //kkc 040310 moved this assertion outside the following loop
  assert( cgerrp!=NULL || errp!=NULL );

  // --- For dispersive models keep track of the maxium errors in the polarization vector per domain -- 
  RealArray & polarizationNorm   =  dbase.get<RealArray>("polarizationNorm");
  RealArray & maxErrPolarization =  dbase.get<RealArray>("maxErrPolarization");
  
  if( polarizationNorm.getLength(0)!=cg.numberOfDomains() || maxErrPolarization.getLength(0)!=cg.numberOfDomains())
  {
    polarizationNorm.redim(cg.numberOfDomains());
    maxErrPolarization.redim(cg.numberOfDomains());
  }
  polarizationNorm=0.;
  maxErrPolarization=0.;

  // --- For nonlinear models keep track of the maxium errors in the nonlinear variables per domain -- 
  RealArray & nonlinearNorm   =  dbase.get<RealArray>("nonlinearNorm");
  RealArray & maxErrNonlinear =  dbase.get<RealArray>("maxErrNonlinear");
  
  if( nonlinearNorm.getLength(0)!=cg.numberOfDomains() || maxErrNonlinear.getLength(0)!=cg.numberOfDomains())
  {
    nonlinearNorm.redim(cg.numberOfDomains());
    maxErrNonlinear.redim(cg.numberOfDomains());
  }
  nonlinearNorm=0.;
  maxErrNonlinear=0.;

  

  // *************************************************************
  // *************** START LOOP OVER GRIDS ************************
  // *************************************************************
  for( int grid=0; grid<numberOfComponentGrids; grid++ )
  {

    if( method==yee )
    {
      assert( numberOfComponentGrids==1 );
      
      int option=1;
      int iparam[5] = { -1,-1,0,0,0 }; // 
      getValuesFDTD( option, iparam, current, t, dt, cgerrp );

      continue;
    }

    c = cGrid(grid);
    eps = epsGrid(grid);
    mu = muGrid(grid);

    EXTRACT_GFP(ERRORS);    // bpp macro


    DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
    int numberOfPolarizationVectors = 0;
    const int domain = cg.domainNumber(grid);
    if( method==nfdtd )
      numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;
    else if( method==bamx )
    {
      numberOfPolarizationVectors = 2*totalNumberOfPolarizationComponents(grid); // Note "2*" : we store [p.p.t]
      // printF("getERR: BAMX: numberOfPolarizationVectors=%d\n",  numberOfPolarizationVectors);

    }
    
    // Each grid may or may not have dispersion model: 
    const DispersionModelEnum localDispersionModel = numberOfPolarizationVectors>0 ? dispersionModel : noDispersion;
    if( dispersionModel == noDispersion )
    {
      assert( numberOfPolarizationVectors==0 );
    }
    

    // --- Get Arrays for the dispersive model ----
    realMappedGridFunction & pCur = getDispersionModelMappedGridFunction( grid,current );

    RealArray pLocal;
    if( numberOfPolarizationVectors>0 )
    {
      OV_GET_SERIAL_ARRAY(real, pCur,pLoc);
      pLocal.reference(pLoc);
      // ::display(pLocal,"pLocal");
    }

    // --- Get grid function that holds the error in the polarization vector ----
    bool getErrorGridFunction=true;
    realMappedGridFunction & pErr = getDispersionModelMappedGridFunction( grid,current,getErrorGridFunction );

    RealArray errPolarization;
    if( numberOfPolarizationVectors>0 )
    {
      OV_GET_SERIAL_ARRAY(real, pErr,pErrLocal );
      errPolarization.reference(pErrLocal);

      // Range Pc = numberOfPolarizationVectors*numberOfDimensions;
      //       errPolarization.redim(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2),Pc);
      //       errPolarization=0.;
    }    

    // -- For nonlinear model: 
    const int numberOfAtomicLevels = dmp.getNumberOfAtomicLevels();
    // Index location for TZ nonlinear variables: 
    const int nce = pxc +numberOfPolarizationVectors*numberOfDimensions;
    RealArray qLocal,errNonlinear;
    if( numberOfAtomicLevels>0 )
    {
      realMappedGridFunction & qCur = getNonlinearModelMappedGridFunction( grid,current);
      OV_GET_SERIAL_ARRAY(real, qCur,qLoc);
      qLocal.reference(qLoc);
      
      realMappedGridFunction & qErr = getNonlinearModelMappedGridFunction( grid,current,getErrorGridFunction );
      OV_GET_SERIAL_ARRAY(real, qErr,qErrLocal );
      errNonlinear.reference(qErrLocal);
    }
    
    bool energyOnly = false;

    const int i0a=mg.gridIndexRange(0,0);
    const int i1a=mg.gridIndexRange(0,1);
    const int i2a=mg.gridIndexRange(0,2);

    const real xa=xab[0][0], dx0=dx[0];
    const real ya=xab[0][1], dy0=dx[1];
    const real za=xab[0][2], dz0=dx[2];

#define X0(i0,i1,i2) (xa+dx0*(i0-i0a))
#define X1(i0,i1,i2) (ya+dy0*(i1-i1a))
#define X2(i0,i1,i2) (za+dz0*(i2-i2a))

    const int numberOfGhost= (method==nfdtd  || method==bamx ) ? orderOfAccuracyInSpace/2 : 0;
      
    // Range C(ex,hz);

    real errEx,errEy,errHz;

    // Here is the box where we evaluate the error when there is a PML
    bool usePML = getBoundsForPML( mg,Iv,pmlErrorOffset ); 
    if( usePML )
    { // do NOT include PML region in the bounds: 
      adjustBoundsForPML(mg,Iev,pmlErrorOffset ); 
      adjustBoundsForPML(mg,Ihv,pmlErrorOffset ); 
    }

    const int & absorbingLayerErrorOffset = parameters.dbase.get<int>("absorbingLayerErrorOffset");
    const int & useSuperGrid = parameters.dbase.get<int>("useSuperGrid");
    if( useSuperGrid==1 )
    { // do NOT include absorbing layer region in the bounds when computing errors 
      const int & absorbingLayerErrorOffset = parameters.dbase.get<int>("absorbingLayerErrorOffset");
      adjustBoundsForAbsorbingLayer(mg,Iev,absorbingLayerErrorOffset ); 
      adjustBoundsForAbsorbingLayer(mg,Ihv,absorbingLayerErrorOffset ); 
    }

    errh = 0.;
    erre = 0.;
    // if( initialConditionOption==planeWaveInitialCondition )
    // printF("getErrors: grid=%i knownSolution=%i\n",grid,(int)knownSolutionOption);
    
    if( knownSolutionOption==planeWaveKnownSolution )
    {
      // ********** Plane wave **********

      getErrorsPlaneWave();
	    
    }
    else if( knownSolutionOption==twilightZoneKnownSolution )
    {

      // ********** Twilight Zone errors *************

      getErrorsTwilightZone();
    
    }
    else if( knownSolutionOption==gaussianPlaneWaveKnownSolution )
    {
      // ********** Gaussian plane wave **********
      getErrorsGaussianPlaneWave();
      

    
    }
    else if( knownSolutionOption==squareEigenfunctionKnownSolution )
    {
      // ********** Square or Box eigenfunctions **********

      getErrorsSquareEigenFunction();
      
    }
    else if( knownSolutionOption==annulusEigenfunctionKnownSolution )
    {
      //kkc XXX not implemented for dsi schemes
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      Index J1 = Range(max(I1.getBase(),uLocal.getBase(0)),min(I1.getBound(),uLocal.getBound(0)));
      Index J2 = Range(max(I2.getBase(),uLocal.getBase(1)),min(I2.getBound(),uLocal.getBound(1)));
      Index J3 = Range(max(I3.getBase(),uLocal.getBase(2)),min(I3.getBound(),uLocal.getBound(2)));

      annulusEigenFunction(error,J1,J2,J3);
            
    }
    else if( knownSolutionOption==planeMaterialInterfaceKnownSolution )
    {
      if( method==nfdtd || method==sosup  || method==bamx )
      { 
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

	// adjust array dimensions for local arrays
	Index J1 = Range(max(I1.getBase(),uel.getBase(0)),min(I1.getBound(),uel.getBound(0)));
	Index J2 = Range(max(I2.getBase(),uel.getBase(1)),min(I2.getBound(),uel.getBound(1)));
	Index J3 = Range(max(I3.getBase(),uel.getBase(2)),min(I3.getBound(),uel.getBound(2)));

	setPlaneMaterialInterfaceMacro(error,J1,J2,J3);
      }
      else
      {
	printF("MX:getErrors: ERROR: initialConditionOption==planeMaterialInterfaceInitialCondition but method=%i\n",
	       (int)method);
	OV_ABORT("ERROR");
      }
    }
    else if( knownSolutionOption==gaussianIntegralKnownSolution )
    {
	    
      // adjust array dimensions for local arrays
      Index J1 = Range(max(I1.getBase(),uel.getBase(0)),min(I1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(I2.getBase(),uel.getBase(1)),min(I2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(I3.getBase(),uel.getBase(2)),min(I3.getBound(),uel.getBound(2)));

      getGaussianIntegralSolution(error,UEX,UEY,UHZ,tE,J1,J2,J3);

	    
    }
    else if( compareToReferenceShowFile )
    {
      //kkc XXX not implemented for dsi schemes

      // printF("XXXX getError : compare to reference: grid=%i, t=%9.3e\n",t);
      

      assert( uReference!=NULL );
      OV_GET_SERIAL_ARRAY(real,(*uReference)[grid],urLocal);
	    
      //            err(I1,I2,I3,C)=fabs(u(I1,I2,I3,C)-ur(I1,I2,I3,C));

      if( solveForMagneticField )
      {
	Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
	errh(Ih1,Ih2,Ih3,Ch)=uh(Ih1,Ih2,Ih3,Ch)-urLocal(Ih1,Ih2,Ih3,Ch);
      }
      
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
      erre(Ie1,Ie2,Ie3,Ce)=ue(Ie1,Ie2,Ie3,Ce) - urLocal(Ie1,Ie2,Ie3,Ce);
    }

    else if( knownSolutionOption==scatteringFromADiskKnownSolution ||
             knownSolutionOption==scatteringFromADielectricDiskKnownSolution ||
             knownSolutionOption==scatteringFromASphereKnownSolution ||
             knownSolutionOption==scatteringFromADielectricSphereKnownSolution )
    {

      // Get errors for various scattering exact solutions
      getErrorsScattering();
      

    }
    else if( knownSolutionOption==userDefinedKnownSolution )
    {
      realCompositeGridFunction & cgerr = (*cgerrp);
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);      
      realMappedGridFunction & qErr = getNonlinearModelMappedGridFunction( grid,current,getErrorGridFunction );

      // NOTE: save exact solution in cgerr (and pErr for dispersive)
      int numberOfTimeDerivatives=0;
      getUserDefinedKnownSolution( current, t, cg,grid, cgerr[grid],pErr,qErr, I1,I2,I3,numberOfTimeDerivatives);

      errLocal(I1,I2,I3,C) = errLocal(I1,I2,I3,C) -  uLocal(I1,I2,I3,C);

      if( method==nfdtd && numberOfPolarizationVectors>0 )
      {
	  Range Pc = numberOfPolarizationVectors*numberOfDimensions;
	  errPolarization(I1,I2,I3,Pc) -= pLocal(I1,I2,I3,Pc);

	  if( numberOfAtomicLevels>0 )
	  {
	    Range Na=numberOfAtomicLevels;
	    errNonlinear(I1,I2,I3,Na) -= qLocal(I1,I2,I3,Na);  // **check me**
	  }
	  
      }
      if( method==bamx )
      {
        const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
	if(  numPolarizationTerms>0 )     
	{
	  Range Pc = numPolarizationTerms;
	  errPolarization(I1,I2,I3,Pc) -= pLocal(I1,I2,I3,Pc);

	  // printF("\n @@@@@@@ getErr: save BAMX polarization errors, numberOfPolarizationVectors=%d, t=%8.2e @@@@@@@@ \n\n",
	  // 	 numberOfPolarizationVectors,t);
	}
      }
      
    }
    else if( knownSolutionOption!=noKnownSolution )
    {
      printF("Maxwell::getErrors: unexpected value for knownSolutionOption=%i\n",(int)knownSolutionOption);
      Overture::abort("Maxwell::getErrors");
    }
    else
    {
      energyOnly = true;
    }


    // ===========================================================================
    // =============== DETERMINE MAX ERRORS AND SOLUTION NORMS ===================
    // ===========================================================================

    getIndex(mg.gridIndexRange(),I1,I2,I3);
    RealArray errMax(C);
    errMax=0.;  // max error on this grid
	
    if ( method==dsiMatVec && !energyOnly )
    { // punt here and use a special function that knows how to exclude uns. ghost points
#ifdef USE_PPP
      Overture::abort("Error: finish me");
#else
      computeDSIErrors( *this,mg, uh, uhpp, ue, uepp, errh, erre, solutionNorm, maximumError );
#endif
    }
    else if( radiusForCheckingErrors<= 0. && (method==nfdtd || method==sosup || method==bamx) && !energyOnly) 
    {
      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
      if( true )
      {
	const int ng=orderOfAccuracyInSpace/2;
	const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
 
	Index J1 = Range(max(I1.getBase(),uel.getBase(0)+ng ),min(I1.getBound(),uel.getBound(0)-ng ));
	Index J2 = Range(max(I2.getBase(),uel.getBase(1)+ng ),min(I2.getBound(),uel.getBound(1)-ng ));
	Index J3 = Range(max(I3.getBase(),uel.getBase(2)+ng3),min(I3.getBound(),uel.getBound(2)-ng3));

	int i1,i2,i3;
	FOR_3D(i1,i2,i3,J1,J2,J3)
	{
	  if( MASK(i1,i2,i3)!=0 )
	  {
	    for( int c=C.getBase(); c<=C.getBound(); c++ )
	    {
#undef ERR
#define ERR(i0,i1,i2,i3) errep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]
#undef U
#define U(i0,i1,i2,i3) uep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]

	      errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
	      solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
#undef ERR
#undef U	    
	    }

	    if( method==nfdtd )
	    {
	      for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
	      {
		const int pc= iv*numberOfDimensions;
		for( int dir=0; dir<numberOfDimensions; dir++ )
		{
		  maxErrPolarization(domain) = max(maxErrPolarization(domain),fabs(errPolarization(i1,i2,i3,pc+dir)));
		  polarizationNorm(domain)=max(polarizationNorm(domain),fabs(pLocal(i1,i2,i3,pc+dir))); 
		}
	      }
	    }
	    else if( method==bamx )
	    {
              const int numPolarizationTerms=totalNumberOfPolarizationComponents(grid)*2;
	      for( int m=0; m<numPolarizationTerms; m++ )
	      {
		const int pc= hz + m + 1;  // TZ solution sits here 
                real maxErrP = fabs(errPolarization(i1,i2,i3,m));
		// printF("t=%8.2e: (i1,i2)=(%d,%d) max-err P[%d] =%9.2e\n",t,i1,i2,m,maxErrP);
		
		maxErrPolarization(domain) = max(maxErrPolarization(domain),maxErrP);
		polarizationNorm(domain)=max(polarizationNorm(domain),fabs(pLocal(i1,i2,i3,m))); 
	      }
	    }

            // --- nonlinear variables ---
            for( int na=0; na<numberOfAtomicLevels; na++ )
	    {
	      maxErrNonlinear(domain) = max(maxErrNonlinear(domain),fabs(errNonlinear(i1,i2,i3,na)));
	      nonlinearNorm(domain)   = max(nonlinearNorm(domain),fabs(qLocal(i1,i2,i3,na))); 
	    }
	    
	    
          }
          // ::display(pLocal,"pLocal","%8.1e ");
        
          // printF(">> getErr >>> maxErrPolarization(domain=%i)=%e solutionNorm=%e\n",domain,maxErrPolarization(domain),
          //                solutionNorm(epc));
        
	    
        } // end for_3d

	if( false && method==bamx )
	  printF("getERR: BAMX: getErrTZ, numberOfPolarizationVectors=%d (total, P and Q), maxErrPolarization(domain)=%9.3e\n",
		 numberOfPolarizationVectors,maxErrPolarization(domain));

        if( debug & 2 )
        {
          fprintf(pDebugFile," *** Max errors on this processor for grid %i at t=%8.2e: ",grid,t);
          for( int c=C.getBase(); c<=C.getBound(); c++ )
            fprintf(pDebugFile,"%10.4e,",errMax(c));
          fprintf(pDebugFile,"\n");
        }
        for( int c=C.getBase(); c<=C.getBound(); c++ )
        {
// 	  errMax(c)=getMaxValue(errMax(c));
// 	  solutionNorm(c)=getMaxValue(solutionNorm(c));
	      
          maximumError(c)=max(maximumError(c),errMax(c));  // max error over all grids
        }
        
      }
      else // check inside radius
      {
        // printF(" Check errors within the sphere of radius %10.2e\n",radiusForCheckingErrors);
	  
        // new way
        const int ng=orderOfAccuracyInSpace/2;
        const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
 
        Index J1 = Range(max(I1.getBase(),uLocal.getBase(0)+ng ),min(I1.getBound(),uLocal.getBound(0)-ng ));
        Index J2 = Range(max(I2.getBase(),uLocal.getBase(1)+ng ),min(I2.getBound(),uLocal.getBound(1)-ng ));
        Index J3 = Range(max(I3.getBase(),uLocal.getBase(2)+ng3),min(I3.getBound(),uLocal.getBound(2)-ng3));

        Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
        Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
	    
        if ( method==nfdtd  || method==bamx )
        {
          const real radiusForCheckingErrorsSquared=SQR(radiusForCheckingErrors);
		
          real radius;
          int i1,i2,i3;
#undef ERR
#define ERR(i0,i1,i2,i3) errep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]
#undef U
#define U(i0,i1,i2,i3) uep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]

          if( isRectangular )
          {
            FOR_3D(i1,i2,i3,J1,J2,J3)
            {
              radius = SQR(X0(i1,i2,i3))+SQR(X1(i1,i2,i3));
              if( numberOfDimensions==3 ) radius+=SQR(X2(i1,i2,i3));
			
              if( radius<radiusForCheckingErrorsSquared && MASK(i1,i2,i3)!=0 )
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                {
                  errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
                  solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
				
                }
                if( method==nfdtd )
		{
		  for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
		  {
		    const int pc= iv*numberOfDimensions;
		    for( int dir=0; dir<numberOfDimensions; dir++ )
		    {
		      maxErrPolarization(domain) = max(maxErrPolarization(domain),fabs(errPolarization(i1,i2,i3,pc+dir)));
		      polarizationNorm(domain)=max(polarizationNorm(domain),fabs(pLocal(i1,i2,i3,pc+dir))); 
		    }
                
		  }
		}
		else
		{
                  OV_ABORT("finish me");
		}
		
              }
              else
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                  ERR(i1,i2,i3,c)=0.;

                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                    errPolarization(i1,i2,i3,pc+dir)=0.;
                }
              }
            } // end FOR3D
          }
          else // curvilinear
          {
            FOR_3D(i1,i2,i3,J1,J2,J3)
            {
              radius = SQR(X(i1,i2,i3,0))+SQR(X(i1,i2,i3,1));
              if( numberOfDimensions==3 ) radius+=SQR(X(i1,i2,i3,2));
			
              if( radius<radiusForCheckingErrorsSquared && MASK(i1,i2,i3)!=0 )
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                {
                  errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
                  solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
				
                }

                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                  {
                    maxErrPolarization(domain) = max(maxErrPolarization(domain),fabs(errPolarization(i1,i2,i3,pc+dir)));
                    polarizationNorm(domain)=max(polarizationNorm(domain),fabs(pLocal(i1,i2,i3,pc+dir))); 
                  }
                }

              }
              else
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                  ERR(i1,i2,i3,c)=0.;

                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                    errPolarization(i1,i2,i3,pc+dir)=0.;
                }
              }
			
            }
          }
        }
        
#undef ERR
#undef U		
	if( debug & 2 )
	{
	  fprintf(pDebugFile," *** Max errors on this processor for grid %i at t=%8.2e: ",grid,t);
	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	    fprintf(pDebugFile,"%10.4e,",errMax(c));
          fprintf(pDebugFile,"\n");
	}
	
	
 	for( int c=C.getBase(); c<=C.getBound(); c++ )
 	{
// 	  errMax(c)=getMaxValue(errMax(c));
// 	  solutionNorm(c)=getMaxValue(solutionNorm(c));
		    
 	  maximumError(c)=max(maximumError(c),errMax(c));  // max error over all grids
 	}
      }
    
    } // end else if inside radius

    bool computeErrorsAtGhost=true;
#ifdef USE_PPP
    computeErrorsAtGhost=false;
#endif
    if( computeErrorsAtGhost && !usePML && (method==nfdtd || method==sosup || method==bamx ) )
    {
	      
      // compute error including ghost points
      // *** this is wrong ==> only check ghost points where mask on boundary !=0 
      realMappedGridFunction & err = mgp==NULL ? (*cgerrp)[grid] : *errp;
      #ifdef USE_PPP
        realSerialArray errLocal;  getLocalArrayWithGhostBoundaries(err,errLocal);
      #else
        const realSerialArray & errLocal  =  err;
      #endif	    
      
	      
      RealArray ghostError(C,Range(1,numberOfGhost));
      ghostError=0.;
      int c,ghost;
      Index Ig1,Ig2,Ig3;
      for( int axis=0; axis<mg.numberOfDimensions(); axis++)
      {
	for( int side=0; side<=1; side++ )
	{
	  getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
          bool ok = ParallelUtility::getLocalArrayBounds(mask,maskLocal,I1,I2,I3);
          if( !ok ) continue;
	  for( ghost=1; ghost<=numberOfGhost; ghost++ )
	  {
	    getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,ghost);
	    bool ok = ParallelUtility::getLocalArrayBounds(mask,maskLocal,Ig1,Ig2,Ig3);
	    if( !ok ) continue;

	    Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
	    Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
			
	    where( maskLocal(I1,I2,I3)!=0 && maskLocal(Ig1,Ig2,Ig3)!=0 )
	    {
	      for( c=C.getBase(); c<=C.getBound(); c++ )
		ghostError(c,ghost)=max(ghostError(c,ghost),max(fabs(errLocal(Ig1,Ig2,Ig3,c))));
			    
	      for( c=C.getBase(); c<=C.getBound(); c++ )
	      {
		if( max(fabs(errLocal(Ig1,Ig2,Ig3,c)))>1.e+1 )
		{
		  fprintf(pDebugFile," *** grid=%i side,axis=%i,%i ghost=%i c=%i ****\n",grid,side,axis,ghost,c);
		  display(errLocal(Ig1,Ig2,Ig3,c),"ERROR on the ghost line",pDebugFile);
		}
	      }
			    
	    }
	  }
	}
      }

      if( debug & 2 )
      {
	for( ghost=1; ghost<=numberOfGhost; ghost++ )
	{
	  fprintf(pDebugFile," t=%9.3e: grid=%i: Errors at ghost line %i: ",t,grid,ghost);
	  for( c=C.getBase(); c<=C.getBound(); c++ )
	    fprintf(pDebugFile,"%8.2e, ",ghostError(c,ghost));
	  fprintf(pDebugFile,"\n");
	}
      }
      
    } // end if compute error at ghost

  
    EXTRACT_GFP_END(ERRORS);
  } // end for grid
  

  for( int c=C.getBase(); c<=C.getBound(); c++ )
  {
    solutionNorm(c)=getMaxValue(solutionNorm(c)); // fix me -- could do all at once
    maximumError(c)=getMaxValue(maximumError(c));
  }

  if( debug & 2 )
  {
    fprintf(pDebugFile,"\n --> t=%10.4e dt=%7.1e Errors: ",t,dt);
    for( int c=C.getBase(); c<=C.getBound(); c++ )
      fprintf(pDebugFile,"%10.4e,",maximumError(c));
    fprintf(pDebugFile,"\n");
  }

  // -------- PRINT ERRORS IN POLARIZATION VECTORS FOR DISPERSIVE MODELS --------
  
  // printF("getErrors: dispersionModel=%d\n",(int)dispersionModel);
  
  if( dispersionModel != noDispersion )
  {
    for( int domain=0; domain<cg.numberOfDomains(); domain++ )
    {
      DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
      int numberOfPolarizationVectors = 0;
      if( method==nfdtd )
	numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;
      else if( method==bamx )
      {
	int grid=domain; // do this for now 
	numberOfPolarizationVectors = 2*totalNumberOfPolarizationComponents(grid); // Note "2*" : we store [p.p.t]
      }
      
      // printF("getErrors: domain=%d, numPolarizationVectors=%i\n",domain,numberOfPolarizationVectors);

      maxErrPolarization(domain) = getMaxValue(maxErrPolarization(domain)); // fix me -- could do all at once
      polarizationNorm(domain) = getMaxValue(polarizationNorm(domain)); // fix me -- could do all at once

      if( numberOfPolarizationVectors>0 )
      {
        printF("--getErrors: t=%9.3e domain=%i (%s) numPolarizationVectors=%i P-norm=%9.3e max-err = %9.3e\n",
               t,domain,(const char*)cg.getDomainName(domain), numberOfPolarizationVectors,
               polarizationNorm(domain),maxErrPolarization(domain));
      }
    }
    
  }
  
  // -------- PRINT ERRORS IN NONLINEAR MODELS --------
  if( nonlinearModel != noNonlinearModel )
  {
    for( int domain=0; domain<cg.numberOfDomains(); domain++ )
    {
      DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
      int numberOfAtomicLevels = dmp.getNumberOfAtomicLevels();

      maxErrNonlinear(domain) = getMaxValue(maxErrNonlinear(domain)); // fix me -- could do all at once
      nonlinearNorm(domain)   = getMaxValue(nonlinearNorm(domain)); // fix me -- could do all at once

      if( numberOfAtomicLevels>0 )
      {
        printF("--getErrors: t=%9.3e domain=%i (%s) numberOfAtomicLevels=%i   Q-norm=%9.3e max-err = %9.3e\n",
               t,domain,(const char*)cg.getDomainName(domain), numberOfAtomicLevels,
               nonlinearNorm(domain),maxErrNonlinear(domain));
      }
    }
    
  }
  
  if( true )
  {
    // *new way* Dec 21, 2019
    const bool getErrorNorms=true;
    getNorms( current, t, dt, getErrorNorms );
  }
  else
  {
    // ** OLD WAY *** 

    if( method==nfdtd || method==yee || method==sosup || method==bamx )
    {
      realCompositeGridFunction & cgerr = *cgerrp;
      realCompositeGridFunction & cgu = cgfields[current];

      // We print the max norm and optionally some lp norms
      // const int errorNorm = parameters.dbase.get<int >("errorNorm");
      int numberOfNormsToPrint=1;
      if( errorNorm<10000 ) numberOfNormsToPrint+=errorNorm;

      for( int norm=0; norm<numberOfNormsToPrint; norm++ )
      { // norm==0 : max-norm, otherwise Lp-norm with p=norm
	int pNorm = norm==0 ? INT_MAX : norm;

	if( norm!=0 ) // max-norm values are already computed -- we could avoid doing this above --
	{
	  // compute the Lp norm
	  maximumError=0.;
	  const int maskOption=0;  // check points where mask != 0
	  const int checkErrorsAtGhostPoints=0;
	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	  {
	    if( pNorm<10000 )
	    {
	      maximumError(c)=lpNorm(pNorm,cgerr,c,maskOption,checkErrorsAtGhostPoints);
	      solutionNorm(c)=lpNorm(pNorm,cgu  ,c,maskOption,checkErrorsAtGhostPoints);
	    }
	    else
	    { // assume this is the max-norm
	      maximumError(c)=maxNorm(cgerr,c,maskOption,checkErrorsAtGhostPoints);
	      solutionNorm(c)=maxNorm(cgu  ,c,maskOption,checkErrorsAtGhostPoints);
	    }
	  }

	  // ---- Compute Lp norm errors of polarization vectors ----
	  if( dispersionModel != noDispersion )
	  {
	    if( method==bamx )
	    {
	      // ---- fix me for multiple material domains ---
	      int domain=0, grid=0;
	      assert( cg.numberOfDomains()==1 && cg.numberOfComponentGrids()==1 );

	      const int numberOfPolarizationVectors = 2*totalNumberOfPolarizationComponents(grid); // Note "2*" : we store [p.p.t]

	      realCompositeGridFunction *ppv = getDispersionModelCompositeGridFunction( domain,current );
	      assert( ppv!=NULL );
	      // get Pv error grid function
	      realCompositeGridFunction *pepv = getDispersionModelCompositeGridFunction( domain,current,true);
	      assert( pepv!=NULL );
          
	      maxErrPolarization(domain)=0.;
	      polarizationNorm(domain)=0.;
	      for( int pc=0; pc<numberOfPolarizationVectors; pc++ )
	      {
		const real pErr =  lpNorm(pNorm,*pepv,pc,maskOption,checkErrorsAtGhostPoints);
		const real pNorm = lpNorm(pNorm,*ppv ,pc,maskOption,checkErrorsAtGhostPoints);

		maxErrPolarization(domain) = max(maxErrPolarization(domain),pErr);
		polarizationNorm(domain)   = max(polarizationNorm(domain)  ,pNorm);
	      }
	    
	    }
	    else 
	    {

	      for( int domain=0; domain<cg.numberOfDomains(); domain++ )
	      {
		DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
		const int numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;  
		if( numberOfPolarizationVectors>0 )
		{
        
		  realCompositeGridFunction *ppv = getDispersionModelCompositeGridFunction( domain,current );
		  assert( ppv!=NULL );
		  // get Pv error grid function
		  realCompositeGridFunction *pepv = getDispersionModelCompositeGridFunction( domain,current,true);
		  assert( pepv!=NULL );
          
		  maxErrPolarization(domain)=0.;
		  polarizationNorm(domain)=0.;
		  for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
		  {
		    for( int dir=0; dir<numberOfDimensions; dir++ )
		    {
		      const int pc = dir+ iv*numberOfDimensions; // component 
		      const real pErr =  lpNorm(pNorm,*pepv,pc,maskOption,checkErrorsAtGhostPoints);
		      const real pNorm = lpNorm(pNorm,*ppv ,pc,maskOption,checkErrorsAtGhostPoints);

		      maxErrPolarization(domain) = max(maxErrPolarization(domain),pErr);
		      polarizationNorm(domain)   = max(polarizationNorm(domain)  ,pNorm);
		    }
		  }
		}
	      }
	    }
	  }
	

	}
      
	aString normName;
	if( pNorm<1000 )
	  sPrintF(normName,"l%i",pNorm);
	else
	  normName="max";

	for( int fileio=0; fileio<2; fileio++ )
	{
	  FILE *output = fileio==0 ? logFile : stdout;

	  if( radiusForCheckingErrors>0 && radiusForCheckingErrors<10. )
	    fPrintF(output,"                t=%8.2e dt=%7.1e %s errors(r=%3.2f):[",
		    t,dt,radiusForCheckingErrors,(const char*)normName);
	  else
	    fPrintF(output,">>> t=%8.2e dt=%7.1e %s errors:[",t,dt,(const char*)normName);

	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	    fPrintF(output,"%8.2e,",maximumError(c));
	  // fPrintF(output,"%10.4e,",maximumError(c));

	  fPrintF(output,"], %s (u):[",(const char*)normName);

	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	    fPrintF(output,"%8.2e,",solutionNorm(c));

	  fPrintF(output,"] (%i steps)\n",numberOfStepsTaken);
	}
      } // end for norm 
    }

  } // end OLD WAY 
  

  timing(timeForGetError)+=getCPU()-time0;
}

