#
# Determine eigenvalues for eigenfunctions of the heat equation on an annulus 
# Dirichlet BCs at r=a and r=b:
#    f(z) = Jn(a*z)*Yn(a*z) - Jn(b*z)*Yn(a*z)
#
# WDH Nov 25, 2021 - New version to compute lots of eigenvalues, ordered by magnitude.
#
#  restart; currentdir("/Users/henshaw/Dropbox/CG6backup/overtureFramework/cg/ad/codes"); currentdir("/Users/henshaw/Dropbox/CG6backup/overtureFramework/cg/ad/codes"); 
#  read "annulusEigenvaluesNew.maple";
#
#
clear:
interface(quiet=true,echo=0):

writeMatlabFile := 0; # save eigenvalues to a Matlab file

Digits:=15;
jn:=BesselJ(nn,rr):
yn:=BesselY(nn,rr):

jp:=diff(BesselJ(nn,rr),rr):
yp:=diff(BesselY(nn,rr),rr):

numBC:=1; # Dirichlet 
# numBC:=2; # Dirichlet and Neumann BC's 

for ibc from 1 by 1 to numBC do

  if( ibc=0 )then
    # Dirichlet BC's on both sides
    fileName := "annulusEigsOrderedDirichletDirichlet.h";

    f:=subs(rr=a*z,jn)*subs(rr=b*z,yn) - subs(rr=b*z,jn)*subs(rr=a*z,yn):

  else
    # Neumann BC's on both sides

    fileName := "annulusEigsOrderedNeumannNeumann.h"; 

    f:=subs(rr=a*z,jp)*subs(rr=b*z,yp) - subs(rr=b*z,jp)*subs(rr=a*z,yp):
  fi:

  a:=1/2; b:=1; 
  # m:=2;


  # --- compute roots to f(z,m)=0 
  nr:=20: # first nr roots of f
  nm:=20; # first nm bessel functions

  w:=array(1..nm+1,1..nr):  # holds roots 
  maxRoots := (nm+1)*nr; 
  myRoots := Vector(1..maxRoots);


  # plot f(z) for different m
  pl := [ subs(nn=n,f) $n=0..nm-1]:
  plot( pl,z=1..50, y=-1..1 ):
  # plot( f,z=0..20);

  # search for roots here: 
  rMin:=.1; 
  rMax:=200;

  # ---- Search for roots -----
  numr := 101:
  dr := ( rMax-rMin )/( numr -1 ); 
  qi := array(1..numr):

  # n = Bessel order : Jn, Yn 
  n1 := 0; 
  mr := 1; # counts roots 
  for n from n1 by 1 to nm do

    m:=1; # root number
    for i from 1 to numr do

      ri := rMin + (i-1)*dr;
      qi[i] := evalf(subs({nn=n,z=ri},f)):

      # printf("n=%d: i=%d, ri=%7.3f qi=%s\n",n,i,ri,convert(qi[i],string));

      # check for a change in sign : 
      if i>1 and Re(qi[i])*Re(qi[i-1]) <= 0 then

        w[n+1-n1,m] := fsolve( subs(nn=n,f)=0,z, (ri-dr)..ri);

        myRoots[mr] := w[n+1-n1,m]; 
        mr:=mr+1;

        printf(" Bessel order n=%d, root m=%d is r_{n,m}=%22.16e\n",n,m,w[n+1-n1,m]);

        m:=m+1;
        if m > nr then
          break;  # we have found nr roots 
        end if;
      end if:
    end do; 

    if m<=nr then
      printf("ERROR: nr=%d roots not found -- you should increase rMax\n",nr); 
      error "error";
    end if;
  end do:

  myRoots := sort(myRoots):
  printf("\n --- SORTED -----\n");
  for mr from 1 to maxRoots do
     # printf(" %s \n",convert(myRoots[mr],string));
     printf("  %22.16e,\n",myRoots[mr]);
  end do;

  # w:=array(1..nm,1..nr):
  # # n = Bessel order : Jn, Yn 
  # for n from 0 by 1 to nm-1 do
  #   lastr:=0:
  #   toavoid:={}:
  #   # r = root number 
  #   for r from 1 by 1 to nr do
  #     # Find the next root, avoiding previous roots
  #     if( writeMatlabFile=1 )then
  #       if( n=0 )then
  #         w[n+1,r] := fsolve( subs(m=n,f)=0,z, avoid=toavoid, lastr..lastr+7);
  #       else
  #         w[n+1,r] := fsolve( subs(m=n,f)=0,z, avoid=toavoid, w[n,r]..w[n,r]+2);
  #       fi;
  #     else
  #       w[n+1,r] := fsolve( subs(m=n,f)=0,z, avoid=toavoid, lastr..max(10,lastr+10));
  #     fi;
  #     printf(" w[%d,%d]=%s\n",n+1,r,convert(w[n+1,r],string));

  #     printf(" n=%d, r=%d, root w=%20.8e\n",n,r,w[n+1,r]);

  #     toavoid:= toavoid union {z=w[n+1,r]}:
  #     lastr := w[n+1,r]:
  #     # print(toavoid):
  #   end do;
  # end do;


  # if( writeMatlabFile=1 )then
  #   # MATLAB FILE
  #   file:=fopen(fileName, WRITE):
  #   fprintf(file,"%% ---- Eigenvalues for eigenfunctions of the heat equation on an annulus ----\n"):
  #   fprintf(file,"%% File written by cg/ad/codes/annulusEigenvalues.maple \n"):
  #   fprintf(file,"%% numBesselOrderDBC  : Bessel orders are m=0,1,2,...,numBesselOrderDBC-1 \n"):
  #   fprintf(file,"%% numRootDBC         : number of roots\n"):
  #   if( ibc=1 )then
  #     fprintf(file,"%% ----------- DIRCHLET BCs at r=ra and r=rb ----- \n"):
  #   else
  #     fprintf(file,"%% ----------- NEUMANN BCs at r=ra and r=rb ----- \n"):
  #   fi;
  #   fprintf(file,"%% Solution is u = cJ*Jn(lambda*r) + cY*Yn(lambda*r)\n");
  #   fprintf(file,"%%  cJ = amp*Yn(lambda*a), cY = -amp*Jn(lambda*a) \n");
  #   # cJ :=  evalf(subs(rr=a,subs(m=n,y))); # Yn(lambda*a)
  #   # cY := -evalf(subs(rr=a,subs(m=n,j))); 
  #   # cNorm := (cJ^2 + cY^2)^(1/2); 
  #   # cJ := cJ/cNorm; cY := cY/cNorm; 
  #   # fprintf(file," const Real cJ=%19.14e, cY=%19.14e\n",cJ,cY);
  #   fprintf(file," ra=%19.14e; rb=%19.14e; \n",a,b):
  #   fprintf(file," numBesselOrder=%d; numRoot=%d;\n",nm,nr):
  #   fprintf(file," lambdav = [...\n"):
  
  #   for n from 0 to nm-1 do
  
  #     # fprintf(file," { // Roots for f(z,n) = Jn(a*z)*Yn(a*z) - Jn(b*z)*Yn(a*z), n=%d\n",n):
  
  #     for mr from 1 to nr do
  
  #       z1 := w[n+1, mr]:
  
  #       # printf(" Jn(%e)=%e : n=%d m=%d xp =%19.14e \n",z1,BesselJ(n,z1),n,mr,z1):
        
  #       fprintf(file," %19.14e; ...\n",z1):
  
  #     od:
  #   od:
  
  #   fprintf(file,"];\n"):
  #   fclose(file):
  #   printf(" *** output written to file %s\n",convert(fileName,string)):

  # else

  #   file:=fopen(fileName, WRITE):
  #   fprintf(file,"// ---- Eigenvalues for eigenfunctions of the heat equation on an annulus ----\n"):
  #   fprintf(file,"// File written by cg/ad/codes/annulusEigenvalues.maple \n"):
  #   fprintf(file,"// numBesselOrderDBC  : Bessel orders are m=0,1,2,...,numBesselOrderDBC-1 \n"):
  #   fprintf(file,"// numRootDBC         : number of roots\n"):
  #   if( ibc=1 )then
  #     fprintf(file,"// ----------- DIRCHLET BCs at r=ra and r=rb ----- \n"):
  #   else
  #     fprintf(file,"// ----------- NEUMANN BCs at r=ra and r=rb ----- \n"):
  #   fi;
  #   fprintf(file,"// Solution is u = cJ*Jn(lambda*r) + cY*Yn(lambda*r)\n");
  #   fprintf(file,"//  cJ = amp*Yn(lambda*a), cY = -amp*Jn(lambda*a) \n");
  #   # cJ :=  evalf(subs(rr=a,subs(m=n,y))); # Yn(lambda*a)
  #   # cY := -evalf(subs(rr=a,subs(m=n,j))); 
  #   # cNorm := (cJ^2 + cY^2)^(1/2); 
  #   # cJ := cJ/cNorm; cY := cY/cNorm; 
  #   # fprintf(file," const Real cJ=%19.14e, cY=%19.14e\n",cJ,cY);
  #   fprintf(file," const Real ra=%19.14e, rb=%19.14e; \n",a,b):
  #   fprintf(file," const int numBesselOrder=%d, numRoot=%d;\n",nm,nr):
  #   fprintf(file," Real annulusEigs[numBesselOrder][numRoot]={\n"):
  
  #   for n from 0 to nm-1 do
  
  #     fprintf(file," { // Roots for f(z,n) = Jn(a*z)*Yn(a*z) - Jn(b*z)*Yn(a*z), n=%d\n",n):
  
  #     for mr from 1 to nr do
  
  #       z1 := w[n+1, mr]:
  
  #       # printf(" Jn(%e)=%e : n=%d m=%d xp =%19.14e \n",z1,BesselJ(n,z1),n,mr,z1):
        
  #       fprintf(file,"    %19.14e",z1):
  #       if mr<nr then
  #         fprintf(file,",\n"):
  #       else
  #         fprintf(file,"}, // end n=%d\n",n):
  #       fi:
  
  #     od:
  #   od:
  
  #   fprintf(file,"                               };\n"):
  #   fclose(file):
  #   printf(" *** output written to file %s\n",convert(fileName,string)):



  # fi

od; # for ibc 


