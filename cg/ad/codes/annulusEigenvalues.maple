#
# Determine eigenvalues for eigenfunctions of the heat equation on an annulus 
# Dirichlet BCs at r=a and r=b:
#    f(z) = Jn(a*z)*Yn(a*z) - Jn(b*z)*Yn(a*z)
#
# WDH April 19, 2021 -- initial version from Dan Serino's mx/codes/shell.maple
#
# restart; currentdir("/Users/henshaw/Dropbox/CG6backup/overtureFramework/cg/ad/codes"); currentdir("/Users/henshaw/Dropbox/CG6backup/overtureFramework/cg/ad/codes"); read "annulusEigenvalues.maple";
#
# But where is the file written?
# restart; read '/Users/henshaw/Dropbox/CG6backup/overtureFramework/cg/ad/codes/annulusEigenvalues.maple';
#
clear:
interface(quiet=true,echo=0):

Digits:=15;
j:=BesselJ(m,rr):
y:=BesselY(m,rr):

jp:=diff(BesselJ(m,rr),rr):
yp:=diff(BesselY(m,rr),rr):

numBC:=2; # Dirichlet and Neumann BC's 
for ibc from 1 by 1 to numBC do

  if( ibc=1 )then
    # Dirichlet BC's on both sides
    fileName := "annulusEigenvaluesHeatEquationDirichlet.h"; 
    f:=subs(rr=a*z,j)*subs(rr=b*z,y) - subs(rr=b*z,j)*subs(rr=a*z,y):
  else
    # Neumann BC's on both sides
    fileName := "annulusEigenvaluesHeatEquationNeumann.h"; 
    f:=subs(rr=a*z,jp)*subs(rr=b*z,yp) - subs(rr=b*z,jp)*subs(rr=a*z,yp):
  fi:

  a:=1/2; b:=1; 
  # m:=2;


  # --- compute roots to f(z,m)=0 
  nr:=4: # first nr roots of f
  nm:=3: # first nm bessel functions 

  # plot f(z) for different m
  pl := [ subs(m=mm,f) $mm=0..nm-1]:
  plot( pl,z=3..20 ):
  # plot( f,z=0..20);

  w:=array(1..nm,1..nr):
  # n = Bessel order : Jn, Yn 
  for n from 0 by 1 to nm-1 do
    lastr:=0:
    toavoid:={}:
    # r = root number 
    for r from 1 by 1 to nr do
      # Find the next root, avoiding previous roots
      w[n+1,r] := fsolve( subs(m=n,f)=0,z, avoid=toavoid, lastr..max(10,lastr+10));
      # printf(" w[%d,%d]=%s\n",n+1,r,convert(w[n+1,r],string));

      printf(" n=%d, r=%d, root w=%20.8e\n",n,r,w[n+1,r]);

      toavoid:= toavoid union {z=w[n+1,r]}:
      lastr := w[n+1,r]:
      # print(toavoid):
    end do:
  end do:


  file:=fopen(fileName, WRITE):
  fprintf(file,"// ---- Eigenvalues for eigenfunctions of the heat equation on an annulus ----\n"):
  fprintf(file,"// File written by cg/ad/codes/annulusEigenvalues.maple \n"):
  fprintf(file,"// numBesselOrderDBC  : Bessel orders are m=0,1,2,...,numBesselOrderDBC-1 \n"):
  fprintf(file,"// numRootDBC         : number of roots\n"):
  if( ibc=1 )then
    fprintf(file,"// ----------- DIRCHLET BCs at r=ra and r=rb ----- \n"):
  else
    fprintf(file,"// ----------- NEUMANN BCs at r=ra and r=rb ----- \n"):
  fi;
  fprintf(file,"// Solution is u = cJ*Jn(lambda*r) + cY*Yn(lambda*r)\n");
  fprintf(file,"//  cJ = amp*Yn(lambda*a), cY = -amp*Jn(lambda*a) \n");
  # cJ :=  evalf(subs(rr=a,subs(m=n,y))); # Yn(lambda*a)
  # cY := -evalf(subs(rr=a,subs(m=n,j))); 
  # cNorm := (cJ^2 + cY^2)^(1/2); 
  # cJ := cJ/cNorm; cY := cY/cNorm; 
  # fprintf(file," const Real cJ=%19.14e, cY=%19.14e\n",cJ,cY);
  fprintf(file," const Real ra=%19.14e, rb=%19.14e; \n",a,b):
  fprintf(file," const int numBesselOrder=%d, numRoot=%d;\n",nm,nr):
  fprintf(file," Real annulusEigs[numBesselOrder][numRoot]={\n"):

  for n from 0 to nm-1 do

    fprintf(file," { // Roots for f(z,n) = Jn(a*z)*Yn(a*z) - Jn(b*z)*Yn(a*z), n=%d\n",n):

    for mr from 1 to nr do

      z1 := w[n+1, mr]:

      # printf(" Jn(%e)=%e : n=%d m=%d xp =%19.14e \n",z1,BesselJ(n,z1),n,mr,z1):
      
      fprintf(file,"    %19.14e",z1):
      if mr<nr then
        fprintf(file,",\n"):
      else
        fprintf(file,"}, // end n=%d\n",n):
      fi:

    od:
  od:

  fprintf(file,"                               };\n"):
  fclose(file):
  printf(" *** output written to file %s\n",convert(fileName,string)):

od; # for ibc 


# fprintf(file," const int nfunc_shell=%d, nzeros_shell=%d, ndata_shell=2;\n",nm,nr):
# fprintf(file," // u(r) = A_m J_m(w r/c) + B_m Y_m(w r/c)\n"):
# fprintf(file," // rOuter/rInner = %d\n",a);
# fprintf(file," // shellEigenvalues[nfunc_shell][nzeros_shell][0] : the eigenvalue w*rInner/c\n"):
# fprintf(file," // shellEigenvalues[nfunc_shell][nzeros_shell][1] : B_m (scaled so A_m=1)\n"):
# fprintf(file," Real shellEigenvalues[nfunc_shell][nzeros_shell][ndata_shell]={\n"):

# 
# nr:=5: # first nr roots of f
# nm:=5: # first nm bessel functions 
# w:=array(1..nm,1..nr):
# Am:=1: # this is arbitrary
# Bmcoeff:=array(1..nm,1..nr):
# a:=2:
# for n from 0 by 1 to nm-1 do
#     lastr:=0:
#     toavoid:={}:
#     for r from 1 by 1 to nr do
#         w[n+1,r] := fsolve(subs(m=n,f)=0,wri,avoid=toavoid,lastr..max(5,2*lastr)):
#   toavoid:= toavoid union {wri=w[n+1,r]}:
#   lastr := w[n+1,r]:
#   #print(toavoid):
#   #print(w[n+1,r]):
#   Bmcoeff[n+1,r] := -Am*evalf(subs(m=n,rr=w[n+1,r],j)/subs(m=n,rr=w[n+1,r],y)):
#     end do:
# end do:
# #print(w):
# #print(Bmcoeff):
# Ri:=1:
# for n from 0 by 1 to nm-1 do
#     pl:=[Am*BesselJ(n,w[n+1,rt]*R)+Bmcoeff[n+1,rt]*BesselY(n,w[n+1,rt]*R) $rt=1..nr]:
#     plot(pl,R=Ri..a*Ri);
# end do;
# 
# file:=fopen("annulusEigenvalues.h", WRITE):
# fprintf(file," const int nfunc_shell=%d, nzeros_shell=%d, ndata_shell=2;\n",nm,nr):
# fprintf(file," // u(r) = A_m J_m(w r/c) + B_m Y_m(w r/c)\n"):
# fprintf(file," // rOuter/rInner = %d\n",a);
# fprintf(file," // shellEigenvalues[nfunc_shell][nzeros_shell][0] : the eigenvalue w*rInner/c\n"):
# fprintf(file," // shellEigenvalues[nfunc_shell][nzeros_shell][1] : B_m (scaled so A_m=1)\n"):
# fprintf(file," Real shellEigenvalues[nfunc_shell][nzeros_shell][ndata_shell]={\n"):
# 
# for n from 0 by 1 to nm-1 do
#     fprintf(file," { // n=%d\n",n):
#     for r from 1 by 1 to nr do
#   fprintf(file,"    {    %19.14e,    %19.14e  }",w[n+1,r],Bmcoeff[n+1,r]):
#   if r<nr then
#      fprintf(file,",\n"):
#   else
#      fprintf(file,"}, \n"):
#   fi:
#     od:
# od:
# fprintf(file,"};\n"):
# fclose(file):
