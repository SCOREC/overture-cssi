// -----------------------------------------------------------------------------------------------------------
// This file contains the **EVEN NEWER VERSION** of the multi-domain advance routine 
//       that supports 
//             GENERAL USER-DEFINED MULTI-STAGE ALGORITHMS 
// 
// Notes on multi-domain (implicit/explicit) time stepping
//
//
// assignInterfaceBoundaryConditions.C
//  - initializeInterfaces(std::vector<int> gfIndex)
//  - assignInterfaceBoundaryConditions(std::vector<int> gfIndex, const real dt )
//  - initializeInterfaceBoundaryConditions( real t, real dt, std::vector<int> gfIndex )
//  - assignInterfaceRightHandSide( int d, real t, real dt, int correct, std::vector<int> gfIndex ) 
//  - getInterfaceResiduals( real t, real dt, std::vector<int> gfIndex, real & maxRes )
// 
// ** For interfaces see also:
// common/src/interfaceBoundaryConditions.C : for iterative implicit interface conditions
//  - setInterfaceBoundaryCondition( GridFaceDescriptor & info )
//  - iterativeInterfaceRightHandSide( InterfaceOptionsEnum option, GridFaceDescriptor & info, 
//                                       int gfIndex, real t )
// common/src/assignInterfaceBoundaryConditions.C
//
//
// -----------------------------------------------------------------------------------------------------------
#include "Cgmp.h"
#include "Ogshow.h"
#include "Interface.h"
#include "AdvanceOptions.h"
#include "MpParameters.h"

// ===================================================================================================================
/// \brief Multi-domain explicit/implicit time stepping following user-defined stages
/// \details 
/// \param t (input/output) : current time
/// \param tFinal (input) : integrate to this final time.
// ==================================================================================================================
int Cgmp::
multiStageAdvance( real &t, real & tFinal )
{  
  real cpu0=getCPU();

  const MpParameters::MultiDomainAlgorithmEnum multiDomainAlgorithm = 
                              parameters.dbase.get<MpParameters::MultiDomainAlgorithmEnum>("multiDomainAlgorithm");
  
  assert( multiDomainAlgorithm==MpParameters::multiStageAlgorithm );
  // Here is a list of the stages in the multi-stage algorithm 
  if( !parameters.dbase.has_key("stageInfoList") )
  {
    OV_ABORT("multiStageAdvance::ERROR: stageInfoList NOT FOUND!");
  }

  std::vector<StageInfo> & stageInfoList = parameters.dbase.get<std::vector<StageInfo> >("stageInfoList");
  const int numberOfStages=stageInfoList.size();

  // ***** NEW WAY: have domains solvers request interface info when they need it
  const Parameters::InterfaceCommunicationModeEnum & interfaceCommunicationMode= 
    parameters.dbase.get<Parameters::InterfaceCommunicationModeEnum>("interfaceCommunicationMode");
  assert( interfaceCommunicationMode==Parameters::requestInterfaceDataWhenNeeded );
  const bool requestInterfaceInfo = interfaceCommunicationMode==Parameters::requestInterfaceDataWhenNeeded;
 

  FILE *& debugFile =parameters.dbase.get<FILE* >("debugFile");
  FILE *& pDebugFile =parameters.dbase.get<FILE* >("pDebugFile");
  FILE *& interfaceFile =parameters.dbase.get<FILE* >("interfaceFile");
  
  // Is this next right or should we expect each DomainSolver to know whether it needs to initialize?
  if( !parameters.dbase.get<DataBase >("modelData").has_key("initializeAdvance") )
    parameters.dbase.get<DataBase >("modelData").put<int>("initializeAdvance",true);
  int & init=parameters.dbase.get<DataBase >("modelData").get<int>("initializeAdvance");

  const int numberOfDomains = domainSolver.size(); 
  const std::vector<int> & domainOrder =parameters.dbase.get<std::vector<int> >("domainOrder");
  
  int numberOfSubSteps=parameters.dbase.get<int>("numberOfSubSteps");

  // Keep a count of the total number of correction steps for sub-time-step iterations
  int & totalNumberOfCorrectionSteps = parameters.dbase.get<int>("totalNumberOfCorrectionSteps");

  InterfaceList & interfaceList = parameters.dbase.get<InterfaceList>("interfaceList");
  const bool solveCoupledInterfaceEquations = parameters.dbase.get<bool>("solveCoupledInterfaceEquations");
  const int & interfaceProjectionGhostOption = parameters.dbase.get<int>("interfaceProjectionGhostOption");
  const bool relaxCorrectionSteps = parameters.dbase.get<bool>("relaxCorrectionSteps");

  const bool & hasHeatFluxInterfaces = parameters.dbase.get<bool>("hasHeatFluxInterfaces");
  const bool & hasTractionInterfaces = parameters.dbase.get<bool>("hasTractionInterfaces");
  
  bool & timeStepHasChanged = parameters.dbase.get<bool>("timeStepHasChanged");

  if( true || debug() & 4 )
    printF("\n"
           " -------------------------------------------------------------------------------------------------------\n"
           " ---- MULTI-STAGE ---- t=%e, dt=%e, tFinal=%e, timeStepHasChanged=%i\n"
           " -------------------------------------------------------------------------------------------------------\n\n",
             t,dt,tFinal,(int)timeStepHasChanged);
  if( debug() & 2 )
    fprintf(debugFile," *** Cgmp::multiDomainAdvanceNew: t=%e, dt=%e, tFinal=%e, timeStepHasChanged=%i *** \n",t,dt,tFinal,(int)timeStepHasChanged);


  bool alwaysSetBoundaryData=true;
  #ifdef USE_PPP
    alwaysSetBoundaryData=false;
  #endif

  if( init )
  {
    // -- check if we are using AMR --
    ForDomainOrdered(d)
    {
      if( domainSolver[d]->parameters.isAdaptiveGridProblem() )
      {
        parameters.dbase.get<bool>("adaptiveGridProblem")=true;
        break;
      }
    }
    if( parameters.isAdaptiveGridProblem() )
    {
      if( true || debug() & 2 )
        printF("--MS-- AMR is being used in at least one domain\n");
    }
  }
  

  if( init || ( timeStepHasChanged && parameters.dbase.get<bool>("useMixedInterfaceConditions")) )
  {
    // When we iterate to solve the decoupled interface conditions we need to specify what sub-set
    // of the interface conditions we solve on each domain.
    if( alwaysSetBoundaryData || !solveCoupledInterfaceEquations )
    {
      std::vector<int> gfIndex(numberOfDomains,current); // ** fix this ** get gfIndex from each domain solver

      // For AMR we need to re-define the interface since the AMR grids for the initial conditions were created
      // after the interfaces were initially constructed
      if( parameters.isAdaptiveGridProblem() )
        initializeInterfaces(gfIndex); // this will re-define the interfaces

      initializeInterfaceBoundaryConditions( t,dt,gfIndex );
    }
  }
  
  if( init )
  {
    //  Assign the RHS for the interface equations on domain at t=0 *wdh* 081105
    //  so that we can apply the boundary conditions at t=0 
    const bool & projectMultiDomainInitialConditions = parameters.dbase.get<bool>("projectMultiDomainInitialConditions");
    if( !requestInterfaceInfo ) // old way -- auto interface data
    {
      if( projectMultiDomainInitialConditions )
      {
        // --- project initial conditions --- 
        // Sometimes we need to iterate on the initial conditions to be self-consistent such as
        // with the pressure for INS + SM). 
        std::vector<int> gfIndex(numberOfDomains,current); // ** fix this ** get gfIndex from each domain solver
        projectInitialConditions(t,dt, gfIndex);
      }
      else
      {
        ForDomainOrdered(d)
        {
          // Assign the RHS for the interface equations on domain d 
          if( alwaysSetBoundaryData || !solveCoupledInterfaceEquations )
          {
            std::vector<int> gfIndex(numberOfDomains,current); // ** fix this ** get gfIndex from each domain solver
            const int correct=0;
            assignInterfaceRightHandSide( d, t, dt, correct, gfIndex );
          }
        }
      }
    }
    
    
    ForDomainOrdered(d)
    {
      domainSolver[d]->initializeTimeStepping( t,dt );
    }

    ForDomainOrdered(d)
    {
      // Initialize interface data such as time histories of interface heat fluxes -- *wdh* Dec 12, 2021
      // Used for testing exact solutions
      domainSolver[d]->initializeInterfaceData(  t, dt );
    }

    init=false;
  }


  std::vector<int> gfIndexCurrent(numberOfDomains,-1); // current GridFunction used by domain solver d
  std::vector<int> gfIndexNext(numberOfDomains,-1);    // next time level GridFunction for domain d 

  // initialResidual : holds the initial residual
  // oldResidual     : holds previous max residual on the interface
  std::vector<real> & maxResidual = parameters.dbase.get<std::vector<real> >("maxResidual");

  // std::vector<real> maxResidual, oldResidual, initialResidual, firstResidual;
  std::vector<real> oldResidual, initialResidual, firstResidual;
  bool interfaceIterationsHaveConverged=false;
  std::vector<AdvanceOptions> advanceOptions(numberOfDomains);  

  int & globalStepNumber = parameters.dbase.get<int >("globalStepNumber");

  for( int i=0; i<numberOfSubSteps; i++ )
  {
    globalStepNumber++;

    const int next = (current+1) %2;

    if( debug() & 2 )
      printF("\n"
             "#######################################################################################################\n"
             "################### MULTI-STAGE - START STEP %i, t=%8.2e -> t+dt=%8.2e ##########################\n"
             "#######################################################################################################\n\n",
             globalStepNumber,t,t+dt);

    std::vector<int> gfIndex(numberOfDomains,-1);  // keep track of which GridFunction to use for each domain
    int numberOfRequiredCorrectorSteps=0;          // The minimum number of corrector steps that we must take

    int minimumNumberOfCorrections=1;  // **Fix me** numberOfRequiredCorrectorSteps may be too large
    
    ForDomainOrdered(d)
    { 
      // The next call will return the number of corrector steps needed by this domain solver.
      // gfIndexCurrent[d],gfIndexNext[d] are also returned here.

      domainSolver[d]->startTimeStep( t,dt,gfIndexCurrent[d],gfIndexNext[d],advanceOptions[d] );

      gfIndex[d]=gfIndexCurrent[d];
      numberOfRequiredCorrectorSteps=max(numberOfRequiredCorrectorSteps,advanceOptions[d].numberOfCorrectorSteps);
    }
    

    // -- corrector steps in a PC method OR stages in a R-K method ---
    //  
    //  numberOfPCcorrections : this is actually the maximum number of correction steps that we
    //                          can take in order to solve the interface equations by iteration.
    int numberOfCorrectorSteps=max(numberOfRequiredCorrectorSteps,parameters.dbase.get<int>("numberOfPCcorrections")); 

    if( debug() & 2 )
      printF(" @@@@ MULTI-STAGE: maximum numberOfCorrectorSteps=%i (required=%i)\n",
             numberOfCorrectorSteps,numberOfRequiredCorrectorSteps);
    if( debug() & 2 )
    {
      fPrintF(interfaceFile,
              "\n --- Start of step: t=%9.3e globalStep=%i numberOfCorrectorSteps=%i required=%i coupled=%i ---\n",
              t,globalStepNumber,numberOfCorrectorSteps,numberOfRequiredCorrectorSteps,
              int(solveCoupledInterfaceEquations));
    }

    
    if(  (  !requestInterfaceInfo && !parameters.isAdaptiveGridProblem()              // -- this is not right with AMR
                 && ( alwaysSetBoundaryData || !solveCoupledInterfaceEquations) 
         )  
      ) 
    {
      // Check how well the interface equations are satisfied at the start of the step

      // **** NOTE: interface history values are saved here ****
      if( debug() & 2 )
        printF("\n"
               "+++++++++++++++++++++++++++ STEP=%i t=+dt=%8.2e GET INTERFACE RESIDUALS ++++++++++++++++++++++++++++++++++++++++\n\n",
               globalStepNumber,t+dt);

      getInterfaceResiduals( t, dt, gfIndex, maxResidual, saveInterfaceTimeHistoryValues );
      if( debug() & 2 )
      {
        for( int inter=0; inter<maxResidual.size(); inter++ )
        {
          printF("--MP-- Before time step %i (t=%9.3e) : interface %i : max-interface-residual=%8.2e\n",
                 globalStepNumber,t,inter,maxResidual[inter]);
        }
      }
    }

    for( int correct=0; correct<=numberOfCorrectorSteps; correct++ )
    {
      if( debug() & 2 )
        printF("\n"
               "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
               "+++++++++++++++++++++++ STEP=%i t=%8.2e -> t+dt=%8.2e START CORRECTION STAGE %i +++++++++++++++++++++++++++++++\n"
               "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n",
               globalStepNumber,t,t+dt,correct);

      // ****** FINISH ME *****
      bool correctionIterationsHaveConverged=true;
      totalNumberOfCorrectionSteps++;
      
      for( int stage=0; stage<numberOfStages; stage++ )
      {
        StageInfo & stageInfo = stageInfoList[stage];
        bool takeStep = (stageInfo.action == AdvanceOptions::takeStepAndApplyBoundaryConditions ||
                         stageInfo.action == AdvanceOptions::takeStepButDoNotApplyBoundaryConditions);
        bool applyBCs = (stageInfo.action == AdvanceOptions::takeStepAndApplyBoundaryConditions ||
                         stageInfo.action == AdvanceOptions::applyBoundaryConditionsOnly );

        bool gridHasChanged=false;
        for( int dd=0; dd<stageInfo.domainList.size(); dd++ )
        {
          int d=stageInfo.domainList[dd];

          if( debug() & 2 )
            printF("\n"
                   "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
                   "++++++ MSA: STAGE=%i takeStep=%i applyBCs=%i : domain %s (d=%i,dd=%i) correct=%i t+dt=%8.2e ++++++\n"
                   "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n",
                   stage,(int)takeStep,(int)applyBCs,(const char*)domainSolver[d]->getName(),d,dd,correct,t+dt);

          advanceOptions[d].takeTimeStepOption=stageInfo.action;

          domainSolver[d]->takeTimeStep( t,dt,correct,advanceOptions[d] );

          gfIndex[d]=gfIndexNext[d]; // Domain d now has a solution at the next time level we can use

          gridHasChanged = gridHasChanged || advanceOptions[d].gridChanges != AdvanceOptions::noChangeToGrid;

          if( relaxCorrectionSteps )
          {
            // Check convergence of FSI sub-iterations
            correctionIterationsHaveConverged =  ( correctionIterationsHaveConverged &&  
                                                   advanceOptions[d].correctionIterationsHaveConverged );

            printF(" +++MSA: relaxCorrectionSteps: correction=%i stage=%i domain=%i correctionsHaveConverged=%i\n",
                   correct,stage,d,(int)advanceOptions[d].correctionIterationsHaveConverged);
          }



        } // end for dd 
        


        assert( !gridHasChanged );  // finish me for AMR -- see multiDomainAdvanceNew
         
      } //  end for stage

      bool heatFluxInterfacesHaveConverged=true;
      if( hasHeatFluxInterfaces )
      {
        // -- check for convergence of heat flux interfaces --
        // *wdh* April 13, 2021 *check me*
        heatFluxInterfacesHaveConverged = 
           checkInterfaceForConvergence( correct,
                                         numberOfCorrectorSteps,
                                         numberOfRequiredCorrectorSteps,
                                         t+dt,
                                         alwaysSetBoundaryData,
                                         gfIndex,
                                         oldResidual,initialResidual,firstResidual,
                                         maxResidual,
                                         interfaceIterationsHaveConverged );

        printF(" +++Cgmp::MSA: hasHeatFluxInterfaces: correction=%i heatFluxInterfacesHaveConverged=%i\n",correct,(int)heatFluxInterfacesHaveConverged);
      }

      
      if( debug() & 2 )
        printF("\n"
               "+++++++++++++++++++++ STEP=%i t+dt=%8.2e END CORRECTION STAGE %i +++++++++++++++++++++++++++++++++++++\n\n",
               globalStepNumber,t+dt,correct);
    
      bool hasConverged = heatFluxInterfacesHaveConverged;
      if( hasTractionInterfaces && relaxCorrectionSteps && !correctionIterationsHaveConverged )
        hasConverged = false;  // FSI interfaces have not converged

      // if( relaxCorrectionSteps && correctionIterationsHaveConverged  && correct>=minimumNumberOfCorrections ) // changed April 13. 2021
      if( hasConverged && correct>=minimumNumberOfCorrections )
      {
        printF(" +++++MSA: relaxCorrectionSteps: all domains have converged at correction step=%i.\n",correct);
        break;
      }
      
    } // end correct 
    
    if( hasHeatFluxInterfaces )
    {
      // -- project the Temperature at heat flux interfaces ----
      projectInterface( t+dt, dt, gfIndex );
    }

    ForDomainOrdered(d)
    {
      real td=t; //  endTimeStep will increment the time. Do not increment t here. 
      domainSolver[d]->endTimeStep( td,dt,advanceOptions[d] );
    }
    


    t+=dt;      
    numberOfStepsTaken++; 
    current=next;

  }

  gf[current].t = t;
  
  return 0;
}

