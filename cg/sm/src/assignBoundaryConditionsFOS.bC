#include "Cgsm.h"
#include "SmParameters.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "RadiationBoundaryCondition.h"
#include "ParallelUtility.h"
#include "GridMaterialProperties.h"

#define bcOptSmFOS EXTERN_C_NAME(bcoptsmfos)

extern "C"
{
  void bcOptSmFOS(const int&nd,
	       const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
	       const int& gridIndexRange,real& u, const int&mask,const real&rsxy, const real&xy, 
               const int & ndMatProp, const int& matIndex, const real& matValpc, const real& matVal,
               const real&det,
	       const int&boundaryCondition, const int&addBoundaryForcing, const int& interfaceType, const int&dim,
               const real & bcf00, const real & bcf10, 
               const real & bcf01, const real & bcf11, 
               const real & bcf02, const real & bcf12, 
               const real & bcf0, const int64_t & bcfOffset,
	       const int & ndpin, const int & pinbc,
	       const int & ndpv, const real & pinValues,
               const int&ipar, const real&rpar, const DataBase *pdb, const int&ierr );
}

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)


#Include "forcing.h"
#Include "translationAndRotationSolution.h"
#Include "boundaryMacros.h"

// ************* WE SHOULD SHARE THE NEXT MACRO WITH BCOPSM *****************

// =============================================================
// Macro to apply optimized versions of BC's
// =============================================================
#beginMacro optimizedBoundaryConditionsMacro()

getIndex(mg.gridIndexRange(),I1,I2,I3);
int includeGhost=1;
bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
if( ok && useOpt )
{

  // use optimised boundary conditions
  int ipar[30];
  real rpar[20];

  int gridType = isRectangular ? 0 : 1;
  int orderOfExtrapolation=orderOfAccuracyInSpace+1;  // not used
  int useForcing = forcingOption==twilightZoneForcing;
  int useWhereMask=false;

  realArray f;  // not currently used

  IntegerArray & pinBoundaryCondition = parameters.dbase.get<IntegerArray>("pinBoundaryCondition");
  int numberToPin=pinBoundaryCondition.getLength(1);
  RealArray & pinValues = parameters.dbase.get<RealArray>("pinValues");



  // fprintf(pDebugFile,"**** pu= %i, %i...\n",&u,pu);

  const bool centerNeeded=useForcing || (forcingOption==planeWaveBoundaryForcing); // **************** fix this 

#ifdef USE_PPP 

  realSerialArray uu;    getLocalArrayWithGhostBoundaries(u,uu);
  realSerialArray uuOld; getLocalArrayWithGhostBoundaries(uOld,uuOld);
  intSerialArray  mask;  getLocalArrayWithGhostBoundaries(mg.mask(),mask);
  realSerialArray rx;    if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg.inverseVertexDerivative(),rx);
  realSerialArray xy;    if( centerNeeded ) getLocalArrayWithGhostBoundaries(mg.center(),xy);
  realSerialArray jacLocal; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg.centerJacobian(),jacLocal);
  realSerialArray ff;    getLocalArrayWithGhostBoundaries(f,ff); 

  if( debug & 16 )
  {
    fprintf(pDebugFile,"\n **** grid=%i p=%i assignBC: gid=[%i,%i][%i,%i][%i,%i] bc=[%i,%i][%i,%i][%i,%i]"
	    " bcg=[%i,%i][%i,%i][%i,%i]******\n\n",grid,Communication_Manager::My_Process_Number,
	    gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2),
	    bc(0,0),bc(1,0),bc(0,1),bc(1,1),bc(0,2),bc(1,2),
	    bcg(0,0),bcg(1,0),bcg(0,1),bcg(1,1),bcg(0,2),bcg(1,2));
	  
	  
    fprintf(pDebugFile,"\n **** uu=[%i,%i] xy=[%i,%i] rsxy=[%i,%i]\n",
	    uu.getBase(0),uu.getBound(0),xy.getBase(0),xy.getBound(0),rx.getBase(0),rx.getBound(0));
	  
  }
	
        
#else
  const realSerialArray & uu    = u;
  const realSerialArray & uuOld = uOld;
  const realSerialArray & ff    = f;
  const intSerialArray  & mask  = mg.mask();

  const realSerialArray & rx = !isRectangular? mg.inverseVertexDerivative() : uu;
  const realSerialArray & xy = centerNeeded ? mg.center() : uu;
  const realSerialArray & jacLocal=mg.centerJacobian();

  const IntegerArray & gid = mg.gridIndexRange();
  const IntegerArray & dim = mg.dimension();
  const IntegerArray & bc = mg.boundaryCondition();
	
  if( debug & 16 )
  {
    const IntegerArray & bcg = mg.boundaryCondition();
    fprintf(pDebugFile,"\n **** grid=%i p=%i assignBC: gid=[%i,%i][%i,%i][%i,%i] bc=[%i,%i][%i,%i][%i,%i]"
	    " bcg=[%i,%i][%i,%i][%i,%i]******\n\n",grid,Communication_Manager::My_Process_Number,
	    gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2),
	    bc(0,0),bc(1,0),bc(0,1),bc(1,1),bc(0,2),bc(1,2),
	    bcg(0,0),bcg(1,0),bcg(0,1),bcg(1,1),bcg(0,2),bcg(1,2));
  }
	
#endif
        

  real *uptr   = uu.getDataPointer();
  real *fptr   = ff.getDataPointer();
  int *maskptr = mask.getDataPointer();
  real *rxptr  = rx.getDataPointer();
  real *xyptr  = centerNeeded ? xy.getDataPointer() : uptr;
  assert( xyptr!=NULL );
  real *jacptr = !isRectangular ? jacLocal.getDataPointer() : uptr;



  // Do this for now -- assumes all sides are PML
  bool usePML = (bc(0,0)==SmParameters::abcPML || bc(1,0)==SmParameters::abcPML ||
		 bc(0,1)==SmParameters::abcPML || bc(1,1)==SmParameters::abcPML ||
		 bc(0,2)==SmParameters::abcPML || bc(1,2)==SmParameters::abcPML);
      

  // *** need to fix gridIndex Range and bc ***********************

  if( debug & 16 )
  {
    ::display(uu,sPrintF("uu before bcOptSolidMechanics, t=%e",t),pDebugFile,"%8.1e ");
  }
      
  if( !isRectangular && debug & 16  ) ::display(rx,sPrintF("rx before bcOptSolidMechanics, t=%e",t),debugFile,"%9.2e ");


  // The next macro is in boundaryMacros.h
  extractBoundaryDataArrays()

  // Macro to extract the pointers to the variable material property arrays
  getVariableMaterialPropertyPointers(maskptr,uptr);


  ipar[0]=numberOfDimensions;
  ipar[1] = grid;
  ipar[2] = uc;
  ipar[3] = vc;
  ipar[4] = wc;
  ipar[5] = gridType;
  ipar[6] = orderOfAccuracyInSpace;
  ipar[7] = orderOfExtrapolation;
  ipar[8] = int(forcingOption==twilightZoneForcing);  // twilightZone *wdh* 090813
  ipar[9] = useWhereMask;
  ipar[10]= debug; 
  ipar[11]=parameters.dbase.get<int >("pdeTypeForGodunovMethod");
  ipar[12]=parameters.dbase.get<int>("applyInterfaceBoundaryConditions");
  ipar[13]=parameters.dbase.get<bool>("projectInterface");
  ipar[14]=numberToPin;

  ipar[15]=(int)materialFormat;

  rpar[ 0]=dx[0];
  rpar[ 1]=dx[1];
  rpar[ 2]=dx[2];
  rpar[ 3]=mg.gridSpacing(0);
  rpar[ 4]=mg.gridSpacing(1);
  rpar[ 5]=mg.gridSpacing(2);
  rpar[ 6]=t;
  OGFunction *& tz = parameters.dbase.get<OGFunction* >("exactSolution");
  rpar[ 7]=(real &)tz;  // twilight zone pointer, ep
  rpar[ 8]=dt;
  rpar[ 9]=mu;
  rpar[10]=lambda;
  rpar[11]=c1;
  rpar[12]=c2;


  int ierr=0;
  const int bc0=-1;  // do all boundaries.
  if( !usePML ) // *** fix this ***
  {
    DataBase *pdb = &parameters.dbase;
    bcOptSmFOS( numberOfDimensions, 
		uu.getBase(0),uu.getBound(0),
		uu.getBase(1),uu.getBound(1),
		uu.getBase(2),uu.getBound(2),
		gid(0,0), *uptr, *maskptr, *rxptr, *xyptr, 
                ndMatProp,*matIndexPtr,*matValPtr,*matValPtr, 
                *jacptr, *bc.getDataPointer(),
		*pAddBoundaryForcing,*interfaceType.getDataPointer(),*pdbc, 
		*pbcf[0][0],*pbcf[1][0], *pbcf[0][1],*pbcf[1][1], *pbcf[0][2],*pbcf[1][2],
		*pbcf[0][0],pbcfOffset[0],
		pinBoundaryCondition.getLength(0),*pinBoundaryCondition.getDataPointer(),
                pinValues.getLength(0),*pinValues.getDataPointer(),
		ipar[0], rpar[0], pdb, ierr );
    
  }
  
 
  if( debug & 16  ) ::display(uu,sPrintF("uu after bcOptSolidMechanics, t=%e",t),pDebugFile,"%8.1e ");

  real *uOldptr = uuOld.getDataPointer();
      
      
} // end use opt
#endMacro    


// =============================================================
// Macro to apply BC's for special solutions (known solutions)
// =============================================================
#beginMacro assignSpecialSolutionBoundaryConditions()

{

//   printF("assignBCFOS: applySpecialSolutionBoundaryConditions=%i, t=%8.2e\n",
//          (int)applySpecialSolutionBoundaryConditions,t);

  if( applySpecialSolutionBoundaryConditions )
  {
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter );

    const realArray & x = mg.center();
    const bool isRectangular = mg.isRectangular();
    real dx[3]={0.,0.,0.}; //

    if( isRectangular )
      mg.getDeltaX(dx);
    
    OV_GET_SERIAL_ARRAY(real,u,uLocal);
    OV_GET_SERIAL_ARRAY_CONST(real,x,xLocal);
    
    const IntegerArray & bcg = mg.boundaryCondition();
    IntegerArray gid, dim, bc;
    getLocalBoundsAndBoundaryConditions( u, gid, dim, bc );


    Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
    Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
    Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];

    const int & s11c = parameters.dbase.get<int>("s11c");
    const int & s12c = parameters.dbase.get<int>("s12c");
    const int & s13c = parameters.dbase.get<int>("s13c");

    for( int axis=axis1; axis<mg.numberOfDimensions(); axis++ )
    {
      for( int side=Start; side<=End; side++ )
      {
	if( knownSolution==Parameters::userDefinedKnownSolution && 
            (mg.boundaryCondition(side,axis)==SmParameters::tractionBC ||
             mg.boundaryCondition(side,axis)==SmParameters::displacementBC ) 
            && interfaceType(side,axis,grid)==Parameters::noInterface )
        {
          // *wdh* April 29, 2018 -- put this here for now 

          getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);

          // -- here is where the boundary data is put:
    	  RealArray & bd = parameters.getBoundaryData(side,axis,grid,mg);
      
          Range Rx=numberOfDimensions, C=numberOfDimensions;
          RealArray state(Ib1,Ib2,Ib3,C);
          int bodyNumber=0; // fix me for multiple deforming bodies
          if( mg.boundaryCondition(side,axis)==SmParameters::tractionBC )
          {
            // =========== TRACTION BC ===========
            printF("--SM-- set TRACTION BC FROM KNOWN SOLUTION at t=%9.3e\n",t);
          
            parameters.getUserDefinedDeformingBodyKnownSolution( 
              bodyNumber,Parameters::boundaryTraction,t, grid, mg,Ib1,Ib2,Ib3,C, state );
            // ::display(state,"exact traction on bndry","%.2f ");

            bd(Ib1,Ib2,Ib3,Range(uc,uc +numberOfDimensions-1))=state; // set traction on the boundary
            // Is hthis needed?
          
            bd(Ib1,Ib2,Ib3,s11c)=state(Ib1,Ib2,Ib3,0); 
            bd(Ib1,Ib2,Ib3,s12c)=state(Ib1,Ib2,Ib3,1); 
            if( numberOfDimensions==3 )
              bd(Ib1,Ib2,Ib3,s13c)=state(Ib1,Ib2,Ib3,2); 

            parameters.getUserDefinedDeformingBodyKnownSolution( 
              bodyNumber,Parameters::boundaryTractionRate,t, grid, mg,Ib1,Ib2,Ib3,C, state );
            bd(Ib1,Ib2,Ib3,Range(v1c,v1c+numberOfDimensions-1))=state;  // set traction-rate on the bndry
          }
          else if( mg.boundaryCondition(side,axis)==SmParameters::displacementBC )
          {
            // ========== DISPLACEMENT BC =============
            printF("--SM-- set DISPLACEMENT BC FROM KNOWN SOLUTION at t=%9.3e\n",t);

            parameters.getUserDefinedKnownSolution( t, cg, grid, bd, Ib1,Ib2,Ib3 );

            // -- evaluate the acceleration and save in "stress" [s11c,s12c,s13c]
            RealArray state(Ib1,Ib2,Ib3,bd.dimension(3));
            int numberOfTimeDerivatives=1;
            parameters.getUserDefinedKnownSolution( t, cg, grid, state, Ib1,Ib2,Ib3,numberOfTimeDerivatives );
            bd(Ib1,Ib2,Ib3,s11c)=state(Ib1,Ib2,Ib3,v1c); // this is really the acceleration
            bd(Ib1,Ib2,Ib3,s12c)=state(Ib1,Ib2,Ib3,v1c+1); 
            if( numberOfDimensions==3 )
              bd(Ib1,Ib2,Ib3,s13c)=state(Ib1,Ib2,Ib3,v1c+2); 

            // *** FIX ACCELERATION***

            // OV_GET_SERIAL_ARRAY(real,mg.center(),xLocal);
            
            // parameters.getUserDefinedDeformingBodyKnownSolution( 
            //   bodyNumber,Parameters::boundaryPosition,t, grid, mg,Ib1,Ib2,Ib3,C, state );
            // Range Uc=Range(uc,uc +numberOfDimensions-1);
            // bd(Ib1,Ib2,Ib3,Uc)=state-xLocal(Ib1,Ib2,Ib3,Rx); // set displacement on the boundary

            // parameters.getUserDefinedDeformingBodyKnownSolution( 
            //   bodyNumber,Parameters::boundaryVelocity,t, grid, mg,Ib1,Ib2,Ib3,C, state );
            // bd(Ib1,Ib2,Ib3,Range(v1c,v1c +numberOfDimensions-1))=state; // set displacement on the boundary

            // parameters.getUserDefinedDeformingBodyKnownSolution( 
            //   bodyNumber,Parameters::boundaryAcceleration,t, grid, mg,Ib1,Ib2,Ib3,C, state );
            // // put acceleration here:         
            // bd(Ib1,Ib2,Ib3,s11c)=state(Ib1,Ib2,Ib3,0); 
            // bd(Ib1,Ib2,Ib3,s12c)=state(Ib1,Ib2,Ib3,1); 
            // if( numberOfDimensions==3 )
            //   bd(Ib1,Ib2,Ib3,s13c)=state(Ib1,Ib2,Ib3,2); 

          }
          else
          {
            OV_ABORT("ERROR- this should not happen");
          }
          

        }
        else if( mg.boundaryCondition(side,axis)==SmParameters::dirichletBoundaryCondition )
	{
	  int numberOfGhostLines = max(2,orderOfAccuracyInSpace/2);  // for godunov we need 2 ghost lines
	  int extra=numberOfGhostLines;
	  getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3,extra);

	  // for now assign dirichlet at ghost lines too.
	  Iv[axis] = side==0 ? Range(Iv[axis].getBase()-numberOfGhostLines,Iv[axis].getBound()) : 
	    Range(Iv[axis].getBase(),Iv[axis].getBound()+numberOfGhostLines);
	      
	  if( mg.boundaryCondition(side,axis)==SmParameters::interfaceBoundaryCondition )
	  { // do not include the boundary
	    Iv[axis] = side==0 ? Range(Iv[axis].getBase(),Iv[axis].getBound()-1) : 
	      Range(Iv[axis].getBase()+1,Iv[axis].getBound());
	  }

	  const int includeGhost=1;
	  bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
	  if( !ok ) continue;

	  real *up = uLocal.Array_Descriptor.Array_View_Pointer3;
	  const int uDim0=uLocal.getRawDataSize(0);
	  const int uDim1=uLocal.getRawDataSize(1);
	  const int uDim2=uLocal.getRawDataSize(2);
#undef U
#define U(i0,i1,i2,i3) up[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]
	  real *xp = xLocal.Array_Descriptor.Array_View_Pointer3;
	  const int xDim0=xLocal.getRawDataSize(0);
	  const int xDim1=xLocal.getRawDataSize(1);
	  const int xDim2=xLocal.getRawDataSize(2);
#undef X
#define X(i0,i1,i2,i3) xp[i0+xDim0*(i1+xDim1*(i2+xDim2*(i3)))]

	  if( specialInitialConditionOption == "travelingWave" )
	  {
	    // --- traveling wave solution ---
	    bool evalSolution = true;
	    // macro: 
	    getTravelingWaveSolution(evalSolution,U,U,X,t,I1,I2,I3);
	  }
	  else if( specialInitialConditionOption == "planeTravelingWave" )
	  {
	    // --- traveling sine wave solution ---
	    bool evalSolution = true;
	    // macro: 
	    getPlaneTravelingWaveSolution(evalSolution,U,U,X,t,I1,I2,I3);
	  }
	  else if( specialInitialConditionOption == "translationAndRotation" )
	  {
	    // Here is the solution for large translation and rotation 
	    bool evalSolution = true;
	    // macro: 
	    getTranslationAndRotationSolution(evalSolution,U,U,X,t,I1,I2,I3);
	  }
	  else if( specialInitialConditionOption == "RayleighWave" )
	  {
	    // --- Rayleigh wave solution ---
	    bool evalSolution = true;
	    // macro: 
	    getRayleighWaveSolution(evalSolution,U,U,X,t,I1,I2,I3);
	  }
	  else if( specialInitialConditionOption == "pistonMotion" )
	  {
	    // --- piston motion (for FSI) ---
	    bool evalSolution = true;
	    getPistonMotionSolution(evalSolution,U,U,X,t,I1,I2,I3);
	  }
          else if( initialConditionOption == knownSolutionInitialCondition )
	  {
            // Assign dirichlet BC from know solution *wdh* 2014/01/09 
	    parameters.getUserDefinedKnownSolution(t,cg, grid, uLocal, I1,I2,I3 );
	  }
	  else
	  {
	    printF("assignBoundaryConditionsFOS:ERROR: unknown specialInitialConditionOption=%s\n",
                   (const char*)specialInitialConditionOption);
	    OV_ABORT("error");
	  }
	 

	}
      }
    }
  }
}
#endMacro
// end macro assignSpecialSolutionBoundaryConditions


// =========================================================================================================
/// \brief Apply boundary conditions for the First-Order-System.
///
///  \param option: 
///
// Note: uOld = u[current]
///
// =========================================================================================================
void Cgsm::
assignBoundaryConditionsFOS( int option, int grid, real t, real dt, realMappedGridFunction & u, 
			     realMappedGridFunction & uOld, int current )
{

  SmParameters::PDEVariation & pdeVariation = parameters.dbase.get<SmParameters::PDEVariation>("pdeVariation");
  if( pdeVariation==SmParameters::hemp )
  {
    // *************** for now we do not apply BC's for hemp  ********************
    // For Hemp we should fill in the boundaryData array

    return;
  }
  
  if(  (debug() & 2 && t<3.*dt) )
    printP("***** assignBoundaryConditionsFOS: grid=%i t=%.3e ******\n",grid,t);

  FILE *& debugFile  =parameters.dbase.get<FILE* >("debugFile");
  FILE *& logFile    =parameters.dbase.get<FILE* >("logFile");
  FILE *& pDebugFile =parameters.dbase.get<FILE* >("pDebugFile");

  const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;

  SmParameters::PDEModel & pdeModel = parameters.dbase.get<SmParameters::PDEModel>("pdeModel");

  const int & numberOfComponents = parameters.dbase.get<int >("numberOfComponents");
  const int & uc =  parameters.dbase.get<int >("uc");
  const int & vc =  parameters.dbase.get<int >("vc");
  const int & wc =  parameters.dbase.get<int >("wc");
  const int & rc =  parameters.dbase.get<int >("rc");
  const int & tc =  parameters.dbase.get<int >("tc");

  const int & u1c = parameters.dbase.get<int >("u1c");
  const int & u2c = parameters.dbase.get<int >("u2c");
  const int & u3c = parameters.dbase.get<int >("u3c");

  const int & v1c =  parameters.dbase.get<int >("v1c");
  const int & v2c =  parameters.dbase.get<int >("v2c");
  const int & v3c =  parameters.dbase.get<int >("v3c");

  const int & orderOfAccuracyInSpace = parameters.dbase.get<int>("orderOfAccuracy");
  const int & orderOfAccuracyInTime  = parameters.dbase.get<int>("orderOfTimeAccuracy");

  real & rho=parameters.dbase.get<real>("rho");
  real & mu = parameters.dbase.get<real>("mu");
  real & lambda = parameters.dbase.get<real>("lambda");
  RealArray & muGrid = parameters.dbase.get<RealArray>("muGrid");
  RealArray & lambdaGrid = parameters.dbase.get<RealArray>("lambdaGrid");
  // bool & gridHasMaterialInterfaces = parameters.dbase.get<bool>("gridHasMaterialInterfaces");
  int & debug = parameters.dbase.get<int >("debug");

  const Parameters::KnownSolutionsEnum & knownSolution = 
    parameters.dbase.get<Parameters::KnownSolutionsEnum >("knownSolution"); 


  const bool projectInterface = parameters.dbase.get<bool>("projectInterface");
  if( projectInterface )
  {
    if( debug & 2 )
      printP("*** assignBoundaryConditionsFOS: projectInterface = %i ***\n",projectInterface);
  }

  lambda = lambdaGrid(grid);
  mu = muGrid(grid);
  c1=(mu+lambda)/rho, c2= mu/rho;

  //   const real cc= c*sqrt( kx*kx+ky*ky );

  MappedGrid & mg = *u.getMappedGrid();
  MappedGridOperators & mgop = (*cgop)[grid];
  
  const int numberOfDimensions = mg.numberOfDimensions();
  
  // The RHS for BC's are saved in these next two objects:
  const RealArray & bcData = parameters.dbase.get<RealArray>("bcData");
  BoundaryData::BoundaryDataArray & pBoundaryData = parameters.getBoundaryData(grid);

  // The interfaceType(side,axis,grid) defines which faces are interfaces.
  const IntegerArray & interfaceType = parameters.dbase.get<IntegerArray >("interfaceType");

  Range all;
  BoundaryConditionParameters bcParams;            
  BoundaryConditionParameters extrapParams;

  Range C=numberOfComponents;

  Range U=Range(uc,uc+numberOfDimensions-1);   // displacements
  Range V=Range(v1c,v1c+numberOfDimensions-1);  // velocities

  bool assignDisplacementBC=false;
  bool assignTractionBC=false;
  bool assignSlipWall=false;
  bool assignDirichletBC=true;
  bool assignSymmetryBC=true;
  for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
  {
    for( int side=0; side<=1; side++ )
    {
      int bc=mg.boundaryCondition(side,axis);
      switch (bc)
      {
      case 0 : break;
      case -1: break;
      case SmParameters::displacementBC:              assignDisplacementBC=true; break;
      case SmParameters::tractionBC:                  assignTractionBC=true; break;
      case SmParameters::slipWall:                    assignSlipWall=true; break;
      case SmParameters::dirichletBoundaryCondition:  assignDirichletBC=true; break;
      case SmParameters::symmetry:                    assignSymmetryBC=true; break;
      default: 
        printf("assignBCFOS: unknown boundary condition =%i on grid %i, side=%i, axis=%i\n",bc,grid,side,axis);
        OV_ABORT("error");
      break;
      }
    }
  }

  if( false && numberOfDimensions == 3 )
  {
    printF("********** assignBoundaryConditionsFOS: DO NOTHING *************\n");
    return;
  }
  

  if( forcingOption==twilightZoneForcing )
  {
    // assign exact values on dirichletBoundaryCondition boundaries for TZ
    // printF(" assignBoundaryConditionsFOS: set exact BC's on dirichletBoundaryCondition's and ghost pts...\n");
    
    // assign the boundary and 2 ghost with the exact solution
    int numGhost=max(orderOfAccuracyInSpace/2,2);
    extrapParams.extraInTangentialDirections=numGhost;
    
    for( int g=0; g<=numGhost; g++ )
    {
      extrapParams.lineToAssign=g;
      u.applyBoundaryCondition(C,BCTypes::dirichlet,SmParameters::dirichletBoundaryCondition,0.,t,extrapParams);
    }
    // reset 
    extrapParams.extraInTangentialDirections=0;
    extrapParams.lineToAssign=1;

  }


  // **** now call the optimized BC routine *****


  const real dtb2=dt*.5;

  const realArray & x = mg.center();

  const bool isRectangular = mg.isRectangular();

  // const bool isRectangular=false; // ********** do this for now for Don ***************

  real dx[3]={0.,0.,0.}; //

  if( isRectangular )
  {
    mg.getDeltaX(dx);
  }
  if( !isRectangular )
  {
    mg.update( MappedGrid::THEinverseVertexDerivative | 
	       MappedGrid::THEinverseCenterDerivative |
               MappedGrid::THEcenterJacobian );  
  }

  // Hemp: here is where we store the initial state (mass,density,energy)
  realMappedGridFunction *pstate0 = NULL;
  if( pdeVariation == SmParameters::hemp )
  {
    assert( parameters.dbase.get<realCompositeGridFunction*>("initialStateGridFunction")!=NULL );
    pstate0 = &(*(parameters.dbase.get<realCompositeGridFunction*>("initialStateGridFunction")))[grid];
  }
  realMappedGridFunction & state0 = *pstate0;

  const aString & specialInitialConditionOption = parameters.dbase.get<aString>("specialInitialConditionOption");
  const bool applySpecialSolutionBoundaryConditions = specialInitialConditionOption != "default" ||
                                                      initialConditionOption == knownSolutionInitialCondition;

  const bool centerNeeded = applySpecialSolutionBoundaryConditions;

  #ifdef USE_PPP
   realSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
   realSerialArray det;  
   if( pdeVariation == SmParameters::hemp ) 
     getLocalArrayWithGhostBoundaries(mg.centerJacobian(),det);
   realSerialArray xLocal; if( centerNeeded ) getLocalArrayWithGhostBoundaries(x,xLocal);
   realSerialArray state0Local;
   if( pdeVariation == SmParameters::hemp )
     getLocalArrayWithGhostBoundaries(state0,state0Local);

  #else
   const realSerialArray & uLocal = u;
   const realSerialArray & xLocal = x;
   const realSerialArray & det = mg.centerJacobian();
   realSerialArray & state0Local = *pstate0;
  #endif

  
  const IntegerArray & bcg = mg.boundaryCondition();
  IntegerArray gid, dim, bc;
  getLocalBoundsAndBoundaryConditions( u, gid, dim, bc );


  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];


  // ---- apply boundary conditions for special solutions ----------
  assignSpecialSolutionBoundaryConditions();
  
  bool useOpt=true; 
  int side,axis;


  u.periodicUpdate();

  if( specialInitialConditionOption == "translationAndRotation" ) 
  { // *************** *wdh* 090807 for now do not apply real BC's for this special IC
    return;
  }
   


  // ---------------------------------------------------------
  // ---------- Apply the (optimized) real BC's --------------
  // ---------------------------------------------------------

  optimizedBoundaryConditionsMacro();


   // *wdh* 090824 -- moved from above 
  if( parameters.dbase.get<int >("extrapolateInterpolationNeighbours") &&
      parameters.dbase.get<int>("useNewExtrapInterpNeighbours") )
  {
    // *new way* 091123 -- MappedGridOperators uses new AssignInterpNeighbours class

    // -- See op/tests/testExtrapInterpNeighbours for proper way to apply --
    if( debug & 4 )
      printF("assignBC-FOS: Use new extrapolateInterpolationNeighbours at t=%g\n",t);

    extrapParams.orderOfExtrapolation=parameters.dbase.get<int >("orderOfExtrapolationForInterpolationNeighbours");
    u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,extrapParams);


    const int & setGhostByExtrapolation = parameters.dbase.get<int>("setGhostByExtrapolation");
    if( setGhostByExtrapolation )
    {
      // ---- SET ALL GHOST BY EXTRAPOLATION : OVERWRITE bcOptSmFOS -----
      // For testing FSI -- added July 18, 2018 *wdh*

      if( debug & 8 )
        printF("---SM-- SET ALL GHOST BY EXTRAPOLATION \n");

      for( int ghost=1; ghost<=2; ghost++ )
      {
        extrapParams.ghostLineToAssign=ghost;
        extrapParams.extraInTangentialDirections=ghost;

        u.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);
      }
      // reset 
      extrapParams.ghostLineToAssign=1;
      extrapParams.extraInTangentialDirections=0;

      u.periodicUpdate();
      u.updateGhostBoundaries();

    }
    else if( true )
    {
      // these are both needed:  (see op/src/fixBoundaryCorners.C)
      u.periodicUpdate();
      u.updateGhostBoundaries();
    }
    else if( false )  // *wdh* 2012/09/04 TURN THIS OFF: --  bcOptSmFOS will set 2nd ghost and corners --
    {  
      // extrap 2nd ghost line extended
      extrapParams.ghostLineToAssign=2;
      extrapParams.extraInTangentialDirections=2;

      u.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);

      // reset 
      extrapParams.ghostLineToAssign=1;
      extrapParams.extraInTangentialDirections=0;

      // NOTE: We must also call finishBoundaryConditions to fix corners and update ghosts 

      // We really only want to set 2nd ghost line corner points! *********** FIX ME ************************

      u.finishBoundaryConditions();
    }
     
  }
  else if( parameters.dbase.get<int >("extrapolateInterpolationNeighbours") )
  {
    // extrapolate the 2nd ghost line and interpolation neighbours for higher-order dissipation
    // -- is this the right place to do this ? 
    extrapParams.ghostLineToAssign=2;
    extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;

    // extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace;  // *wdh* ***********081111

    u.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);
    extrapParams.ghostLineToAssign=1;
    
    // printF(" extrapolateInterpolationNeighbours at t=%g\n",t);
    // *wdh* 091012 -- add extrapParams
    // extrapParams.orderOfExtrapolation=2;
    u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,extrapParams);
  }

   if( !parameters.dbase.get<int>("useNewExtrapInterpNeighbours")  )
   {
     // old way 091123
     u.periodicUpdate();
   }
   
   // if( true )
   // {
   //   if( grid==1 )
   //   {
   //     ::display(u,sPrintF("--SM-- after assign FOS BC at t=%.2e",t),debugFile,"%.2e ");
   //   }
   // }
   
  // u.finishBoundaryConditions();
}

