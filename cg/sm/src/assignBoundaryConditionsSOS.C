// This file automatically generated from assignBoundaryConditionsSOS.bC with bpp.
#include "Cgsm.h"
#include "SmParameters.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "RadiationBoundaryCondition.h"
#include "ParallelUtility.h"
#include "GridMaterialProperties.h"

#define bcOptSM EXTERN_C_NAME(bcoptsm)
#define bcOptSmCons EXTERN_C_NAME(bcoptsmcons)
#define abcSolidMechanics EXTERN_C_NAME(abcsolidmechanics)
#define exmax EXTERN_C_NAME(exmax)

// ==================================================
// ============= include forcing macros =============
// ==================================================
// ==================================================================================
// Macro to evaluate the traveling (shock) wave solution
// 
// evalSolution : true=eval solution, false=eval error
// ==================================================================================

// ==================================================================================
// Macro to evaluate the traveling (sine) wave solution
// 
// evalSolution : true=eval solution, false=eval error
// ==================================================================================


// ==========================================================================
//  Define a Rayleigh surface wave: (see cgDoc/sm/notes.pdf)
//     u1 = SUM_n a_n [ exp(-b1(k_n)*y + ...  ] cos( 2*pi*k_n (x-c*t) )
//     u2 = SUM_n a_n [                       ] sin( 2*pi*k_n (x-c*t) )
//
//  Here we assume that the solid occupies the space y<= ySurf
// where ySurf is given by the user. 
// ==========================================================================

// =======================================================================================
//  The function "fg" is basically the integral appearing in the D'Alambert solution
// ======================================================================================


// ===========================================================
// Evaluate the D'Alambert function "f" and it's derivative
//  Here we assume that u(x,0)=0 and v(x,0)!=0  
// ===========================================================

// ===========================================================
// Evaluate the D'Alambert function "g"
//  Here we assume that u(x,0)=0 and v(x,0)!=0  
// ===========================================================



// ==========================================================================
//  Define the pistonMotion solution (see cgDoc/mp/fluidStructure/fsm.tex)
// ==========================================================================








//   (Ex).t = (1/eps)*[  (Hz).y ]
//   (Ey).t = (1/eps)*[ -(Hz).x ]
//   (Hz).t = (1/mu) *[ (Ex).y - (Ey).x ]

#define exTrue(x,y,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*(-ky/(eps*cc))
#define eyTrue(x,y,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*( kx/(eps*cc))
#define hzTrue(x,y,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))

#define exLaplacianTrue(x,y,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*(+ky*(twoPi*twoPi*(kx*kx+ky*ky))/(eps*cc))
#define eyLaplacianTrue(x,y,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*(-kx*(twoPi*twoPi*(kx*kx+ky*ky))/(eps*cc))
#define hzLaplacianTrue(x,y,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*( -(twoPi*twoPi*(kx*kx+ky*ky) ) )

// define eyTrue(x,y,t) exp( -beta*SQR((x-x0)-c*(t)) )

// Here is a plane wave with the shape of a Gaussian
// xi = kx*(x)+ky*(y)-cc*(t)
// cc=  c*sqrt( kx*kx+ky*ky );
#define hzGaussianPulse(xi)  exp(-betaGaussianPlaneWave*((xi)*(xi)))
#define exGaussianPulse(xi)  hzGaussianPulse(xi)*(-ky/(eps*cc))
#define eyGaussianPulse(xi)  hzGaussianPulse(xi)*( kx/(eps*cc))

#define hzLaplacianGaussianPulse(xi)  ((4.*betaGaussianPlaneWave*betaGaussianPlaneWave*(kx*kx+ky*ky))*xi*xi-(2.*betaGaussianPlaneWave*(kx*kx+ky*ky)))*exp(-betaGaussianPlaneWave*((xi)*(xi)))
#define exLaplacianGaussianPulse(xi)  hzLaplacianGaussianPulse(xi,t)*(-ky/(eps*cc))
#define eyLaplacianGaussianPulse(xi)  hzLaplacianGaussianPulse(xi,t)*( kx/(eps*cc))

// 3D
// E:
//   u.tt = (1/eps)*[ ((1/mu)*u.x).x + ((1/mu)*u.y).y + ((1/mu)*u.z).z ]
//   div(u)=0
// H
//   v.tt = (1/mu)*[ ((1/eps)*v.x).x + ((1/eps)*v.y).y + ((1/eps)*v.z).z ]
// Define macros for forcing functions


//
//   (Ex).t = (1/eps)*[ (Hz).y - (Hy).z ]
//   (Ey).t = (1/eps)*[ (Hx).z - (Hz).x ]
//   (Ez).t = (1/eps)*[ (Hy).x - (Hx).y ]
//   (Hx).t = (1/mu) *[ (Ey).z - (Ez).y ]
//   (Hy).t = (1/mu) *[ (Ez).x - (Ex).z ]
//   (Hz).t = (1/mu) *[ (Ex).y - (Ey).x ]

// ****************** finish this -> should `rotate' the 2d solution ****************

#define exTrue3d(x,y,z,t) sin(twoPi*(kx*(x)+ky*(y)+kz*(z)-cc*(t)))*(-ky/(eps*cc))
#define eyTrue3d(x,y,z,t) sin(twoPi*(kx*(x)+ky*(y)+kz*(z)-cc*(t)))*( kx/(eps*cc))
#define ezTrue3d(x,y,z,t) 0

#define hxTrue3d(x,y,z,t) 0
#define hyTrue3d(x,y,z,t) 0
#define hzTrue3d(x,y,z,t) sin(twoPi*(kx*(x)+ky*(y)+kz*(z)-cc*(t)))

#define exLaplacianTrue3d(x,y,z,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*(+ky*(twoPi*twoPi*(kx*kx+ky*ky))/(eps*cc))
#define eyLaplacianTrue3d(x,y,z,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*(-kx*(twoPi*twoPi*(kx*kx+ky*ky))/(eps*cc))
#define ezLaplacianTrue3d(x,y,z,t) 0

#define hxLaplacianTrue3d(x,y,z,t) 0
#define hyLaplacianTrue3d(x,y,z,t) 0
#define hzLaplacianTrue3d(x,y,z,t) sin(twoPi*(kx*(x)+ky*(y)-cc*(t)))*( -(twoPi*twoPi*(kx*kx+ky*ky) ) )


// ------------ macros for the plane material interface -------------------------


// OPTION: initialCondition, error, boundaryCondition

//==================================================================================================
// Evaluate Tom Hagstom's exact solution defined as an integral of Guassian sources
// 
// OPTION: OPTION=solution or OPTION=error OPTION=bounary to compute the solution or the error or
//     the boundary condition
//
//==================================================================================================
// ==================================================================================
// Macro to evaluate the translation and rotation solution
// 
// evalSolution : true=eval solution, false=eval error
// ==================================================================================
// ===================================================================================
//   This macro extracts the boundary data arrays
// ===================================================================================

// ===============================================================================================
// This macro determines the pointers to the variable material properties that are
// used when calling fortran routines.
// ===============================================================================================

extern "C"
{
    void bcOptSM(const int&nd,
                              const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                              const int& gridIndexRange,real& u, const int&mask,const real&rsxy, const real&xy, 
                              const int & ndMatProp, const int& matIndex, const real& matValpc, const real& matVal,
                              const int&boundaryCondition, const int&addBoundaryForcing, 
                              const int& interfaceType, const int&dim,
                              const real & bcf00, const real & bcf10, 
                              const real & bcf01, const real & bcf11, 
                              const real & bcf02, const real & bcf12, 
                              const real & bcf0, const int64_t & bcfOffset,
                              const int&ipar, const real&rpar, const int&ierr );
    void bcOptSmCons(const int&nd,
                              const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                              const int& gridIndexRange,real& u, const int&mask,const real&rsxy, const real&xy, 
                              const int & ndMatProp, const int& matIndex, const real& matValpc, const real& matVal,
                              const int&boundaryCondition, const int&addBoundaryForcing, 
                              const int& interfaceType, const int&dim,
                              const real & bcf00, const real & bcf10, 
                              const real & bcf01, const real & bcf11, 
                              const real & bcf02, const real & bcf12,
                              const real & bcf0, const int64_t & bcfOffset,
                              const int&ipar, const real&rpar, const int&ierr );
}

extern "C"
{
    void abcSolidMechanics(const int&nd,
                                              const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                                              const int&ndf1a,const int&ndf1b,const int&ndf2a,const int&ndf2b,const int&ndf3a,const int&ndf3b,
                                              const int & gid,
                                              const real&u, const real&un, const real&f, const int&mask, const real&rsxy, const real&xy,
                                              const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );

//   void exmax(double&Ez,double&Bx,double&By,const int &nsources,const double&xs,const double&ys,
//            const double&tau,const double&var,const double&amp, const double&a,
//            const double&x,const double&y,const double&time);
}

#define pmlSolidMechanics EXTERN_C_NAME(pmlsolidmechanics)

extern "C"
{
  void pmlSolidMechanics(const int&nd,
            const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
            const int&ndf1a,const int&ndf1b,const int&ndf2a,const int&ndf2b,const int&ndf3a,const int&ndf3b,
            const int & gid,
            const real&um, const real&u, const real&un, 
            const int&ndra1a,const int&ndra1b,const int&ndra2a,const int&ndra2b,const int&ndra3a,const int&ndra3b,
            const real&vram, const real&vra, const real&vran, const real&wram, const real&wra, const real&wran, 
            const int&ndrb1a,const int&ndrb1b,const int&ndrb2a,const int&ndrb2b,const int&ndrb3a,const int&ndrb3b,
            const real&vrbm, const real&vrb, const real&vrbn, const real&wrbm, const real&wrb, const real&wrbn, 
            const int&ndsa1a,const int&ndsa1b,const int&ndsa2a,const int&ndsa2b,const int&ndsa3a,const int&ndsa3b,
            const real&vsam, const real&vsa, const real&vsan, const real&wsam, const real&wsa, const real&wsan, 
            const int&ndsb1a,const int&ndsb1b,const int&ndsb2a,const int&ndsb2b,const int&ndsb3a,const int&ndsb3b,
            const real&vsbm, const real&vsb, const real&vsbn, const real&wsbm, const real&wsb, const real&wsbn, 
            const int&ndta1a,const int&ndta1b,const int&ndta2a,const int&ndta2b,const int&ndta3a,const int&ndta3b,
            const real&vtam, const real&vta, const real&vtan, const real&wtam, const real&wta, const real&wtan, 
            const int&ndtb1a,const int&ndtb1b,const int&ndtb2a,const int&ndtb2b,const int&ndtb3a,const int&ndtb3b,
            const real&vtbm, const real&vtb, const real&vtbn, const real&wtbm, const real&wtb, const real&wtbn, 
            const real&f, const int&mask, const real&rsxy, const real&xy,
            const int&bc, const int&boundaryCondition, const int&ipar, const real&rpar, int&ierr );
}

#define interfaceSolidMechanics EXTERN_C_NAME(interfacemaxwell)
#define newInterfaceSolidMechanics EXTERN_C_NAME(newinterfacemaxwell)
extern "C"
{
void interfaceSolidMechanics( const int&nd, 
                                              const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                                              const int&gridIndexRange1, real&u1, const int&mask1,const real&rsxy1, const real&xy1, 
                                              const int&boundaryCondition1, 
                                              const int&md1a,const int&md1b,const int&md2a,const int&md2b,const int&md3a,const int&md3b,
                                              const int&gridIndexRange2, real&u2, const int&mask2,const real&rsxy2, const real&xy2, 
                                              const int&boundaryCondition2,
                                              const int&ipar, const real&rpar, 
                                              real&aa2, real&aa4, real&aa8, 
                                              int&ipvt2, int&ipvt4, int&ipvt8,
                                              int&ierr );
void newInterfaceSolidMechanics( const int&nd, 
                                              const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                                              const int&gridIndexRange1, real&u1, const int&mask1,const real&rsxy1, const real&xy1, 
                                              const int&boundaryCondition1, 
                                              const int&md1a,const int&md1b,const int&md2a,const int&md2b,const int&md3a,const int&md3b,
                                              const int&gridIndexRange2, real&u2, const int&mask2,const real&rsxy2, const real&xy2, 
                                              const int&boundaryCondition2,
                                              const int&ipar, const real&rpar, int&ierr );
}


static FILE *localDebugFile=NULL;

extern "C"
{

/* This function is used to update ghost boundaries of a P++ array from fortran  */
void
updateghostboundaries_(realArray *&pu )
{
  // cfprintf(localDebugFile,"**** updateGhostBoundaries called from fortran pu=%i...\n",pu);
  // realSerialArray uu;  getLocalArrayWithGhostBoundaries((*pu),uu);
  // ::display(uu,"u before (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");

    (*pu).updateGhostBoundaries();

  // Communication_Manager::Sync();
  // ::display(uu,"u after (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");
  // Communication_Manager::Sync();
}

void
updateghostandperiodic_(realMappedGridFunction *&pu )
{
  // cfprintf(localDebugFile,"**** updateGhostBoundaries called from fortran pu=%i...\n",pu);
  // realSerialArray uu;  getLocalArrayWithGhostBoundaries((*pu),uu);
  // ::display(uu,"u before (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");

    (*pu).periodicUpdate();
    (*pu).updateGhostBoundaries();

  // Communication_Manager::Sync();
  // ::display(uu,"u after (fortran) update ghost boundaries -- after stage 1",localDebugFile,"%9.5f ");
  // Communication_Manager::Sync();
} 
}

#define FOR_3D(i1,i2,i3,I1,I2,I3) int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); for(i3=I3Base; i3<=I3Bound; i3++) for(i2=I2Base; i2<=I2Bound; i2++) for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); for(i3=I3Base; i3<=I3Bound; i3++) for(i2=I2Base; i2<=I2Bound; i2++) for(i1=I1Base; i1<=I1Bound; i1++)



// =============================================================================================================
// /Description:
//    Compute a new gridIndexRange, dimension
//             and boundaryCondition array that will be valid for the local grid on a processor.
// 
//    Set the gid to match the ends of the local array.
//    Set the bc(side,axis) to -1 (periodic) for internal boundaries between processors
//
// NOTES: In parallel we cannot assume the rsxy array is defined on all ghost points -- it will not
// be set on the extra ghost points put at the far ends of the array. -- i.e. internal boundary ghost 
// points will be set but not external
// =============================================================================================================
void Cgsm::
getLocalBoundsAndBoundaryConditions( const realMappedGridFunction & a, 
                                                                          IntegerArray & gidLocal, 
                                                                          IntegerArray & dimensionLocal, 
                                                                          IntegerArray & bcLocal )
{

    MappedGrid & mg = *a.getMappedGrid();
    
    const IntegerArray & dimension = mg.dimension();
    const IntegerArray & gid = mg.gridIndexRange();
    const IntegerArray & bc = mg.boundaryCondition();
    
    gidLocal = gid;
    bcLocal = bc;
    dimensionLocal=dimension;
    
    for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
    {
//      printF(" axis=%i gidLocal(0,axis)=%i a.getLocalBase(axis)=%i  dimension(0,axis)=%i\n",axis,gidLocal(0,axis),
//                        a.getLocalBase(axis),dimension(0,axis));
//      printF(" axis=%i gidLocal(1,axis)=%i a.getLocalBound(axis)=%i dimension(0,axis)=%i\n",axis,gidLocal(1,axis),
//                        a.getLocalBound(axis),dimension(1,axis));
        if( a.getLocalBase(axis) == a.getBase(axis) ) 
        {
            assert( dimension(0,axis)==a.getLocalBase(axis) );
            gidLocal(0,axis) = gid(0,axis); 
            dimensionLocal(0,axis) = dimension(0,axis); 
        }
        else
        {
            gidLocal(0,axis) = a.getLocalBase(axis)+a.getGhostBoundaryWidth(axis);
            dimensionLocal(0,axis) = a.getLocalBase(axis); 
      // for internal ghost mark as periodic since these behave in the same was as periodic
      // ** we cannot mark as "0" since the mask may be non-zero at these points and assignBC will 
      // access points out of bounds
            bcLocal(0,axis) = -1; // bc(0,axis)>=0 ? 0 : -1;
        }
        
        if( a.getLocalBound(axis) == a.getBound(axis) ) 
        {
            assert( dimension(1,axis) == a.getLocalBound(axis) );
            
            gidLocal(1,axis) = gid(1,axis); 
            dimensionLocal(1,axis) = dimension(1,axis); 
        }
        else
        {
            gidLocal(1,axis) = a.getLocalBound(axis)-a.getGhostBoundaryWidth(axis);
            dimensionLocal(1,axis) = a.getLocalBound(axis);
      // for internal ghost mark as periodic since these behave in the same was as periodic
            bcLocal(1,axis) = -1; // bc(1,axis)>=0 ? 0 : -1;
        }
        
    }
}


// ================================================================================================
//   Get the bounds of valid interior points when there are boundaries with the PML BC
//
// /extra : an additional offset (e.g. to check errors use extra=pmlErrorOffset)
// /Return value: true if this is a PML grid and the Index Iv was changed.
// ================================================================================================
bool Cgsm::
getBoundsForPML( MappedGrid & mg, Index Iv[3], int extra /* =0 */ )
{
  // Do this for now -- assumes all sides are PML
    bool usePML = (mg.boundaryCondition(0,0)==SmParameters::abcPML || mg.boundaryCondition(1,0)==SmParameters::abcPML ||
                                  mg.boundaryCondition(0,1)==SmParameters::abcPML || mg.boundaryCondition(1,1)==SmParameters::abcPML ||
                                  mg.boundaryCondition(0,2)==SmParameters::abcPML || mg.boundaryCondition(1,2)==SmParameters::abcPML);
    
    if( !usePML ) return false;
    
  // Here is the box where we apply the interior equations when there is a PML
    Iv[2]=Range(mg.gridIndexRange(0,2),mg.gridIndexRange(1,2));
    for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
    {
        int na=mg.gridIndexRange(0,axis);
        if( mg.boundaryCondition(0,axis)==SmParameters::abcPML )
            na+=numberLinesForPML+extra;
        int nb=mg.gridIndexRange(1,axis);
        if( mg.boundaryCondition(1,axis)==SmParameters::abcPML )
            nb-=numberLinesForPML+extra;
        Iv[axis]=Range(na,nb);
    }

    return usePML;
}


// =============================================================
// Macro to apply optimized versions of BC's
// =============================================================



// =========================================================================================================
/// \brief Apply boundary conditions for the second-order-system .
///
///  \param option: 
///
///
// =========================================================================================================
void Cgsm::
assignBoundaryConditionsSOS( int option, int grid, real t, real dt, realMappedGridFunction & u, 
                                                          realMappedGridFunction & uOld, int current )
// Note: uOld = u[current]
{

    FILE *& debugFile  =parameters.dbase.get<FILE* >("debugFile");
    FILE *& logFile    =parameters.dbase.get<FILE* >("logFile");
    FILE *& pDebugFile =parameters.dbase.get<FILE* >("pDebugFile");

    localDebugFile=pDebugFile;
    
    const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
    const int next = (current+1) % numberOfTimeLevels;

    SmParameters::PDEModel & pdeModel = parameters.dbase.get<SmParameters::PDEModel>("pdeModel");

    const int & numberOfComponents = parameters.dbase.get<int >("numberOfComponents");
    const int & uc =  parameters.dbase.get<int >("uc");
    const int & vc =  parameters.dbase.get<int >("vc");
    const int & wc =  parameters.dbase.get<int >("wc");
    const int & rc =  parameters.dbase.get<int >("rc");
    const int & tc =  parameters.dbase.get<int >("tc");

    SmParameters::PDEVariation & pdeVariation = parameters.dbase.get<SmParameters::PDEVariation>("pdeVariation");

    const int & u1c = parameters.dbase.get<int >("u1c");
    const int & u2c = parameters.dbase.get<int >("u2c");
    const int & u3c = parameters.dbase.get<int >("u3c");

    const int & orderOfAccuracyInSpace = parameters.dbase.get<int>("orderOfAccuracy");
    const int & orderOfAccuracyInTime  = parameters.dbase.get<int>("orderOfTimeAccuracy");

    real & rho=parameters.dbase.get<real>("rho");
    real & mu = parameters.dbase.get<real>("mu");
    real & lambda = parameters.dbase.get<real>("lambda");
    RealArray & muGrid = parameters.dbase.get<RealArray>("muGrid");
    RealArray & lambdaGrid = parameters.dbase.get<RealArray>("lambdaGrid");
  // bool & gridHasMaterialInterfaces = parameters.dbase.get<bool>("gridHasMaterialInterfaces");
    int & debug = parameters.dbase.get<int >("debug");

    lambda = lambdaGrid(grid);
    mu = muGrid(grid);
    c1=(mu+lambda)/rho, c2= mu/rho;

//   const real cc= c*sqrt( kx*kx+ky*ky );

    MappedGrid & mg = *u.getMappedGrid();
    MappedGridOperators & mgop = (*cgop)[grid];
    
    const int numberOfDimensions = mg.numberOfDimensions();
    
  // The RHS for BC's are saved in these next two objects:
    const RealArray & bcData = parameters.dbase.get<RealArray>("bcData");
    BoundaryData::BoundaryDataArray & pBoundaryData = parameters.getBoundaryData(grid);

  // The interfaceType(side,axis,grid) defines which faces are interfaces.
    const IntegerArray & interfaceType = parameters.dbase.get<IntegerArray >("interfaceType");

    const bool & applyFilter = parameters.dbase.get<bool >("applyFilter");

    Range all;
    BoundaryConditionParameters bcParams;            
    BoundaryConditionParameters extrapParams;

    Range C=numberOfComponents;


  // *wdh* 081009
    u.periodicUpdate();

    if( forcingOption==twilightZoneForcing )
    {
    // assign exact values on dirichletBoundaryCondition boundaries for TZ
    // printF(" assignBoundaryConditionsFOS: set exact BC's on dirichletBoundaryCondition's and ghost pts...\n");
        
    // assign the boundary and 2 ghost with the exact solution
        int numGhost=max(orderOfAccuracyInSpace/2,2);
        extrapParams.extraInTangentialDirections=numGhost;
        
        for( int g=0; g<=numGhost; g++ )
        {
            extrapParams.lineToAssign=g;
            u.applyBoundaryCondition(C,BCTypes::dirichlet,SmParameters::dirichletBoundaryCondition,0.,t,extrapParams);
        }
    // reset 
        extrapParams.extraInTangentialDirections=0;
        extrapParams.lineToAssign=1;
    }


    if( true )
    {
    //  ** new way ** 

    // *wdh* 091012 -- also set interp points with a dirichlet BC: (fixes splitAnnulus, annulusEigen.cmd problem)
        bcParams.extraInTangentialDirections=1;
        u.applyBoundaryCondition(C,BCTypes::dirichlet,SmParameters::displacementBC,bcData,pBoundaryData,t,
                                                          bcParams,grid);
        bcParams.extraInTangentialDirections=0;
        

        if( false )
        {
            for( int axis=axis1; axis<mg.numberOfDimensions(); axis++ )
            {
                for( int side=Start; side<=End; side++ )
                {
                    if( mg.boundaryCondition(side,axis)==SmParameters::displacementBC )
                    {
                        Index Ib1,Ib2,Ib3;
                        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
                        ::display(u(Ib1,Ib2,Ib3,C)," u after displacementBC","%9.3e ");
                    }
                }
            }
        }

        u.applyBoundaryCondition(C,BCTypes::extrapolate,SmParameters::displacementBC,0.,t);

                      
        u.applyBoundaryCondition(C,BCTypes::evenSymmetry,SmParameters::symmetry,0.,t);

        if( orderOfAccuracyInSpace==4 )
        {
            extrapParams.ghostLineToAssign=2;
            u.applyBoundaryCondition(C,BCTypes::extrapolate,SmParameters::displacementBC,0.,t,extrapParams);

            u.applyBoundaryCondition(C,BCTypes::evenSymmetry,SmParameters::symmetry,0.,t,extrapParams);
        }

    }


    if( false )  // --- *wdh* 090824 -- moved to below ---
    {  
        
    // if( orderOfAccuracyInSpace==2 && (orderOfAccuracyInSpace < orderOfArtificialDissipation) )
        if( parameters.dbase.get<int >("extrapolateInterpolationNeighbours") ) // *wdh* 090823
        {
      // extrapolate the 2nd ghost line and interpolation neighbours for higher-order dissipation
      // -- is this the right place to do this ? 
            extrapParams.ghostLineToAssign=2;
            extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;
            if( applyFilter )
                extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1; // *wdh* 090824 -- try this with the 4th order filter
            u.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);

            if( debug & 8  )
                printF(" extrapolateInterpolationNeighbours at t=%g\n",t);

            extrapParams.orderOfExtrapolation=parameters.dbase.get<int >("orderOfExtrapolationForInterpolationNeighbours");
            u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,
                                                              extrapParams,grid);
        }
    }
    


    bool isRectangular = mg.isRectangular();

    if( false && isRectangular && useConservative ) // ***********************
    {
    // for testing : pretend the grid is NOT rectangular 
        if( t < 2.*dt )
            printF("\n *******assignBC: treat rectangular grid as Cartesian for bug in Cons BC ********** \n");
        isRectangular=false; 
        mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter | MappedGrid::THEinverseVertexDerivative );
    }

    const real dtb2=dt*.5;

    const aString & specialInitialConditionOption = parameters.dbase.get<aString>("specialInitialConditionOption");
    const bool applySpecialSolutionBoundaryConditions = specialInitialConditionOption != "default";

    bool centerNeeded = applySpecialSolutionBoundaryConditions;
    if( centerNeeded )
    {
        mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter );
    }

  // Hemp: here is where we store the initial state (mass,density,energy)
    realMappedGridFunction *pstate0 = NULL;
    if( pdeVariation == SmParameters::hemp )
    {
        assert( parameters.dbase.get<realCompositeGridFunction*>("initialStateGridFunction")!=NULL );
        pstate0 = &(*(parameters.dbase.get<realCompositeGridFunction*>("initialStateGridFunction")))[grid];
    }
    realMappedGridFunction & state0 = *pstate0;

    const realArray & x = mg.center();

    real dx[3]={0.,0.,0.}; //

      

    if( isRectangular )
        mg.getDeltaX(dx);
        
    #ifdef USE_PPP
      realSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
      realSerialArray det;  
      if( pdeVariation == SmParameters::hemp ) 
          getLocalArrayWithGhostBoundaries(mg.centerJacobian(),det);
      realSerialArray xLocal; if( centerNeeded ) getLocalArrayWithGhostBoundaries(x,xLocal);
      realSerialArray state0Local;
      if( pdeVariation == SmParameters::hemp )
          getLocalArrayWithGhostBoundaries(state0,state0Local);

    #else
      realSerialArray & uLocal = u;
      const realSerialArray & xLocal = x;
      const realSerialArray & det = mg.centerJacobian();
      realSerialArray & state0Local = *pstate0;
    #endif
    
      const IntegerArray & bcg = mg.boundaryCondition();
      IntegerArray gid, dim, bc;
      getLocalBoundsAndBoundaryConditions( u, gid, dim, bc );


      Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];

      bool useOpt=true; 
      int side,axis;


   // *wdh* 090204 -- new dirichlet boundary condition : assign the exact solution for testing ---
      if( applySpecialSolutionBoundaryConditions )
      {
          for( int axis=axis1; axis<mg.numberOfDimensions(); axis++ )
          {
              for( int side=Start; side<=End; side++ )
              {
                  if( mg.boundaryCondition(side,axis)==SmParameters::dirichletBoundaryCondition )
                  {
                      int numberOfGhostLines = max(2,orderOfAccuracyInSpace/2);  // assign at least 2 ghost (for filter)
                      int extra=numberOfGhostLines;
                      getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3,extra);

           // for now assign dirichlet at ghost lines too.
                      Iv[axis] = side==0 ? Range(Iv[axis].getBase()-numberOfGhostLines,Iv[axis].getBound()) : 
                          Range(Iv[axis].getBase(),Iv[axis].getBound()+numberOfGhostLines);
                            
                      if( mg.boundaryCondition(side,axis)==SmParameters::interfaceBoundaryCondition )
                      { // do not include the boundary
                          Iv[axis] = side==0 ? Range(Iv[axis].getBase(),Iv[axis].getBound()-1) : 
                              Range(Iv[axis].getBase()+1,Iv[axis].getBound());
                      }

                      const int includeGhost=1;
                      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
                      if( !ok ) continue;

                      real *up = uLocal.Array_Descriptor.Array_View_Pointer3;
                      const int uDim0=uLocal.getRawDataSize(0);
                      const int uDim1=uLocal.getRawDataSize(1);
                      const int uDim2=uLocal.getRawDataSize(2);
#undef U
#define U(i0,i1,i2,i3) up[i0+uDim0*(i1+uDim1*(i2+uDim2*(i3)))]
                      real *xp = xLocal.Array_Descriptor.Array_View_Pointer3;
                      const int xDim0=xLocal.getRawDataSize(0);
                      const int xDim1=xLocal.getRawDataSize(1);
                      const int xDim2=xLocal.getRawDataSize(2);
#undef X
#define X(i0,i1,i2,i3) xp[i0+xDim0*(i1+xDim1*(i2+xDim2*(i3)))]

                      if( specialInitialConditionOption == "travelingWave" )
                      {
             // --- traveling (shock) wave solution ---
                          bool evalSolution = true;
             // macro: 
             //	printF("INFO: The traveling wave solutions are combinations of p and s solutions:\n"
             //               "  [u1,u2] = ap* [ k1,k2] * G( k1*(x-xa)+k2*(y-ya) - cp*t )  (p-wave)\n"
             //               "  [u1,u2] = as* [-k2,k1] * G( k1*(x-xa)+k2*(y-ya) - cs*t )  (s-wave\n",
             //               "    where  G(xi)=0 for xi>0 and G(xi)=-1 for xi<0 \n");
                          {
                              const int v1c = parameters.dbase.get<int >("v1c");
                              const int v2c = parameters.dbase.get<int >("v2c");
                              const int v3c = parameters.dbase.get<int >("v3c");
                              bool assignVelocities= v1c>=0 ;
                              const int s11c = parameters.dbase.get<int >("s11c");
                              const int s12c = parameters.dbase.get<int >("s12c");
                              const int s13c = parameters.dbase.get<int >("s13c");
                              const int s21c = parameters.dbase.get<int >("s21c");
                              const int s22c = parameters.dbase.get<int >("s22c");
                              const int s23c = parameters.dbase.get<int >("s23c");
                              const int s31c = parameters.dbase.get<int >("s31c");
                              const int s32c = parameters.dbase.get<int >("s32c");
                              const int s33c = parameters.dbase.get<int >("s33c");
                              const int pc = parameters.dbase.get<int >("pc");
                              bool assignStress = s11c >=0 ;
               // hard code some numbers for now: 
               // real k1=1., k2=0., k3=0.;
               // real ap=1., xa=.5, ya=0.;
                              real cp = sqrt( (lambda+2.*mu)/rho );
                              real cs = sqrt( mu/rho );
                              std::vector<real> & twd = parameters.dbase.get<std::vector<real> >("travelingWaveData");
                              const int np = int(twd[0]);  // number of p wave solutions
                              const int ns = int(twd[1]);  // number of s wave solutions
                              if( pdeVariation == SmParameters::hemp )
                              {
                                  printF("\n\n **************** FIX ME: travelingWave: finish me for HEMP **********\n\n");
                 // OV_ABORT("error");
                              }
               // printF("**** travelingWave: cp=%8.2e, t=%8.2e v0=%8.2e *********\n",cp,t,v0);
                              int i1,i2,i3;
                              if( mg.numberOfDimensions()==2 )
                              {
                                  real z0=0.;
                                  FOR_3D(i1,i2,i3,I1,I2,I3)
                                  {
                                      real x0 = X(i1,i2,i3,0);
                                      real y0 = X(i1,i2,i3,1);
                                      real u1=0., u2=0.;  // back-ground field
                                      real v1=0., v2=0.;
                                      real s11=0., s12=0., s22=0.;
                                      real div=0.;
                   // real a1=0., b1=-1., a2=0., b2=0.;
                   // u1 = a1*x0 + b1*t;  // more general back ground field
                   // u2 = a2*x0 + b2*t;
                                      int m=2;
                                      for (int n=0; n<np; n++ ) // p-wave solutions
                                      {
                                	real ap = twd[m++], k1=twd[m++], k2=twd[m++], k3=twd[m++], xa=twd[m++], ya=twd[m++], za=twd[m++];
                                	real xi = k1*(x0-xa) + k2*(y0-ya) - cp*t;
                                	if( xi <= 0. )
                                	{
                                  	  u1 += -ap*k1*xi;
                                  	  u2 += -ap*k2*xi;
                                              v1 += ap*cp*k1;
                                              v2 += ap*cp*k2;
                                              s11+= -ap*( lambda+2.*mu*k1*k1 );
                                  	  s12+= -ap*( 2.*mu*k1*k2 );
                                  	  s22+= -ap*( lambda+2.*mu*k2*k2 );
                                              div+= -ap;
                                	}
                                      }
                                      for (int n=0; n<ns; n++ ) // s-wave solutions
                                      {
                                	real as = twd[m++], k1=twd[m++], k2=twd[m++], k3=twd[m++], xa=twd[m++], ya=twd[m++], za=twd[m++];
                                	real xi = k1*(x0-xa) + k2*(y0-ya) - cs*t;
                                	if( xi <= 0. )
                                	{  // (-k2,k1)
                                  	  u1 += +as*k2*xi;
                                  	  u2 += -as*k1*xi;
                                              v1 += -as*cs*k2;
                                              v2 += +as*cs*k1;
                                              s11+= -as*(-2.*mu*k1*k2 );
                                  	  s12+= -as*( mu*(k1*k1-k2*k2) );
                                  	  s22+= -as*( 2.*mu*k1*k2 );
                                	}
                                      }
                   // printF(" (i1,i2)=(%i,%i) (x0,y0)=(%8.2e,%8.2e) xi=%8.2e (u1,u2)=(%8.2e,%8.2e)\n",i1,i2,x0,y0,xi,u1,u2);
                                      if( evalSolution )
                                      {
                                	if( pdeVariation == SmParameters::hemp )
                                	{
                                  	  U(i1,i2,i3,u1c) =u1;
                                  	  U(i1,i2,i3,u2c) =u2;
                                  	  U(i1,i2,i3,uc) =x0;
                                  	  U(i1,i2,i3,vc) =y0;
                                  	  state0Local(i1,i2,i3,1) = 1.0; // density
                                  	  /*********/
                                  	  state0Local(i1,i2,i3,0) = state0Local(i1,i2,i3,1)*det(i1,i2,i3)*mg.gridSpacing(axis1)*mg.gridSpacing(axis2); // mass
                                  	  if( pdeVariation == SmParameters::hemp && 
                                      	      i1 > I1Base && i1 < I1Bound &&
                                      	      i2 > I2Base && i2 < I2Bound )
                                  	  {
                                    	    real area = 0.25*(det(i1,i2,i3)+det(i1+1,i2,i3)+det(i1+1,i2+1,i3)+det(i1,i2+1,i3));
                                    	    state0Local(i1,i2,i3,0) = area*mg.gridSpacing(axis1)*mg.gridSpacing(axis2); // mass
                                  	  }
                                	}
                                	else
                                	{
                                	U(i1,i2,i3,uc) =u1;
                                	U(i1,i2,i3,vc) =u2;
                                	}
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) = v1;
                                  	  U(i1,i2,i3,v2c) = v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =s11;
                                  	  U(i1,i2,i3,s12c) =s12;
                                  	  U(i1,i2,i3,s21c) =s12;
                                  	  U(i1,i2,i3,s22c) =s22;
                                  	  if( pdeVariation == SmParameters::hemp )
                                  	  {
                                                  real press = -(lambda+2.0*mu/3.0)*div;
                                                  U(i1,i2,i3,pc)   = press;
                                                  U(i1,i2,i3,s11c) += press;
                                                  U(i1,i2,i3,s22c) += press;
                                  	  }
                                	}
                                      }
                                      else
                                      {
                                	if( pdeVariation == SmParameters::hemp )
                                	{
                                  	  U(i1,i2,i3,u1c) = U(i1,i2,i3,u1c) - u1;
                                  	  U(i1,i2,i3,u2c) = U(i1,i2,i3,u2c) - u2;
                                  	  U(i1,i2,i3,uc) = U(i1,i2,i3,uc) - x0;
                                  	  U(i1,i2,i3,vc) = U(i1,i2,i3,vc) - y0;
                                	}
                                	else
                                	{
                                  	  U(i1,i2,i3,uc) =U(i1,i2,i3,uc) - u1;
                                  	  U(i1,i2,i3,vc) =U(i1,i2,i3,vc) - u2;
                                  	  }
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) =U(i1,i2,i3,v1c) - v1;
                                  	  U(i1,i2,i3,v2c) =U(i1,i2,i3,v2c) - v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =U(i1,i2,i3,s11c) -s11;
                                  	  U(i1,i2,i3,s12c) =U(i1,i2,i3,s12c) -s12;
                                  	  U(i1,i2,i3,s21c) =U(i1,i2,i3,s21c) -s12;
                                  	  U(i1,i2,i3,s22c) =U(i1,i2,i3,s22c) -s22;
                                  	  if( pdeVariation == SmParameters::hemp )
                                  	  {
                                                  real press = -(lambda+2.0*mu/3.0)*div;
                                                  U(i1,i2,i3,s11c) -= press;
                                    	    U(i1,i2,i3,s22c) -= press;
                                    	    U(i1,i2,i3,pc)   = U(i1,i2,i3,pc)   - press;
                                  	  }
                                	}
                                      }
                                  } // end FOR_3D
                              }
                              else
                              {
                                  OV_ABORT("Error: finish me");
                              }
                          }
                      }
                      else if( specialInitialConditionOption == "planeTravelingWave" )
                      {
             // --- traveling sine wave solution ---
                          bool evalSolution = true;
             // macro: 
             //	printF("INFO: The traveling wave solutions are combinations of p and s solutions:\n"
             //               "  [u1,u2] = ap* [ k1,k2] * G( k1*(x-xa)+k2*(y-ya) - cp*t )  (p-wave)\n"
             //               "  [u1,u2] = as* [-k2,k1] * G( k1*(x-xa)+k2*(y-ya) - cs*t )  (s-wave\n",
             //               "    where  G(xi)=sin(freq,xi) \n");
                          {
                              const int v1c = parameters.dbase.get<int >("v1c");
                              const int v2c = parameters.dbase.get<int >("v2c");
                              const int v3c = parameters.dbase.get<int >("v3c");
                              bool assignVelocities= v1c>=0 ;
                              const int s11c = parameters.dbase.get<int >("s11c");
                              const int s12c = parameters.dbase.get<int >("s12c");
                              const int s13c = parameters.dbase.get<int >("s13c");
                              const int s21c = parameters.dbase.get<int >("s21c");
                              const int s22c = parameters.dbase.get<int >("s22c");
                              const int s23c = parameters.dbase.get<int >("s23c");
                              const int s31c = parameters.dbase.get<int >("s31c");
                              const int s32c = parameters.dbase.get<int >("s32c");
                              const int s33c = parameters.dbase.get<int >("s33c");
                              const int pc = parameters.dbase.get<int >("pc");
                              bool assignStress = s11c >=0 ;
               // hard code some numbers for now: 
               // real k1=1., k2=0., k3=0.;
               // real ap=1., xa=.5, ya=0.;
                              real cp = sqrt( (lambda+2.*mu)/rho );
                              real cs = sqrt( mu/rho );
                              std::vector<real> & twd = parameters.dbase.get<std::vector<real> >("travelingWaveData");
                              const int np = int(twd[0]);  // number of p wave solutions
                              const int ns = int(twd[1]);  // number of s wave solutions
                              if( pdeVariation == SmParameters::hemp )
                              {
                                  printF("\n\n **************** FIX ME: travelingWave: finish me for HEMP **********\n\n");
                 // OV_ABORT("error");
                              }
               // printF("**** planeTravelingWave: cp=%8.2e, t=%8.2e  *********\n",cp,t);
                              int i1,i2,i3;
                              if( mg.numberOfDimensions()==2 )
                              {
                                  real z0=0.;
                                  FOR_3D(i1,i2,i3,I1,I2,I3)
                                  {
                                      real x0 = X(i1,i2,i3,0);
                                      real y0 = X(i1,i2,i3,1);
                                      real u1=0., u2=0.;  // back-ground field
                                      real v1=0., v2=0.;
                                      real s11=0., s12=0., s22=0.;
                                      real div=0.;
                   // real a1=0., b1=-1., a2=0., b2=0.;
                   // u1 = a1*x0 + b1*t;  // more general back ground field
                   // u2 = a2*x0 + b2*t;
                                      int m=2;
                                      for (int n=0; n<np; n++ ) // p-wave solutions
                                      {
                                	real ap = twd[m++], k1=twd[m++], k2=twd[m++], k3=twd[m++], xa=twd[m++], ya=twd[m++], za=twd[m++];
                                	real freq=twd[m++];
                                	real xi = k1*(x0-xa) + k2*(y0-ya) - cp*t;
                                          real sinf = sin(freq*xi), cosf=cos(freq*xi);
                                	u1 += -ap*k1*sinf;
                                	u2 += -ap*k2*sinf;
                                	v1 += ap*cp*k1*freq*cosf;
                                	v2 += ap*cp*k2*freq*cosf;
                                	s11+= -ap*( lambda+2.*mu*k1*k1 )*freq*cosf;
                                	s12+= -ap*( 2.*mu*k1*k2        )*freq*cosf;
                                	s22+= -ap*( lambda+2.*mu*k2*k2 )*freq*cosf;
                                	div+= -ap;
                                      }
                                      for (int n=0; n<ns; n++ ) // s-wave solutions
                                      {
                                	real as = twd[m++], k1=twd[m++], k2=twd[m++], k3=twd[m++], xa=twd[m++], ya=twd[m++], za=twd[m++];
                                	real xi = k1*(x0-xa) + k2*(y0-ya) - cs*t;
                                	real freq=twd[m++];
                                	real sinf = sin(freq*xi), cosf=cos(freq*xi);
             	// (-k2,k1)
                                	u1 += +as*k2*sinf;
                                	u2 += -as*k1*sinf;
                                	v1 += -as*cs*k2*freq*cosf;
                                	v2 += +as*cs*k1*freq*cosf;
                                	s11+= -as*(-2.*mu*k1*k2      )*freq*cosf;
                                	s12+= -as*( mu*(k1*k1-k2*k2) )*freq*cosf;
                                	s22+= -as*( 2.*mu*k1*k2      )*freq*cosf;
                                      }
                   // printF(" (i1,i2)=(%i,%i) (x0,y0)=(%8.2e,%8.2e) xi=%8.2e (u1,u2)=(%8.2e,%8.2e)\n",i1,i2,x0,y0,xi,u1,u2);
                                      if( evalSolution )
                                      {
                                	if( pdeVariation == SmParameters::hemp )
                                	{
                                  	  U(i1,i2,i3,u1c) =u1;
                                  	  U(i1,i2,i3,u2c) =u2;
                                  	  U(i1,i2,i3,uc) =x0;
                                  	  U(i1,i2,i3,vc) =y0;
                                  	  state0Local(i1,i2,i3,1) = 1.0; // density
                                  	  /*********/
                                  	  state0Local(i1,i2,i3,0) = state0Local(i1,i2,i3,1)*det(i1,i2,i3)*mg.gridSpacing(axis1)*mg.gridSpacing(axis2); // mass
                                  	  if( pdeVariation == SmParameters::hemp && 
                                      	      i1 > I1Base && i1 < I1Bound &&
                                      	      i2 > I2Base && i2 < I2Bound )
                                  	  {
                                    	    real area = 0.25*(det(i1,i2,i3)+det(i1+1,i2,i3)+det(i1+1,i2+1,i3)+det(i1,i2+1,i3));
                                    	    state0Local(i1,i2,i3,0) = area*mg.gridSpacing(axis1)*mg.gridSpacing(axis2); // mass
                                  	  }
                                	}
                                	else
                                	{
                                	U(i1,i2,i3,uc) =u1;
                                	U(i1,i2,i3,vc) =u2;
                                	}
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) = v1;
                                  	  U(i1,i2,i3,v2c) = v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =s11;
                                  	  U(i1,i2,i3,s12c) =s12;
                                  	  U(i1,i2,i3,s21c) =s12;
                                  	  U(i1,i2,i3,s22c) =s22;
                                  	  if( pdeVariation == SmParameters::hemp )
                                  	  {
                                                  real press = -(lambda+2.0*mu/3.0)*div;
                                                  U(i1,i2,i3,pc)   = press;
                                                  U(i1,i2,i3,s11c) += press;
                                                  U(i1,i2,i3,s22c) += press;
                                  	  }
                                	}
                                      }
                                      else
                                      {
                                	if( pdeVariation == SmParameters::hemp )
                                	{
                                  	  U(i1,i2,i3,u1c) = U(i1,i2,i3,u1c) - u1;
                                  	  U(i1,i2,i3,u2c) = U(i1,i2,i3,u2c) - u2;
                                  	  U(i1,i2,i3,uc) = U(i1,i2,i3,uc) - x0;
                                  	  U(i1,i2,i3,vc) = U(i1,i2,i3,vc) - y0;
                                	}
                                	else
                                	{
                                  	  U(i1,i2,i3,uc) =U(i1,i2,i3,uc) - u1;
                                  	  U(i1,i2,i3,vc) =U(i1,i2,i3,vc) - u2;
                                  	  }
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) =U(i1,i2,i3,v1c) - v1;
                                  	  U(i1,i2,i3,v2c) =U(i1,i2,i3,v2c) - v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =U(i1,i2,i3,s11c) -s11;
                                  	  U(i1,i2,i3,s12c) =U(i1,i2,i3,s12c) -s12;
                                  	  U(i1,i2,i3,s21c) =U(i1,i2,i3,s21c) -s12;
                                  	  U(i1,i2,i3,s22c) =U(i1,i2,i3,s22c) -s22;
                                  	  if( pdeVariation == SmParameters::hemp )
                                  	  {
                                                  real press = -(lambda+2.0*mu/3.0)*div;
                                                  U(i1,i2,i3,s11c) -= press;
                                    	    U(i1,i2,i3,s22c) -= press;
                                    	    U(i1,i2,i3,pc)   = U(i1,i2,i3,pc)   - press;
                                  	  }
                                	}
                                      }
                                  } // end FOR_3D
                              }
                              else
                              {
                                  OV_ABORT("Error: finish me");
                              }
                          }
                      }
                      else if( specialInitialConditionOption == "translationAndRotation" )
                      {
             // Here is the solution for large translation and rotation 
                          bool evalSolution = true;
             // macro: 
                          {
                              const int v1c = parameters.dbase.get<int >("v1c");
                              const int v2c = parameters.dbase.get<int >("v2c");
                              const int v3c = parameters.dbase.get<int >("v3c");
                              bool assignVelocities= v1c>=0 ;
                              const int s11c = parameters.dbase.get<int >("s11c");
                              const int s12c = parameters.dbase.get<int >("s12c");
                              const int s13c = parameters.dbase.get<int >("s13c");
                              const int s21c = parameters.dbase.get<int >("s21c");
                              const int s22c = parameters.dbase.get<int >("s22c");
                              const int s23c = parameters.dbase.get<int >("s23c");
                              const int s31c = parameters.dbase.get<int >("s31c");
                              const int s32c = parameters.dbase.get<int >("s32c");
                              const int s33c = parameters.dbase.get<int >("s33c");
                              const int pc = parameters.dbase.get<int >("pc");
                              bool assignStress = s11c >=0 ;
                              if( pdeVariation == SmParameters::hemp )
                              {
                                  printF("\n\n **************** FIX ME: getTranslationAndRotationSolution: finish me for HEMP **********\n\n");
                 // OV_ABORT("error");
                              }
               // Here is the solution for large translation and rotation
               // hard code some numbers for now: 
                              std::vector<real> & trd = parameters.dbase.get<std::vector<real> >("translationAndRotationSolutionData");
                              real omega   = trd[0];   // rotation rate
                              real xcenter = trd[1];      // center of rotation in the reference frame
                              real ycenter = trd[2];      // center of rotation in the reference frame
                              real zcenter = trd[3];      // center of rotation in the reference frame
                              real vcenter[3]={trd[4],trd[5],trd[6]};   // velocity of center
                              real rx[3]={cos(omega*t)-1.,-sin(omega*t),    0.};
                              real ry[3]={sin(omega*t)   , cos(omega*t)-1., 0.};
                              real rxt[3]={-omega*sin(omega*t),-omega*cos(omega*t), 0.};
                              real ryt[3]={ omega*cos(omega*t),-omega*sin(omega*t), 0.};
                          #define U0(x,y,z,n,t)  (vcenter[n-uc]*(t) +  rx[n-uc]*((x)-xcenter) +  ry[n-uc]*((y)-ycenter))
                          #define U0T(x,y,z,n,t) (vcenter[n-uc]     + rxt[n-uc]*((x)-xcenter) + ryt[n-uc]*((y)-ycenter))
                          #define U0X(x,y,z,n,t) (                     rx[n-uc]                                        )
                          #define U0Y(x,y,z,n,t) (                                               ry[n-uc]              )
                              if( t==0. )
                                  printF("**** translationAndRotationSolution, t=%8.2e omega=%8.2e (x0,x1,x2)=(%8.2e,%8.2e,%8.2e) "
                                   	   " (v0,v1,v2)=(%8.2e,%8.2e,%8.2e) *********\n",t,omega,xcenter,ycenter,zcenter,
                                   	   vcenter[0],vcenter[1],vcenter[2]);
                              int i1,i2,i3;
                              if( mg.numberOfDimensions()==2 )
                              {
                                  real z0=0.;
                                  FOR_3D(i1,i2,i3,I1,I2,I3)
                                  {
                                      real x0 = X(i1,i2,i3,0);
                                      real y0 = X(i1,i2,i3,1);
                                      real u1 = U0(x0,y0,z0,uc,t);
                                      real u2 = U0(x0,y0,z0,vc,t);
                                      if( evalSolution )
                                      {
                                	U(i1,i2,i3,uc) =u1;
                                	U(i1,i2,i3,vc) =u2;
                                      }
                                      else
                                      {
                                	U(i1,i2,i3,uc) =U(i1,i2,i3,uc) - u1;
                                	U(i1,i2,i3,vc) =U(i1,i2,i3,vc) - u2;
                                      }
                                  }
                                  if( assignVelocities )
                                  {
                                      FOR_3D(i1,i2,i3,I1,I2,I3) // loop over all points
                                      {
                                	real x0 = X(i1,i2,i3,0);
                                	real y0 = X(i1,i2,i3,1);
                                	real v1 = U0T(x0,y0,z0,uc,t);
                                	real v2 = U0T(x0,y0,z0,vc,t);
             	// printF(" *** assignSpecial: v1=%e v2=%e\n",v1,v2);
                                	if( evalSolution )
                                	{
                                  	  U(i1,i2,i3,v1c) = v1;
                                  	  U(i1,i2,i3,v2c) = v2;
                                	}
                                	else
                                	{
                                  	  U(i1,i2,i3,v1c) = U(i1,i2,i3,v1c) - v1;
                                  	  U(i1,i2,i3,v2c) = U(i1,i2,i3,v2c) - v2;
                                	}
                                      }
                                  }
                                  if( assignStress )
                                  {
                                      FOR_3D(i1,i2,i3,I1,I2,I3) // loop over all points
                                      {
                                	real x0 = X(i1,i2,i3,0);
                                	real y0 = X(i1,i2,i3,1);
                                	real f11 = 1. + U0X(x0,y0,z0,uc,t);
                                	real f12 =      U0Y(x0,y0,z0,uc,t);
                                	real f21 =      U0X(x0,y0,z0,vc,t);
                                	real f22 = 1. + U0Y(x0,y0,z0,vc,t);
                                	real e11 = .5*(f11*f11+f21*f21-1.);     // this is E(i,j), symmetric
                                	real e12 = .5*(f11*f12+f21*f22   );
                                	real e22 = .5*(f12*f12+f22*f22-1.);
                                	real trace = e11 + e22;
                                	real s11 = lambda*trace + 2*mu*e11;     // this is S(i,j), symmetric
                                	real s12 =                2*mu*e12;
                                	real s21 = s12;
                                	real s22 = lambda*trace + 2*mu*e22;
                                	real p11 = s11*f11 + s12*f12;           // this P(i,j)
                                	real p12 = s11*f21 + s12*f22;
                                	real p21 = s21*f11 + s22*f12;
                                	real p22 = s21*f21 + s22*f22;
                                	if( evalSolution )
                                	{
                                  	  U(i1,i2,i3,s11c) = p11;
                                  	  U(i1,i2,i3,s12c) = p12;
                                  	  U(i1,i2,i3,s21c) = p21;
                                  	  U(i1,i2,i3,s22c) = p22;
                                	}
                                	else
                                	{
                                  	  U(i1,i2,i3,s11c) = U(i1,i2,i3,s11c) - p11;
                                  	  U(i1,i2,i3,s12c) = U(i1,i2,i3,s12c) - p12;
                                  	  U(i1,i2,i3,s21c) = U(i1,i2,i3,s21c) - p21;
                                  	  U(i1,i2,i3,s22c) = U(i1,i2,i3,s22c) - p22;
                                	}
                                      }
                                  }
                              }
                              else
                              { // ***** 3D  ****
                                  OV_ABORT("translationAndRotationSolution: finish me for 3d");
                                  FOR_3D(i1,i2,i3,I1,I2,I3)
                                  {
                                      real x0 = X(i1,i2,i3,0);
                                      real y0 = X(i1,i2,i3,1);
                                      real z0 = X(i1,i2,i3,2);
                                      U(i1,i2,i3,uc) =U0(x0,y0,z0,uc,t);
                                      U(i1,i2,i3,vc) =U0(x0,y0,z0,vc,t);
                                      U(i1,i2,i3,wc) =U0(x0,y0,z0,wc,t);
                                  }
                              }
                          #undef U0
                          #undef U0T
                          #undef U0X
                          #undef U0Y
                          }
                      }
                      else if( specialInitialConditionOption == "RayleighWave" )
                      {
             // --- Rayleigh wave solution ---
                          bool evalSolution = true;
             // macro: 
                          {
                              const int v1c = parameters.dbase.get<int >("v1c");
                              const int v2c = parameters.dbase.get<int >("v2c");
                              const int v3c = parameters.dbase.get<int >("v3c");
                              bool assignVelocities= v1c>=0 ;
                              const int s11c = parameters.dbase.get<int >("s11c");
                              const int s12c = parameters.dbase.get<int >("s12c");
                              const int s13c = parameters.dbase.get<int >("s13c");
                              const int s21c = parameters.dbase.get<int >("s21c");
                              const int s22c = parameters.dbase.get<int >("s22c");
                              const int s23c = parameters.dbase.get<int >("s23c");
                              const int s31c = parameters.dbase.get<int >("s31c");
                              const int s32c = parameters.dbase.get<int >("s32c");
                              const int s33c = parameters.dbase.get<int >("s33c");
                              const int pc = parameters.dbase.get<int >("pc");
                              bool assignStress = s11c >=0 ;
                              real cp = sqrt( (lambda+2.*mu)/rho );
                              real cs = sqrt( mu/rho );
                              std::vector<real> & data = parameters.dbase.get<std::vector<real> >("RayleighWaveData");
                              const int nk = int(data[0]);  // number of modes
                              const real cr    = data[1];   // Rayleigh wave speed
                              const real ySurf = data[2];   // y value on surface
                              const real period= data[3];   // Rayleigh wave speed
                              const real xShift= data[4];   // shift in x for wave 
                              const int mStart=5;  // Fourier coeff's start at this index in the data 
                              if( pdeVariation == SmParameters::hemp )
                              {
                                  printF("\n\n **************** FIX ME: RayelighWave: finish me for HEMP **********\n\n");
                                  OV_ABORT("error");
                              }
                              real cb1 = sqrt(1.-SQR(cr/cp)); // b1/k : for computing b1 
                              real cb2 = sqrt(1.-SQR(cr/cs)); // b2/k : for computing b2 
                              real c1 = .5*SQR(cr/cs)-1.; // x/2-1 ,   x=cr^2/cs^2
                              if( t==0. )
                              {
                                  printF("**** RayleighWave: ySurf=%8.2e, cr=%8.2e, period=%8.2e, t=%8.2e *********\n",ySurf,cr,period,t);
                                  int m=mStart;
                                  for( int n=0; n<nk; n++ ) 
                                  {
                                      real k = data[m++];  // k=wave-number
                                      real a=data[m++];    // an : amplitude
                                      real b=data[m++]; 
                                      printF(" k%i = %e, a%i=%e, b%i=%e\n",n,k,n,a,n,b);
                                  }
                              }
                              real scale = -1./( cb1+(c1/cb2) ); // make coeff of cos() in u2 = a at y=0
                              int i1,i2,i3;
                              if( mg.numberOfDimensions()==2 )
                              {
                                  real z0=0.;
                                  FOR_3D(i1,i2,i3,I1,I2,I3)
                                  {
                                      real x0 = X(i1,i2,i3,0)-xShift;
                                      real y0 = X(i1,i2,i3,1)-ySurf;
                                      real u1=0., u2=0.;  
                                      real v1=0., v2=0.;
                                      real s11=0., s12=0., s22=0.;
                                      int m=mStart;
                   // --- loop over different values of k and add contributions ---
                                      for( int n=0; n<nk; n++ ) 
                                      {
                                	real k = twoPi*data[m++]/period;  // 2*pi*k/period , k=wave-number
                     // -- note definition of a and b so that they define the Fourier coefficients
                     //    of u2 on the surface
                                          real b=data[m++]*scale;          
                                          real a=data[m++]*scale;          
                                          real b1= k*cb1, b2=k*cb2;
                                          real eb1 = exp(b1*(y0)), eb2 = exp(b2*(y0));
                                          real ct = cos(k*(x0-cr*t));
                                	real st = sin(k*(x0-cr*t));
                                          u1 +=  ( eb1 + c1*eb2           )*( a*ct+b*st);
                                	u2 +=  ( cb1*eb1 + (c1/cb2)*eb2 )*( a*st-b*ct);
                                	if( assignVelocities )
                                	{
                                  	  v1 += ( eb1 + c1*eb2           )*( k*cr*( a*st-b*ct) );
                                  	  v2 +=-( cb1*eb1 + (c1/cb2)*eb2 )*( k*cr*( a*ct+b*st) );
                                	}
                                	if( assignStress )
                                	{   
                                              real u1x = ( eb1 + c1*eb2       )*( k*(-a*st+b*ct) );
                                              real u1y = ( b1*eb1 + b2*c1*eb2 )*(   ( a*ct+b*st) );
                                              real u2x = ( cb1*eb1       + (c1/cb2)*eb2 )*( k*(a*ct+b*st) );
                                              real u2y = ( b1*cb1*eb1 + b2*(c1/cb2)*eb2 )*(   (a*st-b*ct) );
                                              real div=u1x+u2y;
                                  	  s11 += lambda*div+2.*mu*u1x;
                                  	  s12 += mu*( u1y+u2x );
                                  	  s22 += lambda*div+2.*mu*u2y;
                                	}
                                      }
                   // printF(" (i1,i2)=(%i,%i) (x0,y0)=(%8.2e,%8.2e) xi=%8.2e (u1,u2)=(%8.2e,%8.2e)\n",i1,i2,x0,y0,xi,u1,u2);
                                      if( evalSolution )
                                      {
                                	U(i1,i2,i3,uc) =u1;
                                	U(i1,i2,i3,vc) =u2;
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) = v1;
                                  	  U(i1,i2,i3,v2c) = v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =s11;
                                  	  U(i1,i2,i3,s12c) =s12;
                                  	  U(i1,i2,i3,s21c) =s12;
                                  	  U(i1,i2,i3,s22c) =s22;
                                	}
                                      }
                                      else
                                      {
                                	if( pdeVariation == SmParameters::hemp )
                                	{
                                  	  U(i1,i2,i3,u1c) = U(i1,i2,i3,u1c) - u1;
                                  	  U(i1,i2,i3,u2c) = U(i1,i2,i3,u2c) - u2;
                                  	  U(i1,i2,i3,uc) = U(i1,i2,i3,uc) - x0;
                                  	  U(i1,i2,i3,vc) = U(i1,i2,i3,vc) - y0;
                                	}
                                	else
                                	{
                                  	  U(i1,i2,i3,uc) =U(i1,i2,i3,uc) - u1;
                                  	  U(i1,i2,i3,vc) =U(i1,i2,i3,vc) - u2;
                                  	  }
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) =U(i1,i2,i3,v1c) - v1;
                                  	  U(i1,i2,i3,v2c) =U(i1,i2,i3,v2c) - v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =U(i1,i2,i3,s11c) -s11;
                                  	  U(i1,i2,i3,s12c) =U(i1,i2,i3,s12c) -s12;
                                  	  U(i1,i2,i3,s21c) =U(i1,i2,i3,s21c) -s12;
                                  	  U(i1,i2,i3,s22c) =U(i1,i2,i3,s22c) -s22;
                                	}
                                      }
                                  } // end FOR_3D
                              }
                              else
                              {
                                  OV_ABORT("RayleighWave:ERROR: finish me for 3D");
                              }
                          }
                      }
                      else if( specialInitialConditionOption == "pistonMotion" )
                      {
             // --- piston motion (for FSI) ---
                          bool evalSolution = true;
                          {
                              const int v1c = parameters.dbase.get<int >("v1c");
                              const int v2c = parameters.dbase.get<int >("v2c");
                              const int v3c = parameters.dbase.get<int >("v3c");
                              bool assignVelocities= v1c>=0 ;
                              const int s11c = parameters.dbase.get<int >("s11c");
                              const int s12c = parameters.dbase.get<int >("s12c");
                              const int s13c = parameters.dbase.get<int >("s13c");
                              const int s21c = parameters.dbase.get<int >("s21c");
                              const int s22c = parameters.dbase.get<int >("s22c");
                              const int s23c = parameters.dbase.get<int >("s23c");
                              const int s31c = parameters.dbase.get<int >("s31c");
                              const int s32c = parameters.dbase.get<int >("s32c");
                              const int s33c = parameters.dbase.get<int >("s33c");
                              const int pc = parameters.dbase.get<int >("pc");
                              bool assignStress = s11c >=0 ;
                              const real cp = sqrt( (lambda+2.*mu)/rho );
                              const real cs = sqrt( mu/rho );
                              std::vector<real> & data = parameters.dbase.get<std::vector<real> >("pistonMotionData");
                              int m=0;
                              const real a    =data[m++];
                              const real p    =data[m++];
                              const real rhog =data[m++];
                              const real pg   =data[m++];
                              const real gamma=data[m++];
                              real angle      =data[m++];  // angle (in degrees) for a rotated piston
                              const real a0 = sqrt( gamma*pg/rhog);  // speed of sound in the gas
                              if( pdeVariation == SmParameters::hemp )
                              {
                                  printF("\n\n **************** FIX ME: getPistonMotionSolution: finish me for HEMP **********\n\n");
                                  OV_ABORT("error");
                              }
                              if( t==0. )
                              {
                                  printP("**** getPistonMotion: a=%8.2e, p=%8.2e, Gas: rho=%8.2e, p=%8.2e gamma=%8.2e angle=%5.2f(degrees)*******\n",
                                                a,p,rhog,pg,gamma,angle);
                              }
                              angle = angle*Pi/180.;
                              const real cosa = cos(angle), sina=sin(angle);
                              const real cg1 = pg/(rho*cp*cp);
                              const real cg2 = (-a)*(gamma-1.)/(2.*a0);
               // we assume gamma=1.4
                              assert( fabs(gamma-1.4) < REAL_EPSILON*100. );
                              int i1,i2,i3;
                              if( mg.numberOfDimensions()==2 )
                              {
                                  real z0=0.;
                                  FOR_3D(i1,i2,i3,I1,I2,I3)
                                  {
                                      real x0 = X(i1,i2,i3,0);
                                      real y0 = X(i1,i2,i3,1);
                                      real u1=0., u2=0.;  
                                      real v1=0., v2=0.;
                                      real s11=0., s12=0., s22=0.;
                   // Boundary motion:
                   //    F(t) = -(a/p)*t^p 
                   //    F'(t) = -a*t^{p-1}
                   // Solution: 
                   //    u1 = f(x-cp*t) + g(x+cp*t)
                   // where  
                   //   f(x) = - 1/(2*cp)*( int_0^x v0(s) ds ) = -(1/2)* int_0^x G(-s/cp) ds  ,   for   x<0
                   //                                          =  (cp/2)* int_0^{-x/cp} G(u) du 
                   //   g(x) = + 1/(2*cp)*( int_0^x v0(s) ds ) =  (1/2)* int_0^x G(-s/cp) ds  ,   for   x<0
                   //                                          = -(cp/2)* int_0^{-x/cp} G(u) du 
                   //   g(x) = F(x/cp) - f(-x),                   for   x>0 
                   //
                   //   v0(s) = cp*G(-t/cp)   : velocity at t=0 for s<0
                   //   G(t) = (pg/(rho*cp^2)) * [ 1 + (gamma-1)/(2*a0)* F'(t) ]^7 + F'(t)/cp
                   //        = cg1* [ 1 + cg2*t^{p-1} ]^7 + F'(t)/cp
                   //     cg1=p0/(rho*cp^2), cg2=(-a)*(gamma-1)/(2*a0)
                   // 
                   // where we have assumed that gamma=1.4=7/5 so that 2*gamma/(gamma-1)= 7 
                   // 
                   //  Int_0^t G(s) ds = cg1*[ t + (7/p)*cg2*t^{p-1}*t + (21/(2p-1))*(cg2*t^{p-1})^2*t + ) + F(t)/cp
                   //                  = cg1*t*[ 1 + Z*(7)/(p) + Z^2*(21)/(2p-1) + Z^3*(35)/(3p-2) + Z^4*(35)/(4p-3) + ...
                   //                              + Z^5*(21)/(5p-4) + Z^6*(7)/(6p-5) + Z^7*(1)/(7p-6) ] 
                   //   Z=cg2*t^{p-1}
                   // xa = distance of point (x0,y0) from the plane  (cosa,sina).(x,y)=0 
                                      real xa = x0*cosa + y0*sina;
                                      real xp = xa + cp*t;
                                      real xm = xa - cp*t;
                                      real fm, fmPrime, gp, gpPrime;
                                      {
                                          real xx = -xm/cp;
                                          real xp1 = pow(xx,p-1);
                                          real z=cg2*xp1;
                                          fm = cp*(.5*(cg1*(xx)*(1.+(z)*(7./p+(z)*(21./(2.*p-1.)+(z)*(35./(3.*p-2.)+(z)*(35./(4.*p-3.)			+(z)*(21./(5.*p-4.)+(z)*(7./(6.*p-5.)+z/(7.*p-6.))))))))))  - .5*(a/p)*xp1*xx;
                                          fmPrime = .5*( -cg1*pow( 1. + z , 7.) + a*xp1/cp );
                                      }
                                      {
                                          if( xp<=0. )
                                          {
                                              real xx = -xp/cp;
                                              real xp1 = pow(xx,p-1);
                                              real z=cg2*xp1;
                                              gp = cp*(.5*(cg1*(xx)*(1.+(z)*(7./p+(z)*(21./(2.*p-1.)+(z)*(35./(3.*p-2.)+(z)*(35./(4.*p-3.)			+(z)*(21./(5.*p-4.)+(z)*(7./(6.*p-5.)+z/(7.*p-6.))))))))))  + .5*(a/p)*xp1*xx ;
                                              gpPrime = +.5*( -cg1*pow( 1. + z , 7.) -a*xp1/cp );
                                          }
                                          else
                                          {
                        //   gp(xp) = F(xp/cp) - f(-xp),
                                              real xx=xp/cp;
                                              real xp1 = pow(xx,p-1);
                                              real z=cg2*xp1;
                                              gp = -(a/p)*xp1*xx - cp*(.5*(cg1*(xx)*(1.+(z)*(7./p+(z)*(21./(2.*p-1.)+(z)*(35./(3.*p-2.)+(z)*(35./(4.*p-3.)			+(z)*(21./(5.*p-4.)+(z)*(7./(6.*p-5.)+z/(7.*p-6.)))))))))) + .5*(a/p)*xp1*xx;
                                              gpPrime = -a*xp1/cp + .5*( -cg1*pow( 1. + z , 7.) + a*xp1/cp );
                                          }
                                      }
                                      real ua = fm + gp;
                                      real va = cp*( - fmPrime + gpPrime );
                                      real uap=fmPrime + gpPrime;
                   // Piston at an angle:
                   //   n = [ cos(angle) , sin(angle) ] = [ c, s ]    -- normal to the face
                   //   u1 = c*ua,  u2=s*ua
                   //   u1.x = c*ua.x,  u1.y = c*ua.y,   u2.x = s*ua.x, u2.y = s*ua.y
                   //   
                   // (1)  ua.n = c*ua.x + s*ua.y = uap
                   // (2)  ua.t =-s*ua.x + c*ua.y = 0    "tangential derivative of motion"
                   //
                   //  (1) and (2) -->   ua.x = c*uap, ua.y=s*uap
                   // Thus: u1.x = c*ua.x = c*c*uap,  u1.y = c*ua.y = c*s*uap
                                      u1 = ua*cosa;
                                      u2 = ua*sina;
                                      v1 = va*cosa;
                                      v2 = va*sina;
                                      real u1x = uap*cosa*cosa;
                                      real u1y = uap*cosa*sina;
                                      real u2x = uap*sina*cosa;
                                      real u2y = uap*sina*sina;
                                      s11 = (lambda+2.*mu)*u1x + lambda*u2y;   
                                      s12 = mu*( u1y+u2x );
                                      s22 = lambda*u1x + (lambda+2.*mu)*u2y;
                   // printF("piston (i1,i2)=(%i,%i) (u1,u2)=(%8.2e,%8.2e)\n",i1,i2,u1,u2);
                                      if( evalSolution )
                                      {
                                	U(i1,i2,i3,uc) =u1;
                                	U(i1,i2,i3,vc) =u2;
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) = v1;
                                  	  U(i1,i2,i3,v2c) = v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =s11;
                                  	  U(i1,i2,i3,s12c) =s12;
                                  	  U(i1,i2,i3,s21c) =s12;
                                  	  U(i1,i2,i3,s22c) =s22;
                                	}
                                      }
                                      else
                                      {
                                	U(i1,i2,i3,uc) =U(i1,i2,i3,uc) - u1;
                                	U(i1,i2,i3,vc) =U(i1,i2,i3,vc) - u2;
                                          if( assignVelocities )
                                	{
                                  	  U(i1,i2,i3,v1c) =U(i1,i2,i3,v1c) - v1;
                                  	  U(i1,i2,i3,v2c) =U(i1,i2,i3,v2c) - v2;
                                	}
                                	if( assignStress )
                                	{
                                  	  U(i1,i2,i3,s11c) =U(i1,i2,i3,s11c) -s11;
                                  	  U(i1,i2,i3,s12c) =U(i1,i2,i3,s12c) -s12;
                                  	  U(i1,i2,i3,s21c) =U(i1,i2,i3,s21c) -s12;
                                  	  U(i1,i2,i3,s22c) =U(i1,i2,i3,s22c) -s22;
                                	}
                                      }
                                  } // end FOR_3D
                              }
                              else
                              {
                                  OV_ABORT("getPistonMotion:ERROR: finish me for 3D");
                              }
                          }
                      }
                      else if( specialInitialConditionOption == "knownSolutionInitialCondition" )
                      {
             // Assign dirichlet BC from known solution *wdh* 2014/01/09 
                          parameters.getUserDefinedKnownSolution(t,cg, grid, uLocal, I1,I2,I3 );
                      }
                      else
                      {
                          printF("assignBoundaryConditionsSOS:ERROR: unknown specialInitialConditionOption=%s\n",
                                        (const char*)specialInitialConditionOption);
                          OV_ABORT("error");
                      }
                  

                  }
              }
          }
      }
      



   // *wdh* 041127 -- apply opt BC's after above dirichlet BC's ----
      getIndex(mg.gridIndexRange(),I1,I2,I3);
      int includeGhost=1;
      bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
      if( ok && useOpt )
      {
     // use optimised boundary conditions
          int ipar[30];
          real rpar[20];
          int gridType = isRectangular ? 0 : 1;
          int orderOfExtrapolation=orderOfAccuracyInSpace+1;  // not used
          int useForcing = forcingOption==twilightZoneForcing;
          int useWhereMask=false;
          realArray f;  // not currently used
          IntegerArray & pinBoundaryCondition = parameters.dbase.get<IntegerArray>("pinBoundaryCondition");
          int numberToPin=pinBoundaryCondition.getLength(1);
          if( numberToPin>0 )
          {
              printF("Cgsm:assignBoundaryConditionsSOS: ERROR: pinning of edges or corners not implemented yet. FIX ME Bill!\n");
              OV_ABORT("error");
          }
     // fprintf(pDebugFile,"**** pu= %i, %i...\n",&u,pu);
          const bool centerNeeded=useForcing || (forcingOption==planeWaveBoundaryForcing); // **************** fix this 
      #ifdef USE_PPP 
          realSerialArray uu;    getLocalArrayWithGhostBoundaries(u,uu);
          realSerialArray uuOld; getLocalArrayWithGhostBoundaries(uOld,uuOld);
          intSerialArray  mask;  getLocalArrayWithGhostBoundaries(mg.mask(),mask);
          realSerialArray rx;    if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg.inverseVertexDerivative(),rx);
          realSerialArray xy;    if( centerNeeded ) getLocalArrayWithGhostBoundaries(mg.center(),xy);
          realSerialArray ff;    getLocalArrayWithGhostBoundaries(f,ff); 
          if( debug & 16 )
          {
              fprintf(pDebugFile,"\n **** grid=%i p=%i assignBC: gid=[%i,%i][%i,%i][%i,%i] bc=[%i,%i][%i,%i][%i,%i]"
                              " bcg=[%i,%i][%i,%i][%i,%i]******\n\n",grid,myid,
                              gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2),
                              bc(0,0),bc(1,0),bc(0,1),bc(1,1),bc(0,2),bc(1,2),
                              bcg(0,0),bcg(1,0),bcg(0,1),bcg(1,1),bcg(0,2),bcg(1,2));
              fprintf(pDebugFile,"\n **** uu=[%i,%i] xy=[%i,%i] rsxy=[%i,%i]\n",
                              uu.getBase(0),uu.getBound(0),xy.getBase(0),xy.getBound(0),rx.getBase(0),rx.getBound(0));
          }
      #else
          const realSerialArray & uu    = u;
          const realSerialArray & uuOld = uOld;
          const realSerialArray & ff    = f;
          const intSerialArray  & mask  = mg.mask();
          const realSerialArray & rx = !isRectangular? mg.inverseVertexDerivative() : uu;
          const realSerialArray & xy = centerNeeded ? mg.center() : uu;
          const IntegerArray & gid = mg.gridIndexRange();
          const IntegerArray & dim = mg.dimension();
          const IntegerArray & bc = mg.boundaryCondition();
          if( debug & 64 )
          {
              const IntegerArray & bcg = mg.boundaryCondition();
              fprintf(pDebugFile,"\n **** grid=%i p=%i assignBC: gid=[%i,%i][%i,%i][%i,%i] bc=[%i,%i][%i,%i][%i,%i]"
                              " bcg=[%i,%i][%i,%i][%i,%i]******\n\n",grid,myid,
                              gid(0,0),gid(1,0),gid(0,1),gid(1,1),gid(0,2),gid(1,2),
                              bc(0,0),bc(1,0),bc(0,1),bc(1,1),bc(0,2),bc(1,2),
                              bcg(0,0),bcg(1,0),bcg(0,1),bcg(1,1),bcg(0,2),bcg(1,2));
          }
      #endif
          real *uptr   = uu.getDataPointer();
          real *fptr   = ff.getDataPointer();
          int *maskptr = mask.getDataPointer();
          real *rxptr  = rx.getDataPointer();
          real *xyptr  = centerNeeded ? xy.getDataPointer() : uptr;
          assert( xyptr!=NULL );
          if( !isRectangular )
          {
       // display(mg.inverseVertexDerivative(),"inverseVertexDerivative","%7.4f ");
       // displayMask(mg.mask());
          }
     // Do this for now -- assumes all sides are PML
          bool usePML = (bc(0,0)==SmParameters::abcPML || bc(1,0)==SmParameters::abcPML ||
                                        bc(0,1)==SmParameters::abcPML || bc(1,1)==SmParameters::abcPML ||
                                        bc(0,2)==SmParameters::abcPML || bc(1,2)==SmParameters::abcPML);
     // *** need to fix gridIndex Range and bc ***********************
          if( debug & 16 )
          {
              ::display(uu,sPrintF("uu before bcOptSm, t=%e",t),pDebugFile,"%8.1e ");
          }
          if( !isRectangular && debug & 16  ) 
              ::display(rx,sPrintF("rx before bcOptSm, t=%e",t),debugFile,"%9.2e ");
     // The next macro is in boundaryMacros.h
              int pdbc[2*3*2*3];
              #define dbc(s,a,side,axis) (pdbc[(s)+2*((a)+3*((side)+2*(axis)))])
              int pAddBoundaryForcing[6];
              #define addBoundaryForcing(side,axis) (pAddBoundaryForcing[(side)+2*(axis)])
              real *pbcf[2][3];
       // long int pbcfOffset[6];
       // We need an 8 byte integer so we can pass to fortran: int64_t is in stdint.h 
              int64_t pbcfOffset[6];
              #define bcfOffset(side,axis) pbcfOffset[(side)+2*(axis)]
              for( int axis=0; axis<=2; axis++ )
              {
                  for( int side=0; side<=1; side++ )
                  {
           // *** for now make sure the boundary data array is allocated on all sides
                      if( ( pBoundaryData[side][axis]==NULL || parameters.isAdaptiveGridProblem() ) && 
                              mg.boundaryCondition(side,axis)>0 )
                      {
                	parameters.getBoundaryData(side,axis,grid,mg);
             // RealArray & bd = *pBoundaryData[side][axis]; // this is now done in the above line *wdh* 090819
             // bd=0.;
                      }
                      if( pBoundaryData[side][axis]!=NULL )
                      {
                	if( debug & 8 )
                  	  printP("+++ Cgsm: add boundary forcing to (side,axis,grid)=(%i,%i,%i) useConservative=%i\n",side,axis,grid,
                       		 (int)useConservative);
                          addBoundaryForcing(side,axis)=true;
                          RealArray & bd = *pBoundaryData[side][axis];
                          pbcf[side][axis] = bd.getDataPointer();
     	// if( debug & 8 )
             //  ::display(bd," ++++ Cgsm: Here is bd ++++","%4.2f ");
                	for( int a=0; a<=2; a++ )
                	{
                  	  dbc(0,a,side,axis)=bd.getBase(a);
                  	  dbc(1,a,side,axis)=bd.getBound(a);
                	}
                      }
                      else
                      {
                          addBoundaryForcing(side,axis)=false;
                	pbcf[side][axis] = fptr;  // should not be used in this case 
                	for( int a=0; a<=2; a++ )
                	{
                  	  dbc(0,a,side,axis)=0;
                  	  dbc(1,a,side,axis)=0;
                	}
                      }
           // for now we save the offset in a 4 byte int (double check that this is ok)
                      int64_t offset = pbcf[side][axis]- pbcf[0][0];
     //       if( offset > INT_MAX )
     //       {
     // 	printF("ERROR: offset=%li INT_MAX=%li \n",offset,(long int)INT_MAX);
     //       }
     //       assert( offset < INT_MAX );
                      bcfOffset(side,axis) = offset;
           // bcfOffset(side,axis) = pbcf[side][axis]- pbcf[0][0];
           // cout << " **** bcfOffset= " << bcfOffset(side,axis) << endl;
                  }
              }
     // Macro to extract the pointers to the variable material property arrays
      // --- Variable material properies ---
            GridMaterialProperties::MaterialFormatEnum materialFormat = GridMaterialProperties::constantMaterialProperties;
            int ndMatProp=1;  // for piecewise constant materials, this is the leading dimension of the matVal array
            int *matIndexPtr=maskptr;  // if not used, point to mask
            real*matValPtr=uptr;       // if not used, point to u
            if( parameters.dbase.get<int>("variableMaterialPropertiesOption")!=0 )
            {
        // Material properties do vary 
                std::vector<GridMaterialProperties> & materialProperties = 
                	parameters.dbase.get<std::vector<GridMaterialProperties> >("materialProperties");
                GridMaterialProperties & matProp = materialProperties[grid];
                materialFormat = matProp.getMaterialFormat();
                if( materialFormat==GridMaterialProperties::piecewiseConstantMaterialProperties )
                {
                	IntegerArray & matIndex = matProp.getMaterialIndexArray();
                    matIndexPtr = matIndex.getDataPointer();
                }
                RealArray & matVal = matProp.getMaterialValuesArray();
                matValPtr = matVal.getDataPointer();
                ndMatProp = matVal.getLength(0);  
        // ::display(matVal,"matVal");
            }
          ipar[0]=numberOfDimensions;
          ipar[1] = grid;
          ipar[2] = uc;
          ipar[3] = vc;
          ipar[4] = wc;
          ipar[5] = gridType;
          ipar[6] = orderOfAccuracyInSpace;
          ipar[7] = orderOfExtrapolation;
          ipar[8] = int(forcingOption==twilightZoneForcing);  // twilightZone *wdh* 090813
          ipar[9] = useWhereMask;
          ipar[10]= debug; 
          ipar[15]=(int)materialFormat;
          rpar[ 0]=dx[0];
          rpar[ 1]=dx[1];
          rpar[ 2]=dx[2];
          rpar[ 3]=mg.gridSpacing(0);
          rpar[ 4]=mg.gridSpacing(1);
          rpar[ 5]=mg.gridSpacing(2);
          rpar[ 6]=t;
          OGFunction *& tz = parameters.dbase.get<OGFunction* >("exactSolution");
          rpar[ 7]=(real &)tz;  // twilight zone pointer, ep
          rpar[ 8]=dt;
          rpar[ 9]=rho;
          rpar[10]=mu;
          rpar[11]=lambda;
          rpar[12]=c1;
          rpar[13]=c2;
   // // ******** for testing ********
   //   for( int axis=0; axis<=2; axis++ )
   //   {
   //     for( int side=0; side<=1; side++ )
   //     {
   //       addBoundaryForcing(side,axis)=false;
   //     }
   //   }
          int ierr=0;
          const int bc0=-1;  // do all boundaries.
          if( !usePML ) // *** fix this ***
          {
   //     bcOptSolidMechanics( mg.numberOfDimensions(), 
   //                uu.getBase(0),uu.getBound(0),
   //                uu.getBase(1),uu.getBound(1),
   //                uu.getBase(2),uu.getBound(2),
   //                ff.getBase(0),ff.getBound(0),
   //                ff.getBase(1),ff.getBound(1),
   //                ff.getBase(2),ff.getBound(2),
   //                *gid.getDataPointer(),*dim.getDataPointer(),
   //                *uptr,*fptr,*maskptr,*rxptr, *xyptr,
   //                bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
              if( useConservative )
              {
                  bcOptSmCons( numberOfDimensions, 
                                            uu.getBase(0),uu.getBound(0),
                                            uu.getBase(1),uu.getBound(1),
                                            uu.getBase(2),uu.getBound(2),
                                            gid(0,0), *uptr, *maskptr, *rxptr, *xyptr, 
                                            ndMatProp,*matIndexPtr,*matValPtr,*matValPtr, 
                                            *bc.getDataPointer(),
                                            *pAddBoundaryForcing,*interfaceType.getDataPointer(),*pdbc, 
                                            *pbcf[0][0],*pbcf[1][0], *pbcf[0][1],*pbcf[1][1], *pbcf[0][2],*pbcf[1][2],
                                            *pbcf[0][0],pbcfOffset[0],
                                            ipar[0], rpar[0], ierr );
              }
              else
              {
                  bcOptSM( numberOfDimensions, 
                                    uu.getBase(0),uu.getBound(0),
                                    uu.getBase(1),uu.getBound(1),
                                    uu.getBase(2),uu.getBound(2),
                                    gid(0,0), *uptr, *maskptr, *rxptr, *xyptr, 
                                    ndMatProp,*matIndexPtr,*matValPtr,*matValPtr, 
                                    *bc.getDataPointer(),
                                    *pAddBoundaryForcing,*interfaceType.getDataPointer(),*pdbc, 
                                    *pbcf[0][0],*pbcf[1][0], *pbcf[0][1],*pbcf[1][1], *pbcf[0][2],*pbcf[1][2],
                                    *pbcf[0][0],pbcfOffset[0],
                                    ipar[0], rpar[0], ierr );
              }
          }
          if( debug & 16  ) ::display(uu,sPrintF("uu after bcOptSM, t=%e",t),pDebugFile,"%8.1e ");
          real *uOldptr = uuOld.getDataPointer();
     // Absorbing boundary conditions
   //   if( !usePML  ) // *** fix this ***
   //     abcSolidMechanics( mg.numberOfDimensions(), 
   //              uu.getBase(0),uu.getBound(0),
   //              uu.getBase(1),uu.getBound(1),
   //              uu.getBase(2),uu.getBound(2),
   //              ff.getBase(0),ff.getBound(0),
   //              ff.getBase(1),ff.getBound(1),
   //              ff.getBase(2),ff.getBound(2),
   //              *gid.getDataPointer(),
   //              *uOldptr, *uptr, *fptr,*maskptr,*rxptr, *xyptr,
   //              bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
          if( usePML )
          {
       // *************************************************************
       // ************* PML boundary conditions ***********************
       // *************************************************************
              realMappedGridFunction & un = u;    // u[next];
       // realMappedGridFunction & uu = uOld; // u[current];
              const int prev= (current-1+numberOfTimeLevels) % numberOfTimeLevels;
              const int next = (current+1) % numberOfTimeLevels;
              realMappedGridFunction & um =gf[prev].u[grid];
              Range all;
       // ::display(um(all,all,all,hz),"um before pml BC's","%9.2e ");
       // ::display(u(all,all,all,hz) ,"u  before pml BC's","%9.2e ");
       // ::display(un(all,all,all,hz),"un before pml BC's","%9.2e ");
       // vra,vrb  vsa,vsb, vsa, vsb
       // *********** In parallel it may be easiest to allocate arrays for the whole grid ******
       // vpml(m,side,axis,grid) m=0 : v , m=1 : w 
              const int numberOfPMLFunctions=2*numberOfTimeLevels; //  v and w, two levels
      #define VPML(m,side,axis,grid) vpml[(m)+numberOfPMLFunctions*(side+2*(axis+3*(grid)))]
      #define WPML(m,side,axis,grid) vpml[(m+numberOfTimeLevels)+numberOfPMLFunctions*(side+2*(axis+3*(grid)))]
              if( vpml==NULL )
              {
                  vpml= new realArray [cg.numberOfComponentGrids()*3*2*numberOfPMLFunctions];
                  printF(" ****** assignBC: allocate vpml arrays ***** \n");
                  for( int side=0; side<=1; side++ )
                  {
                      for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
                      {
                          if( mg.boundaryCondition(side,axis)==SmParameters::abcPML )
                          {
                              for( int m=0; m<numberOfPMLFunctions; m++ )
                              {
                                  realArray & vw = VPML(m,side,axis,grid);
                                  int ndr[2][3];
                                  for( int dir=0; dir<3; dir++ )
                                  {
                                      ndr[0][dir]=mg.dimension(0,dir);
                                      ndr[1][dir]=mg.dimension(1,dir);
                                  }
                                  if( side==0 )
                                  {
                                      ndr[0][axis]=mg.dimension(side,axis);
                                      ndr[1][axis]=mg.gridIndexRange(side,axis)+numberLinesForPML-1;
                                  }
                                  else
                                  {
                                      ndr[0][axis]=mg.gridIndexRange(side,axis)-numberLinesForPML+1;
                                      ndr[1][axis]=mg.dimension(side,axis);
                                  }
                                  realArray a;
                                  a.redim(Range(-2,10),Range(0,0));
                                  vw .redim(Range(ndr[0][0],ndr[1][0]),
                                                      Range(ndr[0][1],ndr[1][1]),
                                                      Range(ndr[0][2],ndr[1][2]),numberOfPMLFunctions);
                                  vw=0.;
                              }
                          }
                      }
                  }
              }
      #ifdef USE_PPP
              realSerialArray uum; getLocalArrayWithGhostBoundaries(um,uum);
              realSerialArray uu;  getLocalArrayWithGhostBoundaries(uOld,uu);
              realSerialArray uun; getLocalArrayWithGhostBoundaries(un,uun);
              realSerialArray vram; getLocalArrayWithGhostBoundaries(VPML(prev   ,0,0,grid),vram); 
              realSerialArray vrbm; getLocalArrayWithGhostBoundaries(VPML(prev   ,1,0,grid),vrbm); 
              realSerialArray vsam; getLocalArrayWithGhostBoundaries(VPML(prev   ,0,1,grid),vsam); 
              realSerialArray vsbm; getLocalArrayWithGhostBoundaries(VPML(prev   ,1,1,grid),vsbm); 
              realSerialArray vtam; getLocalArrayWithGhostBoundaries(VPML(prev   ,0,2,grid),vtam); 
              realSerialArray vtbm; getLocalArrayWithGhostBoundaries(VPML(prev   ,1,2,grid),vtbm); 
              realSerialArray vra ; getLocalArrayWithGhostBoundaries(VPML(current,0,0,grid),vra ); 
              realSerialArray vrb ; getLocalArrayWithGhostBoundaries(VPML(current,1,0,grid),vrb ); 
              realSerialArray vsa ; getLocalArrayWithGhostBoundaries(VPML(current,0,1,grid),vsa ); 
              realSerialArray vsb ; getLocalArrayWithGhostBoundaries(VPML(current,1,1,grid),vsb ); 
              realSerialArray vta ; getLocalArrayWithGhostBoundaries(VPML(current,0,2,grid),vta ); 
              realSerialArray vtb ; getLocalArrayWithGhostBoundaries(VPML(current,1,2,grid),vtb ); 
              realSerialArray vran; getLocalArrayWithGhostBoundaries(VPML(next   ,0,0,grid),vran); 
              realSerialArray vrbn; getLocalArrayWithGhostBoundaries(VPML(next   ,1,0,grid),vrbn); 
              realSerialArray vsan; getLocalArrayWithGhostBoundaries(VPML(next   ,0,1,grid),vsan); 
              realSerialArray vsbn; getLocalArrayWithGhostBoundaries(VPML(next   ,1,1,grid),vsbn); 
              realSerialArray vtan; getLocalArrayWithGhostBoundaries(VPML(next   ,0,2,grid),vtan); 
              realSerialArray vtbn; getLocalArrayWithGhostBoundaries(VPML(next   ,1,2,grid),vtbn); 
              realSerialArray wram; getLocalArrayWithGhostBoundaries(WPML(prev   ,0,0,grid),wram); 
              realSerialArray wrbm; getLocalArrayWithGhostBoundaries(WPML(prev   ,1,0,grid),wrbm); 
              realSerialArray wsam; getLocalArrayWithGhostBoundaries(WPML(prev   ,0,1,grid),wsam); 
              realSerialArray wsbm; getLocalArrayWithGhostBoundaries(WPML(prev   ,1,1,grid),wsbm); 
              realSerialArray wtam; getLocalArrayWithGhostBoundaries(WPML(prev   ,0,2,grid),wtam); 
              realSerialArray wtbm; getLocalArrayWithGhostBoundaries(WPML(prev   ,1,2,grid),wtbm); 
              realSerialArray wra ; getLocalArrayWithGhostBoundaries(WPML(current,0,0,grid),wra ); 
              realSerialArray wrb ; getLocalArrayWithGhostBoundaries(WPML(current,1,0,grid),wrb ); 
              realSerialArray wsa ; getLocalArrayWithGhostBoundaries(WPML(current,0,1,grid),wsa ); 
              realSerialArray wsb ; getLocalArrayWithGhostBoundaries(WPML(current,1,1,grid),wsb ); 
              realSerialArray wta ; getLocalArrayWithGhostBoundaries(WPML(current,0,2,grid),wta ); 
              realSerialArray wtb ; getLocalArrayWithGhostBoundaries(WPML(current,1,2,grid),wtb ); 
              realSerialArray wran; getLocalArrayWithGhostBoundaries(WPML(next   ,0,0,grid),wran); 
              realSerialArray wrbn; getLocalArrayWithGhostBoundaries(WPML(next   ,1,0,grid),wrbn); 
              realSerialArray wsan; getLocalArrayWithGhostBoundaries(WPML(next   ,0,1,grid),wsan); 
              realSerialArray wsbn; getLocalArrayWithGhostBoundaries(WPML(next   ,1,1,grid),wsbn); 
              realSerialArray wtan; getLocalArrayWithGhostBoundaries(WPML(next   ,0,2,grid),wtan); 
              realSerialArray wtbn; getLocalArrayWithGhostBoundaries(WPML(next   ,1,2,grid),wtbn); 
      #else
              const realSerialArray & uum = um;
              const realSerialArray & uu  = uOld;
              const realSerialArray & uun = un;
              const realSerialArray & vram = VPML(prev   ,0,0,grid); 
              const realSerialArray & vrbm = VPML(prev   ,1,0,grid); 
              const realSerialArray & vsam = VPML(prev   ,0,1,grid); 
              const realSerialArray & vsbm = VPML(prev   ,1,1,grid); 
              const realSerialArray & vtam = VPML(prev   ,0,2,grid); 
              const realSerialArray & vtbm = VPML(prev   ,1,2,grid); 
              const realSerialArray & vra  = VPML(current,0,0,grid); 
              const realSerialArray & vrb  = VPML(current,1,0,grid); 
              const realSerialArray & vsa  = VPML(current,0,1,grid); 
              const realSerialArray & vsb  = VPML(current,1,1,grid); 
              const realSerialArray & vta  = VPML(current,0,2,grid); 
              const realSerialArray & vtb  = VPML(current,1,2,grid); 
              const realSerialArray & vran = VPML(next   ,0,0,grid); 
              const realSerialArray & vrbn = VPML(next   ,1,0,grid); 
              const realSerialArray & vsan = VPML(next   ,0,1,grid); 
              const realSerialArray & vsbn = VPML(next   ,1,1,grid); 
              const realSerialArray & vtan = VPML(next   ,0,2,grid); 
              const realSerialArray & vtbn = VPML(next   ,1,2,grid); 
              const realSerialArray & wram = WPML(prev   ,0,0,grid); 
              const realSerialArray & wrbm = WPML(prev   ,1,0,grid); 
              const realSerialArray & wsam = WPML(prev   ,0,1,grid); 
              const realSerialArray & wsbm = WPML(prev   ,1,1,grid); 
              const realSerialArray & wtam = WPML(prev   ,0,2,grid); 
              const realSerialArray & wtbm = WPML(prev   ,1,2,grid); 
              const realSerialArray & wra  = WPML(current,0,0,grid); 
              const realSerialArray & wrb  = WPML(current,1,0,grid); 
              const realSerialArray & wsa  = WPML(current,0,1,grid); 
              const realSerialArray & wsb  = WPML(current,1,1,grid); 
              const realSerialArray & wta  = WPML(current,0,2,grid); 
              const realSerialArray & wtb  = WPML(current,1,2,grid); 
              const realSerialArray & wran = WPML(next   ,0,0,grid); 
              const realSerialArray & wrbn = WPML(next   ,1,0,grid); 
              const realSerialArray & wsan = WPML(next   ,0,1,grid); 
              const realSerialArray & wsbn = WPML(next   ,1,1,grid); 
              const realSerialArray & wtan = WPML(next   ,0,2,grid); 
              const realSerialArray & wtbn = WPML(next   ,1,2,grid); 
      #endif
              real *umptr, *uuptr, *unptr;   
              umptr=uum.getDataPointer();
              uuptr= uu.getDataPointer();  
              unptr=uun.getDataPointer();
       // Here is the box outside of which the PML equations are applied.
              getBoundsForPML(mg,Iv);
              int includeGhost=0;
              bool ok = ParallelUtility::getLocalArrayBounds(uOld,uu,I1,I2,I3,includeGhost);
              if( ok )
              {
                  ipar[2] =I1.getBase();
                  ipar[3] =I1.getBound();
                  ipar[4] =I2.getBase();
                  ipar[5] =I2.getBound();
                  ipar[6] =I3.getBase();
                  ipar[7] =I3.getBound();
                  assert( dx[0]>0. );
                  int bc0=-1;  // not used
         // ** for( int m=0; m<3; m++ )
                  for( int m=0; m<3; m++ )
                  {
                      ipar[12]=uc+m; // assign this component
                      pmlSolidMechanics( mg.numberOfDimensions(), 
                                                            uu.getBase(0),uu.getBound(0),
                                                            uu.getBase(1),uu.getBound(1),
                                                            uu.getBase(2),uu.getBound(2),
                                                            ff.getBase(0),ff.getBound(0),
                                                            ff.getBase(1),ff.getBound(1),
                                                            ff.getBase(2),ff.getBound(2),
                                                            *gid.getDataPointer(),
                                                            *umptr, *uuptr, *unptr, 
                              // vra (left)
                                                            vra.getBase(0),vra.getBound(0),vra.getBase(1),vra.getBound(1),vra.getBase(2),vra.getBound(2),
                                                            *vram.getDataPointer(),*vra.getDataPointer(),*vran.getDataPointer(),
                                                            *wram.getDataPointer(),*wra.getDataPointer(),*wran.getDataPointer(),
                              // vrb (right)
                                                            vrb.getBase(0),vrb.getBound(0),vrb.getBase(1),vrb.getBound(1),vrb.getBase(2),vrb.getBound(2),
                                                            *vrbm.getDataPointer(),*vrb.getDataPointer(),*vrbn.getDataPointer(),
                                                            *wrbm.getDataPointer(),*wrb.getDataPointer(),*wrbn.getDataPointer(),
                              // vsa (bottom)
                                                            vsa.getBase(0),vsa.getBound(0),vsa.getBase(1),vsa.getBound(1),vsa.getBase(2),vsa.getBound(2),
                                                            *vsam.getDataPointer(),*vsa.getDataPointer(),*vsan.getDataPointer(),
                                                            *wsam.getDataPointer(),*wsa.getDataPointer(),*wsan.getDataPointer(),
                              // vsb 
                                                            vsb.getBase(0),vsb.getBound(0),vsb.getBase(1),vsb.getBound(1),vsb.getBase(2),vsb.getBound(2),
                                                            *vsbm.getDataPointer(),*vsb.getDataPointer(),*vsbn.getDataPointer(),
                                                            *wsbm.getDataPointer(),*wsb.getDataPointer(),*wsbn.getDataPointer(),
                              // vta
                                                            vta.getBase(0),vta.getBound(0),vta.getBase(1),vta.getBound(1),vta.getBase(2),vta.getBound(2),
                                                            *vtam.getDataPointer(),*vta.getDataPointer(),*vtan.getDataPointer(),
                                                            *wtam.getDataPointer(),*wta.getDataPointer(),*wtan.getDataPointer(),
                              // vtb 
                                                            vtb.getBase(0),vtb.getBound(0),vtb.getBase(1),vtb.getBound(1),vtb.getBase(2),vtb.getBound(2),
                                                            *vtbm.getDataPointer(),*vtb.getDataPointer(),*vtbn.getDataPointer(),
                                                            *wtbm.getDataPointer(),*wtb.getDataPointer(),*wtbn.getDataPointer(),
                                                            *fptr,*maskptr,*rxptr, *xyptr,
                                                            bc0, *bc.getDataPointer(), ipar[0], rpar[0], ierr );
                  }  // end m
                  ipar[12]=uc; // reset
              }
         // ::display(um(all,all,all,hz),"um after pml BC's","%9.2e ");
       // ::display(u(all,all,all,hz) ,"u  after pml BC's","%9.2e ");
       // ::display(un(all,all,all,hz),"un after pml BC's","%9.2e ");
          }
     // ::display(u,"u after pml BC's","%9.2e ");
      } // end use opt
        

   // *wdh* 090824 -- moved from above 
      if( parameters.dbase.get<int >("extrapolateInterpolationNeighbours") &&
              parameters.dbase.get<int>("useNewExtrapInterpNeighbours") )
      {
     // *new way* 091123 -- MappedGridOperators uses new AssignInterpNeighbours class

     // -- See op/tests/testExtrapInterpNeighbours for proper way to apply --
          if( debug & 2 )
              printF("assignBC-SOS: Use new extrapolateInterpolationNeighbours at t=%g\n",t);

          extrapParams.orderOfExtrapolation=parameters.dbase.get<int >("orderOfExtrapolationForInterpolationNeighbours");
          u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,extrapParams);

     // extrap 2nd ghost line extended
          extrapParams.ghostLineToAssign=2;
          extrapParams.extraInTangentialDirections=2;

          u.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);

     // reset 
          extrapParams.ghostLineToAssign=1;
          extrapParams.extraInTangentialDirections=0;

     // NOTE: We must also call finishBoundaryConditions to fix corners and update ghosts -- done below --

      }
      else  if( parameters.dbase.get<int >("extrapolateInterpolationNeighbours") ) // *wdh* 090823
      {
     // *** OLD WAY ***

     // extrapolate the 2nd ghost line and interpolation neighbours for higher-order dissipation
     // -- is this the right place to do this ? 
          extrapParams.ghostLineToAssign=2;
          extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1;
          if( applyFilter )
              extrapParams.orderOfExtrapolation=orderOfAccuracyInSpace+1; // *wdh* 090824 -- try this with the 4th order filter
          u.applyBoundaryCondition(C,BCTypes::extrapolate,BCTypes::allBoundaries,0.,t,extrapParams);
          extrapParams.ghostLineToAssign=1;
          
          if( debug & 8  )
              printF(" extrapolateInterpolationNeighbours at t=%g\n",t);

     // if( grid==0 ) printF(" u(19,13)=%9.2e before extrapolateInterpolationNeighbours\n",u(19,13,0,0));
     // if( grid==0 ) printF(" u(10,8)=%9.2e before extrapolateInterpolationNeighbours\n",u(10,8,0,0));

          if( debug & 2 && grid==0 )
          {
              ::display(uLocal,sPrintF("uLocal before extrapolateInterpolationNeighbours, t=%e",t),pDebugFile,"%4.2f ");
          }
          

     // extrapParams.orderOfExtrapolation=2;
          u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t);
     //extrapParams.orderOfExtrapolation=parameters.dbase.get<int >("orderOfExtrapolationForInterpolationNeighbours");
     //u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,extrapParams);

          if( debug & 2 && grid==0 )
          {
       // u.updateGhostBoundaries();
              fflush(0);
              Communication_Manager::Sync();
              ::display(uLocal,sPrintF("uLocal after extrapolateInterpolationNeighbours, t=%e",t),pDebugFile,"%4.2f ");
          }

     // BoundaryConditionParameters ep;
     // ep.orderOfExtrapolation=3;
     // u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,ep);

     // extrapParams.orderOfExtrapolation=parameters.dbase.get<int >("orderOfExtrapolationForInterpolationNeighbours");
     // u.applyBoundaryCondition(C,BCTypes::extrapolateInterpolationNeighbours,BCTypes::allBoundaries,0.,t,
     //                          extrapParams,grid);

     // if( grid==0 ) printF(" u(19,13)=%9.2e after extrapolateInterpolationNeighbours\n",u(19,13,0,0));
     // if( grid==0 ) printF(" u(10,8)=%9.2e after extrapolateInterpolationNeighbours\n",u(10,8,0,0));

      }

//     // assign any radiation BC's
//     for( int i=0; i<2; i++ )
//     {
//       if( radbcGrid[i]==grid )
//       {
//         RadiationBoundaryCondition::debug=debug;
//      radiationBoundaryCondition[i].tz=tz; // fix this 
//      radiationBoundaryCondition[i].assignBoundaryConditions( u,t,dt,uOld );
//       }
            
//     }
        

      if( !useConservative || 
              (parameters.dbase.get<int>("useNewExtrapInterpNeighbours") && parameters.dbase.get<int >("extrapolateInterpolationNeighbours") ) ) 
      {
     // *wdh* 090911 -- do NOT change SOS-C values!

     // *wdh* 091123 -- for now apply finishBC to SOS-C TOO !

          u.finishBoundaryConditions();  // do this for now -- corners needed --
      }
      else
      {
     // for SOS-C we need to fixup the 2nd-ghost at corners if we extrap interp neighbours  ************ FIX ME ****

          u.updateGhostBoundaries();  // *wdh* 091123 
      }
      
      
    if( debug & 64 )
    {
        ::display(u,sPrintF("u at end of assignBC, grid=%i t=%e",grid,t),debugFile,"%8.1e ");
    }

}

