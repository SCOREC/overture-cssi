// ==========================================================================================================
// Class to define exact solutions for CgSm
// 
//   VIBRATIONAL MODES OF A SPHERE
// 
// ==========================================================================================================


#include "SmSphereExactSolution.h"

#include "NurbsMapping.h"

#include "PlotStuff.h"
#include "ParallelUtility.h"

#include <complex>


typedef ::real LocalReal;
// typedef ::real OV_real;

typedef std::vector<std::complex<Real> > ComplexVector;

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)



// ===============================================================================
/// \brief  Constructor for the class that defines exact solutions for a sphere
// ===============================================================================
SmSphereExactSolution::
SmSphereExactSolution()
{

  // dbase.put<int>("numberOfDimensions");
  dbase.put<bool>("initialized")=false;

  dbase.put<Real>("omega") = -1.;
  dbase.put<aString>("caseName") = "unknown";

  // dbase.put<Real>("amp")=1.;

  // std::complex<Real> & s  = dbase.put<std::complex<Real> >("s");
  // std::complex<Real> & kx = dbase.put<std::complex<Real> >("kx");

  // ComplexVector & kvyta   = dbase.put<ComplexVector>("kvyt");   // top ky's 
  // ComplexVector & kvyba   = dbase.put<ComplexVector>("kvyb");   // bottom ky's 
  // ComplexVector & qvta    = dbase.put<ComplexVector>("qvt");    // top eigenvectors
  // ComplexVector & qvba    = dbase.put<ComplexVector>("qvb");    // bottom eigenvectors 

  
}


// ===============================================================================
/// \brief destructor 
// ===============================================================================
SmSphereExactSolution::
~SmSphereExactSolution()
{
  if( dbase.has_key("nurbs") )
  {
    NurbsMapping *nurbs = dbase.get<NurbsMapping*>("nurbs");
    delete [] nurbs;
  }
  

}


// ===============================================================================
/// \brief Return a solution parameter by name
// ===============================================================================
int SmSphereExactSolution::
getParameter( const aString & name, Real & value )
{
  if( name=="omega" )
  {
    value = dbase.get<Real>("omega");
    // printF("\n ***** SmSphereExactSolution:: omega=%g ****\n",value);
  }
  else
  {
    printF("SmSphereExactSolution::getParameter: ERROR: unknown parameter=[%s]\n",(const char*)name);
  }
  return 0;
}

// ----------------------------------------------------------------
// Evaluate the polar cooridinates from the cartesian coordinates 
// ----------------------------------------------------------------
#beginMacro getPolar(i1,i2,i3,cosTheta,sinTheta,theta)
  Real x = xLocal(i1,i2,i3,0);
  Real y = xLocal(i1,i2,i3,1);
  Real r = sqrt( x*x + y*y );

  if( r < eps ) //  avoid division by zero
  {
    x=eps;           // avoid atan(0,0)
    y=eps;
    r=sqrt(2.)*eps;  // r=sqrt(x**2+y**2)
  }   

  Real theta = atan2(y,x); 
  Real cosTheta = cos(theta);
  Real sinTheta = sin(theta);
#endMacro



// // ====================================================================
// // Macro : Read the exact solution data and create Nurbs to evalue it.
// // ====================================================================
// #beginMacro getExactSolutionMacro()

//   // --- this next file defines the radial part of the exact solution, computed with finite differences ---
//   //   urRe[] = array of real part of ur
//   //   urIm[] = array of imag part of ur
//   //   uThetaRe[] = array of real part of uTheta
//   //   uThetaIm[] = array of imag part of uTheta

//   // Synthetic data for testing:
//   // #Include "src/incompressible/cylExactTest.h"

//   // >> from $ism/matlab/cylinderDiscreteEigFuncs/hollowCylinderEigFun_d_d.h
//   // >> from $ism/matlab/cylinderDiscreteEigFuncs/hollowCylinderEigFun_t_t.h
//   // Traction-traction
//   // #Include "src/incompressible/hollowCylinderEigFun_t_t.h"

//   // Displacement displacement:
//   // #Include "src/incompressible/hollowCylinderEigFun_d_d.h"

//   printF("SmSphereExactSolution: GET DATA FOR EXACT SOLUTION:\n  omega=%g, Ng=%d, ia=%d, ib=%d\n",omega,Ng,ia,ib);
//   printF("  ra=%g, rb=%g, m=%d, za=%g, zb=%g, kz=%g\n",ra,rb,m, za,zb,kz);

//   // Fill in variables with the "same" name but in outer-scope 
//   ra_=ra; rb_=rb; za_=za; zb_=zb; kz_=kz; omega_=omega;  m_=m;

//   // Grid in r (includes ghost)
//   //         +--+--X--+--+--+-- ...   --+--+--X--+--+
//   //         1     ia                         ib    Ng
//   //               r=ra                      r=rb
//   //               0  1  2                    nr         <- base 0 
//   int nr = ib-ia+1;          // number of grid points
//   int numGhost0 = ia-1;      // num ghost on left 
//   int numGhost1 = Ng-ib;     // num ghost on right
//   assert( numGhost0==numGhost1 ); 

//   IntegerArray dimension(2,3), gridIndexRange(2,3);
//   dimension=0;
//   gridIndexRange=0;

//   gridIndexRange(1,0)=nr-1;

//   dimension(0,0)=gridIndexRange(0,0)-numGhost0;
//   dimension(1,0)=gridIndexRange(1,0)+numGhost1;

//   int nurbsDegree=3; 
//   int xDegree[3] ={ nurbsDegree,nurbsDegree,nurbsDegree };  // 

//   int domainDimension=1, rangeDimension=2; 
//   RealArray x(Range(dimension(0,0),dimension(1,0)),1,1,1,rangeDimension);  // data 
//   // RealArray x(Ng,1,1,1,rangeDimension);  // data 

//   Real *uReArray[]={ urRe, uThetaRe, uzRe, pRe }; // array of pointers to array of real-parts 
//   Real *uImArray[]={ urIm, uThetaIm, uzIm, pIm }; // array of pointers to array of imaginary-parts 
//   for( int n=0; n<numNurbs; n++ )
//   {

//     Real *uRe = uReArray[n];
//     Real *uIm = uImArray[n];
//     // for( int i=0; i<Ng; i++ )
//     const int offset = dimension(0,0); 
//     for( int i=dimension(0,0); i<=dimension(1,0); i++ )
//     {
//       // printF(" n=%d: i=%d uRe=%g, uIm=%g\n",n,i,uRe[i],uIm[i]);
//       x(i,0,0,0,0) = uRe[i-offset];
//       x(i,0,0,0,1) = uIm[i-offset]; 
//     }
//     // --- Nurbs[n] holds the Re and Im parts of the radial solutions ---
//     nurbs[n].interpolate( x,domainDimension,rangeDimension,dimension,gridIndexRange,
//                           NurbsMapping::parameterizeByIndex,xDegree );
//   }

// #endMacro


// ===============================================================================
/// \brief Initialize the exact solution.
// ===============================================================================
int SmSphereExactSolution::
initialize( CompositeGrid & cg, const aString & caseName )
{
  bool & initialized=dbase.get<bool>("initialized");
  initialized=true;

  dbase.get<aString>("caseName")=caseName;  // save the case name


  return 0;
}



//========================================================================================================
/// \brief Evaluate the exact solution
//========================================================================================================
int SmSphereExactSolution::
evalSolution(Real t, CompositeGrid & cg, int grid, RealArray & ua, 
                          const Index & I1, const Index &I2, const Index &I3, 
                          int numberOfTimeDerivatives /* = 0 */  )
{

  if( false )
    printF("\n +++++ SmSphereExactSolution:: evalSolution t=%9.3e ++++++\n",t);

  const aString & caseName = dbase.get<aString>("caseName");


  const int u1c = 0;
  const int u2c = 1;
  const int u3c = 2;
  const int pc  = 3;

  MappedGrid & mg = cg[grid];
  mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex );

  OV_GET_SERIAL_ARRAY(real,mg.center(),xLocal);
  // OV_GET_SERIAL_ARRAY(real,ua,uLocal);
  RealArray & uLocal = ua;

  // These next parameters should be set in the following include files
  int m=-1, n=-1;
  Real cs=-1., a=-1., k=-1., omega=-1., OmegaFact=-1.;
  // fprintf(file,"a=%20.16e;  // Sphere radius \n",a);
  // fprintf(file,"k=%20.16e;\n",k);
  // fprintf(file,"omega=%20.16e;\n",k*cs);
  // fprintf(file,"OmegaFact=%20.16e;\n",OmegaFact);

  if( caseName=="solidSphereD" )
  {
    #Include "ismSolidModeOfVibrationIIDisplacement.h"
  }
  else if( caseName=="solidSphereT" )
  {
    #Include "ismSolidModeOfVibrationIITraction.h"
  }
  else if( caseName=="ismSolidModeOfVibrationIITractionEigenMode2" )
  {
    #Include "ismSolidModeOfVibrationIITractionEigenMode2.h"
  }  
  else
  {
    printF("SmSphereExactSolution:ERROR: unknown caseName=[%s]\n",(const char*)caseName);
    printF(" Expected caseName=solidSphereD or caseName=solidSphereT\n");
    OV_ABORT("ERROR");
  }

// // File written by AMP/ims/maple-DWS/solidVibrationModes.mpl
// // =======================================================================================
// // Macro: evaluate the solid mode of vibration II for an incompressible solid, Traction BC
// // =======================================================================================
// #beginMacro evalSolidMode2Traction(r,theta,phi, u1,u2,u3,p)
//   // Lp = the associated Legendre function
//     Lp = 0.3e1 * (cos(phi) - 0.1e1) * (cos(phi) + 0.1e1);
//   // phip = Pi - phi
//   if( r>eps && phi>eps && phip>eps )
//   { // r, phi and phip=Pi=phi are big
//     u1 = -0.10e2 / 0.3e1 * (cos(phi) - 0.1e1) * Lp * (cos(phi) + 0.1e1) * ((((double) (-6 * r * r * k * k + 15) * pow(cos(phi), 0.2e1) + (double) (3 * r * r * k * k) - 0.9e1) * sin((double) (k * r)) + ((0.9e1 + (double) (r * r * k * k - 15) * pow(cos(phi), 0.2e1)) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) k * (double) r) * cos(theta) * cos(0.2e1 * theta) + sin(0.2e1 * theta) * sin(theta) * ((double) (-3 * r * r * k * k + 6) * sin((double) (k * r)) + (double) k * ((double) (r * r * k * k - 6) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) r)) * pow(sin(phi), -0.3e1) * (double)   pow((double) k, (double) (-5)) * (double)   pow((double) r, (double) (-4));
//     u2 = -0.10e2 / 0.3e1 * (cos(phi) - 0.1e1) * Lp * (sin(theta) * (((double) (-6 * r * r * k * k + 15) * pow(cos(phi), 0.2e1) + (double) (3 * r * r * k * k) - 0.9e1) * sin((double) (k * r)) + ((0.9e1 + (double) (r * r * k * k - 15) * pow(cos(phi), 0.2e1)) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) k * (double) r) * cos(0.2e1 * theta) - sin(0.2e1 * theta) * ((double) (-3 * r * r * k * k + 6) * sin((double) (k * r)) + (double) k * ((double) (r * r * k * k - 6) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) r) * cos(theta)) * (cos(phi) + 0.1e1) * pow(sin(phi), -0.3e1) * (double)   pow((double) k, (double) (-5)) * (double)   pow((double) r, (double) (-4));
//     u3  = 0.10e2 / 0.3e1 * cos(phi) * cos((double) (2 * theta)) * (cos(k * r) * pow(k, 0.3e1) * pow(r, 0.3e1) - 0.6e1 * sin(k * r) * k * k * r * r - 0.15e2 * cos(k * r) * k * r + 0.15e2 * sin(k * r)) * Lp * pow(sin(phi), -0.2e1) * pow(k, -0.5e1) * pow(r, -0.4e1) * (pow(cos(phi), 0.2e1) - 0.1e1);
//     p = -OmegaFact * r * r * Lp * cos((double) (2 * theta));
//   }
//   else if( r>eps )
//   { // small phi or phip but not small r -- series error is O(phi^3)
//     if( phi<eps ) // small phi but not small r
//     { 
//     u1 = -0.10e2 * (((double) (-3 * r * r * k * k + 6) * sin((double) (k * r)) + (double) k * ((double) (r * r * k * k - 6) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) r) * cos(theta) * cos(0.2e1 * theta) + sin(0.2e1 * theta) * sin(theta) * ((double) (-3 * r * r * k * k + 6) * sin((double) (k * r)) + (double) k * ((double) (r * r * k * k - 6) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) r)) * (double)   pow((double) k, (double) (-5)) * (double)   pow((double) r, (double) (-4)) * phi;
//     u2 = -0.10e2 * (sin(theta) * ((double) (-3 * r * r * k * k + 6) * sin((double) (k * r)) + (double) k * ((double) (r * r * k * k - 6) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) r) * cos(0.2e1 * theta) - sin(0.2e1 * theta) * ((double) (-3 * r * r * k * k + 6) * sin((double) (k * r)) + (double) k * ((double) (r * r * k * k - 6) * cos((double) (k * r)) - 0.3e1 / 0.5e1 * (double) (k * k) * (double)   pow((double) r, (double) 4) * (double) OmegaFact) * (double) r) * cos(theta)) * (double)   pow((double) k, (double) (-5)) * (double)   pow((double) r, (double) (-4)) * phi;
//     u3  = 0.10e2 * cos((double) (2 * theta)) * (cos(k * r) * pow(k, 0.3e1) * pow(r, 0.3e1) - 0.6e1 * sin(k * r) * k * k * r * r - 0.15e2 * cos(k * r) * k * r + 0.15e2 * sin(k * r)) * pow(k, -0.5e1) * pow(r, -0.4e1) * phi * phi - 0.25e2 / 0.3e1 * cos((double) (2 * theta)) * (cos(k * r) * pow(k, 0.3e1) * pow(r, 0.3e1) - 0.6e1 * sin(k * r) * k * k * r * r - 0.15e2 * cos(k * r) * k * r + 0.15e2 * sin(k * r)) * pow(k, -0.5e1) * pow(r, -0.4e1) * pow(phi, 0.4e1);
//     p = 0.3e1 * OmegaFact * r * r * cos((double) (2 * theta)) * phi * phi - OmegaFact * r * r * cos((double) (2 * theta)) * pow(phi, 0.4e1);
//     } 
//     else if( phip<eps )// small phip, big r
//     { 
//     u1 = 0.2e1 * pow(k, -0.5e1) * pow(r, -0.4e1) * (-0.3e1 * OmegaFact * pow(r, 0.5e1) * pow(k, 0.3e1) + 0.5e1 * cos(k * r) * pow(k, 0.3e1) * pow(r, 0.3e1) - 0.15e2 * sin(k * r) * k * k * r * r - 0.30e2 * cos(k * r) * k * r + 0.30e2 * sin(k * r)) * (cos(theta) * cos(0.2e1 * theta) + sin(0.2e1 * theta) * sin(theta)) * phip;
//     u2 = -0.2e1 * pow(k, -0.5e1) * pow(r, -0.4e1) * (-0.3e1 * OmegaFact * pow(r, 0.5e1) * pow(k, 0.3e1) + 0.5e1 * cos(k * r) * pow(k, 0.3e1) * pow(r, 0.3e1) - 0.15e2 * sin(k * r) * k * k * r * r - 0.30e2 * cos(k * r) * k * r + 0.30e2 * sin(k * r)) * (cos(theta) * sin(0.2e1 * theta) - cos(0.2e1 * theta) * sin(theta)) * phip;
//     u3  = -0.10e2 * ((double) (-6 * r * r * k * k + 15) * sin((double) (k * r)) + cos((double) (k * r)) * (double) k * (double) r * (double) (r * r * k * k - 15)) * cos((double) (2 * theta)) * (double)   pow((double) k, (double) (-5)) * (double)   pow((double) r, (double) (-4)) * phip * phip + 0.25e2 / 0.3e1 * ((double) (-6 * r * r * k * k + 15) * sin((double) (k * r)) + cos((double) (k * r)) * (double) k * (double) r * (double) (r * r * k * k - 15)) * cos((double) (2 * theta)) * (double)   pow((double) k, (double) (-5)) * (double)   pow((double) r, (double) (-4)) * pow(phip, 0.4e1);
//     p = 0.3e1 * OmegaFact * r * r * cos((double) (2 * theta)) * phip * phip - OmegaFact * r * r * cos((double) (2 * theta)) * pow(phip, 0.4e1);
//     } 
//     else 
//     { // this case should not happen 
//       OV_ABORT("ERROR"); 
//     } 
//   }
//   else if( phi>eps && phip>eps )
//   { // small r, big phi, big phip -- series error is O(r^3) 
//     u1 = 0.2e1 * pow(k, -0.2e1) * pow(cos(phi) - 0.1e1, 0.2e1) * pow(cos(phi) + 0.1e1, 0.2e1) * cos(theta) * (k * k + (double) (3 * OmegaFact)) * pow(sin(phi), -0.3e1) * r;
//     u2 = -0.2e1 * pow(k, -0.2e1) * pow(cos(phi) - 0.1e1, 0.2e1) * pow(cos(phi) + 0.1e1, 0.2e1) * sin(theta) * (k * k + (double) (3 * OmegaFact)) * pow(sin(phi), -0.3e1) * r;
//     u3  = 0;
//     p = (-0.3e1 * OmegaFact * pow(cos(phi), 0.2e1) + 0.3e1 * OmegaFact) * cos((double) (2 * theta)) * r * r;
//   }
//   else if( phi<eps )
//   { // small r,  small phi 
//     u1 = 0.2e1 * pow(k, -0.2e1) * cos(theta) * (k * k + (double) (3 * OmegaFact)) * r * phi;
//     u2 = -0.2e1 * pow(k, -0.2e1) * sin(theta) * (k * k + (double) (3 * OmegaFact)) * r * phi;
//     u3  = 0;
//     p = 0.3e1 * OmegaFact * r * r * cos((double) (2 * theta)) * phi * phi - OmegaFact * r * r * cos((double) (2 * theta)) * pow(phi, 0.4e1);
//   }
//   else if( phip<eps )
//   { // small r,  small phip 
//     u1 = -0.2e1 * pow(k, -0.2e1) * cos(theta) * (k * k + (double) (3 * OmegaFact)) * r * phip;
//     u2 = 0.2e1 * pow(k, -0.2e1) * sin(theta) * (k * k + (double) (3 * OmegaFact)) * r * phip;
//     u3  = 0;
//     p = 0.3e1 * OmegaFact * r * r * cos((double) (2 * theta)) * phip * phip - OmegaFact * r * r * cos((double) (2 * theta)) * pow(phip, 0.4e1);
//   }
//   else 
//   { // this case should not happen 
//     OV_ABORT("ERROR"); 
//   } 
// #endMacro

// // ---- solid vibrational mode parameters ------
// const int m=2, n=2;
// const Real cs=1.0000000000000000e+00; // Shear wave speed 
// const Real a=1.0000000000000000e+00;  // Sphere radius 
// const Real k=2.6656221892356011e+00;
// const Real omega=2.6656221892356011e+00;
// const Real OmegaFact=-2.7751335800711964e-01;



  Real & omegadb = dbase.get<Real>("omega");
  omegadb = omega;  // save 


  // Real cs = 1;         // shear wave speed, sqrt(mu/rho)
  // omega = cs * k;      // **CHECK ME*  ***************************************

  // printF("SPHERE: omega=%g\n",omega);


  Real coswt, sinwt;
  if( numberOfTimeDerivatives==0 )
  {
    coswt = cos(omega*t);  sinwt = sin(omega*t);
  }
  else if( numberOfTimeDerivatives==1 )
  {
    coswt = -omega*sin(omega*t); sinwt = omega*cos(omega*t);
  }
  else
  {
    OV_ABORT("error");
  }

  Real u1e,u2e,u3e,pe;
  Real Lp;

  // Use asymptotic series for r<eps and/or phi<eps -- errors are O(eps^3)
  const Real eps= pow(REAL_EPSILON,1./3.); // 1.e-5; // 1.e-9; // REAL_EPSILON*1000; // 1.e-9;   // ********************************** FIX ME *********

  // Spherical polar:
  //  r = sqrt( x^2 + x^2 + x^2 )
  //  tan( theta) = y/x
  //  cos( phi ) = z/r

  Real theta, phi;
  int i1,i2,i3;
  FOR_3D(i1,i2,i3,I1,I2,I3)
  {
    Real x = xLocal(i1,i2,i3,0);
    Real y = xLocal(i1,i2,i3,1);
    Real z = xLocal(i1,i2,i3,2);

    Real r  = sqrt( x*x + y*y + z*z );
    Real r2 = sqrt( x*x + y*y );
    if( r > eps )
      phi   =  acos(z/r);
    else
      phi = 0.;

    const Real phip = Pi-phi; 

    if( r2 > eps )
      theta = atan2(y,x);
    else
      theta=0.;

    // Real theta = atan2(y,x);
    // Real phi   =  acos(z/r);
    // define some powers of k and r
    // Real k2 =k*k, k3=k2*k, k4=k3*k, k5=k4*k;
    // Real r2 =r*r, r3=r2*r, r4=r3*r, r5=r4*r;

    evalSolidMode2Traction(r,theta,phi, u1e,u2e,u3e,pe)        

    // sphereMacro(x,y,z,t,u1e,u2e,u3e,pe);

    uLocal(i1,i2,i3,u1c) = u1e*coswt;
    uLocal(i1,i2,i3,u2c) = u2e*coswt;
    uLocal(i1,i2,i3,u3c) = u3e*coswt;
    uLocal(i1,i2,i3,pc ) =  pe*coswt;

  }


  return 0;
}


