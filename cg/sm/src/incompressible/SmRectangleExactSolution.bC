// ==========================================================================================================
// Class to define exact solutions for CgSm
// 
//   VIBRATIONAL MODES OF A RECTANGLE IN 2D OR 3
//      (1) PERIODIC STRIP IN 2D
//      (1) PERIODIC STRIP IN 3D
// 
// ==========================================================================================================


#include "SmRectangleExactSolution.h"

#include "NurbsMapping.h"

#include "PlotStuff.h"
#include "ParallelUtility.h"

#include <complex>


typedef ::real LocalReal;
// typedef ::real OV_real;

typedef std::vector<std::complex<Real> > ComplexVector;

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)



// ===============================================================================
/// \brief  Constructor for the class that defines exact solutions for a Rectangle
// ===============================================================================
SmRectangleExactSolution::
SmRectangleExactSolution()
{

  // dbase.put<int>("numberOfDimensions");
  dbase.put<bool>("initialized")=false;

  dbase.put<Real>("omega") = -1.;
  dbase.put<aString>("caseName") = "unknown";

  // mode numbers 
  dbase.put<int>("mx")=1;
  dbase.put<int>("my")=1;
  dbase.put<int>("mz")=1;

}


// ===============================================================================
/// \brief destructor 
// ===============================================================================
SmRectangleExactSolution::
~SmRectangleExactSolution()
{
  if( dbase.has_key("nurbs") )
  {
    NurbsMapping *nurbs = dbase.get<NurbsMapping*>("nurbs");
    delete [] nurbs;
  }
  

}


// ===============================================================================
/// \brief Return a solution parameter by name
// ===============================================================================
int SmRectangleExactSolution::
getParameter( const aString & name, Real & value )
{
  if( dbase.has_key(name) )
  {
    value = dbase.get<Real>(name);
    // printF("\n ***** SmRectangleExactSolution:: omega=%g ****\n",value);
  }
  else
  {
    printF("SmRectangleExactSolution::getParameter: ERROR: unknown parameter=[%s]\n",(const char*)name);
  }
  return 0;
}

// ===============================================================================
/// \brief Set an integer parameter value by name
///   Common parameters: mx, my, mz
// ===============================================================================
int SmRectangleExactSolution::
setParameter( const aString & name, const int value )
{
  if( dbase.has_key(name) )
  {
    dbase.get<int>(name) = value;
    // printF("\n ***** SmRectangleExactSolution:: omega=%g ****\n",value);
  }
  else
  {
    printF("SmRectangleExactSolution::setParameter: ERROR: unknown parameter=[%s]\n",(const char*)name);
  }
  return 0;
}



// ===============================================================================
/// \brief Initialize the exact solution.
// ===============================================================================
int SmRectangleExactSolution::
initialize( CompositeGrid & cg, const aString & caseName )
{
  bool & initialized=dbase.get<bool>("initialized");
  initialized=true;

  dbase.get<aString>("caseName")=caseName;  // save the case name


  return 0;
}



//========================================================================================================
/// \brief Evaluate the exact solution
/// \param numberOfTimeDerivatives (input) : 
///      NOTE: numberOfTimeDerivatives=-1 means eval the pressure only.
//========================================================================================================
int SmRectangleExactSolution::
evalSolution(Real t, CompositeGrid & cg, int grid, RealArray & ua, 
                          const Index & I1, const Index &I2, const Index &I3, 
                          int numberOfTimeDerivatives /* = 0 */  )
{

  const aString & caseName = dbase.get<aString>("caseName");

 // The eigenvalue defined by (mx,my), in the range 1,2,3,...
  const int & mx = dbase.get<int>("mx");
  const int & my = dbase.get<int>("my");
  const int & mz = dbase.get<int>("mz");

  if( true )
    printF("\n +++++ SmRectangleExactSolution:: evalSolution caseName=%s, (mx,my,mz)=(%d,%d,%d) numberOfTimeDerivatives=%d, t=%9.3e ++++++\n",
           (const char*)caseName,mx,my,mz,numberOfTimeDerivatives,t);

 

  Real rho =1., mu=1., c=1.; // FIX ME ****************

  MappedGrid & mg = cg[grid];
  mg.update(MappedGrid::THEcenter | MappedGrid::THEvertex );
  const int numberOfDimensions = mg.numberOfDimensions();

  const int u1c = 0;
  const int u2c = 1;
  const int u3c = 2;
  int pc        = numberOfDimensions;       // may change below if we only eval the pressure

  OV_GET_SERIAL_ARRAY(real,mg.center(),xLocal);
  OV_GET_SERIAL_ARRAY(real,ua,uLocal);


  Real A1,B1, A2,B2, A3, B3, P1, P2, P1p, P1m, P2p, P2m, P3p, P3m;
  Real omega, beta, alpha, kx, ky, kz, k;

  Real scaleFactor=1.; // sets the scale 
  bool isSurfaceWave=false;

  // ---> File written by AMP/ism/maple/ismStrip2d.mpl
  //
  if( caseName=="periodicStripTT" || caseName=="rectangleTT" )
  {
    // periodic strip BC=TT

    // --- Eigenvalues of a 2D periodic strip for incompressible elasticity -----
    //   BC = TT
    //   File written by ismStrip2d.mw on 2022-06-20
    //   Solution is of the form  : u(x,y,t) = uHat(x) *exp( I*k*y )*exp( I*omega t) , k=2*Pi*m 
    //   uHat1 =  A1*cos(beta*x) + B1*sin(beta*x) + pHat'(x)/(mu*(beta^2+k^2) 
    //   uHat2 =  from divergence
    //   pHat  =  A3*exp(k*x) + B3*exp(-k*x) 
    //   beta^2 = (omega/c)^2 - k^2 
    //   Note that beta is generally real except for surface waves where it is pure imaginary
    if( numberOfDimensions==2 )
    {         
      #Include "ismStrip2dTractionTractionRoots.h"
    }
    else
    {
      OV_ABORT("Finish me");
    }      

  }
  else if( caseName=="periodicStripTD" || caseName=="rectangleTD" )
  {
    // periodic strip BC=TRACTION - DISPLACEMENT 

    printF(" \n @@@@@@@ case TD @@@@ \n");  
    if( numberOfDimensions==2 )
    {
      #Include "ismStrip2dTractionDisplacementRoots.h"
    }
    else
    {
      OV_ABORT("Finish me");
    }

  }  
  else if( caseName=="periodicStripDD" || caseName=="rectangleDD" )
  {
    // periodic strip BC=DISPLACEMENT - DISPLACEMENT 
    printF(" \n @@@@@@@ case DD @@@@ \n");  
    if( numberOfDimensions==2 )
    {    
      #Include "ismStrip2dDisplacementDisplacementRoots.h"
    }
    else
    {
      OV_ABORT("Finish me");
    }
  }    
  else
  {
    printF("SmRectangleExactSolution:ERROR: unknown caseName=[%s]\n",(const char*)caseName);
    printF(" Expected caseName=rectangleTT or caseName=periodicStripTT\n");
    OV_ABORT("ERROR");
  }


  Real & omegadb = dbase.get<Real>("omega");
  omegadb = omega;  // save 

  Real coswt, sinwt;
  // By default we eval the displacements and pressure
  bool evalDisplacements=true;
  bool evalPressure=true;

  if( numberOfTimeDerivatives==-1 )
  { // Only eval the pressure 
    evalDisplacements=false;
    numberOfTimeDerivatives=0;
    pc=0; // NOTE - save pressure only
  }

  if( numberOfTimeDerivatives==0 )
  {
    coswt = cos(omega*t);  
    sinwt = sin(omega*t);
  }
  else if( numberOfTimeDerivatives==1 )
  { // do not eval pressure in this case
    evalPressure=false;
    coswt = -omega*sin(omega*t); 
    sinwt =  omega*cos(omega*t);
  }
  else if( numberOfTimeDerivatives==2 )
  { // do not eval pressure in this case
    evalPressure=false;
    coswt = -omega*omega*cos(omega*t); 
    sinwt = -omega*omega*sin(omega*t);
  }  
  else
  {
    OV_ABORT("error");
  }

  Real cosbx, sinbx; 
  int i1,i2,i3;
  if( numberOfDimensions==2 )
  {
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
      Real x = xLocal(i1,i2,i3,0);
      Real y = xLocal(i1,i2,i3,1);

      if( isSurfaceWave )
      {
        cosbx = cosh(alpha*x); sinbx=sinh(alpha*x);
      }
      else
      {
        cosbx = cos(beta*x), sinbx=sin(beta*x);
      }

      const Real exppkx=exp(kx*x), expmkx=1./exppkx; 
      const Real cosky = cos(ky*y), sinky=sin(ky*y); 

      // u1 = Re( u1Hat * exp( i*ky*y) * exp(i*omega t) )
      // u2 = Im( u1Hat * exp( i*ky*y) * exp(i*omega t) )
      // p  = Re( pHat  * exp( i*ky*y) * exp(i*omega t) )

      if( evalDisplacements ) // eval u or its time derivative 
      {
        uLocal(i1,i2,i3,u1c) =  ( A1*cosbx + B1*sinbx + P1p*exppkx + P1m*expmkx )*(cosky*coswt - sinky*sinwt);
        uLocal(i1,i2,i3,u2c) =  ( A2*cosbx + B2*sinbx + P2p*exppkx + P2m*expmkx )*(cosky*sinwt + sinky*coswt);
      }
      if( evalPressure )
      {
        uLocal(i1,i2,i3,pc ) =  ( A3*exppkx + B3*expmkx                         )*(cosky*coswt - sinky*sinwt);
      }

    }
  }
  else
  {
    OV_ABORT("finish me");
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
      Real x = xLocal(i1,i2,i3,0);
      Real y = xLocal(i1,i2,i3,1);
      Real z = xLocal(i1,i2,i3,2);

      if( isSurfaceWave )
      {
        cosbx = cosh(alpha*x); sinbx=sinh(alpha*x);
      }
      else
      {
        cosbx = cos(beta*x), sinbx=sin(beta*x);
      }

      const Real exppkx=exp(kx*x), expmkx=1./exppkx; 
      const Real cosky = cos(ky*y +kz*z), sinky=sin(ky*y + kz*z); 

      // u1 = Re( u1Hat * exp( i*ky*y + i*kz*z ) * exp(i*omega t) )
      // u2 = Im( u1Hat * exp( i*ky*y + i*kz*z ) * exp(i*omega t) )
      // p  = Re( pHat  * exp( i*ky*y + i*kz*z ) * exp(i*omega t) )

      if( evalDisplacements ) // eval u or its time derivative 
      {
        uLocal(i1,i2,i3,u1c) =  ( A1*cosbx + B1*sinbx + P1p*exppkx + P1m*expmkx )*(cosky*coswt - sinky*sinwt);
        uLocal(i1,i2,i3,u2c) =  ( A2*cosbx + B2*sinbx + P2p*exppkx + P2m*expmkx )*(cosky*sinwt + sinky*coswt);
        uLocal(i1,i2,i3,u3c) =  ( A3*cosbx + B3*sinbx + P3p*exppkx + P3m*expmkx )*(cosky*sinwt + sinky*coswt);
      }
      if( evalPressure )
      {
        uLocal(i1,i2,i3,pc ) =  ( P1*exppkx + P2*expmkx                         )*(cosky*coswt - sinky*sinwt);
      }

    }    
  }


  return 0;
}


