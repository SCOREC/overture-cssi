// ==========================================================================================================
// Class to define exact solutions for CgSm
// 
//   VIBRATIONAL MODES OF A CYLINDER
// 
// ==========================================================================================================


#include "SmCylinderExactSolution.h"

#include "NurbsMapping.h"

#include "PlotStuff.h"
#include "ParallelUtility.h"

#include <complex>


typedef ::real LocalReal;
// typedef ::real OV_real;

typedef std::vector<std::complex<Real> > ComplexVector;

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)



// ===============================================================================
/// \brief  Constructor for th class that defines exact solutions 
// ===============================================================================
SmCylinderExactSolution::
SmCylinderExactSolution()
{

  // dbase.put<int>("numberOfDimensions");
  dbase.put<bool>("initialized")=false;

  dbase.put<Real>("omega") = -1.;

  // dbase.put<Real>("amp")=1.;

  // std::complex<Real> & s  = dbase.put<std::complex<Real> >("s");
  // std::complex<Real> & kx = dbase.put<std::complex<Real> >("kx");

  // ComplexVector & kvyta   = dbase.put<ComplexVector>("kvyt");   // top ky's 
  // ComplexVector & kvyba   = dbase.put<ComplexVector>("kvyb");   // bottom ky's 
  // ComplexVector & qvta    = dbase.put<ComplexVector>("qvt");    // top eigenvectors
  // ComplexVector & qvba    = dbase.put<ComplexVector>("qvb");    // bottom eigenvectors 

  
}


// ===============================================================================
/// \brief destructor 
// ===============================================================================
SmCylinderExactSolution::
~SmCylinderExactSolution()
{
  if( dbase.has_key("nurbs") )
  {
    NurbsMapping *nurbs = dbase.get<NurbsMapping*>("nurbs");
    delete [] nurbs;
  }
  

}


// ===============================================================================
/// \brief Return a solution parameter by name
// ===============================================================================
int SmCylinderExactSolution::
getParameter( const aString & name, Real & value )
{
  if( name=="omega" )
  {
    value = dbase.get<Real>("omega");
  }
  else
  {
    printF("SmCylinderExactSolution::getParameter: ERROR: unknown parameter=[%s]\n",(const char*)name);
  }
  return 0;
}

// ----------------------------------------------------------------
// Evaluate the polar cooridinates from the cartesian coordinates 
// ----------------------------------------------------------------
#beginMacro getPolar(i1,i2,i3,cosTheta,sinTheta,theta)
  Real x = xLocal(i1,i2,i3,0);
  Real y = xLocal(i1,i2,i3,1);
  Real r = sqrt( x*x + y*y );

  if( r < eps ) //  avoid division by zero
  {
    x=eps;           // avoid atan(0,0)
    y=eps;
    r=sqrt(2.)*eps;  // r=sqrt(x**2+y**2)
  }   

  Real theta = atan2(y,x); 
  Real cosTheta = cos(theta);
  Real sinTheta = sin(theta);
#endMacro



// ====================================================================
// Macro : Read the exact solution data and create Nurbs to evalue it.
// ====================================================================
#beginMacro getExactSolutionMacro()

  // --- this next file defines the radial part of the exact solution, computed with finite differences ---
  //   urRe[] = array of real part of ur
  //   urIm[] = array of imag part of ur
  //   uThetaRe[] = array of real part of uTheta
  //   uThetaIm[] = array of imag part of uTheta

  // Synthetic data for testing:
  // #Include "src/incompressible/cylExactTest.h"

  // >> from $ism/matlab/cylinderDiscreteEigFuncs/hollowCylinderEigFun_d_d.h
  // >> from $ism/matlab/cylinderDiscreteEigFuncs/hollowCylinderEigFun_t_t.h
  // Traction-traction
  // #Include "src/incompressible/hollowCylinderEigFun_t_t.h"

  // Displacement displacement:
  // #Include "src/incompressible/hollowCylinderEigFun_d_d.h"

  printF("SmCylinderExactSolution: GET DATA FOR EXACT SOLUTION:\n  omega=%g, Ng=%d, ia=%d, ib=%d\n",omega,Ng,ia,ib);
  printF("  ra=%g, rb=%g, m=%d, za=%g, zb=%g, kz=%g\n",ra,rb,m, za,zb,kz);

  // Fill in variables with the "same" name but in outer-scope 
  ra_=ra; rb_=rb; za_=za; zb_=zb; kz_=kz; omega_=omega;  m_=m;

  // Grid in r (includes ghost)
  //         +--+--X--+--+--+-- ...   --+--+--X--+--+
  //         1     ia                         ib    Ng
  //               r=ra                      r=rb
  //               0  1  2                    nr         <- base 0 
  int nr = ib-ia+1;          // number of grid points
  int numGhost0 = ia-1;      // num ghost on left 
  int numGhost1 = Ng-ib;     // num ghost on right
  assert( numGhost0==numGhost1 ); 

  IntegerArray dimension(2,3), gridIndexRange(2,3);
  dimension=0;
  gridIndexRange=0;

  gridIndexRange(1,0)=nr-1;

  dimension(0,0)=gridIndexRange(0,0)-numGhost0;
  dimension(1,0)=gridIndexRange(1,0)+numGhost1;

  int nurbsDegree=3; 
  int xDegree[3] ={ nurbsDegree,nurbsDegree,nurbsDegree };  // 

  int domainDimension=1, rangeDimension=2; 
  RealArray x(Range(dimension(0,0),dimension(1,0)),1,1,1,rangeDimension);  // data 
  // RealArray x(Ng,1,1,1,rangeDimension);  // data 

  Real *uReArray[]={ urRe, uThetaRe, uzRe, pRe }; // array of pointers to array of real-parts 
  Real *uImArray[]={ urIm, uThetaIm, uzIm, pIm }; // array of pointers to array of imaginary-parts 
  for( int n=0; n<numNurbs; n++ )
  {

    Real *uRe = uReArray[n];
    Real *uIm = uImArray[n];
    // for( int i=0; i<Ng; i++ )
    const int offset = dimension(0,0); 
    for( int i=dimension(0,0); i<=dimension(1,0); i++ )
    {
      // printF(" n=%d: i=%d uRe=%g, uIm=%g\n",n,i,uRe[i],uIm[i]);
      x(i,0,0,0,0) = uRe[i-offset];
      x(i,0,0,0,1) = uIm[i-offset]; 
    }
    // --- Nurbs[n] holds the Re and Im parts of the radial solutions ---
    nurbs[n].interpolate( x,domainDimension,rangeDimension,dimension,gridIndexRange,
                          NurbsMapping::parameterizeByIndex,xDegree );
  }

#endMacro


// ===============================================================================
/// \brief Initialize the exact solution.
// ===============================================================================
int SmCylinderExactSolution::
initialize( CompositeGrid & cg, const aString & caseName )
{
  bool & initialized=dbase.get<bool>("initialized");
  initialized=true;

  // one nurbs each for
  //    ur     (real and im parts), 
  //    uTheta (real and im parts)
  //    uz     (real and im parts)
  //    p      (real and im parts)
  const int numNurbs = 4; 
  // if( !dbase.has_key("nurbs") )
  // {
  //   // Build an array of 4 NurbsMapping's 
  //   dbase.put<NurbsMapping*>("nurbs") = new NurbsMapping [numNurbs];
  // }
  // NurbsMapping *nurbs = dbase.get<NurbsMapping*>("nurbs");
  NurbsMapping *nurbs = new NurbsMapping [numNurbs];

  Real & omega = dbase.get<Real>("omega"); 

  Real ra_=0., rb_=1., za_=0., zb_=1., kz_=1., omega_=1.; 
  int m_=1; 

  if( caseName == "hollowCylinderDD" )
  {
    // Displacement displacement:
    // >> from $ism/matlab/cylinderDiscreteEigFuncs/hollowCylinderEigFun_d_d.h
    #Include "src/incompressible/hollowCylinderEigFun_d_d.h"
    getExactSolutionMacro();
  }
  else if( caseName == "hollowCylinderTT" )
  {
    // Traction-traction    
    // >> from $ism/matlab/cylinderDiscreteEigFuncs/hollowCylinderEigFun_t_t.h
    #Include "src/incompressible/hollowCylinderEigFun_t_t.h"
    getExactSolutionMacro();
  }
  else if( caseName == "solidCylinderD" )
  {
    // Solid cylinder, displacement BCs
    // >> from $ism/matlab/solidCylinderEigFun_d.h
    #Include "src/incompressible/solidCylinderEigFun_d.h"
    // From Don:
    // #Include "src/incompressible/dataForBill.h"
    getExactSolutionMacro();
  } 
  else if( caseName == "solidCylinderT" )
  {
    // Solid cylinder, traction BCs
    // >> from $ism/matlab/solidCylinderEigFun_t.h
    #Include "src/incompressible/solidCylinderEigFun_t.h"
    getExactSolutionMacro();
  }    
  else
  {
    printF("SmCylinderExactSolution::initialize: unknown caseName=[%s]\n",(const char*)caseName);
    OV_ABORT("error");

  }
  if( true )
    printF("============= caseName = %s =============\n",(const char*)caseName);


  Real ra=ra_, rb=rb_, za=za_, zb=zb_, kz=kz_;
  omega=omega_; // set value in the dbase
  int m = m_;

  if( 0==1 )
  {
    // Plot radial solution for testing 
    GenericGraphicsInterface & gi = *Overture::getGraphicsInterface();
    PlotStuffParameters psp;
    psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);
    // plot the curve (x(r),y(r),z(r))
    for( int n = 0 ; n<numNurbs; n++ )
    {
      psp.set(GI_TOP_LABEL,sPrintF("Nurbs[%d]",n));
      PlotIt::plot( gi,nurbs[n], psp );
    }

    OV_ABORT("stop here for now");
  }


  // ---- Fill in Grid functions with the Real and Imaginary Parts of the Spatial Eigenfunction ----

  realCompositeGridFunction & wRe = dbase.put<realCompositeGridFunction>("wRe");
  realCompositeGridFunction & wIm = dbase.put<realCompositeGridFunction>("wIm");


  const int numberOfDimensions = cg.numberOfDimensions();

  const int numberOfComponents = 4; // u1,u2,u3,p
  Range all;
  wRe.updateToMatchGrid(cg,all,all,all,numberOfComponents);
  wIm.updateToMatchGrid(cg,all,all,all,numberOfComponents);

  const int u1c = 0;
  const int u2c = 1;
  const int u3c = 2;
  const int pc  = 3;

  const Real eps=1.e-9;   // ********************************** FIX ME *********

  // Real ra=0., rb=1.;  // Inner and outer radii ***** FIX ME 

  // int m=1, n=1; 

  // Real omega = 7.1234; 

  RealArray rv(1,1), wv(1,3);
  rv=0.;

  std::complex<LocalReal> I(0,1.); 
  std::complex<LocalReal> ur, uTheta, uz, p, expi, u1, u2; 

  // exp( - I*omega*t )
  // std::complex<LocalReal> expiOmegat = cos(omega*t) - I*sin(omega*t);

  printF("Eval the solution: ra=%g, rb=%g, m=%d, omega=%12.6e, kz=%12.6e\n",ra,rb,m,omega,kz);
  Index I1,I2,I3;
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cg[grid];
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);
    getIndex( mg.dimension(),I1,I2,I3 );

    OV_GET_SERIAL_ARRAY(real,mg.center(),xLocal);
    OV_GET_SERIAL_ARRAY(real,wRe[grid],wReLocal);
    OV_GET_SERIAL_ARRAY(real,wIm[grid],wImLocal);

    int i1,i2,i3;
    Real z = 0; 
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
      if( numberOfDimensions==3 )
        z = xLocal(i1,i2,i3,2);

      getPolar(i1,i2,i3,cosTheta,sinTheta,theta); 

      rv(0,0) = (r-ra)/(rb-ra); // scale r to [0,1]

      nurbs[0].mapS( rv,wv );  // eval radial component of ur
      ur     = ( wv(0,0) + I*wv(0,1) ) ;

      nurbs[1].mapS( rv,wv );  // eval radial component of uTheta
      uTheta = ( wv(0,0) + I*wv(0,1) ) ;

      nurbs[2].mapS( rv,wv );  // eval radial component of uz
      uz     = ( wv(0,0) + I*wv(0,1) ) ; 

      nurbs[3].mapS( rv,wv );  // eval radial component of p
      p      = ( wv(0,0) + I*wv(0,1) ) ; 

      // if( fabs(r-ra)<1.e-5  || fabs(r-rb)<1.e-5 )
      // {
      //   printF("eval: r=%9.3e ur=%9.3e + I %9.3e\n",r,std::real(ur),std::imag(ur));
      // }

      // --- form the spatial part (complex) of the solution ---
      // expi = exp(i*m*theta) * exp(i*kz*z ) = exp( i*( m*theta + kz*z ) )
      expi = ( cos(m*theta + kz*z ) + I*sin(m*theta + kz*z ) );

      ur     = ur*expi;
      uTheta = uTheta*expi;
      uz     = uz*expi;
      p      = p*expi;

      // Cartesian components of the displacement
      // (u1,u2) = ur*rHat + vr*thetaHat 
      // ur = rHat*uv
      // uTheta = thetaHat*uv
      u1 = ur*cosTheta - uTheta*sinTheta;;
      u2 = ur*sinTheta + uTheta*cosTheta;

      wReLocal(i1,i2,i3,u1c) = std::real( u1 );
      wReLocal(i1,i2,i3,u2c) = std::real( u2 );
      wReLocal(i1,i2,i3,u3c) = std::real( uz );
      wReLocal(i1,i2,i3,pc ) = std::real( p  );

      wImLocal(i1,i2,i3,u1c) = std::imag( u1 );
      wImLocal(i1,i2,i3,u2c) = std::imag( u2 );
      wImLocal(i1,i2,i3,u3c) = std::imag( uz );
      wImLocal(i1,i2,i3,pc ) = std::imag( p  );

    }

  } // end for grid 


  // clean up 
  delete [] nurbs;
  
  return 0;
}




//========================================================================================================
/// \brief Evaluate the exact solution
//========================================================================================================
int SmCylinderExactSolution::
evalSolution(Real t, CompositeGrid & cg, int grid, RealArray & ua, 
             const Index & I1, const Index &I2, const Index &I3, 
             int numberOfTimeDerivatives /* = 0 */  )
{

  const bool & initialized=dbase.get<bool>("initialized");
  if( !initialized )
  {
    OV_ABORT("SmCylinderExactSolution:ERROR:evalSolution: Solution is NOT initialized!");
  }


  const int u1c = 0;
  const int u2c = 1;
  const int u3c = 2;
  const int pc  = 3;

  MappedGrid & mg = cg[grid];

  // OV_GET_SERIAL_ARRAY(real,ua,uLocal);
  RealArray & uLocal = ua;

  // -- Here are the real and imaginary parts of the spatial solution ---
  realCompositeGridFunction & wRe = dbase.get<realCompositeGridFunction>("wRe");
  realCompositeGridFunction & wIm = dbase.get<realCompositeGridFunction>("wIm");
  OV_GET_SERIAL_ARRAY(real,wRe[grid],wReLocal);
  OV_GET_SERIAL_ARRAY(real,wIm[grid],wImLocal);

  const Real & omega = dbase.get<Real>("omega"); 
  Real coswt, sinwt;
  if( numberOfTimeDerivatives==0 )
  {
    coswt = cos(omega*t);  sinwt = sin(omega*t);
  }
  else if( numberOfTimeDerivatives==1 )
  {
    coswt = -omega*sin(omega*t); sinwt = omega*cos(omega*t);
  }
  else
  {
    OV_ABORT("error");
  }
  int i1,i2,i3;
  FOR_3D(i1,i2,i3,I1,I2,I3)
  {
    // solution = Re( (wRe+I*wIm)*exp( - I*omega*t) )
    uLocal(i1,i2,i3,u1c) = wReLocal(i1,i2,i3,u1c)*coswt + wImLocal(i1,i2,i3,u1c)*sinwt; 
    uLocal(i1,i2,i3,u2c) = wReLocal(i1,i2,i3,u2c)*coswt + wImLocal(i1,i2,i3,u2c)*sinwt; 
    uLocal(i1,i2,i3,u3c) = wReLocal(i1,i2,i3,u3c)*coswt + wImLocal(i1,i2,i3,u3c)*sinwt; 
    uLocal(i1,i2,i3,pc ) = wReLocal(i1,i2,i3,pc) *coswt + wImLocal(i1,i2,i3,pc) *sinwt; 

  }

  return 0;
}


