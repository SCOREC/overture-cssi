!
! FILL IN THE PRESSURE RHS AND BOUNDARY CONDITIONS FOR INCOMPRESSIBLE SOLID MECHANICS
!
! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
#Include "defineDiffOrder2f.h"
#Include "defineDiffOrder4f.h"


! ---------------------------------------------------------------------------
! Macro : beginLoops
! ---------------------------------------------------------------------------
#beginMacro beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoops
! ---------------------------------------------------------------------------
#beginMacro endLoops()
  end do
  end do
  end do
#endMacro

! ---------------------------------------------------------------------------
! Macro : beginLoopsMask
! ---------------------------------------------------------------------------
#beginMacro beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
    if( mask(i1,i2,i3).gt.0 )then
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoopsMask()
    end if
  end do
  end do
  end do
#endMacro  

#beginMacro beginGhostLoops()
 do i3=nn3a,nn3b
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

! ogf2d, ogf3d, ogDeriv2, etc. are foundin forcing.bC
#beginMacro OGF2D(i1,i2,i3,t,u0,v0)
 call ogf2d(ep,xy(i1,i2,i3,0),xy(i1,i2,i3,1),t,u0,v0)
#endMacro

#beginMacro OGF3D(i1,i2,i3,t,u0,v0,w0)
 call ogf3d(ep,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u0,v0,w0)
#endMacro

! ntd,nxd,nyd,nzd : number of derivatives to evaluate in t,x,y,z
#beginMacro OGDERIV2D(ntd,nxd,nyd,nzd,i1,i2,i3,t,ux,vx)
  call ogDeriv2(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t, u1c,ux, u2c,vx)
#endMacro

#beginMacro OGDERIV3D(ntd,nxd,nyd,nzd,i1,i2,i3,t,ux,vx,wx)
  call ogDeriv3(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t, u1c,ux, u2c,vx, u3c,wx)
#endMacro


! ----- define extrapolation formulae ------

#defineMacro extrap2(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   2.*uu(k1,k2,k3,kc)\
                  -uu(k1+  ks1,k2+  ks2,k3+  ks3,kc))

#defineMacro extrap3(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   3.*uu(k1,k2,k3,kc)\
               -3.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
                  +uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc))

#defineMacro extrap4(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   4.*uu(k1,k2,k3,kc)\
               -6.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
               +4.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
                  -uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc))

#defineMacro extrap5(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   5.*uu(k1,k2,k3,kc)\
              -10.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +10.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
               -5.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
                  +uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc))

#defineMacro extrap7(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   7.*uu(k1,k2,k3,kc)\
              -21.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +35.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -35.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
              +21.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
               -7.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
                +  uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc) )

#defineMacro extrap9(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   9.*uu(k1,k2,k3,kc)\
              -36.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +84.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
             -126.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
             +126.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
              -84.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
              +36.*uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc)\
               -9.*uu(k1+7*ks1,k2+7*ks2,k3+7*ks3,kc)\
                  +uu(k1+8*ks1,k2+8*ks2,k3+8*ks3,kc) )            

! *************************************************************************************
!  Macro : adjust the gridIndexRange  to account for adjacent sides
!    Precedence at corners:
!       displacement over traction
!       dirichlet over traction
!  
!                  |   |   |
!                  |------------
!  bc=traction     |   |   |
!    =displacement |-----------
!                  |   |   |
!                  X------------
!                     bc=dirichletBoundaryCondition
!     X = this point removed from boundary loops for bc=traction, or bc=displacement
! **************************************************************************************
#beginMacro getAdjustedGridIndexRange( side,axis )
  do leftRight=0,1
    do dir=0,2
      gid(leftRight,dir) = gridIndexRange(leftRight,dir)
    end do
  end do
  ! WHAT SHOULD WE DO FOR TRACTION-TRACTION ?
  if( boundaryCondition(side,axis)==displacementBC .or. boundaryCondition(side,axis)==tractionBC )then
    ! adjust gridIndexRange at ends of the boundary 
    do dir=1,nd-1
      axisp = mod(axis+dir,nd)  ! tangential direction
      do leftRight=0,1
        if( boundaryCondition(leftRight,axisp)==dirichletBoundaryCondition  )then
          ! shift to avoid the corner
          gid(leftRight,axisp) = gid(leftRight,axisp) + (1-2*leftRight)
        end if
      end do
    end do
  end if
#endMacro

! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
! 
! ***********************************************************************************************
#beginMacro beginLoopOverSides(extra,numberOfGhostPoints)
 extra1a=extra
 extra1b=extra
 extra2a=extra
 extra2b=extra
 if( nd.eq.3 )then
   extra3a=extra
   extra3b=extra
 else
   extra3a=0
   extra3b=0
 end if
 if( boundaryCondition(0,0).lt.0 )then
   extra1a=max(0,extra1a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( boundaryCondition(0,0).eq.0 )then
   extra1a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( boundaryCondition(1,0).lt.0 )then
   extra1b=max(0,extra1b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( boundaryCondition(1,0).eq.0 )then
   extra1b=numberOfGhostPoints
 end if

 if( boundaryCondition(0,1).lt.0 )then
   extra2a=max(0,extra2a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( boundaryCondition(0,1).eq.0 )then
   extra2a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( boundaryCondition(1,1).lt.0 )then
   extra2b=max(0,extra2b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( boundaryCondition(1,1).eq.0 )then
   extra2b=numberOfGhostPoints
 end if

 if(  nd.eq.3 )then
  if( boundaryCondition(0,2).lt.0 )then
    extra3a=max(0,extra3a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
  else if( boundaryCondition(0,2).eq.0 )then
    extra3a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
  end if
  ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
  if( boundaryCondition(1,2).lt.0 )then
    extra3b=max(0,extra3b) ! over-ride extra=-1 : assign ends in periodic directions
  else if( boundaryCondition(1,2).eq.0 )then
    extra3b=numberOfGhostPoints
  end if
 end if

 do axis=0,nd-1
 do side=0,1

   if( boundaryCondition(side,axis).gt.0 )then

     ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)
     ! get gid(0;1,0:2) -- adjusted for priority at corners
     getAdjustedGridIndexRange( side,axis )

     axisp1=mod(axis+1,nd)
     axisp2=mod(axis+2,nd)
     
     i3=n3a

     n1a=gid(0,0)
     n1b=gid(1,0)
     n2a=gid(0,1)
     n2b=gid(1,1)
     n3a=gid(0,2)
     n3b=gid(1,2)
     if( axis.eq.0 )then
       n1a=gid(side,axis)
       n1b=gid(side,axis)
     else if( axis.eq.1 )then
       n2a=gid(side,axis)
       n2b=gid(side,axis)
     else
       n3a=gid(side,axis)
       n3b=gid(side,axis)
     end if

     ! if( boundaryCondition(side,axis)==tractionBC )then
     !   if( boundaryCondition(axisp1,0)==dirichletBoundaryCondition )then
     !     n2a = n2a+1; ! skip boundary
     !   end if
     !   if( boundaryCondition(axisp1,1)==dirichletBoundaryCondition )then
     !     n2b = n2b-1; ! skip boundary
     !   end if 
     ! end if

     nn1a=gid(0,0)-extra1a
     nn1b=gid(1,0)+extra1b
     nn2a=gid(0,1)-extra2a
     nn2b=gid(1,1)+extra2b
     nn3a=gid(0,2)-extra3a
     nn3b=gid(1,2)+extra3b
     if( axis.eq.0 )then
       nn1a=gid(side,axis)
       nn1b=gid(side,axis)
     else if( axis.eq.1 )then
       nn2a=gid(side,axis)
       nn2b=gid(side,axis)
     else
       nn3a=gid(side,axis)
       nn3b=gid(side,axis)
     end if

     is=1-2*side

     is1=0
     is2=0
     is3=0
     if( axis.eq.0 )then
       is1=1-2*side
     else if( axis.eq.1 )then
       is2=1-2*side
     else if( axis.eq.2 )then
       is3=1-2*side
     else
       stop 5
     end if
     

     if( debug.gt.7 )then
       write(*,'(" pressureISM: grid,side,axis=",3i3,",loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,n1a,n1b,n2a,n2b,n3a,n3b
       write(*,'("                                                       gridIndexRange=",6i3)') ((gridIndexRange(m,dir),m=0,1),dir=0,nd-1)
       write(*,'("                                                                  gid=",6i3)') ((gid(m,dir),m=0,1),dir=0,nd-1)

     end if
   end if ! if bc>0 

   ! ! On interfaces we should use the bcf array values even for TZ since then
   ! ! we get a coupling at the interface: 
   ! !   bcf = n.sigma(fluid) + [ n.sigma_e(solid) - n.sigma_e(fluid) ]
   ! if( interfaceType(side,axis,grid).eq.noInterface )then
   !   assignTwilightZone=twilightZone
   ! else
   !   assignTwilightZone=0  ! this will turn off the use of TZ
   ! end if

#endMacro


! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
! 
! ***********************************************************************************************
#beginMacro beginLoopOverSidesOLD(extra,numberOfGhostPoints)
 extra1a=extra
 extra1b=extra
 extra2a=extra
 extra2b=extra
 if( nd.eq.3 )then
   extra3a=extra
   extra3b=extra
 else
   extra3a=0
   extra3b=0
 end if
 if( boundaryCondition(0,0).lt.0 )then
   extra1a=max(0,extra1a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( boundaryCondition(0,0).eq.0 )then
   extra1a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( boundaryCondition(1,0).lt.0 )then
   extra1b=max(0,extra1b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( boundaryCondition(1,0).eq.0 )then
   extra1b=numberOfGhostPoints
 end if

 if( boundaryCondition(0,1).lt.0 )then
   extra2a=max(0,extra2a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( boundaryCondition(0,1).eq.0 )then
   extra2a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( boundaryCondition(1,1).lt.0 )then
   extra2b=max(0,extra2b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( boundaryCondition(1,1).eq.0 )then
   extra2b=numberOfGhostPoints
 end if

 if(  nd.eq.3 )then
  if( boundaryCondition(0,2).lt.0 )then
    extra3a=max(0,extra3a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
  else if( boundaryCondition(0,2).eq.0 )then
    extra3a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
  end if
  ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
  if( boundaryCondition(1,2).lt.0 )then
    extra3b=max(0,extra3b) ! over-ride extra=-1 : assign ends in periodic directions
  else if( boundaryCondition(1,2).eq.0 )then
    extra3b=numberOfGhostPoints
  end if
 end if

 do axis=0,nd-1
 do side=0,1

   if( boundaryCondition(side,axis).gt.0 )then

     ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)

     n1a=gridIndexRange(0,0)
     n1b=gridIndexRange(1,0)
     n2a=gridIndexRange(0,1)
     n2b=gridIndexRange(1,1)
     n3a=gridIndexRange(0,2)
     n3b=gridIndexRange(1,2)
     if( axis.eq.0 )then
       n1a=gridIndexRange(side,axis)
       n1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       n2a=gridIndexRange(side,axis)
       n2b=gridIndexRange(side,axis)
     else
       n3a=gridIndexRange(side,axis)
       n3b=gridIndexRange(side,axis)
     end if


     nn1a=gridIndexRange(0,0)-extra1a
     nn1b=gridIndexRange(1,0)+extra1b
     nn2a=gridIndexRange(0,1)-extra2a
     nn2b=gridIndexRange(1,1)+extra2b
     nn3a=gridIndexRange(0,2)-extra3a
     nn3b=gridIndexRange(1,2)+extra3b
     if( axis.eq.0 )then
       nn1a=gridIndexRange(side,axis)
       nn1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       nn2a=gridIndexRange(side,axis)
       nn2b=gridIndexRange(side,axis)
     else
       nn3a=gridIndexRange(side,axis)
       nn3b=gridIndexRange(side,axis)
     end if

     is=1-2*side

     is1=0
     is2=0
     is3=0
     if( axis.eq.0 )then
       is1=1-2*side
     else if( axis.eq.1 )then
       is2=1-2*side
     else if( axis.eq.2 )then
       is3=1-2*side
     else
       stop 5
     end if
     
     axisp1=mod(axis+1,nd)
     axisp2=mod(axis+2,nd)
     
     i3=n3a

     if( debug.gt.7 )then
       write(*,'(" pressureIsm: grid,side,axis=",3i3,", \
         loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,\
         n1a,n1b,n2a,n2b,n3a,n3b

     end if
   end if ! if bc>0 

   ! assignTwilightZone=twilightZone

#endMacro

#beginMacro endLoopOverSides()
 end do ! end side
 end do ! end axis
#endMacro


#beginMacro getNormal2d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2))
 an1=an1*aNormi
 an2=an2*aNormi
#endMacro

#beginMacro getNormal3d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 an3 = rsxy(i1,i2,i3,axis,2)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2+ an3**2))
 an1=an1*aNormi
 an2=an2*aNormi
 an3=an3*aNormi
#endMacro

! =============================================================
!  Macro: Fill in the RHS to to the press CBC[2]:
!     p_xxxx - p_yyyy = 0 
! =============================================================
#beginMacro assignPressureCBC2(DIM,ORDER,GRIDTYPE)
  #If #GRIDTYPE eq "rectangular"

   #If #ORDER eq "2"

      startGhost=2 ! used below to set extra ghost 

   #Elif #ORDER eq "4"
     ! ---- CBC : p_xxxx - p_yyyy = 0  -----

     startGhost=3  ! used below to set extra ghost 

     ghost=2
     j1=i1-is1*ghost
     j2=i2-is2*ghost
     j3=i3-is3*ghost               

     f(j1,j2,j3) = 0.
     if( twilightZone.eq.1 )then 

       ! TZ forcing for p
       #If #DIM eq "2"

         call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pexxxx)
         call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,peyyyy)
         f(j1,j2,j3) = pexxxx - peyyyy  ! note: fill in f at ghost value

       #Else
         ! finish me for 3D
         stop 3434
         ! call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pexx)
         ! call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,peyy)
         ! call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pezz)
         ! f(j1,j2,j3) = pexx + peyy + pezz    ! note: fill in f at ghost value      
       #End     
     end if  

   #Else
     stop 6666
   #End

  #Else

    ! ------- CURVLINEAR ------
   #If #ORDER eq "2"

      startGhost=2 ! used below to set extra ghost 

   #Elif #ORDER eq "4"
     ! ---- CBC : p_xxxx - p_yyyy = 0  -----

     ! write(*,*) 'pressure BC CBC2 -- finish me for curvlinear'

     startGhost=3  ! used below to set extra ghost 

     ghost=2
     j1=i1-is1*ghost
     j2=i2-is2*ghost
     j3=i3-is3*ghost               

     f(j1,j2,j3) = 0.
     if( twilightZone.eq.1 )then 

       ! TZ forcing for p
       #If #DIM eq "2"

         call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pexxxx)
         call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,peyyyy)
         f(j1,j2,j3) = pexxxx - peyyyy  ! note: fill in f at ghost value

         ! call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pexxyy)
         ! f(j1,j2,j3) = pexxxx + 2.*pexxyy + peyyyy  ! note: fill in f at ghost value 

       #Else
         ! finish me for 3D
         stop 3434
         ! call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pexx)
         ! call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,peyy)
         ! call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pezz)
         ! f(j1,j2,j3) = pexx + peyy + pezz    ! note: fill in f at ghost value      
       #End     
     end if  

   #Else
     stop 6666
   #End    

  #End

#endMacro

! ====== here are the common arguments to the various subroutines =====
#defineMacro subroutineArgs() nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,mask,rsxy,xy, um,u,un,f, gridIndexRange, dimRange, isPeriodic, boundaryCondition, ipar, rpar, ierr

! ==============================================================================================
! Macro to declare input arguments to subroutines
! ==============================================================================================
#beginMacro declareInputArgs()
 integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

 real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
 real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)

 integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*), ierr

 integer ipar(0:*)
 real rpar(0:*)
#endMacro

! **********************************************************************************
! NAME: name of the subroutine
! DIM : 2 or 3
! ORDER : 2 ,4, 6 or 8
! GRIDTYPE : rectangular, curvilinear
! **********************************************************************************
#beginMacro PRESSURE_ISM(NAME,DIM,ORDER,GRIDTYPE)
 subroutine NAME( subroutineArgs() )
!======================================================================
!   Fill in the right-hand-side and boundary conditions for the pressure
!       Incompressible Elasticity 
! 
! nd : number of space dimensions
!
!
!======================================================================
 implicit none

 declareInputArgs()

!     ---- local variables -----
 integer i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime,debug,numGhost,numGhost0
 integer addForcing,option,twilightZone,useCurlCurlBoundaryCondition
 integer useWhereMask,grid
 ! integer useConservative
 integer u1c,u2c,u3c,pc
 integer myid

 integer side1,side2,side3, side,axis,axisp1,axisp2,is,is1,is2,is3,j1,j2,j3,ghost
 integer n1a,n1b,n2a,n2b,n3a,n3b
 integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
 integer extra1a,extra1b,extra2a,extra2b,extra3a,extra3b

 integer leftRight,dir,axisp,gid(0:1,0:2)

 real rho,mu,dt,dy,dz,cdv,ff,cdvOverDtSq
 real t,ep
 real dx(0:2),dr(0:2)
 real an1,an2,an3,aNormi,epsx,REAL_MIN 

 real ue,ve,pe
 real pex,pey,pez, pexx,peyy, pezz, pexxxx, peyyyy, pexxyy
 real uex,uey,uez, uexx,ueyy, uezz, uexy, uexz, ueyz
 real vex,vey,vez, vexx,veyy, vezz, vexy, vexz, veyz
 real wex,wey,wez, wexx,weyy, wezz, wexy, wexz, weyz

 integer startGhost
 integer numSmooths,smooth
 real omega


 integer rectangular,curvilinear
 parameter( rectangular=0, curvilinear=1 )


!...........start statement function
 integer kd,m
 real rx,ry,rz,sx,sy,sz,tx,ty,tz

! include 'declareDiffOrder2f.h'
! include 'declareDiffOrder4f.h'
 declareDifferenceOrder2(u,RX)
 declareDifferenceOrder2(un,none)
 ! declareDifferenceOrder2(v,none)

 declareDifferenceOrder4(u,RX)
 declareDifferenceOrder4(un,none)
 ! declareDifferenceOrder4(v,none)


!.......statement functions for jacobian
 rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
 ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
 rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
 sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
 sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
 sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
 tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
 ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
 tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)

!     The next macro call will define the difference approximation statement functions
 defineDifferenceOrder2Components1(u,RX)
 defineDifferenceOrder4Components1(u,RX)

 defineDifferenceOrder2Components1(un,none)
 defineDifferenceOrder4Components1(un,none)

!** defineDifferenceOrder2Components1(v,none)
!** defineDifferenceOrder4Components1(v,none)

#Include "../bcDefineFortranInclude.h"
 

! ******* artificial dissipation ******
! du(i1,i2,i3,c)=u(i1,i2,i3,c)-um(i1,i2,i3,c)


!...........end   statement functions


 ! write(*,*) 'Inside NAME...'

 t        = rpar( 0)  ! This should be the time that p lives at (new time)
 dt       = rpar( 1)
 rho      = rpar( 2)
 mu       = rpar( 3)
 cdv      = rpar( 4)  ! coeff of divergence damping 
 dx(0)    = rpar( 5)
 dx(1)    = rpar( 6)
 dx(2)    = rpar( 7)
 dr(0)    = rpar( 8)
 dr(1)    = rpar( 9)
 dr(2)    = rpar(10)
 ep       = rpar(11)  ! pointer to exact solution (TZ)
 REAL_MIN = rpar(12)
 
 
 epsx=REAL_MIN*100.  ! for normal
 ! rpar(20)=0.  ! return the time used for adding dissipation

 ! dy=dx(1)  ! Are these needed?
 ! dz=dx(2)

 ! timeForArtificialDissipation=rpar(6) ! return value


 option                       = ipar( 0)
 gridType                     = ipar( 1)
 orderOfAccuracy              = ipar( 2)
 orderInTime                  = ipar( 3)
 addForcing                   = ipar( 4)
 twilightZone                 = ipar( 5)
 u1c                          = ipar( 6)
 u2c                          = ipar( 7)
 u3c                          = ipar( 8)
 pc                           = ipar( 9)
 useWhereMask                 = ipar(10)
 debug                        = ipar(11)
 myid                         = ipar(12)
 grid                         = ipar(13)
 useCurlCurlBoundaryCondition = ipar(14)

 ! useCurlCurlBoundaryCondition=0 ! **TEST 
 ! cu=  2.     ! coeff. of u(t) in the time-step formula
 ! cum=-1.     ! coeff. of u(t-dtOld)
 ! csq=cc**2
 ! dtsq=dt**2

 ! cdt=cc*dt

 ! c1dtsq=c1*dtsq
 ! c2dtsq=c2*dtsq



 if( t<=2*dt )then
   write(*,'(" #### NAME: dt=",1pe12.4," u1c,u2c,u3c,pc=",4i3," t=",1pe12.3)') dt,u1c,u2c,u3c,pc,t
   write(*,'("     nd=",i2," debug=",i3," addForcing=",i4," cdv=",f5.2," twilightZone=",i2)') nd,debug,addForcing,cdv,twilightZone
   write(*,'("useCurlCurlBoundaryCondition=",i3)') useCurlCurlBoundaryCondition
 end if

 if( dt>0. )then
   ! div-damping = (cdv/dt)*( U(t) - u(t-dt) )/dt 
   ! One factor of dt comes from the usual scaling, the second factor from D-t
   cdvOverDtSq = cdv/dt**2
 else
   write(*,'("### NAME : ERROR: dt=",1pe12.4," is not greater than zero!")') dt
   stop 6666
 end if



  ! --- Set index bounds for interior and boundary ---
  n1a=gridIndexRange(0,0)
  n1b=gridIndexRange(1,0)
  n2a=gridIndexRange(0,1)
  n2b=gridIndexRange(1,1)
  n3a=gridIndexRange(0,2)
  n3b=gridIndexRange(1,2)

  ! ------------ Define the expression used for the divergence of velocity : u(t) - u(t-dt)-------
  #If #DIM eq "2"
    #If #GRIDTYPE eq "rectangular"
      #If #ORDER eq "2"
        #defineMacro divUt(i1,i2,i3) ( unx22r(i1,i2,i3,u1c)-ux22r(i1,i2,i3,u1c) + uny22r(i1,i2,i3,u2c)-uy22r(i1,i2,i3,u2c) )
      #Elif #ORDER eq "4"
        #defineMacro divUt(i1,i2,i3) ( unx42r(i1,i2,i3,u1c)-ux42r(i1,i2,i3,u1c) + uny42r(i1,i2,i3,u2c)-uy42r(i1,i2,i3,u2c) )
      #Else
        stop 666 
      #End

    #Else
      #If #ORDER eq "2"
        #defineMacro divUt(i1,i2,i3) ( unx22(i1,i2,i3,u1c)-ux22(i1,i2,i3,u1c) + uny22(i1,i2,i3,u2c)-uy22(i1,i2,i3,u2c) )
      #Elif #ORDER eq "4"
        #defineMacro divUt(i1,i2,i3) ( unx42(i1,i2,i3,u1c)-ux42(i1,i2,i3,u1c) + uny42(i1,i2,i3,u2c)-uy42(i1,i2,i3,u2c) )
      #Else
        stop 666 
      #End        

    #End

  #Else
    ! -- 3D ----
    #If #GRIDTYPE eq "rectangular"
      #If #ORDER eq "2"
        #defineMacro divUt(i1,i2,i3) ( unx23r(i1,i2,i3,u1c)-ux23r(i1,i2,i3,u1c) + uny23r(i1,i2,i3,u2c)-uy23r(i1,i2,i3,u2c) + unz23r(i1,i2,i3,u3c)-uz23r(i1,i2,i3,u3c) )
      #Elif #ORDER eq "4"
        #defineMacro divUt(i1,i2,i3) ( unx43r(i1,i2,i3,u1c)-ux43r(i1,i2,i3,u1c) + uny43r(i1,i2,i3,u2c)-uy43r(i1,i2,i3,u2c) + unz43r(i1,i2,i3,u3c)-uz43r(i1,i2,i3,u3c) )
      #Else
        stop 666 
      #End

    #Else
      #If #ORDER eq "2"
        #defineMacro divUt(i1,i2,i3) ( unx23(i1,i2,i3,u1c)-ux23(i1,i2,i3,u1c) + uny23(i1,i2,i3,u2c)-uy23(i1,i2,i3,u2c) + unz23(i1,i2,i3,u3c)-uz23(i1,i2,i3,u3c) )
      #Elif #ORDER eq "4"
        #defineMacro divUt(i1,i2,i3) ( unx43(i1,i2,i3,u1c)-ux43(i1,i2,i3,u1c) + uny43(i1,i2,i3,u2c)-uy43(i1,i2,i3,u2c) + unz43(i1,i2,i3,u3c)-uz43(i1,i2,i3,u3c) )
      #Else
        stop 666 
      #End        

    #End    

  #End

  ! initialize f to zero >>> this is inefficient *fix me*
  beginLoops(i1,i2,i3,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b)
    f(i1,i2,i3)=0.
  endLoops()  

  ! -- evaluate the divergence damping ---
  beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
    if( mask(i1,i2,i3).gt.0 )then
      f(i1,i2,i3)=cdvOverDtSq*divUt(i1,i2,i3)
    end if
  endLoops()

  ! -- smooth divergence damping ---
  numSmooths=0
  omega=.5 
  do smooth=1,numSmooths
    beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
      if( mask(i1,i2,i3).gt.0 )then
        #If #DIM eq "2"    
          f(i1,i2,i3) = (1.-omega)*f(i1,i2,i3) + (omega/4.)*( f(i1+1,i2,i3) + f(i1-1,i2,i3) + f(i1,i2+1,i3) + f(i1,i2-1,i3) )
        #Else
          f(i1,i2,i3) = (1.-omega)*f(i1,i2,i3) + (omega/6.)*( f(i1+1,i2,i3) + f(i1-1,i2,i3) + f(i1,i2+1,i3) + f(i1,i2-1,i3) + f(i1,i2,i3+1) + f(i1,i2,i3-1) )
        #End
      end if
    endLoops()    
  end do

  if( twilightZone.eq.1 )then
    beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
      ! TZ forcing for p
      #If #DIM eq "2"
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pexx)
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,peyy)
        ! write(*,'("pRHS: i1,i2,=",2i3," pexx,peyy=",2(1pe10.2))') i1,i2,pexx,peyy
        ! f(i1,i2,i3) = pexx + peyy  + cdvOverDtSq*divUt(i1,i2,i3) 
        f(i1,i2,i3) = f(i1,i2,i3) + pexx + peyy 
      #Else
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pexx)
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,peyy)
        call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pezz)

        ! f(i1,i2,i3) = pexx + peyy + pezz  + cdvOverDtSq*divUt(i1,i2,i3)   
        f(i1,i2,i3) = f(i1,i2,i3) + pexx + peyy + pezz 
      #End
    endLoops()

  else
    ! This is now done above
    if( .false. )then
      !  Delta(p) = (cdv/dt)*( divUt(u.t) )
      beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        ! write(*,'(" i1,i2=",2i3," cdvOverDtSq=",1pe12.4," divUt=",1pe12.4)') i1,i2,cdvOverDtSq,divUt(i1,i2,i3)
        f(i1,i2,i3) = cdvOverDtSq*divUt(i1,i2,i3)
      endLoops() 
    end if
  end if
 
  numGhost = orderOfAccuracy/2 ! fix for upwinding

  numGhost0 = 0 ! what should this be ?

  ! ---------- BEGIN LOOP OVER BOUNDARIES -------
  beginLoopOverSides(numGhost,numGhost0)

    if( boundaryCondition(side,axis) == dirichletBoundaryCondition )then

      ! ---- Fake Dirichlet BC on the EXTENDED boundary ---
      ff=0.
      beginGhostLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        if( mask(i1,i2,i3).ne.0 )then

          ! getDirichletForcing(ff)
          ! fill in boundary value: 
          #If #DIM eq "2"
            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pe)
          #Else
            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pe)
          #End
          f(i1,i2,i3)=pe
          ! write(*,'(" fill p rhs dirichlet for i1,i2=",2i4," pe=",1pe12.4)') i1,i2,pe

          ! -- Set ghost to zero (RHS to extrapolation conditions) ---
          ! Is this necessary ?
          ! do ghost=1,numGhost
          !   j1=i1-is1*ghost
          !   j2=i2-is2*ghost
          !   j3=i3-is3*ghost

          !   f(j1,j2,j3) = 0.

          ! end do  

        end if 
      endLoops()

    else if( boundaryCondition(side,axis) == tractionBC  )then

      ! ---- Traction BC ---
      ! p = 2*mu*u.x = -2*mu*v.y : left/right side for Cartesian
      ! p = 2*mu*v.y = -2*mu*u.x : left/right side for Cartesian

      ! NOTE: at a traction corner we have
      !      p = 0
      !      ux = 0 
      !      vy = 0 

      #If #GRIDTYPE eq "rectangular"
        #If #ORDER eq "2"
          #If #DIM eq "2"
            #defineMacro UNX(i1,i2,i3,u1c) unx22r(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny22r(i1,i2,i3,u1c)
          #Else
            #defineMacro UNX(i1,i2,i3,u1c) unx23r(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny23r(i1,i2,i3,u1c)
            #defineMacro UNZ(i1,i2,i3,u1c) unz23r(i1,i2,i3,u1c)
          #End
        #Elif #ORDER eq "4"
          #If #DIM eq "2"
            #defineMacro UNX(i1,i2,i3,u1c) unx42r(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny42r(i1,i2,i3,u1c)
          #Else
            #defineMacro UNX(i1,i2,i3,u1c) unx43r(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny43r(i1,i2,i3,u1c)
            #defineMacro UNZ(i1,i2,i3,u1c) unz43r(i1,i2,i3,u1c)
          #End      
        #Else
          stop 6666
        #End

        beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
          if( mask(i1,i2,i3).ne.0 )then
 
            if( axis==0 )then
              f(i1,i2,i3) = 2.*mu*UNX(i1,i2,i3,u1c)
            else if( axis==1 )then
              f(i1,i2,i3) = 2.*mu*UNY(i1,i2,i3,u2c)
            else
              #If #DIM eq "3"              
                f(i1,i2,i3) = 2.*mu*UNZ(i1,i2,i3,u3c)
              #End
            end if 
 
            if( twilightZone.eq.1 )then
              #If #DIM eq "2"
                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pe)
                if( axis.eq.0 )then
                  call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uex)
                  f(i1,i2,i3) = f(i1,i2,i3) + pe - 2.*mu*uex 
                  ! write(*,'(" pressureBC: i1,i2=",2i3," Dzx(u)=",1pe12.3," uex=",1pe12.3)') i1,i2,unx22r(i1,i2,i3,u1c),uex
                else if( axis==1 )then
                  call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vey)
                  f(i1,i2,i3) = f(i1,i2,i3) + pe - 2.*mu*vey
                 else
                   stop 333
                end if 
              #Else
                ! ----- 3D ----
                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pe)
                if( axis.eq.0 )then
                  call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uex)
                  f(i1,i2,i3) = f(i1,i2,i3) + pe - 2.*mu*uex 
                   ! write(*,'(" pressureBC: i1,i2=",2i3," Dzx(u)=",1pe12.3," uex=",1pe12.3)') i1,i2,unx22r(i1,i2,i3,u1c),uex
                else if( axis==1 )then
                  call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vey)
                  f(i1,i2,i3) = f(i1,i2,i3) + pe - 2.*mu*vey
                else
                  call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wez)
                  f(i1,i2,i3) = f(i1,i2,i3) + pe - 2.*mu*wez
                end if                 
              #End

            end if 
 
           ! --- Compatibility equation on the first ghost point ----
           !     Apply the interior equation on the boundary
           !           Delta( p ) = RHS
           ghost=1
           j1=i1-is1*ghost
           j2=i2-is2*ghost
           j3=i3-is3*ghost   
           f(j1,j2,j3) = 0. 
           if( twilightZone.eq.1 )then 
             ! TZ forcing for p
             #If #DIM eq "2"
               call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pexx)
               call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,peyy)
               ! write(*,'("pRHS: TRACTION CBC on ghost 1: i1,i2,=",2i3," pexx,peyy=",2(1pe10.2))') i1,i2,pexx,peyy
               f(j1,j2,j3) = pexx + peyy  ! note: fill in f at ghost value 
             #Else
               call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pexx)
               call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,peyy)
               call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pezz)
               f(j1,j2,j3) = pexx + peyy + pezz    ! note: fill in f at ghost value      
             #End            
           end if 
           ! pressure CBC2 :
           !     p_xxxx - p_yyyy = 0 
           assignPressureCBC2(DIM,ORDER,GRIDTYPE)


           ! -- Set additional ghost to zero (RHS to extrapolation conditions) ---
           ! Is this necessary ?
           do ghost=startGhost,numGhost
             j1=i1-is1*ghost
             j2=i2-is2*ghost
             j3=i3-is3*ghost
 
             f(j1,j2,j3) = 0.
 
           end do  
 
         end if 
        endLoops() 

      #Else

        ! ------- traction curvilinear ---------
        !  p = 2*mu( n1^2*ux + n2^2*vy ) + 2*mu*n1*n2*( uy+vx) 
        ! write(*,'("pressure-RHS curvilinear TRACTION CBC")') 
        #If #ORDER eq "2"
          #If #DIM eq "2"
            #defineMacro UNX(i1,i2,i3,u1c) unx22(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny22(i1,i2,i3,u1c)
          #Else
            #defineMacro UNX(i1,i2,i3,u1c) unx23(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny23(i1,i2,i3,u1c)
            #defineMacro UNZ(i1,i2,i3,u1c) unz23(i1,i2,i3,u1c)
          #End
        #Elif #ORDER eq "4"
          #If #DIM eq "2"
            #defineMacro UNX(i1,i2,i3,u1c) unx42(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny42(i1,i2,i3,u1c)
          #Else
            #defineMacro UNX(i1,i2,i3,u1c) unx43(i1,i2,i3,u1c)
            #defineMacro UNY(i1,i2,i3,u1c) uny43(i1,i2,i3,u1c)
            #defineMacro UNZ(i1,i2,i3,u1c) unz43(i1,i2,i3,u1c)
          #End      
        #Else
          stop 6666
        #End        

        beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
          if( mask(i1,i2,i3).ne.0 )then
 
            #If #DIM eq "2"
              getNormal2d(i1,i2,i3,axis)
            #Else
              getNormal3d(i1,i2,i3,axis)
            #End
            ! #If #ORDER eq "2"
            !   #defineMacro UNX(i1,i2,i3,u1c) unx22(i1,i2,i3,u1c)
            !   #defineMacro UNY(i1,i2,i3,u1c) uny22(i1,i2,i3,u1c)
            ! #Elif #ORDER eq "4"
            !   #defineMacro UNX(i1,i2,i3,u1c) unx42(i1,i2,i3,u1c)
            !   #defineMacro UNY(i1,i2,i3,u1c) uny42(i1,i2,i3,u1c)
            ! #Else
            !   stop 6666
            ! #End              
            #If #DIM eq "2"
              f(i1,i2,i3) = 2.*mu*( an1**2*UNX(i1,i2,i3,u1c) + an2**2*UNY(i1,i2,i3,u2c) )  \
                              + 2.*mu*an1*an2*( UNY(i1,i2,i3,u1c) + UNX(i1,i2,i3,u2c) )
            #Else
              ! p.n = 2*mu * n.( u.n )
              !       2*mu* n^T [ n1*ux+n2*uy+n3*uz ]
              !                 [ n1*vx+n2*vy+n3*vz ] 
              !                 [ n1*wx+n2*wy+n3*wz ] 
              f(i1,i2,i3) = 2.*mu*( an1*( an1*UNX(i1,i2,i3,u1c) + an2*UNY(i1,i2,i3,u1c) + an3*UNZ(i1,i2,i3,u1c) ) + \
                                    an2*( an1*UNX(i1,i2,i3,u2c) + an2*UNY(i1,i2,i3,u2c) + an3*UNZ(i1,i2,i3,u2c) ) + \
                                    an3*( an1*UNX(i1,i2,i3,u3c) + an2*UNY(i1,i2,i3,u3c) + an3*UNZ(i1,i2,i3,u3c) ) )                                   

            #End

 
            if( twilightZone.eq.1 )then
              #If #DIM eq "2"              
                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pe)
                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uex)
                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uey)
                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vex)
                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vey)
  
                f(i1,i2,i3) = f(i1,i2,i3) + pe - ( 2.*mu*( an1**2*uex + an2**2*vey ) + 2.*mu*an1*an2*( uey + vex ) )
              #Else
                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pe)

                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uex)
                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uey)
                call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uez)

                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vex)
                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vey)
                call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vez)

                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wex)
                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wey)
                call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wez)                                
  
                f(i1,i2,i3) = f(i1,i2,i3) + pe - \
                            2.*mu*( an1*( an1*uex + an2*uey + an3*uez ) + \
                                    an2*( an1*vex + an2*vey + an3*vez ) + \
                                    an3*( an1*wex + an2*wey + an3*wez ) )                                
              #End
            end if 
 
            ! --- Compatibility equation on the first ghost point ----
            !     Apply the interior equation on the boundary
            !           Delta( p ) = RHS
            ghost=1
            j1=i1-is1*ghost
            j2=i2-is2*ghost
            j3=i3-is3*ghost   
            f(j1,j2,j3) = 0. 
            if( twilightZone.eq.1 )then 
              ! TZ forcing for p
              #If #DIM eq "2"
                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pexx)
                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,peyy)
                ! write(*,'("pRHS: curvilinear TRACTION CBC on ghost 1: i1,i2,=",2i3," pexx,peyy=",2(1pe10.2))') i1,i2,pexx,peyy
                f(j1,j2,j3) = pexx + peyy  ! note: fill in f at ghost value 
              #Else
                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pexx)
                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,peyy)
                call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pezz)
                f(j1,j2,j3) = pexx + peyy + pezz    ! note: fill in f at ghost value      
              #End            
            end if 
 

             ! pressure CBC2 : for ghost 2
             !     p_xxxx - p_yyyy = 0 
             assignPressureCBC2(DIM,ORDER,GRIDTYPE)

            ! -- Set additional ghost to zero (RHS to extrapolation conditions) ---
            ! Is this necessary ?
            do ghost=startGhost,numGhost
              j1=i1-is1*ghost
              j2=i2-is2*ghost
              j3=i3-is3*ghost
  
              f(j1,j2,j3) = 0.
  
            end do  
 
          end if 
        endLoops()         
      #End   

    else if( boundaryCondition(side,axis) == displacementBC )then

      ! ---------------------------------------------
      ! ------------ DISPLACEMENT BC ----------------
      ! ---------------------------------------------

      ! p.n = -n.(rh0 u_tt) + n.( mu Delta(u) )

      if( gridType.eq.rectangular )then
        ! compute the outward normal (an1,an2,an3)
        an1 = 0.
        an2 = 0.
        an3 = 0.
        if( axis.eq.0 )then
         an1=-is
        else if( axis.eq.1 )then
         an2=-is
        else
         an3=-is
        end if
      end if        

      ff=0.
      beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        if( mask(i1,i2,i3).ne.0 )then
          if( gridType.eq.curvilinear )then
            ! compute the outward normal (an1,an2,an3)
            #If #DIM eq "2"
              getNormal2d(i1,i2,i3,axis)
            #Else
              getNormal3d(i1,i2,i3,axis)
            #End
          end if    

          ! fill in first ghost:
          j1=i1-is1
          j2=i2-is2
          j3=i3-is3
          #If #GRIDTYPE eq "rectangular"          
            #If #ORDER eq "2"
              #If #DIM eq "2"
                #defineMacro UNXX(i1,i2,i3,u1c) unxx22r(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy22r(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy22r(i1,i2,i3,u1c)
              #Else
                #defineMacro UNXX(i1,i2,i3,u1c) unxx23r(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy23r(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy23r(i1,i2,i3,u1c)
                #defineMacro UNXZ(i1,i2,i3,u1c) unxz23r(i1,i2,i3,u1c)
                #defineMacro UNYZ(i1,i2,i3,u1c) unyz23r(i1,i2,i3,u1c)
                #defineMacro UNZZ(i1,i2,i3,u1c) unzz23r(i1,i2,i3,u1c)            
              #End        
            #Elif #ORDER eq "4"
              #If #DIM eq "2"          
                #defineMacro UNXX(i1,i2,i3,u1c) unxx42r(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy42r(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy42r(i1,i2,i3,u1c)  
              #Else
                #defineMacro UNXX(i1,i2,i3,u1c) unxx43r(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy43r(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy43r(i1,i2,i3,u1c)  
                #defineMacro UNXZ(i1,i2,i3,u1c) unxz43r(i1,i2,i3,u1c)
                #defineMacro UNYZ(i1,i2,i3,u1c) unyz43r(i1,i2,i3,u1c)
                #defineMacro UNZZ(i1,i2,i3,u1c) unzz43r(i1,i2,i3,u1c)           
              #End         
            #Else
              stop 6666
            #End

          #Else
            ! ---- curvilinear ---
            #If #ORDER eq "2"
              #If #DIM eq "2"              
                #defineMacro UNXX(i1,i2,i3,u1c) unxx22(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy22(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy22(i1,i2,i3,u1c)
              #Else
                #defineMacro UNXX(i1,i2,i3,u1c) unxx23(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy23(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy23(i1,i2,i3,u1c)
                #defineMacro UNXZ(i1,i2,i3,u1c) unxz23(i1,i2,i3,u1c)
                #defineMacro UNYZ(i1,i2,i3,u1c) unyz23(i1,i2,i3,u1c)
                #defineMacro UNZZ(i1,i2,i3,u1c) unzz23(i1,i2,i3,u1c)              
              #End                      
            #Elif #ORDER eq "4"
              #If #DIM eq "2"              
                #defineMacro UNXX(i1,i2,i3,u1c) unxx42(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy42(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy42(i1,i2,i3,u1c) 
              #Else
                #defineMacro UNXX(i1,i2,i3,u1c) unxx43(i1,i2,i3,u1c)
                #defineMacro UNXY(i1,i2,i3,u1c) unxy43(i1,i2,i3,u1c)
                #defineMacro UNYY(i1,i2,i3,u1c) unyy43(i1,i2,i3,u1c) 
                #defineMacro UNXZ(i1,i2,i3,u1c) unxz43(i1,i2,i3,u1c)
                #defineMacro UNYZ(i1,i2,i3,u1c) unyz43(i1,i2,i3,u1c)
                #defineMacro UNZZ(i1,i2,i3,u1c) unzz43(i1,i2,i3,u1c)               
              #End                       
            #Else
              stop 6666
            #End              
          #End

   
          if( gridType.eq.rectangular )then

            if( axis==0 ) then
              ! p.x = mu*u.xx = -mu.vxy 
              ! p.n = is*mu*v.xy 
              if( useCurlCurlBoundaryCondition.eq.1 )then
                #If #DIM eq "2"
                  f(j1,j2,j3) =   is*mu*UNXY(i1,i2,i3,u2c)
                #Else
                  f(j1,j2,j3) =   is*mu*( UNXY(i1,i2,i3,u2c) + UNXZ(i1,i2,i3,u3c) )
                #End
              else
                f(j1,j2,j3) =  -is*mu*UNXX(i1,i2,i3,u1c)
              end if
              ! write(*,'("pressure BC: i1,i2=",2i3," is=",i2," vxy =",1pe12.4," uxx=",1pe12.4)') i1,i2,is,unxy22r(i1,i2,i3,u2c),unxx22r(i1,i2,i3,u1c)

            else if( axis==1 )then

              if( useCurlCurlBoundaryCondition.eq.1 )then
                #If #DIM eq "2"
                  f(j1,j2,j3) =   is*mu*UNXY(i1,i2,i3,u1c)
                #Else
                  f(j1,j2,j3) =   is*mu*( UNXY(i1,i2,i3,u1c) + UNYZ(i1,i2,i3,u3c) )
                #End
              else
                f(j1,j2,j3) =  -is*mu*UNYY(i1,i2,i3,u2c)
              end if

            else
               ! axis == 2 
              #If #DIM eq "3"
                if( useCurlCurlBoundaryCondition.eq.1 )then
                  f(j1,j2,j3) =   is*mu*( UNXZ(i1,i2,i3,u1c) + UNYZ(i1,i2,i3,u2c) )
                else
                  f(j1,j2,j3) =  -is*mu*UNZZ(i1,i2,i3,u3c)
                end if
              #End

            end if


            ! CBC2: p_xxxx - p_yyyy = 0 for 2nd-ghost 
            assignPressureCBC2(DIM,ORDER,GRIDTYPE)


          else 
            ! --- curvilinear ---
            
            if( useCurlCurlBoundaryCondition.eq.1 )then
              ! Use curl-curl form of the BC:  NOTE: USE un
              #If #DIM eq "2"              
                f(j1,j2,j3) = mu*( an1*( -UNXY(i1,i2,i3,u2c) + UNYY(i1,i2,i3,u1c) ) + an2*( UNXX(i1,i2,i3,u2c) - UNXY(i1,i2,i3,u1c) ) )
              #Else
                f(j1,j2,j3) = mu*( an1*(                       UNYY(i1,i2,i3,u1c) + UNZZ(i1,i2,i3,u1c) - UNXY(i1,i2,i3,u2c) - UNXZ(i1,i2,i3,u3c) ) + \
                                   an2*(  UNXX(i1,i2,i3,u2c)                      + UNZZ(i1,i2,i3,u2c) - UNXY(i1,i2,i3,u1c) - UNYZ(i1,i2,i3,u3c) ) + \
                                   an3*(  UNXX(i1,i2,i3,u3c) + UNYY(i1,i2,i3,u3c)                      - UNXZ(i1,i2,i3,u1c) - UNYZ(i1,i2,i3,u2c) )  )
              #End
            else
              !  p.n = n.( mu Delta( uv ) )
              #If #DIM eq "2"                    
                f(j1,j2,j3) = mu*( an1*(  UNXX(i1,i2,i3,u1c) + UNYY(i1,i2,i3,u1c) ) + an2*( UNXX(i1,i2,i3,u2c) + UNYY(i1,i2,i3,u2c) ) )
              #Else
                f(j1,j2,j3) = mu*( an1*( UNXX(i1,i2,i3,u1c) + UNYY(i1,i2,i3,u1c) + UNZZ(i1,i2,i3,u1c) ) + \
                                   an2*( UNXX(i1,i2,i3,u2c) + UNYY(i1,i2,i3,u2c) + UNZZ(i1,i2,i3,u2c) ) + \
                                   an3*( UNXX(i1,i2,i3,u3c) + UNYY(i1,i2,i3,u3c) + UNZZ(i1,i2,i3,u3c) ) )
              #End
            end if
            ! f(j1,j2,j3) = mu*( an1*( unlaplacian22(i1,i2,i3,u1c)  ) + an2*( unLaplacian22(i1,i2,i3,u2c)  ) )


           ! pressure CBC2 :
           !     p_xxxx - p_yyyy = 0  for 2nd-ghost 
           assignPressureCBC2(DIM,ORDER,GRIDTYPE)                  

          end if

          if( twilightZone==1  )then
            j1=i1-is1
            j2=i2-is2
            j3=i3-is3
            #If #DIM eq "2"
              call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pex)
              call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,pc,pey)
              #If #GRIDTYPE eq "rectangular"
                if( axis==0 ) then
                  if( useCurlCurlBoundaryCondition.eq.1 )then 
                    call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vexy)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey - is*mu*vexy 
                  else
                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uexx)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + is*mu*uexx 
                  end if
                  ! TEST
                  ! f(j1,j2,j3) = an1*pex + an2*pey 
                else if( axis==1 )then
                  if( useCurlCurlBoundaryCondition.eq.1 )then 
                    call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uexy)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey - is*mu*uexy
                  else
                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,veyy)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + is*mu*veyy
                  end if 
                else
                  stop 3322
                end if 

              #Else

                ! --- TZ for curvilinear ---
                if( useCurlCurlBoundaryCondition.eq.1 )then 
                  ! using curl-curl form 
                  call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vexy)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,ueyy)
                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vexx)
                  call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uexy)
                  f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey - mu*( an1*( ( -vexy+ueyy ) ) + an2*( ( vexx-uexy ) ) )
                else
                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,uexx)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u1c,ueyy)
                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,vexx)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,u2c,veyy)
                  f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey - mu*( an1*( ( uexx+ueyy ) ) + an2*( ( vexx+veyy ) ) )                
                end if

              #End

            #Else 

               ! ---- 3D TZ ---- 
              call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pex)
              call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pey)
              call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,pc,pez)
              #If #GRIDTYPE eq "rectangular"
                if( axis==0 ) then
                  if( useCurlCurlBoundaryCondition.eq.1 )then 
                    call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vexy)
                    call ogDeriv(ep,0,1,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wexz)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez - is*mu*( vexy + wexz )
                  else
                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uexx)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez + is*mu*uexx 
                  end if
                  ! TEST
                  ! f(j1,j2,j3) = an1*pex + an2*pey 
                else if( axis==1 )then
                  if( useCurlCurlBoundaryCondition.eq.1 )then 
                    call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uexy)
                    call ogDeriv(ep,0,0,1,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,weyz)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez - is*mu*( uexy + weyz )
                  else
                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,veyy)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez + is*mu*veyy
                  end if 
                else
                  if( useCurlCurlBoundaryCondition.eq.1 )then 
                    call ogDeriv(ep,0,1,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uexz)
                    call ogDeriv(ep,0,0,1,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,veyz)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez - is*mu*( uexz + veyz )
                  else
                    call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wezz)
                    f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez + is*mu*wezz
                  end if                   

                end if 

              #Else

                ! --- TZ for curvilinear ---
                if( useCurlCurlBoundaryCondition.eq.1 )then 
                  ! using curl-curl form 
                  call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uexy)
                  call ogDeriv(ep,0,1,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uexz)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,ueyy)
                  call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uezz)

                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vexx)
                  call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vexy)
                  call ogDeriv(ep,0,0,1,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,veyz)
                  call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vezz)

                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wexx)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,weyy)
                  call ogDeriv(ep,0,1,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wexz)                  
                  call ogDeriv(ep,0,0,1,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,weyz)                  

                  f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez - mu*( an1*( -vexy-wexz +ueyy+uezz ) + an2*( vexx-uexy-weyz+vezz ) + an3*( wexx+weyy-uexz-veyz ) )   


                else
                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uexx)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,ueyy)
                  call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u1c,uezz)

                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vexx)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,veyy)
                  call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u2c,vezz)

                  call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wexx)
                  call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,weyy)
                  call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,u3c,wezz)                  

                  f(j1,j2,j3) = f(j1,j2,j3) + an1*pex + an2*pey + an3*pez - mu*( an1*( uexx+ueyy+uezz ) + an2*( vexx+veyy+vezz ) + an3*( wexx+weyy+wezz ) )                
                end if

              #End

            #End              

          end if

     

       end if 
      endLoops()    
     
    else if( boundaryCondition(side,axis) > 0 )then

      write(*,'("NAME:fill RHS for pressure equation, unexpected boundaryCondition=",i4)') boundaryCondition(side,axis)

        stop 6666
    end if

  endLoopOverSides()   
  ! ---------- END LOOP OVER BOUNDARIES -------

!  #If #GRIDTYPE eq "rectangular"
!
!    #If #ORDER eq "2" 
!
!      #If #DIM eq "2"
!        write(*,*) 'Inside pressureIsm: order=ORDER dim=DIM'
!        if( addForcing.eq.1 )then
!          beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
!            un(i1,i2,i3,u1c)=sm22ru(i1,i2,i3) + dtsq*f(i1,i2,i3,u1c)
!            un(i1,i2,i3,u2c)=sm22rv(i1,i2,i3) + dtsq*f(i1,i2,i3,u2c) 
!            ! FILL IN p with EXACT Solution for testing
!            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t+dt,pc,pe)
!            un(i1,i2,i3,pc)=pe
!          endLoops()
!        else
!          stop 5555
!        end if
! 
!      #Else
!
!      #End
!    #End
!  #End

 if( .true. )then
   return
 end if


 return
 end

#endMacro


#beginMacro buildFile(NAME,DIM,ORDER,GRIDTYPE)
#beginFile src/incompressible/NAME.f90
 PRESSURE_ISM(NAME,DIM,ORDER,GRIDTYPE)
#endFile
#endMacro
 

    buildFile(pressureIsm2dOrder2r,2,2,rectangular)
    buildFile(pressureIsm3dOrder2r,3,2,rectangular)
    buildFile(pressureIsm2dOrder2c,2,2,curvilinear)
    buildFile(pressureIsm3dOrder2c,3,2,curvilinear)

      buildFile(pressureIsm2dOrder4r,2,4,rectangular)
      ! buildFile(pressureIsm3dOrder4r,3,4,rectangular)
      buildFile(pressureIsm2dOrder4c,2,4,curvilinear)
      ! buildFile(pressureIsm3dOrder4c,3,4,curvilinear)
!**
!**      buildFile(pressureIsm22Order6r,2,6,rectangular)
!**      buildFile(pressureIsm23Order6r,3,6,rectangular)
!**
!**       ! build these for testing symmetric operators -- BC's not implemented yet
!**      buildFile(pressureIsm22Order6c,2,6,curvilinear)
!**      buildFile(pressureIsm23Order6c,3,6,curvilinear)
!**
!**      buildFile(pressureIsm22Order8r,2,8,rectangular)
!**      buildFile(pressureIsm23Order8r,3,8,rectangular)
!**
!**       ! build these for testing symmetric operators -- BC's not implemented yet
!**      buildFile(pressureIsm22Order8c,2,8,curvilinear)
!**      buildFile(pressureIsm23Order8c,3,8,curvilinear)






      subroutine pressureIsmOPt( subroutineArgs() )
!=====================================================================================
!      PRESSURE RHS
!   This function calls the appropriate lower level routine for a 
!  given dimension, gridType and order of accuracy
!
!====================================================================================
      implicit none

      declareInputArgs()      

      
      ! -- Declare arrays for variable material properties --
      ! include '../declareVarMatProp.h'

      !     ---- local variables -----
      integer option,gridType,orderOfAccuracy,i

      integer rectangular,curvilinear
      parameter( rectangular=0, curvilinear=1 )
      !...........end   statement functions


      ! write(*,*) 'Inside pressureIsmOpt...'
      ! write(*,*) 'rpar=',(rpar(i),i=0,10)
      ! write(*,*) 'ipar=',(ipar(i),i=0,10)
 
      option                        = ipar( 0)
      gridType                      = ipar( 1)
      orderOfAccuracy               = ipar( 2)      
 

      if( orderOfAccuracy.eq.2 )then

        if( nd.eq.2 .and. gridType.eq.rectangular ) then
          call pressureIsm2dOrder2r( subroutineArgs() )
        else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
          call pressureIsm2dOrder2c(  subroutineArgs() ) 

        else if( nd.eq.3 .and. gridType.eq.rectangular ) then
          call pressureIsm3dOrder2r( subroutineArgs() )

        else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
          call pressureIsm3dOrder2c(  subroutineArgs() ) 

        ! else if( nd.eq.3 .and. gridType.eq.rectangular ) then
        !   call pressureIsm3dOrder2r(nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
        !                      mask,rx,xy, um,u,un,f, bc, ipar, rpar, ierr )
        ! else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
        !   call pressureIsm3dOrder2c(nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
        !                      mask,rx,xy, um,u,un,f, bc, ipar, rpar, ierr )

        else

          stop 2271

        end if

      else if( orderOfAccuracy.eq.4 ) then

        if( nd.eq.2 .and. gridType.eq.rectangular ) then
          call pressureIsm2dOrder4r( subroutineArgs() )
        else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
          call pressureIsm2dOrder4c(  subroutineArgs() ) 
        ! else if( nd.eq.3 .and. gridType.eq.rectangular ) then
        !   call pressureIsm3dOrder2r(nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
        !                      mask,rx,xy, um,u,un,f, bc, ipar, rpar, ierr )
        ! else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
        !   call pressureIsm3dOrder2c(nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
        !                      mask,rx,xy, um,u,un,f, bc, ipar, rpar, ierr )

        else

          stop 4444

        end if        

      else
        write(*,'(" pressureIsmOpt:ERROR: un-implemented order of accuracy =",i6)') orderOfAccuracy
          ! '
        stop 11222
      end if

      return
      end








