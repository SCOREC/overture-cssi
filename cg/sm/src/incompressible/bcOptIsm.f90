! This file automatically generated from bcOptIsm.bf90 with bpp.
! *******************************************************************************
!   Solid Mechanics boundary conditions
!       INCOMPRESSIBLE ELASTICITY
! *******************************************************************************

! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
! Define statement functions for difference approximations of order 2 
! Thsi file was generated by op/src/makeIncludeNew.p  
! Arguments: u,rx,dr,dx: names for the grid function, jacobian, unit square spacing and rectangular grid spacing
! To include derivatives of rx use OPTION=RX
! Arguments: u,rx,dr,dx: names for the grid function, jacobian, unit square spacing and rectangular grid spacing
! To include derivatives of rx use OPTION=RX


! Define statement functions for difference approximations of order 4 
! Thsi file was generated by op/src/makeIncludeNew.p  
! Arguments: u,rx,dr,dx: names for the grid function, jacobian, unit square spacing and rectangular grid spacing
! To include derivatives of rx use OPTION=RX
! Arguments: u,rx,dr,dx: names for the grid function, jacobian, unit square spacing and rectangular grid spacing
! To include derivatives of rx use OPTION=RX






























! *************************************************************************************
!  Macro : adjust the gridIndexRange  to account for adjacent sides
!    Precedence at corners:
!       displacement over traction
!       dirichlet over traction
!  
!              |   |   |
!              |------------
!  bc=traction |   |   |
!              |-----------
!              |   |   |
!              X------------
!                     bc=displacement
!     X = this point removed from boundary loops for bc=traction since
!         extended boundaries are set on displacement BC's 
!
!              |   |   |
!              |------------
!  bc=displace |   |   |
!              |-----------
!              |   |   |
!              X------------
!                     bc=displacement
!     X = this point removed from boundary loops for bc=displacement since extended
!         boundaries are set on displacement BC's
! **************************************************************************************


! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
!  OPTION : none, or adjustAtCorners : adjust bounds for adjacent boundaries
! 
! ***********************************************************************************************








! ----------------------------------------------------------------------------------
!  Macro:
!    --- perturb a ghost point --- 
! Ordering of ghost points:
!    Order=2:
!       u1(-1), u2(-1),          : 2D 
!       u1(-1), u2(-1), u3(-1)   : 3D 
!    Order=4:
!       u1(-1), u2(-1),         u1(-2), u2(-2)           : 2D 
!       u1(-1), u2(-1), u3(-1), u1(-2), u2(-2), u3(-2)   : 3D 
! ----------------------------------------------------------------------------------



! ----------------------------------------------------------------------------------
!  Macro:
!    --- eval matrix coefficients by delta function approach ----
! Input:
!   am : matrix of coefficients is stored here 
!   evalEquations : macro that evaluates the residual of the boundary conditions
!                   and saves the residual in f(0:*)
! ----------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------
!  Macro:
!    --- perturb the solution for the discrete delta approach --- 
!
! ----------------------------------------------------------------------------------



! ----------------------------------------------------------------------------------
!  Macro:
!    --- eval matrix coefficients by delta function approach ----
! Input:
!   am : matrix of coefficients is stored here 
!   evalEquations : macro that evaluates the residual of the boundary conditions
!                   and saves the residual in f(0:*)
! ----------------------------------------------------------------------------------



! ==========================================================================
! Apply a stress free BC -- rectangular and 2d
! 
! FORCING equals noForcing or forcing
! ==========================================================================
! #beginMacro tractionBCRectangular3dMacro(FORCING)
! alpha=lambda/(lambda+2.*mu)
! beta=1./(lambda+2.*mu)
! if( axis.eq.0 )then
!   ! u.x = -alpha*(v.y+w.z)
!   ! v.x = -u.y  
!   ! w.x = -u.z
!  beginLoopsMask3d()
!   vy=uy23r(i1,i2,i3,u2c)
!   wz=uz23r(i1,i2,i3,u3c)
!   uy=uy23r(i1,i2,i3,u1c)
!   uz=uz23r(i1,i2,i3,u1c)
!   #If #FORCING eq "forcing" 
!    if( assignTwilightZone.eq.0 )then
!     u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)+dx(0)*2.*(!                           is1*alpha*(vy+wz)+ beta*bcf(side,axis,i1,i2,i3,u1c) )
!     u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)+dx(0)*2.*(!                           is1*uy+         (1./mu)*bcf(side,axis,i1,i2,i3,u2c) )
!     u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)+dx(0)*2.*(!                           is1*uz+         (1./mu)*bcf(side,axis,i1,i2,i3,u3c) )
!    else
!     OGDERIV3D(0,1,0,0,i1,i2,i3,t,ux0,vx0,wx0)
!     OGDERIV3D(0,0,1,0,i1,i2,i3,t,uy0,vy0,wy0)
!     OGDERIV3D(0,0,0,1,i1,i2,i3,t,uz0,vz0,wz0)
!     u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)-is1*dx(0)*2.*(-alpha*(vy+wz)+ux0+alpha*(vy0+wz0))
!     u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)-is1*dx(0)*2.*(-uy           +vx0+uy0)
!     u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)-is1*dx(0)*2.*(-uz           +wx0+uz0)
!    end if
!   #Else
!    u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)-is1*dx(0)*2.*(-alpha*(vy+wz))
!    u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)-is1*dx(0)*2.*(-uy)
!    u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)-is1*dx(0)*2.*(-uz)
!   #End

!  endLoopsMask3d()

! else if( axis.eq.1 )then
! ! u.y = - v.x
! ! v.y = -alpha*(u.x+w.z)
! ! w.y = - v.z
!  beginLoopsMask3d()
!   vx=ux23r(i1,i2,i3,u2c)
!   ux=ux23r(i1,i2,i3,u1c)
!   wz=uz23r(i1,i2,i3,u3c)
!   vz=uz23r(i1,i2,i3,u2c)
!   #If #FORCING eq "forcing" 
!    if( assignTwilightZone.eq.0 )then
!     u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)+dx(1)*2.*(!                           is2*vx +         (1./mu)*bcf(side,axis,i1,i2,i3,u1c))
!     u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)+dx(1)*2.*(!                           is2*alpha*(ux+wz) + beta*bcf(side,axis,i1,i2,i3,u2c))
!     u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)+dx(1)*2.*(!                           is2*vz +         (1./mu)*bcf(side,axis,i1,i2,i3,u3c) )
!    else
!     OGDERIV3D(0,1,0,0,i1,i2,i3,t,ux0,vx0,wx0)
!     OGDERIV3D(0,0,1,0,i1,i2,i3,t,uy0,vy0,wy0)
!     OGDERIV3D(0,0,0,1,i1,i2,i3,t,uz0,vz0,wz0)
!     u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)-is2*dx(1)*2.*(-vx            +uy0+vx0)
!     u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)-is2*dx(1)*2.*(-alpha*(ux+wz) +vy0+alpha*(ux0+wz0))
!     u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)-is2*dx(1)*2.*(-vz            +wy0+vz0)
!    end if
!   #Else
!    u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)-is2*dx(1)*2.*(-vx)
!    u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)-is2*dx(1)*2.*(-alpha*(ux+wz))
!    u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)-is2*dx(1)*2.*(-vz)
!   #End
!  endLoopsMask3d()

! else 

! ! u.z = - w.x
! ! v.z = - w.y
! ! w.z = -alpha*(u.x+v.y)
!  beginLoopsMask3d()
!   wx=ux23r(i1,i2,i3,u3c)
!   wy=uy23r(i1,i2,i3,u3c)
!   ux=ux23r(i1,i2,i3,u1c)
!   vy=uy23r(i1,i2,i3,u2c)
!   #If #FORCING eq "forcing" 
!    if( assignTwilightZone.eq.0 )then
!     u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)+dx(2)*2.*( !                           is3*wx +         (1./mu)*bcf(side,axis,i1,i2,i3,u1c))
!     u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)+dx(2)*2.*( !                           is3*wy +         (1./mu)*bcf(side,axis,i1,i2,i3,u2c))
!     u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)+dx(2)*2.*(!                           is3*alpha*(ux+vy) + beta*bcf(side,axis,i1,i2,i3,u3c))
!    else
!     OGDERIV3D(0,1,0,0,i1,i2,i3,t,ux0,vx0,wx0)
!     OGDERIV3D(0,0,1,0,i1,i2,i3,t,uy0,vy0,wy0)
!     OGDERIV3D(0,0,0,1,i1,i2,i3,t,uz0,vz0,wz0)
!     u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)-is3*dx(2)*2.*(-wx            +uz0+wx0)
!     u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)-is3*dx(2)*2.*(-wy            +vz0+wy0)
!     u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)-is3*dx(2)*2.*(-alpha*(ux+vy) +wz0+alpha*(ux0+vy0))
!    end if
!   #Else
!    u(i1-is1,i2-is2,i3-is3,u1c)=u(i1+is1,i2+is2,i3+is3,u1c)-is3*dx(2)*2.*(-wx)
!    u(i1-is1,i2-is2,i3-is3,u2c)=u(i1+is1,i2+is2,i3+is3,u2c)-is3*dx(2)*2.*(-wy)
!    u(i1-is1,i2-is2,i3-is3,u3c)=u(i1+is1,i2+is2,i3+is3,u3c)-is3*dx(2)*2.*(-alpha*(ux+vy))
!   #End
!  endLoopsMask3d()

! end if      
! #endMacro



! -----------------------------------------------------------------------
! Evaluate first derivatives using a wide formula in the axis direction
! ---------------------------------------------------------------------


! ==========================================================================
! **OLD**
! Apply a stress free BC -- curvilinear and 2d
! 
! FORCING equals noForcing or forcing
!    ------ TRACTION BC ----
!    Compressible case was
!     (lambda+2*mu) u_x + lambda*v_y = f   left/right
!     mu*( u_y + v_x ) = 0                 left/right
!
!    Incompressible:
!      (1)  u_x + v_y =0 
!      (2) n1*( -p + 2*mu*u_x) + n2*mu*( u_y _ v_x  ) = 0 
!      (3) n1*mu*( u_y + v_x)  + n2*( -p + 2*mu*v_y ) = 0 
!  n1*(2) - n2*(2) : 
!       (2') -p = 2*mu*( n1^2*u_x + n2^2*v_y ) = 0 
!  n2*(1) - n1*(2) :
!       (3') 2*mu*n1*n2*( u_x - v_y ) + (n2^2-n1^2)*mu*( u_y + v_x ) = 0 
! ==========================================================================

! ==========================================================================
! COMPRESSIBLE CASE
! Apply a stress free BC -- curvilinear and 3d
! 
! FORCING equals noForcing or forcing
! ==========================================================================


! ==========================================================================
! Macro: Evaluate the traction BCs, order=4, curvilinear, 2d
!      ORDER=4 CURVLINEAR
!   0 :  u1.x + u2.y 
!   1 :  n.grad( u1.x + u2.y  ) 
!   2 :  u2.x + u1.y 
!   3 : mu*( v_xxx + v_xyy ) + mu*( u_xxy + u_yyy ) - 2 p_xy 
! ==========================================================================



! ==========================================================================
! Macro: Apply a traction BC
!      ORDER=4 CURVLINEAR
! ==========================================================================

! ==========================================================================
! Macro: Evaluate traction 3D curvilinear equations
! ==========================================================================

! ==========================================================================
! Macro: Evaluate traction 3D curvlinear forcings
! ==========================================================================

! ==========================================================================
! Macro: Apply a traction BC
! 
! FORCING : forcing, twilightZone or noForcing
! 
!    ------ TRACTION BC ----
!    Compressible case was
!     (lambda+2*mu) u_x + lambda*v_y = f   left/right
!     mu*( u_y + v_x ) = 0                 left/right
!
!    Incompressible:
!      (1)  u_x + v_y =0 
!      (2) n1*( -p + 2*mu*u_x) + n2*mu*( u_y _ v_x  ) = 0 
!      (3) n1*mu*( u_y + v_x)  + n2*( -p + 2*mu*v_y ) = 0 
!  n1*(2) - n2*(2) : 
!       (2') -p = 2*mu*( n1^2*u_x + n2^2*v_y ) = 0 
!  n2*(1) - n1*(2) :
!       (3') 2*mu*n1*n2*( u_x - v_y ) + (n2^2-n1^2)*mu*( u_y + v_x ) = 0 
!
! THREE DIMENSIONS:
! We can write the three conditions in the form:
!        (div(u)) n + (I- n n^T) tau n = 0 
!  where
!    tau_ij = mu*( D_j u_i + D_i u_j )
! ==========================================================================


! ==========================================================================
! Macro: Evaluate the displacement BCs, order=4, curvilinear, 2d
!      ORDER=4 CURVLINEAR
!   0 :  u1.x + u2.y 
!   1 :  n.grad( u1.x + u2.y  ) 
!   2 :  tv.( mu*Delta(uv) - grad(p) ) 
!   3 :  Extrap (tv.u(-2) ) 
! ==========================================================================



! ==========================================================================
! Macro: Apply a displacement BC
!      ORDER=4 CURVLINEAR
! ==========================================================================



! ==========================================================================
!     Apply displacement BOUNDARY VALUES
!
! New general version - Aug 14, 2021 wdh
! 
! FORCING equals noForcing or TZ or forcing
! DIM : 2 or 3
! ORDER : 2 or 4
! GRIDTYPE rectangular or curvilinear
! ==========================================================================


! ==========================================================================
!   Macro: Assign displacementBC GHOST VALUES 
!
! New general version - Aug 14, 2021 wdh
! 
! FORCING equals noForcing or TZ or forcing
! DIM : 2 or 3
! ORDER : 2 or 4
! GRIDTYPE rectangular or curvilinear
! ==========================================================================




! ==========================================================================
! Apply a displacementBC BC -- 2d  *OLD**
! 
! FORCING equals noForcing or forcing
! ORDER : 2 or 4
! ==========================================================================


! ==========================================================================
! Apply a displacementBC BC -- 3d  *** OLD ****
! 
! FORCING equals noForcing or forcing
! ==========================================================================

! ====================================================================================
! Evaluate the slip-wall equations
! ====================================================================================

! ==========================================================================
! Apply a slip-wall BC -- curvilinear and 2d
! 
! FORCING equals noForcing or forcing
! ==========================================================================



! =================================================================================
!   Assign values in the corners in 2D (see bcMaxwellCorners.bf)
!
!  Set the normal component of the solution on the extended boundaries (points N in figure)
!  Set the corner points "C" 
!              |
!              X
!              |
!        N--N--X--X----
!              |
!        C  C  N
!              |
!        C  C  N
!
! ORDER: 2 or 4
! GRIDTYPE: rectangular, curvilinear
! FORCING: none, twilightZone
! =================================================================================


! ======================================================================================
!   Assign edges and corner points next to edges in 3D
!
!  Set the corner points "C" and points outside vertices
!              |
!              X
!              |
!        N--N--X--X----
!              |
!        C  C  N
!              |
!        C  C  N
!
! =================================================================================


!*****************************************************************************************************
!   Assign corners and edges in 3D
! 
!  ORDER: 2,4,6,8
!  GRIDTYPE: 
!  FORCING:
! 
!*****************************************************************************************************



! =======================================================================================
! Macro: evaluate the equations for a traction traction corner 
!    
!     Traction conditions
!           ux + vy = 0    :  x=0 and y=0 (left and bottom)
!           vx + uy = 0    :  x=0 and y=0 (left and bottom)
!           p = 2*mu*ux    : x=0
!           p = 2*mu*vy    : y=0
!  At the corner we thus have
!           p = 0
!           ux = 0 
!           vy = 0 
!           uxx - uyy =0 
!           vxx - vyy =0
!           uxy + vyy = 0
!           vxy + uyy = 0
!
!     (0)  ux + vy = 0 
!     (1)  vx + uy = 0 
!     (2)  uxx + vxy = uxx - uyy = 0
!     (3)  vxx + uxy = vxx - vyy = 0
!
!     (4)  uxy + vyy = 0        (for u(-1,-1) )
!     (5)  vxy + uyy = 0        (for v(-1,-1) )
!
! ========================================================================================

! =======================================================================================
! Macro: evaluate the FORCING for the equations for a traction traction corner 
!    
! ========================================================================================


! =======================================================================================
! Macro: evaluate the equations for a traction-displacement corner 
!    
! --- Traction-displacement corner : rectangular ---
!  Case 1 : 
!       |
!       +
! u=0   | u.x + v.y = 0 
! v=0   +
!       |
!       +---+---+---
!            u.x + v.y = 0
!            v.x + u.y = 0 
!  
!   Corner: 
!       u.xy = - v.yy = 0     
!       v.xy = - u.xx 
!
! ========================================================================================

! =======================================================================================
! Macro: evaluate the FORCING for the equations for a traction-displacement corner 
!    
! ========================================================================================

! =================================================================================
!   Assign values in the corners 
!
!  Set the corner points "C" and possibly the extended boundary points N 
!              |
!              X
!              |
!        N--N--X--X----
!              |
!        C  C  N
!              |
!        C  C  N
!
! DIM : 2 or 3 
! ORDER: 2 or 4
! GRIDTYPE: rectangular, curvilinear
! FORCING: none, twilightZone
! =================================================================================

! ---------------------------------------------------------------------
!  Macro Assign value on boundaries 
! ---------------------------------------------------------------------


!$$$
!$$$
!$$$#beginMacro getBoundaryForcing()
!$$$ if( side.eq.0 .and.axis.eq.0 )then
!$$$   beginGhostLoops3d()
!$$$    f(i1,i2,i3,u1c)=bcf00(i1,i2,i3,u1c)
!$$$#endMacro 

! ====== Here are the common subroutine arguments ====

! ========================================================================================
! Macro: declare input arguments
! ========================================================================================

! **********************************************************************************
! NAME: name of the subroutine
! DIM : 2 or 3
! ORDER : 2 ,4, 6 or 8
! GRIDTYPE : rectangular, curvilinear
! **********************************************************************************




      ! buildFile(bcIsm3dOrder4r,3,4,rectangular)
      ! buildFile(bcIsm3dOrder4c,3,4,curvilinear)   


  subroutine bcOptIsm( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
! ===================================================================================
!  Boundary conditions for solid mechanics
!
!  gridType : 0=rectangular, 1=curvilinear
!
!  c2= mu/rho, c1=(mu+lambda)/rho;
! 
! The forcing for the boundary conditions can be accessed in two ways. One can either 
! use the arrays: 
!       bcf00(i1,i2,i3,m), bcf10(i1,i2,i3,m), bcf01(i1,i2,i3,m), bcf11(i1,i2,i3,m), 
!       bcf02(i1,i2,i3,m), bcf12(i1,i2,i3,m)
! which provide values for the 6 different faces in 6 different arrays. One can also
! access the same values using the single statement function
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

  implicit none

    integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ierr
    real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
    integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
    real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
    real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
    integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2)
    integer addBoundaryForcing(0:1,0:2)
    integer interfaceType(0:1,0:2,0:*)
    integer dim(0:1,0:2,0:1,0:2)
    real bcf00(dim(0,0,0,0):dim(1,0,0,0), dim(0,1,0,0):dim(1,1,0,0), dim(0,2,0,0):dim(1,2,0,0),0:*)
    real bcf10(dim(0,0,1,0):dim(1,0,1,0), dim(0,1,1,0):dim(1,1,1,0), dim(0,2,1,0):dim(1,2,1,0),0:*)
    real bcf01(dim(0,0,0,1):dim(1,0,0,1), dim(0,1,0,1):dim(1,1,0,1), dim(0,2,0,1):dim(1,2,0,1),0:*)
    real bcf11(dim(0,0,1,1):dim(1,0,1,1), dim(0,1,1,1):dim(1,1,1,1), dim(0,2,1,1):dim(1,2,1,1),0:*)
    real bcf02(dim(0,0,0,2):dim(1,0,0,2), dim(0,1,0,2):dim(1,1,0,2), dim(0,2,0,2):dim(1,2,0,2),0:*)
    real bcf12(dim(0,0,1,2):dim(1,0,1,2), dim(0,1,1,2):dim(1,1,1,2), dim(0,2,1,2):dim(1,2,1,2),0:*)
    real bcf0(0:*)
    integer*8 bcOffset(0:1,0:2)
    integer ipar(0:*)
    real rpar(0:*)
    ! -- Declare arrays for variable material properties --
    include '../declareVarMatProp.h'
    integer rectangular,curvilinear
    parameter(rectangular=0,curvilinear=1)

  integer grid,gridType,orderOfAccuracy

  ierr=0

  nd                           = ipar(0)
  grid                         = ipar(1)
  ! u1c                          = ipar(2)
  ! u2c                          = ipar(3)
  ! u3c                          = ipar(4)
  gridType                     = ipar(5)
  orderOfAccuracy              = ipar(6)
  ! orderOfExtrapolation         = ipar(7)
  ! twilightZone                 = ipar(8)
  ! useWhereMask                 = ipar(9)
  ! debug                        = ipar(10)
     
  ! materialFormat               = ipar(15)
  ! pc                           = ipar(16)
  ! upwindSOS                    = ipar(17)
  ! useCurlCurlBoundaryCondition = ipar(18);

  if( orderOfAccuracy.eq.2 )then

    if( nd.eq.2 .and. gridType.eq.rectangular ) then
      call bcIsm2dOrder2r( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
      call bcIsm2dOrder2c( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else if( nd.eq.3 .and. gridType.eq.rectangular ) then
      call bcIsm3dOrder2r( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
      call bcIsm3dOrder2c( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else
      stop 2271
    end if

  else if( orderOfAccuracy.eq.4 ) then

    if( nd.eq.2 .and. gridType.eq.rectangular ) then
      call bcIsm2dOrder4r( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
      call bcIsm2dOrder4c( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else if( nd.eq.3 .and. gridType.eq.rectangular ) then
      call bcIsm3dOrder4r( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
      call bcIsm3dOrder4c( nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange,u,mask,rsxy,xy,ndMatProp,matIndex,matValpc,matVal,boundaryCondition,addBoundaryForcing,interfaceType,dim,bcf00,bcf10,bcf01,bcf11,bcf02,bcf12,bcf0,bcOffset,ipar,rpar,ierr )
    else
      stop 4444
    end if



  else
    write(*,'(" bcIsm:ERROR: un-implemented order of accuracy =",i6)') orderOfAccuracy
      ! '
    stop 11222
  end if

  return
  end      

