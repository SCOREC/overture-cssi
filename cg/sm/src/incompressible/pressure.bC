#include "Cgsm.h"
#include "SmParameters.h"
#include "display.h"
#include "ParallelUtility.h"
#include "ParallelGridUtility.h"
#include "Oges.h"
#include "CompositeGridOperators.h"
#include "SparseRep.h"
#include "App.h"
#include "OGPolyFunction.h"


// -------- function prototypes for Fortran routines --------
#define pressureIsmOpt EXTERN_C_NAME(pressureismopt)
extern "C"
{
// nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,mask,rsxy,xy, um,u,un,f, gridIndexRange, dimRange, isPeriodic, boundaryCondition, ipar, rpar, ierr
void pressureIsmOpt( const int&nd, 
                     const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,
                     const int&nd3a,const int&nd3b,const int&nd4a,const int&nd4b,
                     const int&mask, const real&rsxy, const real&xy,
                     real&um, real&u, real&un, real &f, 
                     const int&gridIndexRange, const int& dimRange, const int &isPeriodic, 
                     const int&boundaryCondition, 
                     const int&ipar, const real&rpar, int&ierr );

}

// Macros to define 2nd-order difference approximations: 
// #include "cgux2a.h"
// These next were taken from bcIsm2dOrder4c.f90
         // dr12(kd) = 1./(2.*dr(kd))
         // dr22(kd) = 1./(dr(kd)**2)
#defineMacro  rsxyr2(i1,i2,i3,m,n)    (rsxy(i1+1,i2,i3,m,n)-rsxy(i1-1,i2,i3,m,n))*dr12(0)
#defineMacro  rsxys2(i1,i2,i3,m,n)    (rsxy(i1,i2+1,i3,m,n)-rsxy(i1,i2-1,i3,m,n))*dr12(1)
#defineMacro  rsxyt2(i1,i2,i3,m,n)    (rsxy(i1,i2,i3+1,m,n)-rsxy(i1,i2,i3-1,m,n))*dr12(2)
#defineMacro  rsxyrr2(i1,i2,i3,m,n)   (-2.*rsxy(i1,i2,i3,m,n)+(rsxy(i1+1,i2,i3,m,n)+rsxy(i1-1,i2,i3,m,n)) )*dr22(0)
#defineMacro  rsxyss2(i1,i2,i3,m,n)   (-2.*rsxy(i1,i2,i3,m,n)+(rsxy(i1,i2+1,i3,m,n)+rsxy(i1,i2-1,i3,m,n)) )*dr22(1)
#defineMacro  rsxyrs2(i1,i2,i3,m,n)   (rsxyr2(i1,i2+1,i3,m,n)-rsxyr2(i1,i2-1,i3,m,n))*dr12(1)
#defineMacro  rsxytt2(i1,i2,i3,m,n)   (-2.*rsxy(i1,i2,i3,m,n)+(rsxy(i1,i2,i3+1,m,n)+rsxy(i1,i2,i3-1,m,n)) )*dr22(2)
#defineMacro  rsxyrt2(i1,i2,i3,m,n)   (rsxyr2(i1,i2,i3+1,m,n)-rsxyr2(i1,i2,i3-1,m,n))*dr12(2)
#defineMacro  rsxyst2(i1,i2,i3,m,n)   (rsxys2(i1,i2,i3+1,m,n)-rsxys2(i1,i2,i3-1,m,n))*dr12(2)
#defineMacro  rsxyrrr2(i1,i2,i3,m,n)  (-2.*(rsxy(i1+1,i2,i3,m,n)-rsxy(i1-1,i2,i3,m,n))+(rsxy(i1+2,i2,i3,m,n)-rsxy(i1-2,i2,i3,m,n)) )*dr22(0)*dr12(0)
#defineMacro  rsxysss2(i1,i2,i3,m,n)  (-2.*(rsxy(i1,i2+1,i3,m,n)-rsxy(i1,i2-1,i3,m,n))+(rsxy(i1,i2+2,i3,m,n)-rsxy(i1,i2-2,i3,m,n)) )*dr22(1)*dr12(1)
#defineMacro  rsxyttt2(i1,i2,i3,m,n)  (-2.*(rsxy(i1,i2,i3+1,m,n)-rsxy(i1,i2,i3-1,m,n))+(rsxy(i1,i2,i3+2,m,n)-rsxy(i1,i2,i3-2,m,n)) )*dr22(1)*dr12(2)
#defineMacro  rsxyrrs2(i1,i2,i3,m,n)  ( rsxyrr2(i1,i2+1,i3,m,n)-rsxyrr2(i1,i2-1,i3,m,n))/(2.*dr(1))
#defineMacro  rsxyrss2(i1,i2,i3,m,n)  ( rsxyss2(i1+1,i2,i3,m,n)-rsxyss2(i1-1,i2,i3,m,n))/(2.*dr(0))
#defineMacro  rsxyrrt2(i1,i2,i3,m,n)  ( rsxyrr2(i1,i2,i3+1,m,n)-rsxyrr2(i1,i2,i3-1,m,n))/(2.*dr(2))
#defineMacro  rsxysst2(i1,i2,i3,m,n)  ( rsxyss2(i1,i2,i3+1,m,n)-rsxyss2(i1,i2,i3-1,m,n))/(2.*dr(2))
#defineMacro  rsxyrtt2(i1,i2,i3,m,n)  ( rsxytt2(i1+1,i2,i3,m,n)-rsxytt2(i1-1,i2,i3,m,n))/(2.*dr(0))
#defineMacro  rsxystt2(i1,i2,i3,m,n)  ( rsxytt2(i1,i2+1,i3,m,n)-rsxytt2(i1,i2-1,i3,m,n))/(2.*dr(1))

#defineMacro rsxyx22(i1,i2,i3,m,n)    rsxy(i1,i2,i3,0,0)*rsxyr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxys2(i1,i2,i3,m,n)
#defineMacro rsxyy22(i1,i2,i3,m,n)    rsxy(i1,i2,i3,0,1)*rsxyr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxys2(i1,i2,i3,m,n)
#defineMacro rsxyxx22(i1,i2,i3,m,n)  (SQR(rsxy(i1,i2,i3,0,0)))*rsxyrr2(i1,i2,i3,m,n)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*rsxyrs2(i1,i2,i3,m,n)+(SQR(rsxy(i1,i2,i3,1,0)))*rsxyss2(i1,i2,i3,m,n)+(rsxyx22(i1,i2,i3,0,0))*rsxyr2(i1,i2,i3,m,n)+(rsxyx22(i1,i2,i3,1,0))*rsxys2(i1,i2,i3,m,n)
#defineMacro rsxyyy22(i1,i2,i3,m,n)  (SQR(rsxy(i1,i2,i3,0,1)))*rsxyrr2(i1,i2,i3,m,n)+2.*(rsxy(i1,i2,i3,0,1)*rsxy(i1,i2,i3,1,1))*rsxyrs2(i1,i2,i3,m,n)+(SQR(rsxy(i1,i2,i3,1,1)))*rsxyss2(i1,i2,i3,m,n)+(rsxyy22(i1,i2,i3,0,1))*rsxyr2(i1,i2,i3,m,n)+(rsxyy22(i1,i2,i3,1,1))*rsxys2(i1,i2,i3,m,n)
#defineMacro rsxyxy22(i1,i2,i3,m,n)  rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,1)+rsxy(i1,i2,i3,0,1)*rsxy(i1,i2,i3,1,0))*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxy(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,0,1)*rsxyr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxys2(i1,i2,i3,m,n)
#defineMacro rsxyxxx22(i1,i2,i3,m,n) rsxyxx22(i1,i2,i3,0,0)*rsxyr2(i1,i2,i3,m,n)+rsxyxx22(i1,i2,i3,1,0)*rsxys2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,0,0)*(rsxy(i1,i2,i3,0,0)*rsxyrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,0)*(rsxyx22(i1,i2,i3,0,0)*rsxyrr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,0)*rsxyrs2(i1,i2,i3,m,n))+rsxyx22(i1,i2,i3,1,0)*(rsxy(i1,i2,i3,0,0)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,0)*(rsxyx22(i1,i2,i3,0,0)*rsxyrs2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,0)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,0)*(rsxyx22(i1,i2,i3,0,0)*rsxyrr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,0)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,0)*(rsxy(i1,i2,i3,0,0)*rsxyrrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,0)*(rsxy(i1,i2,i3,0,0)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrss2(i1,i2,i3,m,n)))+rsxy(i1,i2,i3,1,0)*(rsxyx22(i1,i2,i3,0,0)*rsxyrs2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,0)*rsxyss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,0)*(rsxy(i1,i2,i3,0,0)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,0)*(rsxy(i1,i2,i3,0,0)*rsxyrss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxysss2(i1,i2,i3,m,n)))
#defineMacro rsxyxxy22(i1,i2,i3,m,n) rsxyxy22(i1,i2,i3,0,0)*rsxyr2(i1,i2,i3,m,n)+rsxyxy22(i1,i2,i3,1,0)*rsxys2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,0)*rsxyrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,0)*(rsxyx22(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxyrs2(i1,i2,i3,m,n))+rsxyx22(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,0)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,0)*(rsxyx22(i1,i2,i3,0,1)*rsxyrs2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,1)*(rsxyx22(i1,i2,i3,0,0)*rsxyrr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,0)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,0)*(rsxy(i1,i2,i3,0,0)*rsxyrrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,0)*(rsxy(i1,i2,i3,0,0)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrss2(i1,i2,i3,m,n)))+rsxy(i1,i2,i3,1,1)*(rsxyx22(i1,i2,i3,0,0)*rsxyrs2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,0)*rsxyss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,0)*(rsxy(i1,i2,i3,0,0)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,0)*(rsxy(i1,i2,i3,0,0)*rsxyrss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxysss2(i1,i2,i3,m,n)))
#defineMacro rsxyxyy22(i1,i2,i3,m,n) rsxyyy22(i1,i2,i3,0,0)*rsxyr2(i1,i2,i3,m,n)+rsxyyy22(i1,i2,i3,1,0)*rsxys2(i1,i2,i3,m,n)+rsxyy22(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,0)*rsxyrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,1)*(rsxyx22(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxyrs2(i1,i2,i3,m,n))+rsxyy22(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,0)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,1)*(rsxyx22(i1,i2,i3,0,1)*rsxyrs2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,1)*(rsxyx22(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,0)*rsxyrrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,0)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrss2(i1,i2,i3,m,n)))+rsxy(i1,i2,i3,1,1)*(rsxyx22(i1,i2,i3,0,1)*rsxyrs2(i1,i2,i3,m,n)+rsxyx22(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,0)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxyrss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,0)*rsxyrss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,0)*rsxysss2(i1,i2,i3,m,n)))
#defineMacro rsxyyyy22(i1,i2,i3,m,n) rsxyyy22(i1,i2,i3,0,1)*rsxyr2(i1,i2,i3,m,n)+rsxyyy22(i1,i2,i3,1,1)*rsxys2(i1,i2,i3,m,n)+rsxyy22(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxyrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,1)*(rsxyy22(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+rsxyy22(i1,i2,i3,1,1)*rsxyrs2(i1,i2,i3,m,n))+rsxyy22(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,1)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,1)*(rsxyy22(i1,i2,i3,0,1)*rsxyrs2(i1,i2,i3,m,n)+rsxyy22(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,0,1)*(rsxyy22(i1,i2,i3,0,1)*rsxyrr2(i1,i2,i3,m,n)+rsxyy22(i1,i2,i3,1,1)*rsxyrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,1)*rsxyrrr2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxyrrs2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,1)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxyrss2(i1,i2,i3,m,n)))+rsxy(i1,i2,i3,1,1)*(rsxyy22(i1,i2,i3,0,1)*rsxyrs2(i1,i2,i3,m,n)+rsxyy22(i1,i2,i3,1,1)*rsxyss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,0,1)*(rsxy(i1,i2,i3,0,1)*rsxyrrs2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxyrss2(i1,i2,i3,m,n))+rsxy(i1,i2,i3,1,1)*(rsxy(i1,i2,i3,0,1)*rsxyrss2(i1,i2,i3,m,n)+rsxy(i1,i2,i3,1,1)*rsxysss2(i1,i2,i3,m,n)))





// **** This macro came from opStencilCoeffOrder2.h generated by specialStencilCoeff.maple ******

#beginMacro lapSqCoeffOrder2Dim2(coeff,dr,ds)
 // Operator lapSq = (4*ry*ryyy+3*ryy^2)*urr+(4*sy*syyy+3*syy^2)*uss+ryyyy*ur+syyyy*us+(7*sy*ry*ryy+syy*ry^2+ry*(3*ry*syy+3*ryy*sy)+ry*(2*ry*syy+2*ryy*sy))*urrs+(sy*(3*ry*syy+3*ryy*sy)+7*ry*syy*sy+ryy*sy^2+sy*(2*ry*syy+2*ryy*sy))*urss+(4*ry*syyy+6*ryy*syy+4*ryyy*sy)*urs+ry^4*urrrr+sy^4*ussss+2*(2*rx*rxyy+rxx*ryy+2*rxxy*ry+2*rxy^2)*urr+2*rxxyy*ur+2*sxxyy*us+2*(sy*(rx^2*sy+2*rx*ry*sx)+ry*(2*rx*sx*sy+ry*sx^2))*urrss+2*(sy*(2*rx*sx*sy+ry*sx^2)+ry*sy*sx^2)*ursss+2*(sy*(2*rx*rxy+rxx*ry)+2*sy*rxy*rx+2*ryy*sx*rx+syy*rx^2+ry*(2*rx*sxy+rxx*sy+2*rxy*sx+ry*sxx)+ry*(2*rx*sxy+2*rxy*sx))*urrs+2*(sy*(2*rx*sxy+rxx*sy+2*rxy*sx+ry*sxx)+ry*(2*sx*sxy+sxx*sy)+ryy*sx^2+2*ry*sxy*sx+2*syy*sx*rx+sy*(2*rx*sxy+2*rxy*sx))*urss+2*(2*sy*sxy*sx+sy*(2*sx*sxy+sxx*sy)+syy*sx^2)*usss+2*(2*rx*sxyy+rxx*syy+2*rxxy*sy+4*rxy*sxy+2*rxyy*sx+2*ry*sxxy+ryy*sxx)*urs+2*(2*sx*sxyy+sxx*syy+2*sxxy*sy+2*sxy^2)*uss+(7*sx*rx*rxx+sxx*rx^2+rx*(3*rx*sxx+3*rxx*sx)+rx*(2*rx*sxx+2*rxx*sx))*urrs+(sx*(3*rx*sxx+3*rxx*sx)+7*rx*sxx*sx+rxx*sx^2+sx*(2*rx*sxx+2*rxx*sx))*urss+(4*rx*sxxx+6*rxx*sxx+4*rxxx*sx)*urs+2*(sy*ry*rx^2+ry*(rx^2*sy+2*rx*ry*sx))*urrrs+2*(2*ry*rxy*rx+ry*(2*rx*rxy+rxx*ry)+ryy*rx^2)*urrr+rx^4*urrrr+sx^4*ussss+(4*rx*rxxx+3*rxx^2)*urr+(4*sx*sxxx+3*sxx^2)*uss+rxxxx*ur+sxxxx*us+4*rx^3*sx*urrrs+6*rx^2*sx^2*urrss+4*rx*sx^3*ursss+6*rx^2*rxx*urrr+6*sx^2*sxx*usss+4*ry^3*sy*urrrs+6*ry^2*sy^2*urrss+4*ry*sy^3*ursss+6*ry^2*ryy*urrr+6*sy^2*syy*usss+2*ry^2*rx^2*urrrr+2*sy^2*sx^2*ussss
Real cur = ryyyy + 2 * rxxyy + rxxxx;

Real curr = 4 * rx * rxxx + 4 * rx * rxyy + 3 * rxx * rxx + 2 * rxx * ryy + 4 * rxxy * ry + 4 * rxy * rxy + 4 * ry * ryyy + 3 * ryy * ryy;

Real currr = 4 * ry * rxy * rx + 2 * ry * (2 * rx * rxy + rxx * ry) + 2 * ryy * rx * rx + 6 * rx * rx * rxx + 6 * ry * ry * ryy;

Real currrr = pow(rx, 0.4e1) + 0.2e1 * ry * ry * rx * rx + pow(ry, 0.4e1);

Real cus = syyyy + 2 * sxxyy + sxxxx;

Real curs = 4 * rx * sxxx + 4 * rx * sxyy + 6 * rxx * sxx + 2 * rxx * syy + 4 * rxxx * sx + 4 * rxxy * sy + 8 * rxy * sxy + 4 * rxyy * sx + 4 * ry * sxxy + 4 * ry * syyy + 2 * ryy * sxx + 6 * ryy * syy + 4 * ryyy * sy;

Real currs = 7 * sy * ry * ryy + syy * ry * ry + ry * (3 * ry * syy + 3 * ryy * sy) + ry * (2 * ry * syy + 2 * ryy * sy) + 2 * sy * (2 * rx * rxy + rxx * ry) + 4 * sy * rxy * rx + 4 * ryy * sx * rx + 2 * syy * rx * rx + 2 * ry * (2 * rx * sxy + rxx * sy + 2 * rxy * sx + ry * sxx) + 2 * ry * (2 * rx * sxy + 2 * rxy * sx) + 7 * sx * rx * rxx + sxx * rx * rx + rx * (3 * rx * sxx + 3 * rxx * sx) + rx * (2 * rx * sxx + 2 * rxx * sx);

Real currrs = 2 * sy * ry * rx * rx + 2 * ry * (rx * rx * sy + 2 * rx * ry * sx) + 4 * pow((double) rx, (double) 3) * sx + 4 * pow((double) ry, (double) 3) * sy;

Real cuss = 4 * sx * sxxx + 4 * sx * sxyy + 3 * sxx * sxx + 2 * sxx * syy + 4 * sxxy * sy + 4 * sxy * sxy + 4 * sy * syyy + 3 * syy * syy;

Real curss = sy * (3 * ry * syy + 3 * ryy * sy) + 7 * ry * syy * sy + ryy * sy * sy + sy * (2 * ry * syy + 2 * ryy * sy) + 2 * sy * (2 * rx * sxy + rxx * sy + 2 * rxy * sx + ry * sxx) + 2 * ry * (2 * sx * sxy + sxx * sy) + 2 * ryy * sx * sx + 4 * ry * sxy * sx + 4 * syy * sx * rx + 2 * sy * (2 * rx * sxy + 2 * rxy * sx) + sx * (3 * rx * sxx + 3 * rxx * sx) + 7 * rx * sxx * sx + rxx * sx * sx + sx * (2 * rx * sxx + 2 * rxx * sx);

Real currss = 2 * sy * (rx * rx * sy + 2 * rx * ry * sx) + 2 * ry * (2 * rx * sx * sy + ry * sx * sx) + 6 * rx * rx * sx * sx + 6 * ry * ry * sy * sy;

Real cusss = 4 * sy * sxy * sx + 2 * sy * (2 * sx * sxy + sxx * sy) + 2 * syy * sx * sx + 6 * sx * sx * sxx + 6 * sy * sy * syy;

Real cursss = 2 * sy * (2 * rx * sx * sy + ry * sx * sx) + 2 * ry * sy * sx * sx + 4 * rx * pow((double) sx, (double) 3) + 4 * ry * pow((double) sy, (double) 3);

Real cussss = pow(sx, 0.4e1) + 0.2e1 * sy * sy * sx * sx + pow(sy, 0.4e1);

 coeff(-2,-2, 0) = 0;
 
 coeff(-1,-2, 0) = cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 0,-2, 0) = -cusss * pow(ds, -0.3e1) / 0.2e1 + cussss * pow(ds, -0.4e1);
 
 coeff( 1,-2, 0) = -cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 2,-2, 0) = 0;
 
 coeff(-2,-1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-1,-1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.2e1 - currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + curs / dr / ds / 0.4e1 - curss / dr * pow(ds, -0.2e1) / 0.2e1 - cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 0,-1, 0) = currs * pow(dr, -0.2e1) / ds - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - cus / ds / 0.2e1 + cuss * pow(ds, -0.2e1) + cusss * pow(ds, -0.3e1) - 0.4e1 * cussss * pow(ds, -0.4e1);
 
 coeff( 1,-1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.2e1 - currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - curs / dr / ds / 0.4e1 + curss / dr * pow(ds, -0.2e1) / 0.2e1 + cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 2,-1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-2, 0, 0) = -currr * pow(dr, -0.3e1) / 0.2e1 + currrr * pow(dr, -0.4e1);
 
 coeff(-1, 0, 0) = -cur / dr / 0.2e1 + curr * pow(dr, -0.2e1) + currr * pow(dr, -0.3e1) - 0.4e1 * currrr * pow(dr, -0.4e1) - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + curss / dr * pow(ds, -0.2e1);
 
 coeff( 0, 0, 0) = -0.2e1 * curr * pow(dr, -0.2e1) + 0.6e1 * currrr * pow(dr, -0.4e1) + 0.4e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - 0.2e1 * cuss * pow(ds, -0.2e1) + 0.6e1 * cussss * pow(ds, -0.4e1);
 
 coeff( 1, 0, 0) = cur / dr / 0.2e1 + curr * pow(dr, -0.2e1) - currr * pow(dr, -0.3e1) - 0.4e1 * currrr * pow(dr, -0.4e1) - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - curss / dr * pow(ds, -0.2e1);
 
 coeff( 2, 0, 0) = currr * pow(dr, -0.3e1) / 0.2e1 + currrr * pow(dr, -0.4e1);
 
 coeff(-2, 1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-1, 1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.2e1 + currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - curs / dr / ds / 0.4e1 - curss / dr * pow(ds, -0.2e1) / 0.2e1 + cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 0, 1, 0) = -currs * pow(dr, -0.2e1) / ds - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + cus / ds / 0.2e1 + cuss * pow(ds, -0.2e1) - cusss * pow(ds, -0.3e1) - 0.4e1 * cussss * pow(ds, -0.4e1);
 
 coeff( 1, 1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.2e1 + currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + curs / dr / ds / 0.4e1 + curss / dr * pow(ds, -0.2e1) / 0.2e1 - cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 2, 1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-2, 2, 0) = 0;
 
 coeff(-1, 2, 0) = -cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 0, 2, 0) = cusss * pow(ds, -0.3e1) / 0.2e1 + cussss * pow(ds, -0.4e1);
 
 coeff( 1, 2, 0) = cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 2, 2, 0) = 0;
 
#endMacro


// ===========================================================================================
// *WDH* Sept 10, 2021 -- added Dxxxx - Dyyyy
//   Delta = 0 and Delta^2=0 =>
//         D_xxxx + 2*D_xxyy + 2*D_xxzz + 2*D_yyzz + D_yyyy + D_zzzz = 0
//               D_xx + D_yy + D_zz = 0
//               D_xxyy = - D_yyyy - D_yyzz
//               D_xxzz = - Dyyzz - D_zzzz
//   =>    D_xxxx = D_yyyy + D_zzzz + 2*D_yyzz  (for a BC at x=0)
//         LapSq - 2*LapD_yy - 2*LapD_zz 
// **** This macro came from opStencilCoeffOrder2.h generated by specialStencilCoeff.maple ******
// =========================================================================================== 
#beginMacro LapSqAdjustedCoeffOrder2Dim2(coeff,dr,ds)
 // Operator LapSqMinus = -(4*ry*ryyy+3*ryy^2)*urr-(4*sy*syyy+3*syy^2)*uss-ryyyy*ur-syyyy*us-(7*sy*ry*ryy+syy*ry^2+ry*(3*ry*syy+3*ryy*sy)+ry*(2*ry*syy+2*ryy*sy))*urrs-(sy*(3*ry*syy+3*ryy*sy)+7*ry*syy*sy+ryy*sy^2+sy*(2*ry*syy+2*ryy*sy))*urss-(4*ry*syyy+6*ryy*syy+4*ryyy*sy)*urs-ry^4*urrrr-sy^4*ussss+(7*sx*rx*rxx+sxx*rx^2+rx*(3*rx*sxx+3*rxx*sx)+rx*(2*rx*sxx+2*rxx*sx))*urrs+(sx*(3*rx*sxx+3*rxx*sx)+7*rx*sxx*sx+rxx*sx^2+sx*(2*rx*sxx+2*rxx*sx))*urss+(4*rx*sxxx+6*rxx*sxx+4*rxxx*sx)*urs+rx^4*urrrr+sx^4*ussss+(4*rx*rxxx+3*rxx^2)*urr+(4*sx*sxxx+3*sxx^2)*uss+rxxxx*ur+sxxxx*us+4*rx^3*sx*urrrs+6*rx^2*sx^2*urrss+4*rx*sx^3*ursss+6*rx^2*rxx*urrr+6*sx^2*sxx*usss-4*ry^3*sy*urrrs-6*ry^2*sy^2*urrss-4*ry*sy^3*ursss-6*ry^2*ryy*urrr-6*sy^2*syy*usss
Real cur = -ryyyy + rxxxx;

Real curr = 4 * rx * rxxx + 3 * rxx * rxx - 4 * ry * ryyy - 3 * ryy * ryy;

Real currr = 6 * rx * rx * rxx - 6 * ry * ry * ryy;

Real currrr = pow(rx, 0.4e1) - pow(ry, 0.4e1);

Real cus = -syyyy + sxxxx;

Real curs = 4 * rx * sxxx + 6 * rxx * sxx + 4 * rxxx * sx - 4 * ry * syyy - 6 * ryy * syy - 4 * ryyy * sy;

Real currs = -7 * sy * ry * ryy - syy * ry * ry - ry * (3 * ry * syy + 3 * ryy * sy) - ry * (2 * ry * syy + 2 * ryy * sy) + 7 * sx * rx * rxx + sxx * rx * rx + rx * (3 * rx * sxx + 3 * rxx * sx) + rx * (2 * rx * sxx + 2 * rxx * sx);

Real currrs = 0.4e1 * pow(rx, 0.3e1) * sx - 0.4e1 * pow(ry, 0.3e1) * sy;

Real cuss = 4 * sx * sxxx + 3 * sxx * sxx - 4 * sy * syyy - 3 * syy * syy;

Real curss = -sy * (3 * ry * syy + 3 * ryy * sy) - 7 * ry * syy * sy - ryy * sy * sy - sy * (2 * ry * syy + 2 * ryy * sy) + sx * (3 * rx * sxx + 3 * rxx * sx) + 7 * rx * sxx * sx + rxx * sx * sx + sx * (2 * rx * sxx + 2 * rxx * sx);

Real currss = 6 * rx * rx * sx * sx - 6 * ry * ry * sy * sy;

Real cusss = 6 * sx * sx * sxx - 6 * sy * sy * syy;

Real cursss = 0.4e1 * rx * pow(sx, 0.3e1) - 0.4e1 * ry * pow(sy, 0.3e1);

Real cussss = pow(sx, 0.4e1) - pow(sy, 0.4e1);

 coeff(-2,-2, 0) = 0;
 
 coeff(-1,-2, 0) = cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 0,-2, 0) = -cusss * pow(ds, -0.3e1) / 0.2e1 + cussss * pow(ds, -0.4e1);
 
 coeff( 1,-2, 0) = -cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 2,-2, 0) = 0;
 
 coeff(-2,-1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-1,-1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.2e1 - currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + curs / dr / ds / 0.4e1 - curss / dr * pow(ds, -0.2e1) / 0.2e1 - cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 0,-1, 0) = currs * pow(dr, -0.2e1) / ds - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - cus / ds / 0.2e1 + cuss * pow(ds, -0.2e1) + cusss * pow(ds, -0.3e1) - 0.4e1 * cussss * pow(ds, -0.4e1);
 
 coeff( 1,-1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.2e1 - currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - curs / dr / ds / 0.4e1 + curss / dr * pow(ds, -0.2e1) / 0.2e1 + cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 2,-1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-2, 0, 0) = -currr * pow(dr, -0.3e1) / 0.2e1 + currrr * pow(dr, -0.4e1);
 
 coeff(-1, 0, 0) = -cur / dr / 0.2e1 + curr * pow(dr, -0.2e1) + currr * pow(dr, -0.3e1) - 0.4e1 * currrr * pow(dr, -0.4e1) - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + curss / dr * pow(ds, -0.2e1);
 
 coeff( 0, 0, 0) = -0.2e1 * curr * pow(dr, -0.2e1) + 0.6e1 * currrr * pow(dr, -0.4e1) + 0.4e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - 0.2e1 * cuss * pow(ds, -0.2e1) + 0.6e1 * cussss * pow(ds, -0.4e1);
 
 coeff( 1, 0, 0) = cur / dr / 0.2e1 + curr * pow(dr, -0.2e1) - currr * pow(dr, -0.3e1) - 0.4e1 * currrr * pow(dr, -0.4e1) - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - curss / dr * pow(ds, -0.2e1);
 
 coeff( 2, 0, 0) = currr * pow(dr, -0.3e1) / 0.2e1 + currrr * pow(dr, -0.4e1);
 
 coeff(-2, 1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-1, 1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.2e1 + currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) - curs / dr / ds / 0.4e1 - curss / dr * pow(ds, -0.2e1) / 0.2e1 + cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 0, 1, 0) = -currs * pow(dr, -0.2e1) / ds - 0.2e1 * currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + cus / ds / 0.2e1 + cuss * pow(ds, -0.2e1) - cusss * pow(ds, -0.3e1) - 0.4e1 * cussss * pow(ds, -0.4e1);
 
 coeff( 1, 1, 0) = -currrs * pow(dr, -0.3e1) / ds / 0.2e1 + currs * pow(dr, -0.2e1) / ds / 0.2e1 + currss * pow(dr, -0.2e1) * pow(ds, -0.2e1) + curs / dr / ds / 0.4e1 + curss / dr * pow(ds, -0.2e1) / 0.2e1 - cursss / dr * pow(ds, -0.3e1) / 0.2e1;
 
 coeff( 2, 1, 0) = currrs * pow(dr, -0.3e1) / ds / 0.4e1;
 
 coeff(-2, 2, 0) = 0;
 
 coeff(-1, 2, 0) = -cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 0, 2, 0) = cusss * pow(ds, -0.3e1) / 0.2e1 + cussss * pow(ds, -0.4e1);
 
 coeff( 1, 2, 0) = cursss / dr * pow(ds, -0.3e1) / 0.4e1;
 
 coeff( 2, 2, 0) = 0;
 
#endMacro





// =======================================================================================
// Macro: Call optimized routine to assign pressure RHS and boundary conditions
// =======================================================================================
#beginMacro getPressureRHSOpt()   

  IntegerArray indexRangeLocal(2,3), dimLocal(2,3), bcLocal(2,3);
  ParallelGridUtility::getLocalIndexBoundsAndBoundaryConditions( u[grid],indexRangeLocal,dimLocal,bcLocal );

  const bool isRectangular=mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);
 
 // option           = ipar( 0)
 // gridType         = ipar( 1)
 // orderOfAccuracy  = ipar( 2)
 // orderInTime      = ipar( 3)
 // addForcing       = ipar( 4)
 // twilightZone     = ipar( 5)
 // uc               = ipar( 6)
 // vc               = ipar( 7)
 // wc               = ipar( 8)
 // pc               = ipar( 9)
 // useWhereMask     = ipar(10)
 // debug            = ipar(11)
 // myid             = ipar(12)
 // grid             = ipar(13)

  const real & cdv = parameters.dbase.get<real>("cdv");   // coeff of div-damping for ILE
  real & rho=parameters.dbase.get<real>("rho");

  int gridType = isRectangular ? 0 : 1;
  int option=0; // not used yet
  int useWhereMask=0; 
  int ipar[] = {
    option,                   // ipar( 0)
    gridType,                 // ipar( 1)
    orderOfAccuracyInSpace,   // ipar( 2)
    orderOfAccuracyInTime,    // ipar( 3)
    addForcing,               // ipar( 4)
    twilightZone,             // ipar( 5)
    uc,                       // ipar( 6)
    vc,                       // ipar( 7)
    wc,                       // ipar( 8)
    pc,                       // ipar( 9)
    useWhereMask,             // ipar(10)
    debug(),                  // ipar(11)
    myid,                     // ipar(12)
    grid,                     // ipar(13)
    useCurlCurlBoundaryCondition
              };


 // t        = rpar( 0)  ! This should be the time that p lives at (new time)
 // dt       = rpar( 1)
 // rho      = rpar( 2)
 // mu       = rpar( 3)
 // cdv      = rpar( 4)  ! coeff of divergence damping 
 // dx(0)    = rpar( 5)
 // dx(1)    = rpar( 6)
 // dx(2)    = rpar( 7)
 // dr(0)    = rpar( 8)
 // dr(1)    = rpar( 9)
 // dr(2)    = rpar(10)
 // ep       = rpar(11)  ! pointer to exact solution (TZ)
 // REAL_MIN = rpar(12)
 
 

  real rpar[] = {
    t                ,                                   //  rpar( 0)
    dt               ,                                   //  rpar( 1)
    rho,         
    mu,         
    cdv,         
    dx[0]            ,                                   //  rpar( 5)
    dx[1]            ,                                   //  rpar( 6)
    dx[2]            ,                                   //  rpar( 7)
    mg.gridSpacing(0),                                   //  rpar( 8)
    mg.gridSpacing(1),                                   //  rpar( 9)
    mg.gridSpacing(2),                                   //  rpar(10)
    (real &)(parameters.dbase.get<OGFunction* >("exactSolution")), //  rpar(11) ! pointer for exact solution -- new : 110311 
    REAL_MIN,                                            //  rpar(12)
                };   

  real *pf   = fLocal.getDataPointer();
  real *pum  = umLocal.getDataPointer();
  real *pu   = uLocal.getDataPointer();
  real *pun  = unLocal.getDataPointer();
  int *pmask = maskLocal.getDataPointer();

  real temp, *pxy=&temp, *prsxy=&temp;
  if( !isRectangular )
  {
    #ifdef USE_PPP
     prsxy=mg.inverseVertexDerivative().getLocalArray().getDataPointer();
    #else
     prsxy=mg.inverseVertexDerivative().getDataPointer();
    #endif    
  }
  bool vertexNeeded = twilightZone || knownSolutionOption!=0;
  if( vertexNeeded )
  {
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter );
    #ifdef USE_PPP
     pxy=mg.vertex().getLocalArray().getDataPointer();
    #else
     pxy=mg.vertex().getDataPointer();
    #endif    
  }

  // nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,mask,rsxy,xy, um,u,un,f, gridIndexRange, dimRange, isPeriodic, boundaryCondition, ipar, rpar, ierr
  int ierr=0;
  pressureIsmOpt(mg.numberOfDimensions(),
                 unLocal.getBase(0),unLocal.getBound(0),unLocal.getBase(1),unLocal.getBound(1),
                 unLocal.getBase(2),unLocal.getBound(2),unLocal.getBase(3),unLocal.getBound(3),
                 *pmask, *prsxy, *pxy, *pum, *pu, *pun, *pf, 
                 indexRangeLocal(0,0), dimLocal(0,0), mg.isPeriodic(0),bcLocal(0,0),  
                 ipar[0],rpar[0], ierr );

#endMacro                                  





#define ForBoundary(side,axis)   for( int axis=0; axis<cg.numberOfDimensions(); axis++ ) \
                                 for( int side=0; side<=1; side++ )


// ============================================================================================
/// \brief Take an implicit time step to new time t
/// \param t (input) : new time
// ============================================================================================
int Cgsm::solveForPressure( int current, Real t, Real dt )
{
  real cpu0=getCPU();

  const int myid = max(0,Communication_Manager::My_Process_Number);
  const int np   = max(1,Communication_Manager::numberOfProcessors());

  if( !parameters.dbase.get<int>("pressureSolverInitialized") )
  {
    // Oges::debug=63;
    formPressureEquation();
  }


  FILE *& debugFile  =parameters.dbase.get<FILE* >("debugFile");
  FILE *& logFile    =parameters.dbase.get<FILE* >("logFile");
  FILE *& pDebugFile =parameters.dbase.get<FILE* >("pDebugFile");
  
  const int numberOfDimensions             = cg.numberOfDimensions();
  const int numberOfComponentGrids         = cg.numberOfComponentGrids();
  const int & numberOfComponents           = parameters.dbase.get<int >("numberOfComponents");
  const int & uc                           = parameters.dbase.get<int >("uc");
  const int & vc                           = parameters.dbase.get<int >("vc");
  const int & wc                           = parameters.dbase.get<int >("wc");
  const int & rc                           = parameters.dbase.get<int >("rc");
  const int & tc                           = parameters.dbase.get<int >("tc");
  const int & pc                           = parameters.dbase.get<int >("pc");
  const int & orderOfAccuracyInSpace       = parameters.dbase.get<int>("orderOfAccuracy");
  const int & orderOfAccuracyInTime        = parameters.dbase.get<int>("orderOfTimeAccuracy");
  const int & useCurlCurlBoundaryCondition = parameters.dbase.get<int>("useCurlCurlBoundaryCondition"); 

  const Real & mu                    = parameters.dbase.get<real>("mu");


  const bool twilightZone = forcingOption==twilightZoneForcing; 
  const bool addForcing = forcingOption!=noForcing && forcingOption!=planeWaveBoundaryForcing;

  RealArray & timing = parameters.dbase.get<RealArray >("timing");

  // const int & applyKnownSolutionAtBoundaries = dbase.get<int>("applyKnownSolutionAtBoundaries"); // by default, do NOT apply known solution at boundaries

  // const int & current                  = dbase.get<int>("current"); // hold the current solution index

  const int cur = current;   // current time level
  const int prev= (cur-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next= (cur+1+numberOfTimeLevels) % numberOfTimeLevels;

  realCompositeGridFunction & um = gf[prev].u;        // prev time
  realCompositeGridFunction & u  = gf[cur ].u;        // current time
  realCompositeGridFunction & un = gf[next].u;        // new time

  // --- Fill in the RHS for pressure equation and boundary conditions ----

  if( !parameters.dbase.has_key("pressure") )
  {
    // pressure could be a link to un(.,.,.,pc) in serial -- see Cgins::pressure.bC
    realCompositeGridFunction & pressure = parameters.dbase.put<realCompositeGridFunction>("pressure");
    pressure.updateToMatchGrid(cg);
    pressure=0.;   

    realCompositeGridFunction & pressureRightHandSide =  parameters.dbase.put<realCompositeGridFunction>("pressureRightHandSide");
    pressureRightHandSide.updateToMatchGrid(cg);  // could be the same as pressure for non-iterative solvers
    pressureRightHandSide=0.;
  }
  realCompositeGridFunction & pressure              = parameters.dbase.get<realCompositeGridFunction>("pressure");
  realCompositeGridFunction & pressureRightHandSide = parameters.dbase.get<realCompositeGridFunction>("pressureRightHandSide");

  int numGhost = orderOfAccuracyInSpace/2;

  // Copy pressure from un 
  Range all;
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    assign(pressure[grid],all,all,all,0, un[grid],all,all,all,pc );
  }

  // const int assignBCForImplicit = 1;  

  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cg[grid];
    // const IntegerArray & gid = mg.gridIndexRange();
    
    OV_GET_SERIAL_ARRAY(Real,pressureRightHandSide[grid],fLocal);

    OV_GET_SERIAL_ARRAY(Real,um[grid],umLocal);
    OV_GET_SERIAL_ARRAY(Real,u[grid], uLocal);
    OV_GET_SERIAL_ARRAY(Real,un[grid],unLocal);

    OV_GET_SERIAL_ARRAY(int,mg.mask(),maskLocal);

    // Call optimized routine to assign pressure RHS and boundary conditions
    getPressureRHSOpt();

 

  } // end for grid 


  if( false )
    un.display("solve for pressure: un","%8.3f ");

  Oges & pressureSolver = parameters.dbase.get<Oges>("pressureSolver");


  const int & pressurePoissonIsSingular = parameters.dbase.get<int>("pressurePoissonIsSingular");
  if( pressurePoissonIsSingular )
  {
    real value[1]={0.};
    pressureSolver.setExtraEquationRightHandSideValues(pressureRightHandSide,value );
  }
  // If we need to set the RHS for the compatibility constraint then here is how to do it (from tcm3.C)
        // if( singularProblem )
        // {
        //   // we need to first initialize the solver before we can fill in the rhs for the compatibility equation
        //   solver.initialize();
        //   realCompositeGridFunction ue(cg);
        //   exact.assignGridFunction(ue,0.);
        //   real value=0.;
        //   solver.evaluateExtraEquation(ue,value);

        //   if( Oges::debug & 4 )
        //     printF(" Neumann: RHS for singular equation=%10.3e\n",value);
          
        //   solver.setExtraEquationValues(f,&value );
        // }


  // ------- SOLVE THE IMPLICIT PRESSURE EQUATION -----

  bool outputMatrix=false; // false; // true;  // for debugging 
  if( outputMatrix )
  {
    Oges::debug=63;
    pressureSolver.set(OgesParameters::THEkeepSparseMatrix,true);
  }

  if( false )
  {
    pressureRightHandSide.display("pressureRHS","%7.3f");
  }

  // ----------------------------------------------------------------------------
  // ---------------- SOLVE THE PRESSURE EQUAION --------------------------------
  // ----------------------------------------------------------------------------
  pressureSolver.solve( pressure,pressureRightHandSide );

  // Copy pressure to un 
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    assign( un[grid],all,all,all,pc, pressure[grid],all,all,all,0 );
  }   

  if( outputMatrix )
  {
    printF("Cgsm: INFO: save the pressure matrix to file cgsmMatrix.out (using writeMatrixToFile). \n");
    pressureSolver.writeMatrixToFile("cgsmMatrix.out");

    aString fileName = "cgsmSparseMatrix.dat";
    printF("Cgsm: INFO: save the pressure matrix to file %s (using outputSparseMatrix)\n",(const char*)fileName);
    pressureSolver.outputSparseMatrix( fileName );

    OV_ABORT("stop here for now"); 
  }

  // RealArray & timing = parameters.dbase.get<RealArray >("timing");
  timing(parameters.dbase.get<int>("timeForPressureSolve"))+=getCPU()-cpu0;


  return 0;
}


#define ForStencil(m1,m2,m3)   \
for( m3=-halfWidth3; m3<=halfWidth3; m3++) \
for( m2=-halfWidth2; m2<=halfWidth2; m2++) \
for( m1=-halfWidth1; m1<=halfWidth1; m1++)

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)

// =======================================================================
// indexToEquation( n,i1,i2,i3 ) : defines the global index for each unknown in the system
//     n=component number (uc,vc,...)
//    (i1,i2,i3) = grid point
// =======================================================================
#define indexToEquation( n,i1,i2,i3 ) (n+1+ \
numberOfComponentsForCoefficients*(i1-equationNumberBase1+\
equationNumberLength1*(i2-equationNumberBase2+\
equationNumberLength2*(i3-equationNumberBase3))) + equationOffset)

// =======================================================================
// =======================================================================
#define setEquationNumber(m, ni,i1,i2,i3,  nj,j1,j2,j3 )\
equationNumber(m,i1,i2,i3)=indexToEquation( nj,j1,j2,j3)

// =======================================================================
// =======================================================================
#define setClassify(n,i1,i2,i3, type) \
classify(i1,i2,i3,n)=type

// ==========================================================================
// Macro: setup the variables needed to fill a sparse matrix on a mappedGrid
// ==========================================================================
#beginMacro setupVariablesForSparseMatrix()      
  assert( coeff.sparse!=NULL );
  
  SparseRepForMGF & sparse = *coeff.sparse;
  int numberOfComponentsForCoefficients = sparse.numberOfComponents;  // size of the system of equations
  int numberOfGhostLines = sparse.numberOfGhostLines;
  int stencilSize = sparse.stencilSize;
  int stencilDim=stencilSize*numberOfComponentsForCoefficients; // number of coefficients per equation
  
  
  const int equationOffset=sparse.equationOffset;
  // FIX ME FOR PARALLEL
  intArray & equationNumber = sparse.equationNumber;
  intArray & classify = sparse.classify;
  
  const int equationNumberBase1  =equationNumber.getBase(1);
  const int equationNumberLength1=equationNumber.getLength(1);
  const int equationNumberBase2  =equationNumber.getBase(2);
  const int equationNumberLength2=equationNumber.getLength(2);
  const int equationNumberBase3  =equationNumber.getBase(3);
  
  const int orderOfAccuracy=mgop.getOrderOfAccuracy(); 
  
  // stencil width's and half-width's :
  const int width = orderOfAccuracy+1;
  // const int width      = stencilWidth;
  const int halfWidth1 = (width-1)/2;
  const int halfWidth2 = numberOfDimensions>1 ? halfWidth1 : 0;
  const int halfWidth3 = numberOfDimensions>2 ? halfWidth1 : 0;
  
  Range M0 = baseStencilSize;    // ***** May 15, 2021 -> is this right
  Range M = coeff.dimension(0);
#endMacro



// ==========================================================================================
// Macro: Adjust the boundary index bounds on the ends to account for adjacent sides
//    Priority of boundary conditions:
//       dirichlet take priority over traction and displacement
// 
//              |   |   |   |
//              +---+---+---+--
//              |   |   |   |
//  bc=traction +---+---+---+--
//              |   |   |   |
//              +---+---+---+--
//              |   |   |   |
//              X---+---+---+--
//                 bc=dirichlet
// When filling in a traction BC we skip point X which is adjacent to a dirichlet BC
//  
// ==========================================================================================
#beginMacro adjustBoundaryIndexBounds( side,axis,Ibv )
  if( mg.boundaryCondition(side,axis)==SmParameters::tractionBC || 
      mg.boundaryCondition(side,axis)==SmParameters::displacementBC ||
      mg.boundaryCondition(side,axis)==SmParameters::dirichletBoundaryCondition )
  {
    for( int dir=1; dir<numberOfDimensions; dir++ )  // loop for adjacent directions
    {
      const int axisp = (axis+dir) % numberOfDimensions;  // tangential direction
      for( int endSide=0; endSide<=1; endSide++ )
      {
        if( mg.boundaryCondition(endSide,axisp)==SmParameters::dirichletBoundaryCondition )
        {
          // remove a point from one end
          Ibv[axisp] = endSide==0 ? Range( Ibv[axisp].getBase()+1,Ibv[axisp].getBound() ) :
                                    Range( Ibv[axisp].getBase()  ,Ibv[axisp].getBound()-1 );
        }
      }
    }
  }
#endMacro


// ==========================================================================
// Macro: fill the matrix with extrapolation for a given ghost=1,2,3,...
// ==========================================================================
#beginMacro fillGhostExtrapolation(ghost)    

  getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,ghost);
  adjustBoundaryIndexBounds( side,axis,Igv );

  coeffLocal(M0,Ig1,Ig2,Ig3) = 0.0;

  FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) // loop over points on the boundary
  {
      
    int i1m=i1-is1*ghost, i2m=i2-is2*ghost, i3m=i3-is3*ghost; //  ghost point is (i1m,i2m,i3m)

    // --- fill in the coefficients of the extrapolation formula ---
    for( int m=0; m<=extrapOrder; m++ )
    {
      coeffLocal(m,i1m,i2m,i3m) = extrapCoeff[m];
      int j1=i1m + m*is1, j2=i2m + m*is2, j3=i3m + m*is3;     // index of point "m" in extrap formula is shifted in the direction (is1,is2,is3)
      setEquationNumber(m, e,i1m,i2m,i3m,  cc,j1,j2,j3 );      // macro to set equationNumber
    }

  } // end FOR_3D

#endMacro


// ============================================================================================
// Macro: evaluate metric derivatives  
//     Set D = x, y, xx, yy, etc. to evaluate the D-derivative of the metrics                
// ============================================================================================
#beginMacro evalMetricDerivatives(D)
  Real rx ## D = rsxy ## D ## 22(i1,i2,i3,0,0), ry ## D=rsxy ## D ## 22(i1,i2,i3,0,1), sx ## D=rsxy ## D ## 22(i1,i2,i3,1,0), sy ## D=rsxy ## D ## 22(i1,i2,i3,1,1);                  
#endMacro


// ============================================================================================
// Macro: Fill in the local matrix mat with the coefficients of  
//                          Laplacian-squared                
// ============================================================================================
#beginMacro getLaplacianSquaredCoefficients(DIM)                  
  // Real dr = mg.gridSpacing(0), ds=mg.gridSpacing(1); 
  Real rx = rsxy(i1,i2,i3,0,0), ry = rsxy(i1,i2,i3,0,1), sx = rsxy(i1,i2,i3,1,0), sy = rsxy(i1,i2,i3,1,1);
  evalMetricDerivatives(x);
  evalMetricDerivatives(y);
  evalMetricDerivatives(xx);
  evalMetricDerivatives(xy);
  evalMetricDerivatives(yy);
  evalMetricDerivatives(xxx);
  evalMetricDerivatives(xxy);
  evalMetricDerivatives(xyy);
  evalMetricDerivatives(yyy);

  // Real rxx = rsxyx22(i1,i2,i3,0,0), ryx=rsxyx22(i1,i2,i3,0,1), sxx=rsxyx22(i1,i2,i3,1,0), syx=rsxyx22(i1,i2,i3,1,1);
  // Real rxy = rsxyy22(i1,i2,i3,0,0), ryy=rsxyy22(i1,i2,i3,0,1), sxy=rsxyy22(i1,i2,i3,1,0), syy=rsxyy22(i1,i2,i3,1,1);

  // Real rxxx = rsxyxx22(i1,i2,i3,0,0), ryxx=rsxyxx22(i1,i2,i3,0,1), sxxx=rsxyxx22(i1,i2,i3,1,0), syxx=rsxyxx22(i1,i2,i3,1,1);
  // Real rxxy = rsxyxy22(i1,i2,i3,0,0), ryxy=rsxyxy22(i1,i2,i3,0,1), sxxy=rsxyxy22(i1,i2,i3,1,0), syxy=rsxyxy22(i1,i2,i3,1,1);
  // Real rxyy = rsxyyy22(i1,i2,i3,0,0), ryyy=rsxyyy22(i1,i2,i3,0,1), sxyy=rsxyyy22(i1,i2,i3,1,0), syyy=rsxyyy22(i1,i2,i3,1,1);                  

  // Fill in mat(m1,m2,m3) with the coefficients of Laplacian-squared
  lapSqCoeffOrder2Dim2(mat,dr(0),dr(1));

#endMacro

// ============================================================================================
// Macro: Fill in the local matrix mat with the coefficients of  
//          Laplacian-squared  Adjusted
// In 2D : D_xxxx - D_yyyy              
// ============================================================================================
#beginMacro getLaplacianSquaredAdjustedCoefficients(DIM)                  
  // Real dr = mg.gridSpacing(0), ds=mg.gridSpacing(1); 
  Real rx = rsxy(i1,i2,i3,0,0), ry = rsxy(i1,i2,i3,0,1), sx = rsxy(i1,i2,i3,1,0), sy = rsxy(i1,i2,i3,1,1);
  evalMetricDerivatives(x);
  evalMetricDerivatives(y);
  evalMetricDerivatives(xx);
  evalMetricDerivatives(xy);
  evalMetricDerivatives(yy);
  evalMetricDerivatives(xxx);
  evalMetricDerivatives(xxy);
  evalMetricDerivatives(xyy);
  evalMetricDerivatives(yyy);

  // Real rxx = rsxyx22(i1,i2,i3,0,0), ryx=rsxyx22(i1,i2,i3,0,1), sxx=rsxyx22(i1,i2,i3,1,0), syx=rsxyx22(i1,i2,i3,1,1);
  // Real rxy = rsxyy22(i1,i2,i3,0,0), ryy=rsxyy22(i1,i2,i3,0,1), sxy=rsxyy22(i1,i2,i3,1,0), syy=rsxyy22(i1,i2,i3,1,1);

  // Real rxxx = rsxyxx22(i1,i2,i3,0,0), ryxx=rsxyxx22(i1,i2,i3,0,1), sxxx=rsxyxx22(i1,i2,i3,1,0), syxx=rsxyxx22(i1,i2,i3,1,1);
  // Real rxxy = rsxyxy22(i1,i2,i3,0,0), ryxy=rsxyxy22(i1,i2,i3,0,1), sxxy=rsxyxy22(i1,i2,i3,1,0), syxy=rsxyxy22(i1,i2,i3,1,1);
  // Real rxyy = rsxyyy22(i1,i2,i3,0,0), ryyy=rsxyyy22(i1,i2,i3,0,1), sxyy=rsxyyy22(i1,i2,i3,1,0), syyy=rsxyyy22(i1,i2,i3,1,1);                  

  // Fill in mat(m1,m2,m3) with the coefficients of Laplacian-squared adjusted 
  LapSqAdjustedCoeffOrder2Dim2(mat,dr(0),dr(1));

#endMacro  

// ============================================================================================
/// \brief Form the implicit pressure equation
// ============================================================================================
int Cgsm::formPressureEquation()
{
  real cpu0=getCPU();

  parameters.dbase.get<int>("pressureSolverInitialized")=true;

  const int & debug                  = parameters.dbase.get<int>("debug");
  const int & orderOfAccuracyInSpace = parameters.dbase.get<int>("orderOfAccuracy");
  const int & orderOfAccuracyInTime  = parameters.dbase.get<int>("orderOfTimeAccuracy");
  const int & upwindSOS              = parameters.dbase.get<int>("upwindSOS"); 
  RealArray & timing = parameters.dbase.get<RealArray >("timing");

  printF("\n ======================= FORM MATRIX FOR PRESSURE EQUATION ======================\n");
  printF("   orderOfAccuracyInSpace=%d\n",orderOfAccuracyInSpace);
  printF(" ================================================================================\n");


  const int & numberOfComponentGrids = cg.numberOfComponentGrids(); 
  const int & numberOfDimensions     = cg.numberOfDimensions(); 

  // This is now done in setupGridFunctions: 

  // if( !parameters.dbase.has_key("pressureSolver") )
  // {
  //   Oges & pressureSolver = parameters.dbase.put<Oges>("pressureSolver");
  // }
  // Oges & pressureSolver = parameters.dbase.get<Oges>("pressureSolver");
  // pressureSolver.updateToMatchGrid( cg );                     

  // pressureSolver.setOgesParameters(pressureSolverParameters);

  Oges & pressureSolver = parameters.dbase.get<Oges>("pressureSolver");
   
  // int solverType=OgesParameters::yale; 

  // if( numberOfDimensions==3 )
  // {
  //    solverType=OgesParameters::PETSc;
  //    // solverType=OgesParameters::PETScNew; // parallel
  // }

  // pressureSolver.set(OgesParameters::THEsolverType,solverType); 

  // if( solverType==OgesParameters::PETSc )
  //  pressureSolver.set(OgesParameters::THEsolverMethod,OgesParameters::biConjugateGradientStabilized);

  // // pressureSolver.set(OgesParameters::THEparallelSolverMethod,OgesParameters::gmres);
  // if( numberOfDimensions==3 )
  // {
  //   Real tol=1.e-5;  // ***** FIX ME ********************************************************************
  //   int iluLevels=2; 
  //    pressureSolver.set(OgesParameters::THErelativeTolerance,max(tol,REAL_EPSILON*10.));
  //    pressureSolver.set(OgesParameters::THEmaximumNumberOfIterations,10000);
  //    if( iluLevels>=0 )
  //      pressureSolver.set(OgesParameters::THEnumberOfIncompleteLULevels,iluLevels);
  //  }


  CompositeGridOperators & op = (*cgop);
  op.setOrderOfAccuracy(orderOfAccuracyInSpace);

  bool usePredefined = false; // true; // false;

  if( usePredefined )
  {
    // *old way* that only works for simplified cases

    // ---- use Oges predefined equations  ----
  
    IntegerArray boundaryConditions(2,3,numberOfComponentGrids);
    RealArray bcData(2,2,3,numberOfComponentGrids);
    bcData=0.;

    // Range all; 

    // Assign boundary conditions for Oges
    for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    {
      MappedGrid & mg = cg[grid];
      ForBoundary(side,axis)
      {
         if( mg.boundaryCondition(side,axis)==SmParameters::dirichletBoundaryCondition ||
             mg.boundaryCondition(side,axis)==SmParameters::tractionBC )
         {
           boundaryConditions(side,axis,grid) = OgesParameters::dirichlet;
         }
         else if( mg.boundaryCondition(side,axis)==SmParameters::displacementBC )
         { 
           printF("presureMatrix: set Neuman BC for displacment BC : (grid,side,axis)=(%d,%d,%d)\n",grid,side,axis);
           boundaryConditions(side,axis,grid) = OgesParameters::neumann;
         }
         else if( mg.boundaryCondition(side,axis) <= 0 )
         { 
           boundaryConditions(side,axis,grid) = mg.boundaryCondition(side,axis);
         }       
         else if( mg.boundaryCondition(side,axis) > 0 )
         {
           printF("Cgsm::formPressureEquation:ERROR: unknown boundaryCondition=%d for (side,axis,grid)=(%d,%d,%d)\n", mg.boundaryCondition(side,axis),side,axis,grid);
           OV_ABORT("ERROR");
         }

      }

    }



    pressureSolver.setEquationAndBoundaryConditions( OgesParameters::laplaceEquation ,op,boundaryConditions,bcData );

  }
  else
  {
     // ---- NOTE: This was originally from CgWave implicit.bC ----

    // --------------------------------------------------------------------------------------
    // ---- Fill in the implicit matrix : more general equations allowed than predefined ----
    // --------------------------------------------------------------------------------------

    // // Here are the coefficients in the upwind dissipation operator (D+D-)^p 
    // // There are 4 cases depending on whether the full wider stencil is available
      
    // // fourth-order dissipation for 2nd-order scheme:
    // Real upwindCoeff4[4][5] = { 1.,-4.,6.,-4.,1.,
    //                             1.,-3.,3.,-1.,0.,   // extrap right-most point D-^3 u(2)
    //                             0.,-1.,3.,-3.,1.,   // extrap left -most point D+^3 u(-2)
    //                             0.,-1.,2.,-1.,0.
    //                           };
    
    // // sixth-order dissipation for 4th-order scheme
    // Real upwindCoeff6[4][7] = {1.,-6.,15.,-20.,15.,-6.,1.,
    //                            1.,-5.,10.,-10., 5.,-1.,0.,  // extrap right-most point D-^5 u(3)
    //                            0.,-1., 5.,-10.,10.,-5.,1.,  // extrap left -most point D+^5 u(-3)
    //                            0.,-1., 4., -6., 4.,-1.,0.
    //    
    //                           };
    // //  --- Coefficients in the sosup dissipation from Jordan Angel ---
    // // These must match the values in advWave.bf90                          
    // Real *upwindCoeff[4];
    // Real adSosup;
    // const int upwindHalfStencilWidth = orderOfAccuracy; 
    // if( orderOfAccuracy==2 )
    // {
    //   adSosup=-c*dt*1./8.;
    //   for( int m=0; m<4; m++ )
    //     upwindCoeff[m] =upwindCoeff4[m];
    // }
    // else if( orderOfAccuracy==4 )
    // {
    //   adSosup=c*dt*5./288.;
    //   for( int m=0; m<4; m++ )
    //     upwindCoeff[m] =upwindCoeff6[m];      
    // }
    // else if( orderOfAccuracy==6 )
    // {
    //   adSosup=-c*dt*31./8640.;
    //   // upwindDissCoeff=upwindDissCoeff8;
    // }
    // else
    // {
    //  OV_ABORT("ERROR orderOfAccuracy");
    // }
// 


    // ---- determine if the pressure equation is singular ----
    int & pressurePoissonIsSingular = parameters.dbase.get<int>("pressurePoissonIsSingular");
    pressurePoissonIsSingular = true;
    for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    {
      MappedGrid &mg = cg[grid];    
      ForBoundary(side,axis)
      {
        if( mg.boundaryCondition(side,axis)==SmParameters::dirichletBoundaryCondition ||
            mg.boundaryCondition(side,axis)==SmParameters::tractionBC )
        {
          pressurePoissonIsSingular=false;
          break;
        }
      }
    }
    if( pressurePoissonIsSingular )
    {
      printF("formPressureEquation: INFO: pressure equation is singular\n");
      // OV_ABORT("finish me");
    }

    const int cc=0; // component number

    Range all;
    int stencilWidth = orderOfAccuracyInSpace + 1;
    int numberOfGhostLines= orderOfAccuracyInSpace/2;  
    if( !pressurePoissonIsSingular && upwindSOS ) // we need space for an extra equation for singular (this ghost not needed)
      numberOfGhostLines++;

  
    // if( TRUE )
    //     numberOfGhostLines++; // *********************************************** TEST ***********************

    int extraEntries = 1;  // we add 1 extra entry for interpolation equations

    // if( addUpwinding )
    // {
    //   // -- Note: we do not always have to add extra entries for upwinding
    //   //          e.g. on Cartesian grids there are zeros in the existing stencil that could be used. 
    //   extraEntries = 2*numberOfDimensions; // for upwinding equations
    //   // stencilWidth += 2;
    //   numberOfGhostLines += 1;   // for extrapolate an extra ghost line when upwinding
    // }

    const int baseStencilSize = pow(stencilWidth,cg.numberOfDimensions());   // number of entries in default stencil 
    const int stencilSize=int( baseStencilSize + extraEntries );                      // add extra for interpolation and upwind equations

    const int numberOfComponentsForCoefficients=1;
    const int stencilDimension=stencilSize*SQR(numberOfComponentsForCoefficients);

    const int baseStencilDimension=baseStencilSize*SQR(numberOfComponentsForCoefficients);



    printF(">>>> formPressureEqn: GENERAL CASE stenciWidth=%d, stencilSize=%d, numberOfGhostLines=%d\n",stencilWidth,stencilSize,numberOfGhostLines);

    // Do we need to save the coefficient matrix ?? probbaly not
    if( !parameters.dbase.has_key("pressureCoeff") )
    {
      parameters.dbase.put<realCompositeGridFunction>("pressureCoeff");
    }
    realCompositeGridFunction & pressureCoeff = parameters.dbase.get<realCompositeGridFunction>("pressureCoeff"); 

    pressureCoeff.updateToMatchGrid(cg,stencilDimension,all,all,all); 
    // pressureCoeff.setIsACoefficientMatrix(true,baseStencilSize,numberOfGhostLines,numberOfComponentsForCoefficients);
    pressureCoeff.setIsACoefficientMatrix(true,stencilSize,numberOfGhostLines,numberOfComponentsForCoefficients);

    op.setStencilSize(stencilSize);
    op.setNumberOfComponentsForCoefficients(numberOfComponentsForCoefficients);
    pressureCoeff.setOperators(op);



    // Use these for indexing into coefficient matrices representing systems of equations
    // #define CE(c,e) (baseStencilSize*((c)+numberOfComponentsForCoefficients*(e)))
    #define M123(m1,m2,m3) (m1+halfWidth1+width*(m2+halfWidth2+width*(m3+halfWidth3)))
    // #define M123CE(m1,m2,m3,c,e) (M123(m1,m2,m3)+CE(c,e))    

    Index I1,I2,I3;
    Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
    Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
    Index Iev[3], &Ie1=Iev[0], &Ie2=Iev[1], &Ie3=Iev[2];
    int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];
    int m1,m2,m3; 

    for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    {
      MappedGrid &mg = cg[grid];
      OV_GET_SERIAL_ARRAY(int,mg.mask(),maskLocal);
      OV_GET_SERIAL_ARRAY(real,mg.inverseVertexDerivative(),RSXY);
      #define rsxy(i1,i2,i3,m,n) RSXY(i1,i2,i3,(m)+numberOfDimensions*(n))

      const bool isRectangular=mg.isRectangular();
      real dx[3]={1.,1.,1.};
      if( isRectangular )
        mg.getDeltaX(dx); 

      // dr12(kd) = 1./(2.*dr(kd))
      // dr22(kd) = 1./(dr(kd)**2)                  
      RealArray dr(3), dr12(3), dr22(3);
      for( int dir=0; dir<3; dir++) 
      { 
        dr(dir)  = mg.gridSpacing(dir); 
        dr12(dir)= 1./(2.*dr(dir)); 
        dr22(dir)= 1./(SQR(dr(dir)));
      }

      realMappedGridFunction & coeff = pressureCoeff[grid];
      MappedGridOperators & mgop = op[grid];

      OV_GET_SERIAL_ARRAY(real,coeff,coeffLocal);
      coeffLocal=0.; 

      // set up some variables we need to index into sparse coefficient matrices
      setupVariablesForSparseMatrix();


      // --- FILL INTERIOR EQUATIONS ----
      //     L = Laplacian 

      const int mDiag = M123(0,0,0);              // index of diagonal entry

      getIndex(mg.gridIndexRange(),I1,I2,I3);
      RealArray lapCoeff(M0,I1,I2,I3);
      mgop.assignCoefficients(MappedGridOperators::laplacianOperator,lapCoeff,I1,I2,I3,0,0); // 
        
      coeffLocal(M0,I1,I2,I3)  = lapCoeff;



      // --- FILL BOUNDARY CONDITIONS ----

      const int extrapOrder = orderOfAccuracy+1;

      const Real extrapCoeff3[] = {1.,-3.,3.,-1.};
      const Real extrapCoeff4[] = {1.,-4.,6.,-4.,1.};
      const Real extrapCoeff5[] = {1.,-5.,10.,-10.,5.,-1.};
      const Real *extrapCoeff;
      if( extrapOrder==3 )
        extrapCoeff = extrapCoeff3;
      else if( extrapOrder==4 )
        extrapCoeff = extrapCoeff4;
      else if( extrapOrder==5 )
        extrapCoeff = extrapCoeff5;
      else
       {
        printF("Cgsm::formPressureEquation : unexpected extrapOrder=%d\n",extrapOrder);
        OV_ABORT("ERROR");
       }

      const int e=0, c=0; // equation number and component number 
      ForBoundary(side,axis)
      {

        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);

        // Set the index-shift for this side
        is1=is2=is3=0;
        isv[axis]=1-2*side;   // +1 on left and -1 on right      

        if( mg.boundaryCondition(side,axis)==SmParameters::dirichletBoundaryCondition )
        {
          // ------------ FILL DIRICHLET BC for fake dirichlet condition ------------

          // -- set dirichlet on extended boundary ---
          // getBoundaryIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);
          //getBoundaryIndex(mg.dimension(),side,axis,Ig1,Ig2,Ig3);
          // Igv[axis]=mg.gridIndexRange(side,axis);

          getBoundaryIndex(mg.gridIndexRange(),side,axis,Ie1,Ie2,Ie3,numberOfGhostLines);  // extended boundary

          printF("+++++ Cgsm::formPressureEqn : FILL MATRIX BC FOR (grid,side,axis)=(%d,%d,%d) dirichletBoundaryCondition (extended boundary)\n",grid,side,axis);
          coeffLocal(    M,Ie1,Ie2,Ie3) = 0.0;  // zero out any existing equations
          coeffLocal(mDiag,Ie1,Ie2,Ie3) = 1.0;

          setClassify(0,Ie1,Ie2,Ie3, SparseRepForMGF::ghost1); 
          
          // FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) // loop over points on the boundary
          // {
              
          //   int i1m=i1-is1*ghost, i2m=i2-is2*ghost, i3m=i3-is3*ghost; //  ghost point is (i1m,i2m,i3m)
        
          //   // --- fill in the coefficients of the extrapolation formula ---
          //   for( int m=0; m<=extrapOrder; m++ )
          //   {
          //     coeffLocal(m,i1m,i2m,i3m) = extrapCoeff[m];
          //     int j1=i1m + m*is1, j2=i2m + m*is2, j3=i3m + m*is3;     // index of point "m" in extrap formula is shifted in the direction (is1,is2,is3)
          //     setEquationNumber(m, e,i1m,i2m,i3m,  cc,j1,j2,j3 );      // macro to set equationNumber
          //   }
        
          // } // end FOR_3D          

          // --- EXTRAPOLATE GHOST LINES ---
          adjustBoundaryIndexBounds( side,axis,Ibv );  // do not extrapolate on ends if adjacent sides are dirichlet
          for( int ghost=1; ghost<=numberOfGhostLines; ghost++ )
          {
            fillGhostExtrapolation(ghost);
          } // end for ghost

        }
        else if( mg.boundaryCondition(side,axis)==SmParameters::tractionBC )
        {
          // ------------ FILL TRACTION BC C ------------

          printF("+++++ Cgsm::formPressureEqn : FILL MATRIX BC FOR (grid,side,axis)=(%d,%d,%d) Traction\n",grid,side,axis);

          adjustBoundaryIndexBounds( side,axis,Ibv );

          // Traction BC is p = RHS
          coeffLocal(    M,Ib1,Ib2,Ib3) = 0.0;  // zero out any existing equations
          coeffLocal(mDiag,Ib1,Ib2,Ib3) = 1.0;

          // --- First Ghost is compatibility: ---
          // --- Apply the "interior" equation as the boundary condition:
          //          Delta( p ) = RHS   (centered on hte boundary point but placed in the matrcix at the ghost point )

          // Note: We cannot apply the equation next to a corner with another traction condition as the equation
          // would be duplicated
          //               |
          //               |
          //      traction |
          //               |
          //            X--+-------------
          //               |    traction
          //               X
          // 
          const int axisp1 = (axis +1) % numberOfDimensions;
          const int axisp2 = numberOfDimensions==2 ? axisp1 : (axis +2) % numberOfDimensions;
          const IntegerArray & gid = mg.gridIndexRange();

          int startGhost = orderOfAccuracyInSpace==2 ? 2 : 3;

          FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) // loop over points on the boundary 
          {
            const int i1m=i1-is1, i2m=i2-is2, i3m=i3-is3; //  ghost point is (i1m,i2m,i3m)

            // -- check if we are at a traction corner ----
            int iv[3] ={i1,i2,i3}; 
            bool tractionCorner = false;
            if(  ( iv[axisp1]== gid(0,axisp1) && mg.boundaryCondition(0,axisp1)==SmParameters::tractionBC ) ||
                 ( iv[axisp1]== gid(1,axisp1) && mg.boundaryCondition(1,axisp1)==SmParameters::tractionBC ) ||
                 ( iv[axisp2]== gid(0,axisp2) && mg.boundaryCondition(0,axisp2)==SmParameters::tractionBC ) ||
                 ( iv[axisp2]== gid(1,axisp2) && mg.boundaryCondition(1,axisp2)==SmParameters::tractionBC )
                 )
            {
              // we could leave the equation in the ghost for one side of the corner -- fix me
               tractionCorner = true;
               // printF("pressureMatrix:fillBC: traction corner found at (i1,i2,i3)=(%d,%d,%d), (side,axis,grid)=(%d,%d,%d)\n",i1,i2,i3,side,axis,grid);
            }

            if( !tractionCorner )
            {
              // CBC : Fill in equation
  
              // --- loop over the stencil coeff ----
              ForStencil(m1,m2,m3)
              {
                int m  = M123(m1,m2,m3);        // the single-component coeff-index
                // int mm = M123CE(m1,m2,m3,c,e);  // the system coeff-index (for systems of equations, we have a scalar eqn)
                int mm = m;                        // the system coeff-index 
  
                coeffLocal(mm,i1m,i2m,i3m) = lapCoeff(m,i1,i2,i3);
                
                // Specify that the above coeff value is the coefficient of component c at the grid point (j1,j2,j3).
                const int j1=i1+m1, j2=i2+m2, j3=i3+m3;   // the stencil is centred on the boundary pt (i1,i2,i3)
                setEquationNumber(mm, e,i1m,i2m,i3m,  c,j1,j2,j3 );  // macro to set equationNumber
              }           

              // Specify that this a "real" equation on the first ghost line: 
              // (A "real" equation has a possible non-zero right-hand-side)
              setClassify(e,i1m,i2m,i3m, SparseRepForMGF::ghost1); 

              if( orderOfAccuracyInSpace==4 )
              {
                // CBC: p_xxxx - p_yyyy = 0  (from Delta^2(p)=0 )

                // ***** FIX ME -- THIS ARRAY IS BUILT AT EACH POINT ***
                Range S(-2,2);
                RealArray mat(S,S);
                mat=0.;

                if( isRectangular )
                {
                  Real dxPow4 = pow(dx[0],4.), dyPow4 = pow(dx[1],4.);
                  mat( 0,-2,0) = (              -1./dyPow4   );
                  mat(-2, 0,0) = (   +1./dxPow4              );
                  mat( 0,-1,0) = (              +4./dyPow4   );
                  mat(-1, 0,0) = (   -4./dxPow4              );
                  mat( 0, 0,0) = (   +6./dxPow4 -6./dyPow4   );
                  mat(+1, 0,0) = (   -4./dxPow4              );
                  mat( 0,+1,0) = (              +4./dyPow4   );
                  mat(+2, 0,0) = (   +1./dxPow4              ); 
                  mat( 0,+2,0) = (              -1./dyPow4   ); 
                }
                else
                {  
                   // ------ curvilinear -----
                   //   Use
                   //     Delta^2 p = 
                   // u_xxxx + 2 *u_xxyy + u_yyyy 
                   // 



                  // printF("\n @@@@@@@@ pressure CBC: Delta^2(p) FINISH ME @@@@@@@@@@\n\n");


                  // Real dx0 = mg.gridSpacing(0), dx1=mg.gridSpacing(1); 

                  // Real dxPow4 = pow(dx0,4.), dyPow4 = pow(dx1,4.);
                  // mat( 0,-2,0) = (              -1./dyPow4   );
                  // mat(-2, 0,0) = (   +1./dxPow4              );
                  // mat( 0,-1,0) = (              +4./dyPow4   );
                  // mat(-1, 0,0) = (   -4./dxPow4              );
                  // mat( 0, 0,0) = (   +6./dxPow4 -6./dyPow4   );
                  // mat(+1, 0,0) = (   -4./dxPow4              );
                  // mat( 0,+1,0) = (              +4./dyPow4   );
                  // mat(+2, 0,0) = (   +1./dxPow4              ); 
                  // mat( 0,+2,0) = (              -1./dyPow4   );     

                  // ::display(mat,"D_xxxx - D_yyyy (old way)","%9.1f ");


                  // Assign mat(m1,m2,m3)with the Laplacian-squared coefficients 
                  // getLaplacianSquaredCoefficients(2); 
                  getLaplacianSquaredAdjustedCoefficients(DIM); 

                  // ::display(mat,"Dxxxx - Dyyyy (new curvilinear way)","%9.1f ");
                  // OV_ABORT("stop here for now");
              
                }

                if( numberOfDimensions==3  )
                {
                  OV_ABORT("pressure CBC: p_xxxx - p_yyyy finish me for curvilinear");
                }  

                const int j1m=i1-2*is1, j2m=i2-2*is2, j3m=i3-2*is3; //  2nd ghost
                // --- loop over the stencil coeff ----
                ForStencil(m1,m2,m3)
                {
                  int m  = M123(m1,m2,m3);        // the single-component coeff-index
                  int mm = m;                        // the system coeff-index 
    
                  coeffLocal(mm,j1m,j2m,j3m) = mat(m1,m2,m3); 
                  
                  // Specify that the above coeff value is the coefficient of component c at the grid point (j1,j2,j3).
                  const int j1=i1+m1, j2=i2+m2, j3=i3+m3;   // the stencil is centred on the boundary pt (i1,i2,i3)
                  setEquationNumber(mm, e,j1m,j2m,j3m,  c,j1,j2,j3 );  // macro to set equationNumber
                }           

                // Specify that this a "real" equation on the first ghost line: 
                // (A "real" equation has a possible non-zero right-hand-side)
                setClassify(e,j1m,j2m,j3m, SparseRepForMGF::ghost1);                 


                // // --- EXTRAPOLATE ANY ADDITIONAL GHOST LINES ---
                // for( int ghost=3; ghost<=numberOfGhostLines; ghost++ )
                // {
                //   fillGhostExtrapolation(ghost);
                // } // end for ghost

              }
              else if( orderOfAccuracyInSpace==2 )
              {
                 // // --- EXTRAPOLATE ADDITIONAL GHOST LINES ---
                 // for( int ghost=2; ghost<=numberOfGhostLines; ghost++ )
                 // {
                 //   fillGhostExtrapolation(ghost);
                 // } // end for ghost

              }


            }
            else 
            {
              // ----- TRACTION CORNER -----

              if( isRectangular )
              {
                // rectangular grid:
                // p.x = -2*mu*u_xx    x=0
                // p.y = -2*mu*v.yy    y=0 
                // *** FINISH ME ****

              }

              // --- extrapolate this point for now ----
              // --- fill in the coefficients of the extrapolation formula ---
              for( int m=0; m<=extrapOrder; m++ )
              {
                coeffLocal(m,i1m,i2m,i3m) = extrapCoeff[m];
                int j1=i1m + m*is1, j2=i2m + m*is2, j3=i3m + m*is3;     // index of point "m" in extrap formula is shifted in the direction (is1,is2,is3)
                setEquationNumber(m, e,i1m,i2m,i3m,  cc,j1,j2,j3 );      // macro to set equationNumber
              }  



            } // end traction corner
  
          } // end for 3d

          // --- EXTRAPOLATE ADDITIONAL GHOST LINES ---
          for( int ghost=startGhost; ghost<=numberOfGhostLines; ghost++ )
          {
            fillGhostExtrapolation(ghost);
          } // end for ghost          


        }        
        else if( mg.boundaryCondition(side,axis)==SmParameters::displacementBC )
        {
          // ------------- DISPLACEMENT BC ---------------
          // ------------  p.n = ...      ------------

          printF("+++++ Cgsm:formPressureEqn : FILL MATRIX BC FOR (grid,side,axis)=(%d,%d,%d) NEUMANN for displacementBC\n",grid,side,axis);
          adjustBoundaryIndexBounds( side,axis,Ibv );

          mg.update(MappedGrid::THEvertexBoundaryNormal);
          OV_GET_VERTEX_BOUNDARY_NORMAL(mg,side,axis,normal); 

          realSerialArray xCoeff(M0,Ib1,Ib2,Ib3), yCoeff(M0,Ib1,Ib2,Ib3), zCoeff; 
          mgop.assignCoefficients(MappedGridOperators::xDerivative ,xCoeff, Ib1,Ib2,Ib3,0,0);
          mgop.assignCoefficients(MappedGridOperators::yDerivative ,yCoeff, Ib1,Ib2,Ib3,0,0);
          if( numberOfDimensions==3 )
          {
            zCoeff.redim(M0,Ib1,Ib2,Ib3);
            mgop.assignCoefficients(MappedGridOperators::zDerivative ,zCoeff, Ib1,Ib2,Ib3,0,0);
          }

          int startGhost= orderOfAccuracyInSpace==2 ? 2 : 3; // used below to fix ghost 

          FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) // loop over points on the boundary
          {
              
            int i1m=i1-is1, i2m=i2-is2, i3m=i3-is3; //  ghost point is (i1m,i2m,i3m)

            // Specify that this a "real" equation on the first ghost line: 
            // (A "real" equation has a possible non-zero right-hand-side)
            setClassify(e,i1m,i2m,i3m, SparseRepForMGF::ghost1);              

            ForStencil(m1,m2,m3)
            {
              int m  = M123(m1,m2,m3);        // the single-component coeff-index
              
              coeffLocal(m,i1m,i2m,i3m) = normal(i1,i2,i3,0)*xCoeff(m,i1,i2,i3) + normal(i1,i2,i3,1)*yCoeff(m,i1,i2,i3);
              if( numberOfDimensions==3 )
                coeffLocal(m,i1m,i2m,i3m) += normal(i1,i2,i3,2)*zCoeff(m,i1,i2,i3);

              // Specify that the above coeff value is the coefficient of component c at the grid point (j1,j2,j3).
              int j1=i1+m1, j2=i2+m2, j3=i3+m3;                       // the stencil is centred on the boundary pt (i1,i2,i3)
              setEquationNumber(m, e,i1m,i2m,i3m,  cc,j1,j2,j3 );      // macro to set equationNumber
            }
          }

          if( orderOfAccuracyInSpace==4 )
          {
            // ---- CBC[2] : for ghost 2 ------
            // CBC: p_xxxx - p_yyyy = 0  (from Delta^2(p)=0 )
            Range S(-2,2);
            RealArray mat(S,S,S);
            mat=0.;

            if( isRectangular )
            {
              Real dxPow4 = pow(dx[0],4.), dyPow4 = pow(dx[1],4.);
              mat( 0,-2,0) = (              -1./dyPow4   );
              mat(-2, 0,0) = (   +1./dxPow4              );
              mat( 0,-1,0) = (              +4./dyPow4   );
              mat(-1, 0,0) = (   -4./dxPow4              );
              mat( 0, 0,0) = (   +6./dxPow4 -6./dyPow4   );
              mat(+1, 0,0) = (   -4./dxPow4              );
              mat( 0,+1,0) = (              +4./dyPow4   );
              mat(+2, 0,0) = (   +1./dxPow4              ); 
              mat( 0,+2,0) = (              -1./dyPow4   ); 
            }
            else
            {  
               // ------ curvilinear -----
               //   Use
               //     Delta^2 p = 
               // u_xxxx + 2 *u_xxyy + u_yyyy 
               // 

              // printF("\n @@@@@@@@ pressure CBC: Delta^2(p) DISPLACEMENT - FINISH ME @@@@@@@@@@\n\n");

              // //   ** USE DELTA APPROACH ******

              // Real dx0 = mg.gridSpacing(0), dx1=mg.gridSpacing(1); 

              // Real dxPow4 = pow(dx0,4.), dyPow4 = pow(dx1,4.);
              // mat( 0,-2,0) = (              -1./dyPow4   );
              // mat(-2, 0,0) = (   +1./dxPow4              );
              // mat( 0,-1,0) = (              +4./dyPow4   );
              // mat(-1, 0,0) = (   -4./dxPow4              );
              // mat( 0, 0,0) = (   +6./dxPow4 -6./dyPow4   );
              // mat(+1, 0,0) = (   -4./dxPow4              );
              // mat( 0,+1,0) = (              +4./dyPow4   );
              // mat(+2, 0,0) = (   +1./dxPow4              ); 
              // mat( 0,+2,0) = (              -1./dyPow4   );   



            }

            // Real dxPow4 = pow(dx[0],4.), dyPow4 = pow(dx[1],4.);
            // mat( 0,-2,0) = (              -1./dyPow4   );
            // mat(-2, 0,0) = (   +1./dxPow4              );
            // mat( 0,-1,0) = (              +4./dyPow4   );
            // mat(-1, 0,0) = (   -4./dxPow4              );
            // mat( 0, 0,0) = (   +6./dxPow4 -6./dyPow4   );
            // mat(+1, 0,0) = (   -4./dxPow4              );
            // mat( 0,+1,0) = (              +4./dyPow4   );
            // mat(+2, 0,0) = (   +1./dxPow4              ); 
            // mat( 0,+2,0) = (              -1./dyPow4   ); 

            if( numberOfDimensions==3  )
            {
              OV_ABORT("finish me");
            }  

            FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) // loop over points on the boundary
            {
              const int j1m=i1-2*is1, j2m=i2-2*is2, j3m=i3-2*is3; //  2nd ghost
              // --- loop over the stencil coeff ----
              ForStencil(m1,m2,m3)
              {
                int m  = M123(m1,m2,m3);        // the single-component coeff-index
                int mm = m;                        // the system coeff-index 

                if( !isRectangular )
                {
                  // Assign mat(m1,m2,m3)with the Laplacian-squared coefficients 
                  // getLaplacianSquaredCoefficients(2);
                  getLaplacianSquaredAdjustedCoefficients(DIM); 
                }
                coeffLocal(mm,j1m,j2m,j3m) = mat(m1,m2,m3); 
                
                // Specify that the above coeff value is the coefficient of component c at the grid point (j1,j2,j3).
                const int j1=i1+m1, j2=i2+m2, j3=i3+m3;   // the stencil is centred on the boundary pt (i1,i2,i3)
                setEquationNumber(mm, e,j1m,j2m,j3m,  c,j1,j2,j3 );  // macro to set equationNumber
              }           

              // Specify that this a "real" equation on the first ghost line: 
              // (A "real" equation has a possible non-zero right-hand-side)
              setClassify(e,j1m,j2m,j3m, SparseRepForMGF::ghost1);  

            } // end FOR_3D

          } // end if order=4


          // fill any extra ghost with extrapolation
          for( int ghost=startGhost; ghost<=numberOfGhostLines; ghost++ )
          {
            fillGhostExtrapolation(ghost);
          } // end for ghost

        }
        else if(  mg.boundaryCondition(side,axis)> 0 )
        {
          printF("Cgsm::formPressureEquation fill pressure matrix:ERROR: unknown boundaryCondition=%d \n",mg.boundaryCondition(side,axis));
          OV_ABORT("error");

        }
      }

          // // Evaluate the (single component) Laplace operator for points on the boundary
          // realSerialArray xxCoeff(M0,Ib1,Ib2,Ib3), yyCoeff(M0,Ib1,Ib2,Ib3), xCoeff(M0,Ib1,Ib2,Ib3), yCoeff(M0,Ib1,Ib2,Ib3), idCoeff(M0,Ib1,Ib2,Ib3);
          // mgop.assignCoefficients(MappedGridOperators::xxDerivative,xxCoeff,Ib1,Ib2,Ib3,0,0); //
          // mgop.assignCoefficients(MappedGridOperators::yyDerivative,yyCoeff,Ib1,Ib2,Ib3,0,0); //
          // mgop.assignCoefficients(MappedGridOperators::xDerivative ,xCoeff, Ib1,Ib2,Ib3,0,0);
          // mgop.assignCoefficients(MappedGridOperators::yDerivative ,yCoeff, Ib1,Ib2,Ib3,0,0);
          // mgop.assignCoefficients(MappedGridOperators::identityOperator,idCoeff,Ib1,Ib2,Ib3,0,0);

      // if( addUpwinding && debug>3  )
      // {
      //   // ::display(pressureCoeff[grid],sPrintF("implicit time-stepping matrix on grid=%d",grid));
      //   displayCoeff(pressureCoeff[grid],sPrintF("implicit time-stepping matrix on grid=%d",grid));
      //   // OV_ABORT("stop here for now");
      // }

    }

    BoundaryConditionParameters bcParams;
    bcParams.orderOfExtrapolation = orderOfAccuracyInSpace + 1;

    bcParams.setCornerBoundaryCondition(BoundaryConditionParameters::extrapolateCorner);
    pressureCoeff.finishBoundaryConditions(bcParams); 

    pressureSolver.setCoefficientArray( pressureCoeff );   // supply coefficients to Oges   

    // if the problem is singular Oges will add an extra constraint equation to make the system nonsingular
    if( pressurePoissonIsSingular )
      pressureSolver.set(OgesParameters::THEcompatibilityConstraint,true);      
  

  }
  // RealArray & timing = parameters.dbase.get<RealArray >("timing");
  timing(parameters.dbase.get<int>("timeForPressureSolve"))+=getCPU()-cpu0;

 
  return 0;
}
