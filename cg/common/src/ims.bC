#include "DomainSolver.h"
#include "CompositeGridOperators.h"
#include "GridCollectionOperators.h"
#include "interpPoints.h"
#include "SparseRep.h"
#include "ExposedPoints.h"
#include "Ogen.h"
#include "App.h"
#include "ParallelUtility.h"
#include "Oges.h"
#include "OgesParameters.h"
#include "AdamsPCData.h"
#include "gridFunctionNorms.h"
#include "CyclicIndex.h"

//==================================================================
//            Implicit Multi-step Method
//            --------------------------
//
//==================================================================

static bool useNewExposedPoints=true;

// here are some bpp macros that are used for the explicit and implicit predictor-corrector methods
#Include pcMacros.h

// This next declaration also appears in advance.bC
#define updateOpt EXTERN_C_NAME(updateopt)
#define updateOptNew EXTERN_C_NAME(updateoptnew)
extern "C"
{
   void updateOpt(const int &nd1a,const int &nd1b,const int &nd2a,const int &nd2b,
                  const int &nd3a,const int &nd3b,const int &nd4a,const int &nd4b, \
                  const int &mask,real &u1, const real&u2,  
                  const real&ut1, const real&ut2, const real&ut3, const real&ut4, 
                  const int &ipar, const real& rpar, int & ierr );

   void updateOptNew(const int &nd1a,const int &nd1b,const int &nd2a,const int &nd2b,
                     const int &nd3a,const int &nd3b,const int &nd4a,const int &nd4b, \
                     const int &mask,real & uNew,
                     const real&u1, const real&u2, const real&u3, const real&u4, const real&u5,
                     const real&u6, const real&u7, const real&u8, const real&u9, const real&u10,
                     const int &ipar, const real& rpar, int & ierr );
}


#define ForBoundary(side,axis)   for( axis=0; axis<mg.numberOfDimensions(); axis++ ) \
                                 for( side=0; side<=1; side++ )

//\begin{>>CompositeGridSolverInclude.tex}{\subsection{buildImplicitSolvers}} 
void DomainSolver::
buildImplicitSolvers(CompositeGrid & cg)
// ==========================================================================================
// /Description:
//     Determine the number and type of implicit solvers needed. Depending on the boundary
//
//  1) If the equations are decoupled and the boundary conditions for all components are 
//     the same then we can form one scalar implicit system.
//  2) If the equations are decoupled and the boundary conditions are not the same but 
//     decoupled then we can solve separate scalar implicit systems.
//  3) If the boundary conditions or equations are coupled then we solve a implicit system.  
//
//\end{CompositeGridSolverInclude.tex}  
// ==========================================================================================
{
  printF("DomainSolver::buildImplicitSolvers:ERROR: base class function called! This function should\n"
         "              be re-written by a derived class!\n");
  Overture::abort("error");

}


//\begin{>>CompositeGridSolverInclude.tex}{\subsection{implicitSolve}} 
void DomainSolver::
implicitSolve(const real & dt0,
              GridFunction & cgf1,
              GridFunction & cgf0)
// ==========================================================================================
// /Description:
//    The implicit method can be optionally used on only some grids. To implement this
//   approach we simply create a sparse matrix that is just the identity matrix on grids that
// are advanced explicitly but equal to the standard implicit matrix on grids that are advance
// implicitly:
// \begin{verbatim}
//         I - \nu \alpha \dt \Delta      on implicit grids
//         I                              on explicit grids
// \end{verbatim}
// If the form of the boundary conditions for the different components of $\uv$ are the same
// then we can build a single scalar matrix that can be used to advance each component, one after
// the other. If the boundary conditions are not of the same form then we build a matrix for
// a system of equations for the velocity components $(u,v,w)$.
//
// /dt0 (input) : time step used to build the implicit matrix.
// /cgf1 (input/output) : On input holds the right-hand-side for the implicit equations; on output
//    holds the solution.
// /cgf0 (input) : current best approximation to the solution. Used as initial guess for iterative
//   solvers and used for linearization.
//\end{CompositeGridSolverInclude.tex}  
// ==========================================================================================
{
  
  printF("DomainSolver::implicitSolve:ERROR: base class function called! This function should\n"
         "              be re-written by a derived class!\n");
  OV_ABORT("error");

}

// ===========================================================================================
//      *** Time-step update macro ***
// 
//  IMEX-CN
//    u1 <- u0 + AB1*UA0 + AB2*UB0 [ + DTI*UTIMPLICIT ]  (add last terms for implicit grids)
//
//  IMEX-BDF2
//    u1 = (4/3)*uCur + (-1/3)*uOld + (4/3)*dt*utCur + (-2/3)*dt*utOld + (2/3)*dt*utImplicit
//
// ===========================================================================================
#beginMacro timeStepUpdateMacro( AB1,AB2,DTI, UA0,UB0,UTIMPLICIT )

 OV_GET_SERIAL_ARRAY(real,gf[mNew].u[grid],u1);
 OV_GET_SERIAL_ARRAY(real,gf[mCur].u[grid],u0);
 OV_GET_SERIAL_ARRAY(real,ua[grid],ua0);
 OV_GET_SERIAL_ARRAY(real,ub[grid],ub0);
 OV_GET_SERIAL_ARRAY(real,uti[grid],utImplicit);
 OV_GET_SERIAL_ARRAY(int,gf[mNew].cg[grid].mask(),mask1);


// #ifdef USE_PPP
//   RealArray u1;  getLocalArrayWithGhostBoundaries(gf[mNew].u[grid],u1);
//   RealArray u0;  getLocalArrayWithGhostBoundaries(gf[mCur].u[grid],u0);
//   RealArray ua0; getLocalArrayWithGhostBoundaries(ua[grid],ua0);
//   RealArray ub0; getLocalArrayWithGhostBoundaries(ub[grid],ub0);
//   RealArray utImplicit; getLocalArrayWithGhostBoundaries(uti[grid],utImplicit);
//   const intSerialArray & mask1 = gf[mNew].cg[grid].mask().getLocalArray();
// #else
//   RealDistributedArray & u1 = gf[mNew].u[grid];
//   RealDistributedArray & u0 = gf[mCur].u[grid];
//   RealDistributedArray & ua0 = ua[grid];
//   RealDistributedArray & ub0 = ub[grid];
//   RealDistributedArray & utImplicit = uti[grid];
//   const intSerialArray & mask1 = gf[mNew].cg[grid].mask(); 
// #endif

  getIndex(gf[mNew].cg[grid].extendedIndexRange(),I1,I2,I3);

  int n1a,n1b,n2a,n2b,n3a,n3b;
  bool ok = ParallelUtility::getLocalArrayBounds(gf[mCur].u[grid],u0,I1,I2,I3,n1a,n1b,n2a,n2b,n3a,n3b);
  if( !ok ) continue;
          
  // const intArray & mask1 = gf[mNew].cg[grid].mask();

  int ierr=0;
  const int maskOption=0; // assign pts where mask>0
int ipar[]={0,maskOption,n1a,n1b,n2a,n2b,n3a,n3b,N.getBase(),N.getBound(),0}; //
  real rpar[15]={0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.};
  real *ut1p, *ut2p, *ut3p, *ut4p;
          
  if( implicitMethod==Parameters::crankNicolson )
  {
    // --- IMEX: AB2+CN ---
    if( parameters.getGridIsImplicit(grid) )
      ipar[0]=3;  // add three extra "ut" terms if grid is advanced implicitly
    else    
      ipar[0]=2;  // add two extra "ut" terms

    rpar[0]=AB1; rpar[1]=AB2; rpar[2]=DTI;
    ut1p=UA0.getDataPointer();
    ut2p=UB0.getDataPointer();
    ut3p=UTIMPLICIT.getDataPointer();
    ut4p=ut3p;

    updateOpt(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
              u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
              *mask1.getDataPointer(),  
              *u0.getDataPointer(),*u1.getDataPointer(), 
              *ut1p, *ut2p, *ut3p, *ut4p, 
              ipar[0], rpar[0], ierr );
  }
  else if( implicitMethod==Parameters::implicitExplicitMultistep )
  {
    // --------------
    // ---- IMEX ----
    // --------------

    assert( parameters.getGridIsImplicit(grid) );  // fix me when some grids are explicit

    if( orderOfTimeAccuracy==2 )
    {
      // --- 2nd-order IMEX-BDF ----

      OV_GET_SERIAL_ARRAY(real,gf[mOld].u[grid],uOld);


      // // **fix me for variable dt**
      // if( fabs(dt0/dtb-1.) > 1.e-12 )
      // {
      //   printF("IMEX-BDF WARNING, dt has changed but formula assume constant dt, dt/dtOld=%8.2e\n",dt0/dtb);
      // }


      if( correction==0 )
      {
        if( debug() & 4 )
          printF("IMEX BDF2 updateOptNew predictor mNew=%i mCur=%i mOld=%i...\n",mNew,mCur,mOld);

        // --- PREDICTOR   (last term is already in the matrix)
        //    u1 = (4/3)*uCur + (-1/3)*uOld + (4/3)*dt*utCur + (-2/3)*dt*utOld  [ + (2/3)*dt*utImplicit ]

        // BDF weights for variable time-step
        // **FINISH ME***
        // -- ISSUES:
        // -->   If dt changes then matrix coefficient will also change (ok for moving grids, sibnce matrix changes evry step)
        // --> for non-moving grids we could alter BDF a bit to use (2/3)*dt*f_I^{n+1} + gamma*dt f_I^n 
/* ---
   const real dtRatio = dtb/dt0;
   real alpha = -1./(dtRatio*(2.+dtRatio));  // -1/3 if dtRatio=1
   real beta = (1.+dtRatio)/(2.+dtRatio);     // 2/3 if dtRatio=1
   //const real c1=4./3., c2=-1./3, c3=(4./3.)*dt0, c4=-(2./3.)*dt0;
   real c1 = 1.-alpha, c2=alpha, c3=2.*beta*dt0, c4=-beta*dt0;
   --- */      

        real *puNew, *pu1, *pu2, *pu3, *pu4, *pu5;

        
        if( variableDt )
        {
          // *new way* Jan 9, 2019
          // ----- MODIFIED IMEX PREDICTOR Second-order variable dt (const b0, one extra level)------

          printF("PPPPPPPPPPPPPPPPPPP VARIABLE DT IMEX-BDF22 PREDICTOR t=%9.3e, [dt0,dt1,dt2]=[%9.3e,%9.3e,%9.3e] \n",t0,dt0,dt1,dt2);
          

          real b0= 2./3.;
          real b1= 1./3.*(2.*dt0+2.*dt1)/dt1;
          real b2=-2./3.*dt0/dt1;

          real a1= 1./3.*(-3.*dt1*dt1+(-2.*dt0-3.*dt2)*dt1+dt0*(dt0-dt2))/(dt1+dt2)/dt1;
          real a2=-1./3.*(dt0-dt1-dt2)*dt0/dt1/dt2;
          real a3= 1./3.*dt0*(dt0-dt1)/dt2/(dt1+dt2);

          printF(" a1=%g (-4/3) a2=%g (1/3) a3=%g (0) b0=%g (2/3) b1=%g (4/3) b2=%g (-2/3)\n",a1,a2,a3,b0,b1,b2);
          

          // ----- MODIFIED Second-order constant dt------
          // b0=2/3
          // b1=4/3
          // b2=-2/3
          // a1=-4/3
          // a2=1/3
          // a3=0

          assert( numberOfGridFunctions>= 4 );  // *check me*

          int mu;
          mu = (mCur + 2 + numberOfGridFunctions) % numberOfGridFunctions;
          OV_GET_SERIAL_ARRAY(real,gf[mu].u[grid],uOld2);  // u(t-2*dt)          

          puNew=u1.getDataPointer();    // uNew
          pu1  =u0.getDataPointer();    // uCur
          pu2  =uOld.getDataPointer();  // uOld
          pu3 = uOld2.getDataPointer(); // u(t-2*dt) 
          pu4  =UA0.getDataPointer();   // fCur
          pu5  =UB0.getDataPointer();   // fOld
          
          rpar[0]=-a1;
          rpar[1]=-a2;
          rpar[2]=-a3;
          rpar[3]=b1*dt0;
          rpar[4]=b2*dt0;

          int option=5;  // 5 terms on the RHS
          ipar[0]=option;
  
        }
        else
        {
          // *old way* 
          // This assumes a constant dt: 
          const real c1=4./3., c2=-1./3, c3=(4./3.)*dt0, c4=-(2./3.)*dt0;

          rpar[0]=c1;
          rpar[1]=c2;
          rpar[2]=c3;
          rpar[3]=c4;

          int option=4;  // 4 terms on the RHS
          ipar[0]=option;

          puNew=u1.getDataPointer();    // uNew
          pu1  =u0.getDataPointer();    // uCur
          pu2  =uOld.getDataPointer();  // uOld
          pu3  =UA0.getDataPointer();   // fCur
          pu4  =UB0.getDataPointer();   // fOld
          pu5 = pu4;                    // not used

        }
        

        updateOptNew(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
                     u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
                     *mask1.getDataPointer(),  
                     *puNew,
                     *pu1,*pu2,*pu3,*pu4,*pu5, *pu2,*pu2,*pu2,*pu2,*pu2, // only first 4 or 5 arguments are used
                     ipar[0], rpar[0], ierr );
        
      }
      else
      {
        if( debug() & 4 )
          printF("IMEX BDF2 updateOptNew corrector mNew=%i mCur=%i mOld=%i...\n",mNew,mCur,mOld);

        // ---- CORRECTOR   (last term is already in the matrix)
        // u1 = (4/3)*uCur + (-1/3)*uOld + (2/3)*dt*utNew   [ + (2/3)*dt*utImplicit ] 

        real *puNew, *pu1, *pu2, *pu3, *pu4;


        if( variableDt )
        {
          // NOTE: we only need the variable dt code if dt0 != dt1 (doesn't matter id dt2 is different)

          // *new way* Jan 9, 2019
          // ----- MODIFIED IMEX PREDICTOR Second-order variable dt (const b0, one extra level)------

          printF("CCCCCCCCCCCCCCCCCCC VARIABLE DT IMEX-BDF22 CORRECTOR t=%9.3e, [dt0,dt1,dt2]=[%9.3e,%9.3e,%9.3e] \n",t0,dt0,dt1,dt2);
          

          real b0= 2./3.;
          // real b1= 1./3.*(2.*dt0+2.*dt1)/dt1;
          // real b2=-2./3.*dt0/dt1;

          real a1= 1./3.*(-3.*dt1*dt1+(-2.*dt0-3.*dt2)*dt1+dt0*(dt0-dt2))/(dt1+dt2)/dt1;
          real a2=-1./3.*(dt0-dt1-dt2)*dt0/dt1/dt2;
          real a3= 1./3.*dt0*(dt0-dt1)/dt2/(dt1+dt2);

          printF(" a1=%g (-4/3) a2=%g (1/3) a3=%g (0) b0=%g\n",a1,a2,a3,b0);
          

          // ----- MODIFIED Second-order constant dt------
          // b0=2/3
          // b1=4/3
          // b2=-2/3
          // a1=-4/3
          // a2=1/3
          // a3=0

          assert( numberOfGridFunctions>= 4 );  // *check me*

          int mu;
          mu = (mCur + 2 + numberOfGridFunctions) % numberOfGridFunctions;
          OV_GET_SERIAL_ARRAY(real,gf[mu].u[grid],uOld2);  // u(t-2*dt)          

          puNew=u1.getDataPointer();    // uNew
          pu1  =u0.getDataPointer();    // uCur
          pu2  =uOld.getDataPointer();  // uOld
          pu3 = uOld2.getDataPointer(); // u(t-2*dt) 
          pu4  =UA0.getDataPointer();   // fCur
          
          rpar[0]=-a1;
          rpar[1]=-a2;
          rpar[2]=-a3;
          rpar[3]=b0*dt0;

          int option=4;  // 4 terms on the RHS
          ipar[0]=option;
  
        }
        else
        {
          // *old way* 

          // This assumes a constant dt: 
          const real c1=4./3., c2=-1./3, c3=(2./3.)*dt0;  

          rpar[0]=c1;
          rpar[1]=c2;
          rpar[2]=c3;

          int option=3;  // 3 terms on the RHS
          ipar[0]=option;

          puNew=u1.getDataPointer();    // uNew
          pu1  =u0.getDataPointer();    // uCur
          pu2  =uOld.getDataPointer();  // uOld
          pu3  =UA0.getDataPointer();   // fNew
          pu4  = pu3;                   // not used 
          // pu3  = fn[naba][grid].getDataPointer(); // UA0.getDataPointer();   // fNew

        }
        
        updateOptNew(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
                     u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
                     *mask1.getDataPointer(),  
                     *puNew,
                     *pu1,*pu2,*pu3,*pu4, *pu1,*pu1,*pu1,*pu1,*pu1,*pu1, // only first 3 arguments are used
                     ipar[0], rpar[0], ierr );

      }
      


    }
    else if( orderOfTimeAccuracy==4 )
    {
      // -----------------------------
      // ---- 4th-order IMEX-BDF -----
      // -----------------------------

      OV_GET_SERIAL_ARRAY(real,gf[mOld].u[grid],uOld); // u(t-dt)
      
      int mu;
      mu = (mCur + 2 + numberOfGridFunctions) % numberOfGridFunctions;
      int muOld2=mu;
      OV_GET_SERIAL_ARRAY(real,gf[mu].u[grid],uOld2);  // u(t-2*dt)

      mu = (mCur + 3 + numberOfGridFunctions) % numberOfGridFunctions;
      int muOld3=mu;
      OV_GET_SERIAL_ARRAY(real,gf[mu].u[grid],uOld3); // u(t-3*dt)


      // **fix me for variable dt**
      if( fabs(dt0/dtb-1.) > 1.e-12 )
      {
        printF("IMEX-BDF4 WARNING, dt has changed but formula assume constant dt, dt/dtOld=%8.2e\n",dt0/dtb);
      }


      if( correction==0 )
      {
        if( debug() & 4 )
          printF("IMEX BDF4 updateOptNew predictor mNew=%i mCur=%i mOld=%i, "
                 "numberOfGridFunctions=%i numberOfTimeDerivativeLevels=%i\n",
                 mNew,mCur,mOld,numberOfGridFunctions,numberOfTimeDerivativeLevels);

        int nfeCur, nfeOld, nfeOld2, nfeOld3;
        int mf;
        mf = (nab0 + 0 + numberOfTimeDerivativeLevels ) % numberOfTimeDerivativeLevels; 
        nfeCur=mf;
        OV_GET_SERIAL_ARRAY(real,fn[mf][grid],feCur);  // F_E(t)
        mf = (nab0 + 1 + numberOfTimeDerivativeLevels ) % numberOfTimeDerivativeLevels;
        nfeOld=mf;
        OV_GET_SERIAL_ARRAY(real,fn[mf][grid],feOld);  // F_E(t-dt)
        mf = (nab0 + 2 + numberOfTimeDerivativeLevels ) % numberOfTimeDerivativeLevels;
        nfeOld2=mf;
        OV_GET_SERIAL_ARRAY(real,fn[mf][grid],feOld2);  // F_E(t-2*dt)
        mf = (nab0 + 3 + numberOfTimeDerivativeLevels ) % numberOfTimeDerivativeLevels;
        nfeOld3=mf;
        OV_GET_SERIAL_ARRAY(real,fn[mf][grid],feOld3);  // F_E(t-3*dt)
      
        if( debug() & 4 )
        {
          fPrintF(debugFile,"\n *********************** IMEX BDF PREDICTOR t=%9.3e *******************\n",gf[mCur].t);
          ::display(u0,"u0=uCur",debugFile,"%6.3f ");
          ::display(uOld,"uOld",debugFile,"%6.3f ");
          ::display(uOld2,"uOld2",debugFile,"%6.3f ");
          ::display(uOld3,"uOld3",debugFile,"%6.3f ");

          ::display(feCur,sPrintF("feCur fn[nf=%i]",nfeCur),debugFile,"%6.3f ");
          ::display(feOld,sPrintF("feOld fn[nf=%i]",nfeOld),debugFile,"%6.3f ");
          ::display(feOld2,sPrintF("feOld2 fn[nf=%i]",nfeOld2),debugFile,"%6.3f ");
          ::display(feOld3,sPrintF("feOld3 fn[nf=%i]",nfeOld3),debugFile,"%6.3f ");
        }
        

        if( predictorOrder==4 )
        {
          // --- FOURTH-ORDER PREDICTOR   (last term is already in the matrix)
          // (25/12)*u(n+1) = 4*U(n) -3*u(n-1) + (4/3)*u(n-2) - (1/4)*u(n-3) +
          //                  dt*( 4*fe(n) - 6*fe(n-1) + 4*fe(n-2) - fe(n-3) [+ fI(n+1)] )

          if( t0 <= 10.*dt0 )
            printF(" %%%%%% IMEX: Fourth-order predictor %%%%%%%\n");

          // This assumes a constant dt: 
          const real c0=25./12., c1=4./c0, c2=-3./c0, c3=(4./3.)/c0, c4=-(1./4.)/c0;
          const real c5=(4./c0)*dt0, c6=(-6./c0)*dt0, c7 = (4./c0)*dt0, c8=(-1./c0)*dt0;

          rpar[0]=c1;
          rpar[1]=c2;
          rpar[2]=c3;
          rpar[3]=c4;
          rpar[4]=c5;
          rpar[5]=c6;
          rpar[6]=c7;
          rpar[7]=c8;

          int option=8;  // option = number of terms on the RHS
          ipar[0]=option;
        }
        else if( predictorOrder==3 )
        {
          // --- THIRD-ORDER PREDICTOR   (last term is already in the matrix)
          // This modified version has the same implicit matrix as the fourth-order scheme

          if( t0 <= 10.*dt0 )
            printF(" PPPPPPPP IMEX: Third-order predictor PPPPPPP\n");
          
          if( variableDt )
          {
            // *new way* Jan 9, 2019
            // ----- MODIFIED IMEX PREDICTOR Second-order variable dt (const b0, one extra level)------
            if( true || t0 <= 10.*dt0 )
              printF("PPPPPPPPPPPPPPPPPPP VARIABLE DT MODIFIED THIRD-ORDER PREDICTOR, b0=12/25, t=%9.3e, "
                   "[dt0,dt1,dt2,dt3,dt4]=[%9.3e,%9.3e,%9.3e,%9.3e] \n",t0,dt0,dt1,dt2,dt3,dt4);
          
            // 
            // ----- MODIFIED Third-order variable dt with constant b0=12/25 and one extra level------
            real dt0p2=dt0*dt0, dt0p3=dt0*dt0p2, dt1p2=dt1*dt1, dt1p3=dt1*dt1p2, dt2p2=dt2*dt2;
            real b0,b1,b2,b3, a1,a2,a3,a4;
            
            b0=12./25.;
            b1=12./25.*(dt0+dt1)*(dt0+dt1+dt2)/(dt1+dt2)/dt1;
            b2=-12./25.*(dt0+dt1+dt2)*dt0/dt2/dt1;
            b3=12./25.*dt0*(dt0+dt1)/dt2/(dt1+dt2);
            a1=1./25.*(-25*dt1p3+(-39*dt0-50*dt2-25*dt3)*dt1p2+(-3*dt0p2+(-52*dt2-26*dt3)*dt0-25*dt2*(dt3+dt2))*dt1
               +11*dt0p3+(-2*dt2-dt3)*dt0p2-13*dt2*(dt3+dt2)*dt0)/(dt3+dt1+dt2)/(dt1+dt2)/dt1;
            a2=-11./25.*(-13./11.*dt2p2+(-2./11.*dt0-26./11.*dt1-13./11.*dt3)*dt2+dt0p2+(-2./11.*dt1-1./11.*dt3)*dt0
                -13./11.*dt1*(dt1+dt3))*dt0/dt1/dt2/(dt3+dt2);
            a3=11./25.*(dt0p2+(-2./11.*dt1-1./11.*dt2-1./11.*dt3)*dt0-13./11.*dt1*(dt3+dt1+dt2))*dt0/(dt1+dt2)/dt2/dt3;
            a4=-11./25.*(dt0p2+(-2./11.*dt1-1./11.*dt2)*dt0-13./11.*(dt1+dt2)*dt1)*dt0/dt3/(dt3+dt2)/(dt3+dt1+dt2);
            
            printF(" a1/(-48/25)=%g a2/(36/25)=%g a3/(-16/25)=%g a4/(3/25)=%g  b0/(12/25)=%g b1/(36/25)=%g b2/(-36/25)=%g b3/(12/25)=%g \n",
                   a1/(-48./25),a2/(36./25),a3/(-16./25),a4/(3./25), b0/(12./25),b1/(36./25),b2/(-36./25),b3/(12./25) );

            // ----- MODIFIED Third-order modified constant dt------
            // b0=12/25, b1=36/25, b2=-36/25, b3=12/25,  a1=-48/25, a2=36/25, a3=-16/25, a4=3/25

            rpar[0]=-a1;
            rpar[1]=-a2;
            rpar[2]=-a3;
            rpar[3]=-a4;
            rpar[4]=b1*dt0;
            rpar[5]=b2*dt0;
            rpar[6]=b3*dt0;
            // rpar[7]=b4*dt0;

            int option=7;  // option = number of terms on the RHS
            ipar[0]=option;
          }
          else
          {
            // This assumes a constant dt: 
            const real a1=-48./25., a2=36./25., a3=-16./25., a4= 3./25;         // same as 4th order scheme above
            const real b0 =12./25., b1=36./25., b2=-36./25., b3=12./25, b4=0.;

            rpar[0]=-a1;
            rpar[1]=-a2;
            rpar[2]=-a3;
            rpar[3]=-a4;
            rpar[4]=b1*dt0;
            rpar[5]=b2*dt0;
            rpar[6]=b3*dt0;
            // rpar[7]=b4*dt0;

            int option=7;  // option = number of terms on the RHS
            ipar[0]=option;
          }
        
        }
        else
        {
          OV_ABORT("IMEX:ERROR: unexpected orderOfPredictorCorrector");
        }
        
        real *puNew, *pu1, *pu2, *pu3, *pu4, *pu5, *pu6, *pu7, *pu8;

        puNew=u1.getDataPointer();    // uNew
        pu1  =u0.getDataPointer();    // uCur
        pu2  =uOld.getDataPointer();  // u(t-dt)
        pu3  =uOld2.getDataPointer(); // u(t-2*dt)
        pu4  =uOld3.getDataPointer(); // u(t-3*dt)

        pu5  =feCur.getDataPointer();  // fe(t)
        pu6  =feOld.getDataPointer();  // fe(t-dt)
        pu7  =feOld2.getDataPointer(); // fe(t-2*dt)
        pu8  =feOld3.getDataPointer(); // fe(t-3*dt)

        updateOptNew(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
                     u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
                     *mask1.getDataPointer(),  
                     *puNew,
                     *pu1,*pu2,*pu3,*pu4, *pu5,*pu6,*pu7,*pu8, *pu8,*pu8, // only first 7 or 8 arguments are used
                     ipar[0], rpar[0], ierr );

        if( false )
        {
          // -- initial testing:
          printF("\n___ IMEX-BDF4 : predictor after updateOptNew:\n");
          
          OGFunction & e = *(parameters.dbase.get<OGFunction* >("exactSolution"));
          const int & uc = parameters.dbase.get<int >("uc");
          int i1=1,i2=1,i3=0;
          real x=0., y=0., z=0.;
          real ue[5], uet[5];
          for( int k=0; k<5; k++ ){ ue[k]=e(x,y,x,uc,t0-k*dt0); uet[k]=e.t(x,y,x,uc,t0-k*dt0); }  // 
          real ueNew = e(x,y,x,uc,t0+dt0);
          
          real uBDF = (12./25)*( 4.*ue[0]-3.*ue[1]+(4./3.)*ue[2]-(1./4.)*ue[3] )
            +(12./25.)*dt*( 4.*uet[0]-6.*uet[1]+4.*uet[2]-1.*uet[3]);
          
          real *puv[4] ={pu1,pu2,pu3,pu4};
          for( int k=0; k<4; k++ )
          {
            realArray &ugf = gf[mgfi[-k]].u[grid];

            real uk = ugf(i1,i2,i3,uc);
            printF(" t=%9.2e u =%12.5e ue =%12.5e err=%9.2e\n",t0-k*dt0,uk,ue[k],uk-ue[k]);

            real utk = fn[nfni[-k]][grid](i1,i2,i3,uc);
            printF(" t=%9.2e ut=%12.5e uet=%12.5e err=%9.2e\n",t0-k*dt0,utk,uet[k],utk-uet[k]);

          }
          

          printF(" uNew=%12.5e ue=%12.5e err=%9.2e\n",u1(i1,i2,i3,uc),ueNew,u1(i1,i2,i3,uc)-ueNew);
          printF(" uBDF=%12.5e ue=%12.5e err=%9.2e\n",uBDF,ueNew,uBDF-ueNew);

        }
        
      }
      else
      {
        // -------------------- FOURTH-ORDER CORRECTOR -----------------------

        if( debug() & 4 )
          printF("IMEX BDF4 updateOptNew corrector mNew=%i mCur=%i mOld=%i...\n",mNew,mCur,mOld);

        int mf;
        mf = (nab3 + numberOfTimeDerivativeLevels ) % numberOfTimeDerivativeLevels;       // **CHECK nab3 ***
        OV_GET_SERIAL_ARRAY(real,fn[mf][grid],feNew);  // F_E(t+dt) (from predictor)

        real *puNew, *pu1, *pu2, *pu3, *pu4, *pu5, *pu6, *pu7, *pu8;

        if( variableDt )
        {
          // *new way* Jan 9, 2019
          // ----- MODIFIED Fourth-order variable dt with constant b0 and one extra level------
          if( true || t0 <= 10.*dt0 )
            printF("CCCCCCCCCCCCCCCCCCC VARIABLE DT IMEX-BDF44 MODIFIED CORRECTOR, b0=12/25, t=%9.3e, "
                   "[dt0,dt1,dt2,dt3,dt4]=[%9.3e,%9.3e,%9.3e,%9.3e] \n",
                   t0,dt0,dt1,dt2,dt3,dt4);

          real dt0p2=dt0*dt0, dt0p3=dt0*dt0p2, dt1p2=dt1*dt1, dt1p3=dt1*dt1p2, dt1p4=dt1p2*dt1p2, dt2p2=dt2*dt2, dt2p3=dt2*dt2p2;
          real b0, a1,a2,a3,a4,a5;
          b0=12./25.;
          // b1=12/25.*(dt0+dt1)*(dt0+dt1+dt2)*(dt0+dt1+dt2+dt3)/(dt1+dt2+dt3)/(dt1+dt2)/dt1;
          // b2=-12/25.*dt0*(dt0+dt1+dt2)*(dt0+dt1+dt2+dt3)/dt1/dt2/(dt2+dt3);
          // b3=12/25.*(dt0+dt1)*(dt0+dt1+dt2+dt3)*dt0/(dt1+dt2)/dt2/dt3;
          // b4=-12/25.*dt0*(dt0+dt1)*(dt0+dt1+dt2)/dt3/(dt2+dt3)/(dt1+dt2+dt3);
            
          a1=1./25.*(-25*dt1p4+(-52*dt0-75*dt2-50*dt3-25*dt4)*dt1p3+(-6*dt0p2+(-117*dt2-78*dt3-39*dt4)*dt0-75*dt2p2
             +(-100*dt3-50*dt4)*dt2-25*dt3*(dt3+dt4))*dt1p2+(44*dt0p3+(-9*dt2-6*dt3-3*dt4)*dt0p2+(-78*dt2p2
             +(-104*dt3-52*dt4)*dt2-26*dt3*(dt3+dt4))*dt0-25*dt2*(dt2+dt3)*(dt2+dt3+dt4))*dt1+23*dt0*(dt0p3
              +(33./23.*dt2+22./23.*dt3+11/23.*dt4)*dt0p2+(-3./23.*dt2p2+(-4./23.*dt3-2./23.*dt4)*dt2-1./23.*dt3*(dt3+dt4))*dt0
              -13./23.*dt2*(dt2+dt3)*(dt2+dt3+dt4)))/(dt1+dt2+dt3+dt4)/(dt1+dt2+dt3)/(dt1+dt2)/dt1;
         
          a2=-23./25.*dt0*(-13./23.*dt2p3+(-3./23.*dt0-39./23.*dt1-13./23.*dt4-26./23.*dt3)*dt2p2+(33./23.*dt0p2
            +(-2./23.*dt4-4./23.*dt3-6./23.*dt1)*dt0-39./23.*dt1p2+(-26./23.*dt4-52./23.*dt3)*dt1-13./23.*dt3*(dt3+dt4))*dt2+dt0p3
             +(33./23.*dt1+22./23.*dt3+11./23.*dt4)*dt0p2+(-3./23.*dt1p2+(-4./23.*dt3-2./23.*dt4)*dt1-1./23.*dt3*(dt3+dt4))*dt0
                        -13./23.*dt1*(dt1+dt3)*(dt1+dt3+dt4))/dt1/(dt2+dt3+dt4)/dt2/(dt2+dt3);
         
          a3=23./25.*(dt0p3+(33./23.*dt1+22./23.*dt2+22./23.*dt3+11./23.*dt4)*dt0p2
             +(-3./23.*dt1p2+(-4./23.*dt2-4./23.*dt3-2./23.*dt4)*dt1
             -1./23.*(dt2+dt3)*(dt2+dt3+dt4))*dt0-13./23.*dt1*(dt1+dt2+dt3)*(dt1+dt2+dt3+dt4))*dt0/(dt1+dt2)/dt2/dt3/(dt3+dt4);
         
          a4=-23./25.*(dt0p3+(33./23.*dt1+22./23.*dt2+11./23.*dt3+11./23.*dt4)*dt0p2
              +(-3./23.*dt1p2+(-4./23.*dt2-2./23.*dt3-2./23.*dt4)*dt1
              -1./23.*dt2*(dt2+dt3+dt4))*dt0-13./23.*dt1*(dt1+dt2)*(dt1+dt2+dt3+dt4))*dt0/(dt2+dt3)/(dt1+dt2+dt3)/dt3/dt4;
         
          a5=23./25.*(dt0p3+(33./23.*dt1+22./23.*dt2+11./23.*dt3)*dt0p2
                     +(-3./23.*dt1p2+(-4./23.*dt2-2/23.*dt3)*dt1-1./23.*dt2*(dt2+dt3))*dt0
                     -13./23.*(dt1+dt2+dt3)*(dt1+dt2)*dt1)*dt0/dt4/(dt3+dt4)/(dt2+dt3+dt4)/(dt1+dt2+dt3+dt4);

          printF(" a1/(-48/25)=%g a2/(36/25)=%g a3/(-16/25)=%g a4/(-16/25)=%g a5=%g (0), x b0/(12/25)=%g \n",
                   a1/(-48./25),a2/(36./25),a3/(-16./25),a4/(3./25),a5,  b0/(12./25) );

          // ----- MODIFIED Fourth-order constant dt------
          // b0=12/25, b1=48/25, b2=-72/25, b3=48/25, b4=-12/25
          // a1=-48/25, a2=36/25, a3=-16/25, a4=3/25, a5=0
          rpar[0]=-a1;
          rpar[1]=-a2;
          rpar[2]=-a3;
          rpar[3]=-a4;
          rpar[4]=-a5;
          rpar[5]=b0*dt0;

          int option=6;  // option = number of terms on the RHS
          ipar[0]=option;

          int muOld4=(mCur + 4 + numberOfGridFunctions) % numberOfGridFunctions;
          OV_GET_SERIAL_ARRAY(real,gf[muOld4].u[grid],uOld4); // u(t-4*dt)

          puNew=u1.getDataPointer();    // uNew
          pu1  =u0.getDataPointer();    // uCur
          pu2  =uOld.getDataPointer();  // u(t-dt)
          pu3  =uOld2.getDataPointer(); // u(t-2*dt)
          pu4  =uOld3.getDataPointer(); // u(t-3*dt)
          pu5  =uOld4.getDataPointer(); // u(t-4*dt)

          pu6  =feNew.getDataPointer();  // fe(t+dt) from predictor 
        }
        else
        {
          // ---- CORRECTOR   (last term is already in the matrix)
          // (25/12)*u(n+1) = 4*U(n) -3*u(n-1) + (4/3)*u(n-2) - (1/4)*u(n-3) +
          //                  dt*( fe(predictor) [+ fI(n+1)] )

          // This assumes a constant dt: 
          const real c0=25./12., c1=4./c0, c2=-3./c0, c3=(4./3.)/c0, c4=-(1./4.)/c0;
          const real c5=(1./c0)*dt0;

          rpar[0]=c1;
          rpar[1]=c2;
          rpar[2]=c3;
          rpar[3]=c4;
          rpar[4]=c5;

          int option=5;  // option = number of terms on the RHS
          ipar[0]=option;

          puNew=u1.getDataPointer();    // uNew
          pu1  =u0.getDataPointer();    // uCur
          pu2  =uOld.getDataPointer();  // u(t-dt)
          pu3  =uOld2.getDataPointer(); // u(t-2*dt)
          pu4  =uOld3.getDataPointer(); // u(t-3*dt)

          pu5  =feNew.getDataPointer();  // fe(t+dt) from predictor 
          pu6=pu5; // not used 
        }
        


        updateOptNew(u0.getBase(0),u0.getBound(0),u0.getBase(1),u0.getBound(1),
                     u0.getBase(2),u0.getBound(2),u0.getBase(3),u0.getBound(3),
                     *mask1.getDataPointer(),  
                     *puNew,
                     *pu1,*pu2,*pu3,*pu4,*pu5,*pu6, *pu5,*pu5,*pu5,*pu5, // only first 5 or 6 arguments are used
                     ipar[0], rpar[0], ierr );

        if( false )
        {
          // -- initial testing:
          printF("\n___ IMEX-BDF4 corrector: after updateOptNew:\n");
          
          OGFunction & e = *(parameters.dbase.get<OGFunction* >("exactSolution"));
          const int & uc = parameters.dbase.get<int >("uc");
          int i1=1,i2=1,i3=0;
          real x=0., y=0., z=0.;
          real ue[5], uet;
          for( int k=0; k<5; k++ ){ ue[k]=e(x,y,x,uc,t0-k*dt0);  }  // 

          uet = e.t(x,y,x,uc,t0+dt0);

          real ueNew = e(x,y,x,uc,t0+dt0);
          
          real uBDF = (12./25)*( 4.*ue[0]-3.*ue[1]+(4./3.)*ue[2]-(1./4.)*ue[3] )
            +(12./25.)*dt*( uet );
          
          real *puv[4] ={pu1,pu2,pu3,pu4};
          for( int k=0; k<4; k++ )
          {
            realArray &ugf = gf[mgfi[-k]].u[grid];

            real uk = ugf(i1,i2,i3,uc);
            printF(" t=%9.2e u=%12.5e ue=%12.5e err=%9.2e\n",t0-k*dt0,uk,ue[k],uk-ue[k]);


          }
          real utk = fn[nfni[1]][grid](i1,i2,i3,uc);
          printF(" t=%9.2e ut=%12.5e uet=%12.5e err=%9.2e mf=%i nfni[1]=%i\n",t0+dt0,utk,uet,utk-uet,mf,nfni[1]);
          

          printF(" uNew=%12.5e ue=%12.5e err=%9.2e\n",u1(i1,i2,i3,uc),ueNew,u1(i1,i2,i3,uc)-ueNew);
          printF(" uBDF=%12.5e ue=%12.5e err=%9.2e\n",uBDF,ueNew,uBDF-ueNew);

        }

      }
   
    }
    else
    {
      printF("IMEX-BDF:ERROR: unexpected orderOfTimeAccuracy=%i\n",orderOfTimeAccuracy);
      OV_ABORT("ERROR unexpected orderOfTimeAccuracy");
    }
    
    

  }
  else
  {
    OV_ABORT("unexpected implicitMethod");
  }

#endMacro


//\begin{>>CompositeGridSolverInclude.tex}{\subsection{advanceImplicitMultiStep}} 
void DomainSolver::
advanceImplicitMultiStep( real & t0, real & dt0, int & numberOfSubSteps, int & init, int initialStep  )
// ======================================================================================
//  /Description:
//     Time step using an implicit method on the viscous terms and and a multi-step
//    method on the rest.
//
//  This approach should be efficient for moving grids since a larger time step is taken
// and the grid need to be regenerated fewer times. The grid needs only be moved on the
// predictor step. Then one or more corrections can be applied.
//
//
//  Method:
//   Suppose we are solving a PDE:
//           u_t = f(u,x,t)  + F(x,t)
//   That we have split into an explicit part, fe(u),  and implicit part, A*u:
//           u_t = fe(u) + A u  + F(x,t)
//
//   Predictor (2nd-order): (implicit part involves u(p) )
//
//      (u(p)-u(n))/dt = 1.5*( fe(u(n)) + g(n) ) - .5*( fe(u(n-1))+g(n-1) )
//                       + A(  u(p)+u(n) )/2   + G(n)
//   where for TZ flow with exact soluton, ue, the forcing functions g and G are 
//             g(n) = ue_t - fe(ue)
//             G(n) = -[ A( ue(n+1)+ue(n) )/2 ]
// 
//   Corrector:
//      (u(c)-u(n))/dt = 5*( fe(u(p)) + g(p) ) + .5*( fe(u(n))+g(n) )  
//                            + A( u(c)+u(n) )/2   + G(n)
//   
//  Note: 
//           utImplicit = A*u(n)/2  + G(n) 
//  which is computed (once per step) by getUt when implicitOption=computeImplicitTermsSeparately
// 
//\end{CompositeGridSolverInclude.tex}  
// ==========================================================================================
{
  FILE *& debugFile =parameters.dbase.get<FILE* >("debugFile");
  FILE *& pDebugFile =parameters.dbase.get<FILE* >("pDebugFile");

  if( debug() & 4 )
    printF(" $$$$$$ DomainSolver::advanceImplicitMultiStep $$$$$$$$\n");

  const Parameters::TimeSteppingMethod & timeSteppingMethod =
    parameters.dbase.get<Parameters::TimeSteppingMethod >("timeSteppingMethod")=Parameters::implicit;
  
  assert( timeSteppingMethod==Parameters::implicit );

  const Parameters::ImplicitMethod & implicitMethod = 
                parameters.dbase.get<Parameters::ImplicitMethod >("implicitMethod");
  assert( implicitMethod==Parameters::crankNicolson ||
          implicitMethod==Parameters::implicitExplicitMultistep );

  const int & numberOfSolutionLevels = parameters.dbase.get<int>("numberOfSolutionLevels");
  const int & numberOfTimeDerivativeLevels = parameters.dbase.get<int>("numberOfTimeDerivativeLevels");
  const int orderOfAccuracy = parameters.dbase.get<int >("orderOfAccuracy");
  const int orderOfTimeAccuracy = parameters.dbase.get<int >("orderOfTimeAccuracy");

  if( !parameters.dbase.get<DataBase >("modelData").has_key("AdamsPCData") )
  {
    // this must be the initial call to this routine
    parameters.dbase.get<DataBase >("modelData").put<AdamsPCData>("AdamsPCData");
  }

  AdamsPCData & adamsData = parameters.dbase.get<DataBase >("modelData").get<AdamsPCData>("AdamsPCData");
  
  real & dtb=adamsData.dtb;
  // int &mab0 =adamsData.mab0, &mab1=adamsData.mab1, &mab2=adamsData.mab2;
  int &mab0 =adamsData.mab0;
  int &nab0 =adamsData.nab0, &nab1=adamsData.nab1, &nab2=adamsData.nab2, &nab3=adamsData.nab3;
  int &ndt0=adamsData.ndt0;
  real *dtp = adamsData.dtp;

  int & predictorOrder = parameters.dbase.get<int>("predictorOrder");
  int & orderOfPredictorCorrector= parameters.dbase.get<int >("orderOfPredictorCorrector");
  if( implicitMethod==Parameters::implicitExplicitMultistep )
  {
    orderOfPredictorCorrector=orderOfTimeAccuracy; 
    if( predictorOrder<=0 )
    {
      if( orderOfPredictorCorrector==2 )
        predictorOrder=orderOfTimeAccuracy;  // use 2nd-order predictor for IMEX22 *wdh* Jan 7, 2019 
      else
        predictorOrder=orderOfTimeAccuracy-1;  // use THIRD ORDER PREDICTOR for IMEX44 *wdh* Jan 7, 2019 
    }
    
  }

  assert( orderOfPredictorCorrector==2 || 
          orderOfPredictorCorrector==4    );

  if( predictorOrder==0 )
    predictorOrder=2; // default

  if( predictorOrder<0 || predictorOrder>orderOfTimeAccuracy )
  {
    if( init )
      printF("advanceImplicitMultiStep: ERROR: predictorOrder=%i!",predictorOrder);
    predictorOrder=2; // default
    if( init )
      printF("Will use default=%i\n",predictorOrder);
  }
  if( init && debug() & 1 )
  {
    printF("advanceImplicitMultiStep:INFO: predictorOrder=%i ( =0 -> use default, order=%i)\n",
           predictorOrder,orderOfTimeAccuracy);
    fPrintF(debugFile,"advanceImplicitMultiStep:INFO: predictorOrder=%i ( =0 -> use default, order=%i)\n",
            predictorOrder,orderOfTimeAccuracy);
  }
  
  int numberOfCorrections=parameters.dbase.get<int>("numberOfPCcorrections"); 

  // If we check a convergence tolerance when correcting (e.g. for moving grids) then this is
  // the minimum number of corrector steps we must take:
  const int minimumNumberOfPCcorrections = parameters.dbase.get<int>("minimumNumberOfPCcorrections");
  
   
  
  
  // ***** NOTE *********
  // **** For moving grids we need to keep gf[OLD] in addition to fn[OLD] since we need the mask
  // **** for computing exposed points
  // ********************

  // For moving grids we keep gf[mab0], gf[mab1] and gf[mab2]
  // For non-moving grids we keep gf[mab0], gf[mab1] and we set mab2==mab1

  // *wdh* 2017/01/29 const int numberOfGridFunctions =  movingGridProblem() ? 3 : 2; 
  const int numberOfGridFunctions =  numberOfGridFunctionsToUse; // assigned in setupGridFunctions

  // Make a reverse cyclic index to match mab0: 
  CyclicIndex mgfi(numberOfSolutionLevels,ovmod(-mab0,numberOfSolutionLevels),false);
  CyclicIndex nfni(numberOfTimeDerivativeLevels,ovmod(-nab0,numberOfTimeDerivativeLevels),false);
  if( (true || implicitMethod==Parameters::implicitExplicitMultistep) && t0<5.*dt0 )
  {
    printF(" mgfi[1]=%i mgfi[0]=%i mgfi[-1]=%i mgfi[-2]=%i mgfi[-3]=%i\n", 
             mgfi[1],mgfi[0],mgfi[-1],mgfi[-2],mgfi[-3]);
    printF(" nfni[1]=%i nfni[0]=%i nfni[-1]=%i nfni[-2]=%i nfni[-3]=%i\n", 
             nfni[1],nfni[0],nfni[-1],nfni[-2],nfni[-3]);

    // mgfi.shift();
    // printF(" mgfi[2]=%i mgfi[1]=%i mgfi[0]=%i mgfi[-1]=%i mgfi[-2]=%i (after shift)\n", mgfi[2],mgfi[1],mgfi[0],mgfi[-1]
    //     ,mgfi[-2]);
  }
  
  // Cyclic indexes for gf[.]
  int mNew = mgfi[ 1];    // new     : gf[mNew] : will hold u(t+dt)
  int mCur = mgfi[ 0];    // current : gf[mCur] : holds u(t) 
  int mOld = mgfi[-1];    // old     : gf[mOld] : holds u(t-dt) if numberOfGridFunctions==3 otherwise mOld=mNew


  // Index's into fn[.]
  int nNew=nfni[1];
  int nCur=nfni[0];
  int nOld=nfni[-1];


  // // *** WHAT IS THIS ??? *WDH* 2017
  // mab2 = (mab0 -1 + numberOfGridFunctions) % numberOfGridFunctions;


  // int mNew = mab2;    // new     : gf[mNew] : will hold u(t+dt)
  // int mCur = mab0;    // current : gf[mCur] : holds u(t) 
  // int mOld = mab1;    // old     : gf[mOld] : holds u(t-dt) if numberOfGridFunctions==3 otherwise mOld=mNew

  
  if( debug() & 2 )
  {
    fPrintF(debugFile," *** Entering advanceImplicitMultiStep: t0=%e, dt0=%e *** \n",t0,dt0);
 
    if( implicitMethod==Parameters::implicitExplicitMultistep && t0<5.*dt0 )
    {
      printF("____-> IMEX AB-BDF scheme: numberOfCorrections=%i numberOfSolutionLevels=%i "
             "numberOfTimeDerivativeLevels=%i numberOfGridFunctions=%i numberOfExtraFunctionsToUse=%i\n",
             numberOfCorrections,numberOfSolutionLevels,numberOfTimeDerivativeLevels,numberOfGridFunctions,
             numberOfExtraFunctionsToUse);

    }
    else
    {
      printF("____-> IM scheme: numberOfCorrections=%i numberOfSolutionLevels=%i "
             "numberOfTimeDerivativeLevels=%i numberOfGridFunctions=%i numberOfExtraFunctionsToUse=%i\n",
             numberOfCorrections,numberOfSolutionLevels,numberOfTimeDerivativeLevels,numberOfGridFunctions,
             numberOfExtraFunctionsToUse);
    }
    // printF("____-> [mab0,mab1,mab2]=[%i,%i,%i] [nab0,nab1,nab2]=[%i,%i,%i] [mNew,mCur,mOld]=[%i,%i,%i]\n",
    //       mab0,mab1,mab2, nab0,nab1,nab2, mNew,mCur,mOld);

    printF("____-> [mab0]=[%i] [nab0,nab1,nab2]=[%i,%i,%i] [mNew,mCur,mOld]=[%i,%i,%i]\n",
          mab0, nab0,nab1,nab2, mNew,mCur,mOld);
    


  }



  Parameters::ImplicitOption & implicitOption = parameters.dbase.get<Parameters::ImplicitOption >("implicitOption");
  
  implicitOption=Parameters::doNotComputeImplicitTerms; // no need to compute during initialization

  // parameters.dbase.get<Parameters::ImplicitMethod >("implicitMethod")=Parameters::crankNicolson;

  int iparam[10];
  real rparam[10];

  // uti : holds the implicit part of the operator at the current time "n" used in C.N. for example.
  RealCompositeGridFunction & uti = fn[numberOfExtraFunctionsToUse-1];  // *wdh* 2017/02/03 Was [2]
  // RealCompositeGridFunction & uti = fn[2];   // **** Holds du/dt(t) for implicit part of operator I think..
  
  if( debug() & 2 )
  {
    printF(" *** Entering advanceImplicitMultiStep: t0=%e, dt0=%e dtb=%e*** \n",t0,dt0,dtb);
    fPrintF(debugFile," *** Entering advanceImplicitMultiStep: t0=%e, dt0=%e dtb=%e *** \n",t0,dt0,dtb);
  }
 
  
  int grid;
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2]; 
  Range N = parameters.dbase.get<Range >("Rt");   // time dependent variables
  RealArray error(numberOfComponents()+3); 
  
  // real time0=getCPU();

  int numberOfExtraPressureTimeLevels=0;
  
  if( init )
  {
    // Form the matrix for implicit time stepping (optionally save the solution used for linearization)
    // NOTE: the matrix will only be generated the first time through or if parameters.dbase.get<int >("globalStepNumber") % refactorFrequency == 0 
    // We want to factor the matrix here since it may be needed for computing the RHS
    formMatrixForImplicitSolve(dt,gf[mNew], gf[mCur] );

    // **** To initialize the method we need to compute du/dt at times t and t-dt *****

    // this is a macro (pcMacros.h):
    // PC22 needs 
    //   numberOfPastTimes=1 : u(t-dt)
    //   numberOfPastTimeDerivatives=1 : u_t(t-dt)
    // BDF4 needs
    //  numberOfPastTimes=3 : u(n-1) u(n-2) u(n-3)
    // numberOfPastTimeDerivatives=3 : u_t(n-1) u_t(n-2) u_t(n-3)
    int numberOfPastTimes=orderOfTimeAccuracy-1;
    const int numberOfPastTimeDerivatives=orderOfTimeAccuracy-1;
    // *old* -- *wdh* Feb 3, 2017
    // *old* int numberOfPastTimes=1;                            // PC needs u(t-dt)
    // *old* int numberOfPastTimeDerivatives=orderOfAccuracy-1;  // PC needs u_t(t-dt), u_t(t-2*dt), ...

    initializePredictorCorrector(implicitPC,uti);

  }
  else
  {
    if( dtb!=dt0 )
    {
      if( debug() & 2 ) printF("advanceImplicitMultiStep dtb!=dt0 : re-initialize\n");
      parameters.dbase.get<int >("initializeImplicitTimeStepping")=true;
    }
    else
    {
      if( debug() & 2 )
        printF("advanceImplicitMultiStep dtb==dt0 : do not re-initialize\n");
    }
  }

  const bool TESTING=false;
  
  for( int mst=1; mst<=numberOfSubSteps; mst++ )
  {
    parameters.dbase.get<int >("globalStepNumber")++;
    
    realCompositeGridFunction & ua = fn[nab0];   // pointer to du/dt
    realCompositeGridFunction & ub = fn[nab1];   // pointer to du(t-dt)/dt or du/dt(t+dt)
    
    // -- new way : *wdh* 2017/02/05
    // Index's into fn[.]
    nNew=nfni[1];
    nCur=nfni[0];
    nOld=nfni[-1];

    realCompositeGridFunction & fNew = fn[nNew];   // pointer to du/dt(t+dt)
    realCompositeGridFunction & fCur = fn[nCur];   // pointer to du/dt
    realCompositeGridFunction & fOld = fn[nOld];   // pointer to du/dt(t-dt)

    // *new* June 7, 2017 *wdh* 
    int nOld2=nOld, nOld3=nOld;  // not used for orderOfTimeAccuracy==2 
    if( orderOfTimeAccuracy>2 )
    {
      // Fouth-order in time requires two more past levels for the boundaryConditionPredictor
      nOld2 =nfni[-2];
      nOld3 =nfni[-3];
    }
    realCompositeGridFunction & fOld2 = fn[nOld2];   // pointer to du/dt(t-2*dt)
    realCompositeGridFunction & fOld3 = fn[nOld3];   // pointer to du/dt(t-3*dt)


    real ab1,ab2;
    if( predictorOrder==1 )
    { // first order predictor
      ab1=dt0;
      ab2=0.;
    }
    else 
    { // 2nd -order predictor
      ab1= dt0*(1.+dt0/(2.*dtb));  // for AB predictor
      ab2= -dt0*dt0/(2.*dtb);
    }


    dtp[ndt0]=dt0;
    real dt1=dtp[(ndt0+1)%5];
    real dt2=dtp[(ndt0+2)%5];
    real dt3=dtp[(ndt0+3)%5];
    real dt4=dtp[(ndt0+4)%5];

    // printF("\n>>>>>>>>>>>>>>>>>>>>> dtp=%g,%g,%g\n\n",dtp[0],dtp[1],dtp[2]);
    // printF(">>>>>>>>>>>>>>>>>>>>> dt1,dt2,dt3=%g,%g,%g\n\n",dt1,dt2,dt3);

    bool variableDt = false;
    if( implicitMethod==Parameters::implicitExplicitMultistep )
    {
      const real dtTol=REAL_EPSILON*100.;
      if( orderOfPredictorCorrector==2 )
      {
        if( fabs(dt0/dt1-1.) > dtTol )
          variableDt=true;
      }
      else if( orderOfPredictorCorrector==4 )
      {
        if( fabs(dt0/dt1-1.) > dtTol || fabs(dt0/dt2-1.) > dtTol || fabs(dt0/dt3-1.) > dtTol )
          variableDt=true;
      }
      else
      {
        printF("ims:ERROR: unexpected IMEX orderOfPredictorCorrector=%i\n",orderOfPredictorCorrector);
        OV_ABORT("error");
      }
    }
    // variableDt = true;  // ** FOR TESTING **


    const real am1=.5*dt0;                  // for AM corrector
    const real am2=.5*dt0;

    // coefficients for 2nd order extrap:
    const real cex2a=1.+dt0/dtb;       // -> 2.
    const real cex2b=-dt0/dtb;         // -> -1.

    // coefficients for third order extrapolation (from ab.maple)
    //   These reduce to 3, -3, 1 for dt=constant
    const real cex30= (dt0+dt1+dt2)*(dt0+dt1)/(dt1+dt2)/dt1;
    const real cex31= -(dt0+dt1+dt2)/dt2*dt0/dt1;
    const real cex32= (dt0+dt1)*dt0/dt2/(dt1+dt2);

    for( int correction=0; correction<=numberOfCorrections; correction++ )
    {
      if( correction>1  && debug() & 4 )
        printF("ims: correction=%i\n",correction);

      parameters.dbase.get<int>("correctionStage")=correction;
      parameters.dbase.get<int>("totalNumberOfPCcorrections")++;  // count the total number of corrections.
      
      // Predictor-Corrector. First time predict, subsequent times correct.
      //
      //  correction==0 :
      //       ---Adams-Bashforth Predictor
      //           u(*) <- u(t) + ab1*du/dt +ab2*du(t-dtb)/dt
      //  i.e.     gf[1]<- gf[mCur]+ ab1*fCur    +ab2*fOld
      //      
      //            The constants ab1 and ab2 are
      //                 ab1 = dt*( 1.+dt/(2*dtb) )   = (3/2)*dt if dtb=dt
      //                 ab2 = -dt*(  dt/(2*dtb) )    =-(1/2)*dt if dtb=dt
      //            Determined by extrapolation to time t+dt/2 from the
      //            times of fCur and fOld
      //
      // correction>0 :
      //       ---Adams Moulton Corrector
      //          u(t+dt) <- u(t) + dt* ( (1/2) du(*)/dt + (1/2) du(t)/dt )
      //          gf[mNew]  gf[mCur]              fNew             fCur

      // We only need to compute the "explicit" part of the implicit terms once for correction==0: 
      // These values are stored in utImplicit 
      implicitOption =correction==0 ? Parameters::computeImplicitTermsSeparately : 
                                      Parameters::doNotComputeImplicitTerms;

      if( correction==0 )
      {
        // ------------------------------------------------------
        // ----------------- Moving Grids -----------------------
        // ------------------------------------------------------

        bool useNew=false;
        bool gridWasAdapted=false;

        real tb=gf[mCur].t-dtb, tc=tb-dtb, td=tc-dtb; // tc,td not used
        if( movingGridProblem() )
        {
          // assert( predictorOrder<=2 );
        }

        int numberOfPastTimeDerivatives=predictorOrder-1; 
        int numberOfPastTimes=max(0,numberOfPastTimeDerivatives);

        if( implicitMethod==Parameters::implicitExplicitMultistep && orderOfTimeAccuracy>2 )
        {
          // IMEX-BDF fourth-order : *wdh* Jan 3, 2019
          // Fourth-order predictor: 
          //   numberOfPastTimes=3 : u(n-1) u(n-2) u(n-3)
          //   numberOfPastTimeDerivatives=3 : u_t(n-1) u_t(n-2) u_t(n-3)
          // Third-order predictor: one less
          numberOfPastTimes          =orderOfPredictorCorrector-1;    // we need these for corrector 
          if( variableDt ) numberOfPastTimes++;                       // One extra level when dt varies 
          numberOfPastTimeDerivatives=predictorOrder-1;               // we need these for the predictor
        }

        // Fill in exposed points on (tb,ub), ...

        // *new* way Jan 7, 2019: make separate lists of old time grid indexes
        #define USE_NEW_OLD_TIME_INDEX
        int gfList[] = { mgfi[0],mgfi[-1],mgfi[-2],mgfi[-3],mgfi[-4] }; // list of current and past solutions
        int fnList[] = { nfni[0],nfni[-1],nfni[-2],nfni[-3],nfni[-4] }; // lits of current and past time-derivatives
        real tList[] = { t0, t0-dt1,t0-(dt1+dt2),t0-(dt1+dt2+dt3),t0-(dt1+dt2+dt3+dt4) }; // 

        moveTheGridsMacro(adamsPC,uti, predictorOrder,tb,ub,tc,ub,td,ub); // **FIX FOR HIGHER ORDER**

        // we need to rebuild the implicit time stepping matrix.
        if( movingGridProblem() )
          parameters.dbase.get<int >("initializeImplicitTimeStepping")=true;

      }

      // Optionally refactor the matrix : if parameters.dbase.get<int >("globalStepNumber") % refactorFrequency == 0 
      // (We need to do this after the grids have moved but before dudt is evaluated (for nonlinear problems)
      if( correction==0 && (parameters.dbase.get<int >("initializeImplicitTimeStepping") || parameters.dbase.get<int >("globalStepNumber")>0) )
        formMatrixForImplicitSolve(dt0,gf[mNew], gf[mCur] );

      const int maba = correction==0 ? mCur : mNew;
      const int naba = correction==0 ? nCur : nNew;


      // --- Compute: fn[nab0] <- du/dt(t0)  or fn[nab1] <- du/dt(t+dt0) ---

      // -- evaluate any body forcing (this is saved in realCompositeGridFunction bodyForce found in the data-base) ---
      const real tForce = gf[maba].t; // evaluate the body force at this time  ***CHECK ME**
      computeBodyForcing( gf[maba], tForce );

      for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
      {
        // if( false && TESTING )
        // {
        //   gf[maba].u[grid].updateGhostBoundaries(); // TRY THIS June 5, 2017 +TEMP+
        // }
        

        rparam[0]=gf[maba].t;
        rparam[1]=gf[maba].t;     // tforce
        rparam[2]=gf[maba].t+dt0; // tImplicit
        iparam[0]=grid;
        iparam[1]=gf[maba].cg.refinementLevelNumber(grid);
        iparam[2]=numberOfStepsTaken;

        getUt(gf[maba].u[grid],gf[maba].getGridVelocity(grid),
              fn[naba][grid],iparam,rparam,uti[grid],&gf[mNew].cg[grid]);
      }

      addArtificialDissipation(gf[maba].u,dt0); // add "implicit" dissipation to u 

      if( (TESTING && debug() & 4) || debug() & 64 ) // turned 16 -> 4  June 5, 2017 +TEMP+
      {
        for( grid=0; grid<gf[mCur].cg.numberOfComponentGrids(); grid++ )
        {
          display(fCur[grid],"\n ****fCur: du/dt(t)",debugFile);
          if( correction==0 )
            display(fOld[grid],"\n ****fOld: du/dt(t-dt)",debugFile);
          else
            display(fNew[grid],"\n ****fNew: du/dt(t+dt)",debugFile);
        }
      }
      if( FALSE )
      {
        ::display(fn[naba][0],sPrintF(" du/dt t=%9.2e fn[naba=%i]",gf[maba].t,naba),"%5.2f ");
      }
      
      if( debug() & 16 )
      {
        aString label;
        label = sPrintF(" ImplicitMS: errors in u at t=%e, correction=%i maba=%i gf[maba].t=%9.2e\n",
                        t0,correction,maba,gf[maba].t);
        determineErrors( gf[maba].u,gf[mCur].gridVelocity, t0, 0, error,label );

        label = sPrintF(" ImplicitMS: errors in ut fCur at t=%e, correction=%i \n",t0,correction);
        determineErrors( fCur,gf[mCur].gridVelocity, t0, 1, error,label );
        if( correction==0 )
        {
          real tub = t0-dtb;
          label = sPrintF(" ImplicitMS: errors in ut (fOld) at t=%e, correction=%i \n",tub,correction);
          determineErrors( fOld,gf[mNew].gridVelocity, tub, 1, error,label );
        }
        else
        {
          real tub = t0+dt0;
          label = sPrintF(" ImplicitMS: errors in ut (fNew) at t=%e, correction=%i \n",tub,correction);
          determineErrors( fNew,gf[mNew].gridVelocity, tub, 1, error,label );
        }
        
      }

      //  --------------------------------------------------------
      //  --- Assign the explicit or implicit time-step update ---
      //  --------------------------------------------------------
      for( int grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
      {

        const real dti = (1.-parameters.dbase.get<real >("implicitFactor"))*dt0;

        if( correction==0 )
        { // u1 <- u0 + ab1*ua0 + ab2*ub0 [ + dti*utImplicit ]  (add last terms for implicit grids)
          timeStepUpdateMacro( ab1,ab2,dti, fCur[grid],fOld[grid],utImplicit );
        }
        else
        { // u1 <- u0 + am1*ub0 + am2*ua0 [ + dti*utImplicit ] (add last terms for implicit grids)
          timeStepUpdateMacro( am1,am2,dti, fNew[grid],fCur[grid],utImplicit );
        }
      }

      if( correction==0 )
      {
        // printF(" +++ ims: gf[mNew].t=%9.3e --> change to t0+dt0=%9.3e +++\n",gf[mNew].t,t0+dt0);
        gf[mNew].t=t0+dt0;  // gf[mNew] now lives at this time
      }
      
      // *** assign boundary conditions for the implicit method 
      applyBoundaryConditionsForImplicitTimeStepping( gf[mNew], gf[mCur] ); // ***** gf[mNew].gridVelocity must be correct here
    
      if( debug() & 4 )
      {
        aString label = sPrintF(" ***ImplicitMS: RHS Before implicitSolve t=%e, correction=%i\n",gf[mNew].t,correction);
        if( twilightZoneFlow() )
        {
          gf[mNew].u.display(label,debugFile,"%8.5f ");
        }
        label = sPrintF(" ***ImplicitMS: Errors in rhs gf before implicitSolve t=%e, correction=%i\n",gf[mNew].t,correction);
        determineErrors( gf[mNew],label );
      }

      // **** fix this *** we could refactor for each correction here !
//       if( mst>1 || correction>0 )
//       {
//         // Optionally refactor the matrix : if parameters.dbase.get<int >("globalStepNumber") % refactorFrequency == 0 
//      formMatrixForImplicitSolve(dt0,gf[mNew], gf[mCur] );
//       }
      

      // ------------------------------------
      // --- Solve the implicit equations ---
      // ------------------------------------
 
      implicitSolve( dt0,gf[mNew], gf[mCur] );  // gf[mNew]=RHS  gf[mCur]=used for initial guess and linearization

      // * ---
//       implicitSolve( dt0,gf[mNew], gfl );  // gf[mNew]=RHS  gf[mCur]=used for initial guess and linearization
//       gfl.u=gf[mNew].u;


      if( false )
      {
        realCompositeGridFunction diff;
        diff=gf[mNew].u-gf[mCur].u;
        Range & Rt = parameters.dbase.get<Range >("Rt");
        printF(" After implicit solve: max-diff(u-uGuess) =");
        for( int n=Rt.getBase(); n<=Rt.getBound(); n++ )
        {
          int maskOption=0, extra=1;
          real maxDiff = maxNorm(diff, n, maskOption, extra );
          real mxd = 0;
          for( int grid=0; grid<gf[mNew].cg.numberOfComponentGrids(); grid++ )
            mxd = max( mxd, max(fabs(gf[mNew].u[grid]-gf[mCur].u[grid])));
          printF(" n=%i : %8.2e (all=%8.2e), ",n,maxDiff,mxd);
        }
        printF("\n");
      }

      if( debug() & 4 )
      {
        if( twilightZoneFlow() )
        {
          gf[mNew].u.display(sPrintF("ImplicitMS: gf[mNew].u after implicitSolve but BEFORE BC's (t=%8.2e)",
                                     gf[mNew].t),debugFile,"%8.5f ");
        }
        aString label = sPrintF(" ***ImplicitMS: after implicitSolve but BEFORE BC's, t=%e, correction=%i\n",gf[mNew].t,correction);
        determineErrors( gf[mNew],label );
      }

      if( correction==0 )
      {
        // --- For fourth-order in space we need to extrapolate p in time at ghost points --
        //    We extrapolate in time using 
        //               uCur : t
        //               uOld : t-dt
        //               fCur : t-2*dt   (holds boundary p and u in unused ghost points)
        //               fOld : t-3*dt   (holds boundary p and u in unused ghost points)
        if( true )
        {
          // *new* way June 7, 2017 -- extrapolate in time to higher order ---
          int orderOfExtrapolation = orderOfTimeAccuracy==2 ? 3 : 4;
          // int orderOfExtrapolation = orderOfTimeAccuracy==2 ? 3 : 5;
       
          // *new* Jan 14, 2019 -- predict pressure and velocity  try this: 
          //boundaryConditionPredictor( predictPressureAndVelocity,adamsData,orderOfExtrapolation, 
          //                            mNew,mCur,mOld,&fCur,&fOld,&fOld2,&fOld3 );

          boundaryConditionPredictor( predictPressure,adamsData,orderOfExtrapolation, 
                                      mNew,mCur,mOld,&fCur,&fOld,&fOld2,&fOld3 );
        }
        else
        {
          const int orderOfExtrapolation = 3;
          boundaryConditionPredictor( predictPressure,adamsData,orderOfExtrapolation, mNew,mCur,mOld,&fCur,&fOld );
        }
        
      }
      
      if( debug() & 64 ) 
      {
        if( twilightZoneFlow() )
        {
          gf[mNew].u.display(sPrintF("ImplicitMS: gf[mNew].u after implicitSolve and boundaryConditionPredictor but BEFORE BC's (t=%8.2e)",
                                     gf[mNew].t),debugFile,"%8.5f ");
        }
      }

      // apply explicit BC's  --- > really only have to apply to implicit grids I think?
      const int option=-1, grid=-1; // *wdh* Dec 20, 2017 -- pass old time grid function too
      applyBoundaryConditions(gf[mNew],option,grid, &(gf[mCur]));   // ***** gf[mNew].gridVelocity must be correct here!


      updateStateVariables( gf[mNew],1 );  

      if( debug() & 4 )
      {
        if( twilightZoneFlow() )
        {
          gf[mNew].u.display(sPrintF("ImplicitMS: gf[mNew].u after implicitSolve and BC's (t=%8.2e)",
                                     gf[mNew].t),debugFile,"%8.5f ");
        }
        aString label = sPrintF(" ***ImplicitMS: after implicitSolve and BC's, t=%e, correction=%i\n",gf[mNew].t,correction);
        determineErrors( gf[mNew],label );
      }

      // extrapolate p in time as an initial guess for iterative solvers
      if( correction==0 )  // *new way* 2015/01/22
      { 
        // --- for some reason the implicit scheme always extrapolates p in time ---

        assert( parameters.dbase.get<int>("movingBodyPressureBC")==0 ); // this case was treated below for testing -- maybe not used
        
        if( parameters.dbase.has_key("extrapolatePoissonSolveInTime") )
          parameters.dbase.get<bool>("predictedPressureNeeded")= parameters.dbase.get<bool>("extrapolatePoissonSolveInTime");
        const int numberOfTimeLevels=3;
        const int gfIndex[numberOfTimeLevels]={mNew,mCur,mOld}; // 
        predictTimeIndependentVariables( numberOfTimeLevels,gfIndex );
      }

      const bool addedDampingSkip = (parameters.dbase.get<bool>("useAddedDampingAlgorithm") && 
                                     parameters.dbase.get<bool>("addedDampingProjectVelocity") );

      // --- For added-damping scheme we skip the last correction of the rigid body ---
      //   *wdh* June 9, 2016      
      bool includeExtraPressureSolve=false;
      if( !includeExtraPressureSolve && correction>1 && correction==numberOfCorrections && addedDampingSkip )
      {
        printF("--IMS: skip pressure solve and moving grid correction step for AMP: correction=%i, t=%9.3e\n",
               correction,t0);
        break;  // break from corrections 
      }


      // e.g. for variable density, update p eqn here     
      bool updateSolutionDependentEquations = correction==0;  
      solveForTimeIndependentVariables( gf[mNew],updateSolutionDependentEquations ); 

      if( debug() & 8 )
      {
        aString label =sPrintF(" ImplicitMS: Errors after pressure solve, t0+dt0: t0=%e, dt0=%e  \n",t0,dt0);
        determineErrors( gf[mNew],label );
      }

      // -- Correct for forces on moving bodies if we have more corrections --

      // We could skip here -- but this is worse for sher block case at least
      if( includeExtraPressureSolve && correction>1 && correction==numberOfCorrections && addedDampingSkip )
      {
        printF("--IMS: skip moving grid correction step for AMP: correction=%i, t=%9.3e\n",
               correction,t0);
        break;  // break from corrections 
      }


      correctForMovingGridsMacro(IMS);
      if( movingGridCorrectionsHaveConverged )
        break;

      
    } // end corrections
    
    
    // -----------------------------------------------
    // --- Shift cyclic indices for next sub-step ----
    // -----------------------------------------------
    // Shift cyclic indices for next sub-step
    nfni.shift();
    mgfi.shift();
    
    if( true )
    {
      // *new way Feb 9, 2017 
      mNew=mgfi[1];
      mCur=mgfi[0];
      mOld=mgfi[-1];
      
      // mab2=mNew;
      mab0=mCur;
      // mab1=mOld;
      
      nab0=nfni[ 0];
      nab1=nfni[-1];
      nab2=nfni[-2];
      nab3=nfni[-3];
    }
    else
    {
/* ----
      // *old way*

      // permute (mab0,mab1,mab2) 
      mab0 = (mab0-1 + numberOfGridFunctions) % numberOfGridFunctions;
      mab1 = (mab1-1 + numberOfGridFunctions) % numberOfGridFunctions;

      // mab2 is always 1 "ahead" of mab0 
      mab2 = (mab0-1 + numberOfGridFunctions) % numberOfGridFunctions;

      // mab2=mgfi[1];

      // XXX     ^ should that be a 2 ?? kkc 060301  -- this is ok *wdh* 071121
      mNew=mab2;
      mCur=mab0;
      mOld=mab1;

      // *** FIX ME ***
      if( parameters.dbase.get<int >("orderOfPredictorCorrector")==2 )
      {
        nab0 = (nab0+1) % 2;
        nab1 = (nab1+1) % 2;
      }
      else
      {
        nab0 = (nab0-1 +4) % 4;
        nab1 = (nab1-1 +4) % 4;
        nab2 = (nab2-1 +4) % 4;
        nab3 = (nab3-1 +4) % 4;
      }
    --- */
    }
    
    ndt0=(ndt0-1 +5)%5;  // for dtp[]
//      // switch mab0 <-> mab1
//      mab0 = (mab0+1) % 2;
//      mab1 = (mab1+1) % 2;
      
    dtb=dt0;
    t0+=dt0;

    if( parameters.dbase.get<int >("globalStepNumber") % 10 == 0 )
    {
      // residual = u.t = fn[nab0]+uti
      // saveSequenceInfo(t0,evaluate(fn[nab0]+uti));   // 070704 *wdh* turn this off for now -- this is not correct in general 

      // new way:
      if( parameters.dbase.get<int>("useNewImplicitMethod")==1 )
      {
        realCompositeGridFunction & residual = uti;  // save residual here -- check this 
        getResidual( t0,dt0,gf[mab0],residual );
        saveSequenceInfo(t0,residual);
      }
      
    }
    
    output( gf[mab0],parameters.dbase.get<int >("globalStepNumber")+1 ); // output to files, user defined output

    const int zeroUnusedPointsAfterThisManySteps=20;
    if( (mst==numberOfSubSteps || (mst % zeroUnusedPointsAfterThisManySteps)==0) &&  // mst starts at 1
        parameters.dbase.get<int >("extrapolateInterpolationNeighbours")==0 )
    {
      // *note* we cannot fixup unused if we extrapolate interp. neighbours since these values will be zeroed out!
      // (esp. important for viscoPlastic model -- linearized solution becomes corrupted)

      if( debug() & 2 ) printF(" ************** ims.bC fixupUnusedPoints ************\n");
      
      // zero out unused points to keep them from getting too big ** is this needed?? ****
      for( int m=0; m<=1; m++ )
      {
        // ** gf[m].u.zeroUnusedPoints(coeff);
        fixupUnusedPoints(gf[m].u);
      }
    }
    
  } // end  substeps

  // update the current solution:  
  current = mab0;
  
  // tm(2)+=getCPU()-time0;
}


//\begin{>>CompositeGridSolverInclude.tex}{\subsection{applyBoundaryConditionsForImplicitTimeStepping}} 
int DomainSolver::
applyBoundaryConditionsForImplicitTimeStepping(GridFunction & cgf, GridFunction & cgfOld )
// ======================================================================================
//  /Description:
//     On implicit grids, apply boundary conditions to the rhs side grid function used in the implicit solve;
//  on explicit grids apply the normal explicit boundary conditions. 
// /cgf (input) : use this grid function as the right-hand-side. cgf.t should be the time corresponding to the
//      next time step.
// \cgfOld (input): solution at current time (used by some BC's, e.g. AMP bulk-solid)
//\end{CompositeGridSolverInclude.tex}  
// ==========================================================================================
{
  for( int grid=0; grid<cgf.cg.numberOfComponentGrids(); grid++ )
  {
    if( true )
    {
      // ---- Revaluate any time-dependent boundary conditions ----
      // *wdh* 2014/06/26 

      // determine time dependent conditions:
      getTimeDependentBoundaryConditions( cgf.cg[grid],cgf.t,grid ); 

      // Variable boundary values:
      setVariableBoundaryValues( cgf.t,cgf,grid );

      if( parameters.thereAreTimeDependentUserBoundaryConditions(nullIndex,nullIndex,grid)>0 )
      {
        // there are user defined boundary conditions
        userDefinedBoundaryValues( cgf.t,cgf,grid);
      }
    }
    


    if( parameters.getGridIsImplicit(grid) )
    {
      applyBoundaryConditionsForImplicitTimeStepping(cgf.u[grid],          // new time
                                                     gf[current].u[grid],  // -- fix this -- should be uL
                                                     cgfOld.u[grid],       // current time soution
                                                     cgf.getGridVelocity(grid),
                                                     cgf.t,
                                                     parameters.dbase.get<int >("scalarSystemForImplicitTimeStepping"),grid );
    }
    else
    { // apply explicit BC's **** could be trouble if these require interpolation points ??   **********
      const int option=-1;
      applyBoundaryConditions(cgf.t,cgf.u[grid],cgf.getGridVelocity(grid),grid,option,&(cgfOld.u[grid]));
    }


  }
  
  return 0;
}


#include "Integrate.h"


bool DomainSolver::
isImplicitMatrixSingular( realCompositeGridFunction &uL )
{
  return false;
}

int  DomainSolver::
addConstraintEquation( Parameters &parameters, Oges& solver, 
                       realCompositeGridFunction &coeff, 
                       realCompositeGridFunction &ucur, 
                       realCompositeGridFunction &rhs, const int &numberOfComponents) 
{
  printF("DomainSolver::addConstraintEquation should never be called!");
  Overture::abort("error");
  return 0;
}

//\begin{>>CompositeGridSolverInclude.tex}{\subsection{implicitSolve}} 
void DomainSolver::
formMatrixForImplicitSolve(const real & dt0,
                           GridFunction & cgf1,
                           GridFunction & cgf0 )
// ==========================================================================================
// /Description: This function was once part of implicitSolve.  It was
// broken out to allow the construction of the matrix independently of
// the actual solve.  Basically all the work is done to initialize the
// implicit time stepping.  The implicit method can be optionally used
// on only some grids. To implement this approach we simply create a
// sparse matrix that is just the identity matrix on grids that are
// advanced explicitly but equal to the standard implicit matrix on
// grids that are advance implicitly: 
//  \begin{verbatim} 
//  I - \nu \alpha \dt \Delta on implicit grids 
//  I on explicit grids 
//  \end{verbatim} 
// If the form of the boundary conditions for the different components of
// $\uv$ are the same then we can build a single scalar matrix that
// can be used to advance each component, one after the other. If the
// boundary conditions are not of the same form then we build a matrix
// for a system of equations for the velocity components $(u,v,w)$.
//
// Note that originally cgf1 from implicitSolve was used to get the time,
// grid, and operators.  We are now using whatever is passed in as "u" to
// this function.  The operators should be the same (?) and the time is
// used in the debug output.  What about the grid though? It can change 
// due to AMR (used with implicit?) as well as from the grid velocity.
// /dt0 (input) : time step used to build the implicit matrix.
// /cgf1 (input) : holds the RHS 
// /cgf0 (input) : holds the current state of the solution (used for linearization)
//\end{CompositeGridSolverInclude.tex}  
// ==========================================================================================
{
  printf("DomainSolver::formMatrixForImplicitSolve:ERROR: base class function called. This function should be over-ridden\n");
  Overture::abort("error");
}

int
DomainSolver::
setOgesBoundaryConditions( GridFunction &cgf, IntegerArray & boundaryConditions, RealArray &boundaryConditionData,
                           const int imp )
// ===================================================================================================================
// /Description:
//   Assign the boundaryCondition data for passing to Oges (predfined equations) when it builds the implicit system.
//
// This function is called by DomainSolver::formMatrixForImplicitSolve
// 
//  /cgf (input) : A grid function holding the current grid.
//  /boundaryConditions (output) : boundary conditions for Oges
//  /boundaryConditionData (output) : boundary condition data for Oges 
//  /imp (input) : the number of the implicit system being solved
// 
// ====================================================================================================================
{
  CompositeGrid & cg = cgf.cg;

  printf("DomainSolver::setOgesBoundaryConditions:ERROR: base class function called. This function should be over-ridden\n");
  Overture::abort("error");

  return 0;
}
