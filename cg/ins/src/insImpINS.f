! This file automatically generated from insImpINS.bf with bpp.
! **************************************************************************************************
!   Define the full implicit matrix for the incompressible Navier-Stokes
! **************************************************************************************************


! Macro's for forming the general implicit matrix
!  -*- mode: F90 -*-
! ****************************************************************************************************
!   Define macros that are used to build the full implicit matrices for the INS, VP etc. equations
!
!  This file contains generic macros that are used by the different PDEs
!
!  Used by 
!     insImpINS.bf
!     insImpVP.bf 
!     insImpBL.bf 
! ****************************************************************************************************


! --- See --- op/fortranCoeff/opcoeff.bf 
!             op/include/defineConservative.h
! --- See --- mx/src/interfaceMacros.bf <-- mixes different orders of accuracy 

! -- define bpp macros for coefficient operators (from op/src/stencilCoeff.maple)
! This file, opStencilCoeffOrder2.h,  was generated by Overture/op/src/stencilCoeff.maple

! ****************************************************************************** 
! **** This file contains bpp macros to evaluate the coefficient matrix for **** 
! **** derivatives such as x,y,z,xx,yy,zz,laplacian,rr,ss,tt,rrrr,ssss      **** 
! ****************************************************************************** 


! *** dim=2, orderOfAccuracy = 2 *** 





















! *** dim=3, orderOfAccuracy = 2 *** 






























! This file, opStencilCoeffOrder4.h,  was generated by Overture/op/src/stencilCoeff.maple

! ****************************************************************************** 
! **** This file contains bpp macros to evaluate the coefficient matrix for **** 
! **** derivatives such as x,y,z,xx,yy,zz,laplacian,rr,ss,tt,rrrr,ssss      **** 
! ****************************************************************************** 


! *** dim=2, orderOfAccuracy = 4 *** 





















! *** dim=3, orderOfAccuracy = 4 *** 






























! This file, opStencilCoeffOrder6.h,  was generated by Overture/op/src/stencilCoeff.maple

! ****************************************************************************** 
! **** This file contains bpp macros to evaluate the coefficient matrix for **** 
! **** derivatives such as x,y,z,xx,yy,zz,laplacian,rr,ss,tt,rrrr,ssss      **** 
! ****************************************************************************** 


! *** dim=2, orderOfAccuracy = 6 *** 





















! *** dim=3, orderOfAccuracy = 6 *** 






























! #Include opStencilCoeffOrder8.h


! These next include file will define the macros that will define the difference approximations (in op/src)
! Defines getDuDx2(u,aj,ff), getDuDxx2(u,aj,ff), getDuDx3(u,aj,ff), ...  etc. 


! ****** Dimension 2 ******
 ! getDuDx2 operation count     : additions+2*multiplications+assignments
 ! getDuDx2 optimization savings: -assignments
 ! getDuDy2 operation count     : additions+2*multiplications+assignments
 ! getDuDy2 optimization savings: -assignments
 ! getDuDxx2 operation count     : 9*multiplications+3*assignments+4*additions
 ! getDuDxx2 optimization savings: -3*assignments
 ! getDuDxy2 operation count     : 5*additions+9*multiplications+assignments
 ! getDuDxy2 optimization savings: -assignments
 ! getDuDyy2 operation count     : 9*multiplications+3*assignments+4*additions
 ! getDuDyy2 optimization savings: -3*assignments
 ! getDuDxxx2 operation count     : 25*multiplications+3*assignments+9*additions
 ! getDuDxxx2 optimization savings: 2*multiplications-3*assignments
 ! getDuDxxy2 operation count     : 33*multiplications+3*assignments+15*additions
 ! getDuDxxy2 optimization savings: 2*multiplications-3*assignments
 ! getDuDxyy2 operation count     : 32*multiplications+5*assignments+16*additions
 ! getDuDxyy2 optimization savings: additions+3*multiplications-5*assignments
 ! getDuDyyy2 operation count     : 25*multiplications+3*assignments+9*additions
 ! getDuDyyy2 optimization savings: 2*multiplications-3*assignments
 ! getDuDxxxx2 operation count     : 59*multiplications+11*assignments+24*additions
 ! getDuDxxxx2 optimization savings: 3*additions+23*multiplications-11*assignments
 ! getDuDxxxy2 operation count     : 86*multiplications+11*assignments+37*additions
 ! getDuDxxxy2 optimization savings: 2*additions+24*multiplications-11*assignments
 ! getDuDxxyy2 operation count     : 105*multiplications+16*assignments+50*additions
 ! getDuDxxyy2 optimization savings: 8*additions+37*multiplications-16*assignments
 ! getDuDxyyy2 operation count     : 89*multiplications+21*assignments+52*additions
 ! getDuDxyyy2 optimization savings: 17*additions+47*multiplications-21*assignments
 ! getDuDyyyy2 operation count     : 59*multiplications+11*assignments+24*additions
 ! getDuDyyyy2 optimization savings: 3*additions+23*multiplications-11*assignments
 ! getDuDxxxxx2 operation count     : 154*multiplications+43*assignments+82*additions
 ! getDuDxxxxx2 optimization savings: 39*additions+196*multiplications-43*assignments
 ! getDuDxxxxy2 operation count     : 207*multiplications+42*assignments+102*additions
 ! getDuDxxxxy2 optimization savings: 45*additions+211*multiplications-42*assignments
 ! getDuDxxxyy2 operation count     : 249*multiplications+55*assignments+126*additions
 ! getDuDxxxyy2 optimization savings: 49*additions+241*multiplications-55*assignments
 ! getDuDxxyyy2 operation count     : 239*multiplications+67*assignments+150*additions
 ! getDuDxxyyy2 optimization savings: 97*additions+363*multiplications-67*assignments
 ! getDuDxyyyy2 operation count     : 215*multiplications+73*assignments+150*additions
 ! getDuDxyyyy2 optimization savings: 153*additions+371*multiplications-73*assignments
 ! getDuDyyyyy2 operation count     : 154*multiplications+43*assignments+82*additions
 ! getDuDyyyyy2 optimization savings: 39*additions+196*multiplications-43*assignments
 ! getDuDxxxxxx2 operation count     : 364*multiplications+134*assignments+258*additions
 ! getDuDxxxxxx2 optimization savings: 345*additions+1337*multiplications-134*assignments
 ! getDuDxxxxxy2 operation count     : 525*multiplications+149*assignments+326*additions
 ! getDuDxxxxxy2 optimization savings: 409*additions+1502*multiplications-149*assignments
 ! getDuDxxxxyy2 operation count     : 543*multiplications+173*assignments+339*additions
 ! getDuDxxxxyy2 optimization savings: 415*additions+1552*multiplications-173*assignments
 ! getDuDxxxyyy2 operation count     : 510*multiplications+172*assignments+360*additions
 ! getDuDxxxyyy2 optimization savings: 463*additions+1755*multiplications-172*assignments
 ! getDuDxxyyyy2 operation count     : 482*multiplications+184*assignments+391*additions
 ! getDuDxxyyyy2 optimization savings: 731*additions+2241*multiplications-184*assignments
 ! getDuDxyyyyy2 operation count     : 456*multiplications+188*assignments+384*additions
 ! getDuDxyyyyy2 optimization savings: 1019*additions+2233*multiplications-188*assignments
 ! getDuDyyyyyy2 operation count     : 366*multiplications+133*assignments+258*additions
 ! getDuDyyyyyy2 optimization savings: 345*additions+1335*multiplications-133*assignments


! ****** Dimension 3 ******
 ! getDuDx3 operation count     : 2*additions+3*multiplications+assignments
 ! getDuDx3 optimization savings: -assignments
 ! getDuDy3 operation count     : 2*additions+3*multiplications+assignments
 ! getDuDy3 optimization savings: -assignments
 ! getDuDz3 operation count     : 2*additions+3*multiplications+assignments
 ! getDuDz3 optimization savings: -assignments
 ! getDuDxx3 operation count     : 18*multiplications+4*assignments+8*additions
 ! getDuDxx3 optimization savings: -4*assignments
 ! getDuDxy3 operation count     : 11*additions+18*multiplications+assignments
 ! getDuDxy3 optimization savings: -assignments
 ! getDuDyy3 operation count     : 18*multiplications+4*assignments+8*additions
 ! getDuDyy3 optimization savings: -4*assignments
 ! getDuDxz3 operation count     : 11*additions+18*multiplications+assignments
 ! getDuDxz3 optimization savings: -assignments
 ! getDuDyz3 operation count     : 11*additions+18*multiplications+assignments
 ! getDuDyz3 optimization savings: -assignments
 ! getDuDzz3 operation count     : 18*multiplications+4*assignments+8*additions
 ! getDuDzz3 optimization savings: -4*assignments
 ! getDuDxxx3 operation count     : 58*multiplications+4*assignments+21*additions
 ! getDuDxxx3 optimization savings: 6*multiplications-4*assignments
 ! getDuDxxy3 operation count     : 82*multiplications+7*assignments+38*additions
 ! getDuDxxy3 optimization savings: 9*multiplications-7*assignments
 ! getDuDxyy3 operation count     : 76*multiplications+10*assignments+41*additions
 ! getDuDxyy3 optimization savings: 6*additions+15*multiplications-10*assignments
 ! getDuDyyy3 operation count     : 58*multiplications+4*assignments+21*additions
 ! getDuDyyy3 optimization savings: 6*multiplications-4*assignments
 ! getDuDxxz3 operation count     : 82*multiplications+7*assignments+38*additions
 ! getDuDxxz3 optimization savings: 9*multiplications-7*assignments
 ! getDuDxyz3 operation count     : 50*additions+79*multiplications+4*assignments
 ! getDuDxyz3 optimization savings: 6*additions+12*multiplications-4*assignments
 ! getDuDyyz3 operation count     : 82*multiplications+7*assignments+38*additions
 ! getDuDyyz3 optimization savings: 9*multiplications-7*assignments
 ! getDuDxzz3 operation count     : 76*multiplications+10*assignments+41*additions
 ! getDuDxzz3 optimization savings: 6*additions+15*multiplications-10*assignments
 ! getDuDyzz3 operation count     : 76*multiplications+10*assignments+41*additions
 ! getDuDyzz3 optimization savings: 6*additions+15*multiplications-10*assignments
 ! getDuDzzz3 operation count     : 58*multiplications+4*assignments+21*additions
 ! getDuDzzz3 optimization savings: 6*multiplications-4*assignments
 ! getDuDxxxx3 operation count     : 161*multiplications+29*assignments+71*additions
 ! getDuDxxxx3 optimization savings: 15*additions+98*multiplications-29*assignments
 ! getDuDxxxy3 operation count     : 246*multiplications+28*assignments+110*additions
 ! getDuDxxxy3 optimization savings: 12*additions+109*multiplications-28*assignments
 ! getDuDxxyy3 operation count     : 280*multiplications+43*assignments+142*additions
 ! getDuDxxyy3 optimization savings: 46*additions+192*multiplications-43*assignments
 ! getDuDxyyy3 operation count     : 235*multiplications+49*assignments+148*additions
 ! getDuDxyyy3 optimization savings: 97*additions+225*multiplications-49*assignments
 ! getDuDyyyy3 operation count     : 161*multiplications+29*assignments+71*additions
 ! getDuDyyyy3 optimization savings: 15*additions+98*multiplications-29*assignments
 ! getDuDxxxz3 operation count     : 247*multiplications+27*assignments+110*additions
 ! getDuDxxxz3 optimization savings: 12*additions+108*multiplications-27*assignments
 ! getDuDxxyz3 operation count     : 292*multiplications+31*assignments+154*additions
 ! getDuDxxyz3 optimization savings: 46*additions+186*multiplications-31*assignments
 ! getDuDxyyz3 operation count     : 271*multiplications+166*additions+31*assignments
 ! getDuDxyyz3 optimization savings: 97*additions+207*multiplications-31*assignments
 ! getDuDyyyz3 operation count     : 247*multiplications+27*assignments+110*additions
 ! getDuDyyyz3 optimization savings: 12*additions+108*multiplications-27*assignments
 ! getDuDxxzz3 operation count     : 277*multiplications+46*assignments+142*additions
 ! getDuDxxzz3 optimization savings: 46*additions+195*multiplications-46*assignments
 ! getDuDxyzz3 operation count     : 256*multiplications+52*assignments+175*additions
 ! getDuDxyzz3 optimization savings: 115*additions+222*multiplications-52*assignments
 ! getDuDyyzz3 operation count     : 277*multiplications+46*assignments+142*additions
 ! getDuDyyzz3 optimization savings: 46*additions+195*multiplications-46*assignments
 ! getDuDxzzz3 operation count     : 235*multiplications+49*assignments+148*additions
 ! getDuDxzzz3 optimization savings: 97*additions+225*multiplications-49*assignments
 ! getDuDyzzz3 operation count     : 235*multiplications+49*assignments+148*additions
 ! getDuDyzzz3 optimization savings: 97*additions+225*multiplications-49*assignments
 ! getDuDzzzz3 operation count     : 161*multiplications+29*assignments+71*additions
 ! getDuDzzzz3 optimization savings: 15*additions+98*multiplications-29*assignments
 ! getDuDxxxxx3 operation count     : 480*multiplications+117*assignments+279*additions
 ! getDuDxxxxx3 optimization savings: 239*additions+1000*multiplications-117*assignments
 ! getDuDxxxxy3 operation count     : 644*multiplications+120*assignments+345*additions
 ! getDuDxxxxy3 optimization savings: 266*additions+1103*multiplications-120*assignments
 ! getDuDxxxyy3 operation count     : 402*additions+732*multiplications+150*assignments
 ! getDuDxxxyy3 optimization savings: 311*additions+1309*multiplications-150*assignments
 ! getDuDxxyyy3 operation count     : 685*multiplications+177*assignments+458*additions
 ! getDuDxxyyy3 optimization savings: 576*additions+1896*multiplications-177*assignments
 ! getDuDxyyyy3 operation count     : 619*multiplications+186*assignments+461*additions
 ! getDuDxyyyy3 optimization savings: 924*additions+1926*multiplications-186*assignments
 ! getDuDyyyyy3 operation count     : 479*multiplications+117*assignments+279*additions
 ! getDuDyyyyy3 optimization savings: 239*additions+1001*multiplications-117*assignments
 ! getDuDxxxxz3 operation count     : 646*multiplications+120*assignments+345*additions
 ! getDuDxxxxz3 optimization savings: 266*additions+1101*multiplications-120*assignments
 ! getDuDxxxyz3 operation count     : 833*multiplications+116*assignments+441*additions
 ! getDuDxxxyz3 optimization savings: 323*additions+1298*multiplications-116*assignments
 ! getDuDxxyyz3 operation count     : 889*multiplications+138*assignments+512*additions
 ! getDuDxxyyz3 optimization savings: 594*additions+1827*multiplications-138*assignments
 ! getDuDxyyyz3 operation count     : 754*multiplications+156*assignments+536*additions
 ! getDuDxyyyz3 optimization savings: 984*additions+1908*multiplications-156*assignments
 ! getDuDyyyyz3 operation count     : 648*multiplications+119*assignments+345*additions
 ! getDuDyyyyz3 optimization savings: 266*additions+1099*multiplications-119*assignments
 ! getDuDxxxzz3 operation count     : 730*multiplications+149*assignments+402*additions
 ! getDuDxxxzz3 optimization savings: 311*additions+1311*multiplications-149*assignments
 ! getDuDxxyzz3 operation count     : 754*multiplications+183*assignments+500*additions
 ! getDuDxxyzz3 optimization savings: 606*additions+1899*multiplications-183*assignments
 ! getDuDxyyzz3 operation count     : 524*additions+727*multiplications+174*assignments
 ! getDuDxyyzz3 optimization savings: 978*additions+1953*multiplications-174*assignments
 ! getDuDyyyzz3 operation count     : 730*multiplications+149*assignments+402*additions
 ! getDuDyyyzz3 optimization savings: 311*additions+1311*multiplications-149*assignments
 ! getDuDxxzzz3 operation count     : 679*multiplications+183*assignments+458*additions
 ! getDuDxxzzz3 optimization savings: 576*additions+1902*multiplications-183*assignments
 ! getDuDxyzzz3 operation count     : 658*multiplications+195*assignments+533*additions
 ! getDuDxyzzz3 optimization savings: 1095*additions+2004*multiplications-195*assignments
 ! getDuDyyzzz3 operation count     : 679*multiplications+183*assignments+458*additions
 ! getDuDyyzzz3 optimization savings: 576*additions+1902*multiplications-183*assignments
 ! getDuDxzzzz3 operation count     : 619*multiplications+186*assignments+461*additions
 ! getDuDxzzzz3 optimization savings: 924*additions+1926*multiplications-186*assignments
 ! getDuDyzzzz3 operation count     : 619*multiplications+186*assignments+461*additions
 ! getDuDyzzzz3 optimization savings: 924*additions+1926*multiplications-186*assignments
 ! getDuDzzzzz3 operation count     : 481*multiplications+115*assignments+279*additions
 ! getDuDzzzzz3 optimization savings: 239*additions+999*multiplications-115*assignments
 ! getDuDxxxxxx3 operation count     : 1232*multiplications+380*assignments+916*additions
 ! getDuDxxxxxx3 optimization savings: 2414*additions+8130*multiplications-380*assignments
 ! getDuDxxxxxy3 operation count     : 1742*multiplications+419*assignments+1142*additions
 ! getDuDxxxxxy3 optimization savings: 2790*additions+9123*multiplications-419*assignments
 ! getDuDxxxxyy3 operation count     : 1728*multiplications+492*assignments+1158*additions
 ! getDuDxxxxyy3 optimization savings: 2837*additions+9455*multiplications-492*assignments
 ! getDuDxxxyyy3 operation count     : 1194*additions+1600*multiplications+481*assignments
 ! getDuDxxxyyy3 optimization savings: 3128*additions+10552*multiplications-481*assignments
 ! getDuDxxyyyy3 operation count     : 1265*additions+1496*multiplications+508*assignments
 ! getDuDxxyyyy3 optimization savings: 4761*additions+13467*multiplications-508*assignments
 ! getDuDxyyyyy3 operation count     : 1421*multiplications+505*assignments+1253*additions
 ! getDuDxyyyyy3 optimization savings: 6954*additions+13503*multiplications-505*assignments
 ! getDuDyyyyyy3 operation count     : 1230*multiplications+381*assignments+916*additions
 ! getDuDyyyyyy3 optimization savings: 2414*additions+8132*multiplications-381*assignments
 ! getDuDxxxxxz3 operation count     : 1741*multiplications+417*assignments+1142*additions
 ! getDuDxxxxxz3 optimization savings: 2790*additions+9124*multiplications-417*assignments
 ! getDuDxxxxyz3 operation count     : 2098*multiplications+378*assignments+1289*additions
 ! getDuDxxxxyz3 optimization savings: 3120*additions+10006*multiplications-378*assignments
 ! getDuDxxxyyz3 operation count     : 2226*multiplications+460*assignments+1406*additions
 ! getDuDxxxyyz3 optimization savings: 3465*additions+11159*multiplications-460*assignments
 ! getDuDxxyyyz3 operation count     : 2063*multiplications+503*assignments+1531*additions
 ! getDuDxxyyyz3 optimization savings: 5227*additions+14391*multiplications-503*assignments
 ! getDuDxyyyyz3 operation count     : 1552*additions+1886*multiplications+521*assignments
 ! getDuDxyyyyz3 optimization savings: 7924*additions+14415*multiplications-521*assignments
 ! getDuDyyyyyz3 operation count     : 1745*multiplications+412*assignments+1142*additions
 ! getDuDyyyyyz3 optimization savings: 2790*additions+9120*multiplications-412*assignments
 ! getDuDxxxxzz3 operation count     : 1733*multiplications+489*assignments+1158*additions
 ! getDuDxxxxzz3 optimization savings: 2837*additions+9450*multiplications-489*assignments
 ! getDuDxxxyzz3 operation count     : 1971*multiplications+514*assignments+1338*additions
 ! getDuDxxxyzz3 optimization savings: 3398*additions+11018*multiplications-514*assignments
 ! getDuDxxyyzz3 operation count     : 2018*multiplications+554*assignments+1463*additions
 ! getDuDxxyyzz3 optimization savings: 5157*additions+14124*multiplications-554*assignments
 ! getDuDxyyyzz3 operation count     : 1502*additions+1835*multiplications+572*assignments
 ! getDuDxyyyzz3 optimization savings: 7830*additions+14196*multiplications-572*assignments
 ! getDuDyyyyzz3 operation count     : 1735*multiplications+490*assignments+1158*additions
 ! getDuDyyyyzz3 optimization savings: 2837*additions+9448*multiplications-490*assignments
 ! getDuDxxxzzz3 operation count     : 1595*multiplications+477*assignments+1194*additions
 ! getDuDxxxzzz3 optimization savings: 3128*additions+10557*multiplications-477*assignments
 ! getDuDxxyzzz3 operation count     : 1631*multiplications+526*assignments+1373*additions
 ! getDuDxxyzzz3 optimization savings: 5079*additions+13824*multiplications-526*assignments
 ! getDuDxyyzzz3 operation count     : 1415*additions+1610*multiplications+511*assignments
 ! getDuDxyyzzz3 optimization savings: 7512*additions+14169*multiplications-511*assignments
 ! getDuDyyyzzz3 operation count     : 1595*multiplications+477*assignments+1194*additions
 ! getDuDyyyzzz3 optimization savings: 3128*additions+10557*multiplications-477*assignments
 ! getDuDxxzzzz3 operation count     : 1487*multiplications+517*assignments+1265*additions
 ! getDuDxxzzzz3 optimization savings: 4761*additions+13476*multiplications-517*assignments
 ! getDuDxyzzzz3 operation count     : 1478*multiplications+538*assignments+1406*additions
 ! getDuDxyzzzz3 optimization savings: 8178*additions+14193*multiplications-538*assignments
 ! getDuDyyzzzz3 operation count     : 1487*multiplications+517*assignments+1265*additions
 ! getDuDyyzzzz3 optimization savings: 4761*additions+13476*multiplications-517*assignments
 ! getDuDxzzzzz3 operation count     : 1421*multiplications+505*assignments+1253*additions
 ! getDuDxzzzzz3 optimization savings: 6954*additions+13503*multiplications-505*assignments
 ! getDuDyzzzzz3 operation count     : 1421*multiplications+505*assignments+1253*additions
 ! getDuDyzzzzz3 optimization savings: 6954*additions+13503*multiplications-505*assignments
 ! getDuDzzzzzz3 operation count     : 1232*multiplications+382*assignments+916*additions
 ! getDuDzzzzzz3 optimization savings: 2414*additions+8130*multiplications-382*assignments

! Define 
!    defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)
!       defines -> ur2, us2, ux2, uy2, ...            (2D)
!                  ur3, us3, ut3, ux3, uy3, uz3, ...  (3D)
! This file was generated by weights.maple


! This next macro will evaluate parametric derivatives and save in temporaries
!   u is the variable name, v is the prefix for the temporaries, e.g.
!   For example, lines of the following form will be generated:
!      v = u(i1,i2,i3) 
!      vr = ur4(i1,i2,i3) 

! This next macro will evaluate parametric derivatives and save in temporaries
!   u is the variable name, v is the prefix for the temporaries, e.g.
!   For example, lines of the following form will be generated:
!      v = u(i1,i2,i3) 
!      vr = ur4(i1,i2,i3) 

! This next macro will evaluate parametric derivatives and save in temporaries
!   u is the variable name, v is the prefix for the temporaries, e.g.
!   For example, lines of the following form will be generated:
!      v = u(i1,i2,i3) 
!      vr = ur4(i1,i2,i3) 

! This next macro will evaluate x,y,z derivatives using temporaries already computed 
!   u1 is the variable name, aj the jaocbian name and v is the prefix for the temporaries
!   For example, lines of the following form will be generated:
!      getDuDx2(u1,aj,vx) 
!      getDuDxy2(u1,aj,vxy) 
!      getDuDxxx2(u1,aj,vxxx) 

! This next macro will evaluate x,y,z derivatives using temporaries already computed 
!   u1 is the variable name, aj the jaocbian name and v is the prefix for the temporaries
!   For example, lines of the following form will be generated:
!      getDuDx2(u1,aj,vx) 
!      getDuDxy2(u1,aj,vxy) 
!      getDuDxxx2(u1,aj,vxxx) 

! This next macro will evaluate x,y,z derivatives using temporaries already computed 
!   u1 is the variable name, aj the jaocbian name and v is the prefix for the temporaries
!   For example, lines of the following form will be generated:
!      getDuDx2(u1,aj,vx) 
!      getDuDxy2(u1,aj,vxy) 
!      getDuDxxx2(u1,aj,vxxx) 

! This next macro will evaluate x,y,z derivatives of the jacobian 

! u = jacobian name (rsxy), v=prefix for derivatives: vrxr, vrys, 

! 2D, order=6, components=1
! defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)

! defineParametricDerivativeMacros(u,dr,dx,2,2,1,2)
 ! *************** 0 components *************
 ! *************** 1 components *************
 ! *************** 2 components *************
 ! *************** 0 components *************
 ! *************** 1 components *************
 ! *************** 2 components *************
 ! *************** 0 components *************
 ! *************** 1 components *************
 ! *************** 2 components *************

 ! *************** 0 components *************
 ! *************** 1 components *************
 ! *************** 2 components *************
 ! *************** 0 components *************
 ! *************** 1 components *************
 ! *************** 2 components *************


! Example to define orders 2,4,6: 
! defineParametricDerivativeMacros(u1,dr1,dx1,2,2,1,6)
! defineParametricDerivativeMacros(u1,dr1,dx1,2,4,1,4)
! defineParametricDerivativeMacros(u1,dr1,dx1,2,6,1,2)


! define macros for conservative operators: (in op/src)
!  defines getConservativeCoeff( OPERATOR,s,coeff ), OPERATOR=divScalarGrad, ...
! =============================================================================================
! bpp macros defining macros for conservative coefficient matrix approximations to
!              laplace
!              div(scalar grad)
!              div( tensor.grad )
!              Dx( scalar Dy )
! =============================================================================================

! include macros that define  getDivTensorGradCoeffOrder2Dim2() etc.
! ------------------------------------------------------------------------------------
!  This file contains bpp macros that define the coefficient matricies for 
!  conservative operators: 
!     div( tensor grad), div( scalar grad),  Dx( scalar Dx), Dx( scalar Dy) ...
!  All these different operators are handled by the same macro below by appropriately 
!  defining the arguments a11, a12, etc. that appear in the macros. 
!   
!  This file, conservativeCoefficientMatrixMacros.h, was written by op/doc/consCoeff.maple
! ------------------------------------------------------------------------------------
! *** order of accuracy 2  ***




! *** order of accuracy 4  ***




! *** order of accuracy 6  ***




! *** order of accuracy 8  ***






! ===============================================================================================
! Declare variables needed by the conservative coefficients 
!  ORDER : maximum order of accuracy to be used. 
! ===============================================================================================



! ===============================================================================================
! Declare inline macros needed by the conservative coefficients 
!  OPERATOR: 
!          divTensorGrad
!          divScalarGrad
!          laplacian
!          DxScalarDy, ... TODO ...
!          
! Implied arguments:
!  $DIM: 2 or 3 
!  $ORDER : 2,4,6,8
!  $GRIDTYPE : "curvilinear", "rectangular"
! ===============================================================================================

! ==================================================================================================
! Define the values of the coefficients at x+ m*h/2  for m=+1,-1,+2,-2,...
!
!  OPERATOR: 
!          divTensorGrad
!          divScalarGrad
!          laplacian
!          DxScalarDy, 
!          
! old: 
!          DSG = divScalarGrad
!          LAPLACE = laplace
!          DSGR = divScalarGrad (rectangular)
!

! Implied arguments:
!  $DIM: 2 or 3 
!  $ORDER : 2,4,6,8
!  $GRIDTYPE : "curvilinear", "rectangular"
!
!  (originally from op/fortranDeriv/dsgc6.bf)
! ==================================================================================================


! ====================================================================================================
! Get the coefficient matrix for a conservative approximation. 
!
!  OPERATOR : divScalarGrad
!             divTensorGrad
!             laplacian
!             DxDx, DxDy, 
!             DxScalarDx, DxScalarDy
! Implied arguments:
!    (i1,i2,i3) : assign the coefficients at this grid point.
!    $DIM, $ORDER : dimension and order of accuracy.
!    $GRIDTYPE : "curvilinear", "rectangular"
! ====================================================================================================

! -- From opcoeff.bf





! This loop will check for mask>0 and mask != interiorBoundaryPoint



! ======================================================================================================
! Add the local matrix operator opCoeff to the global matrix coeff in equation "e" and component "c"
! ======================================================================================================


! ======================================================================================================
! Assign and add up to 10 different local matrix operators to the global matrix coeff 
! in equation "e" and component "c"
! 
! (Leave final unused arguments empty)
! ======================================================================================================



! ======================================================================================================
! Add up to 10 different local matrix operators to the global matrix coeff 
! in equation "e" and component "c"
! 
! (Leave final unused arguments empty)
! ======================================================================================================






! ======================================================================================================
! Set the local matrix operator opCoeff to the global matrix coeff in equation "e" and component "c"
! ======================================================================================================

! ==========================================================================================
!  Evaluate the Jacobian and its derivatives (parametric and spatial). 
!    aj     : prefix for the name of the resulting jacobian variables, 
!             e.g. ajrx, ajsy, ajrxx, ajsxy, ...
!    MAXDER : number of derivatives to evaluate.  
! ==========================================================================================

! ==========================================================================================
!  Evaluate the parametric derivatives of u.
!    u      : evaluate derivatives of this function.
!    uc     : component to evaluate
!    uu     : prefix for the name of the resulting derivatives, e.g. uur, uus, uurr, ...
!    MAXDER : number of derivatives to evaluate.  
! ==========================================================================================


! ==========================================================================================
!  Evaluate a derivative. (assumes parametric derivatives have already been evaluated)
!   DERIV   : name of the derivative. One of 
!                x,y,z,xx,xy,xz,...
!    u      : evaluate derivatives of this function.
!    uc     : component to evaluate
!    uu     : prefix for the name of the resulting derivatives (same name used with opEvalParametricDerivative) 
!    aj     : prefix for the name of the jacobian variables.
!    ud     : derivative is assigned to this variable.
! ==========================================================================================


! ==========================================================================================
!  Form the local coefficient matrix for an operator. (assumes parametric derivatives have already been evaluated)
!   DERIV   : name of the operator. One of 
!                x,y,z,xx,xy,xz,...
!                laplacian, rr,ss,tt, rrrr,ssss,tttt, 
!                r2Dissipation=rr+ss[+tt]
!                r4Dissipation=rrrr+ssss[+tttt]
!    coeff  : fill in this (local) coefficient matrix
!    AJ     : prefix for the name of the jacobian variables.
! ==========================================================================================



! ==============================================================================================================
!   Fill in the coefficients for a derivative
! ==============================================================================================================

! ==============================================================================================================
!   Fill in the coefficients for a derivative *CONSERVATIVE*
!     DERIV : divScalarGrad
! ==============================================================================================================




!=======================================================================================
! /Description: Return the equation number for given indices
!  /n (input): component number ( n=0,1,..,numberOfComponents-1 )
!  /i1,i2,i3 (input): grid indices
! /return value : The equation number.
!\end{SparseRepInclude.tex}
!=======================================================================================


!===============================================================================================
! /Description:
!     Assign row and column numbers to entries in a sparse matrix.
!    This routine is normally only used for assign equation numbers on CompositeGrids
!  when the equationNumber belongs to a point on a different MappedGrid.
!  Rows and columns in the sparse matrix are numbered according to the values of
!             (n,I1,I2,I3)
!  where n is the component number and (I1,I2,I3) are the coordinate indicies on the grid.
!  The component number n runs from 0 to the numberOfComponentsForCoefficients-1 and is used
!  when solving a system of equations.
!
! /m (input): assign row/column values for the m''th entry in the sparse matrix
! /na,I1a,I2a,I3a (input): defines the row(s)
! /equationNumber (input): defines an equation number
!
!\end{SparseRepInclude.tex}
!===============================================================================================



!===============================================================================================
! /Description:
!   Specify the classification for a set of Index values
!\end{SparseRepInclude.tex}
!===============================================================================================

! =======================================================================
!  Macro to zero out the matrix coefficients for equations e1,e1+1,..,e2
! =======================================================================

! ===============================================================================================
!  Add an extrapolation equation to the matrix
!  Macro args:
!   coeff : coefficient matrix to fill in.
!   c,e : fill in equation e, extrapolate component c
!   i1,i2,i3 : marks the boundary point, ghost points will be assigned to assign
!   orderOfExtrap : order of extrapolation
!   ghost : point line to extrapolate (ghost=1,2,..)
! ===============================================================================================


! ===============================================================================================
!  Add a Neumann or mixed BC to the matrix
!       a0*I + a1*D_n 
!  Macro args:
!   coeff : coefficient matrix to fill in.
!   c,e : fill in equation e, extrapolate component c
!   i1,i2,i3 : boundary point (will assign equations on the ghost point)
!   an(0:2) : holds the outward normal vector 
!   a0,a1 : coefficients of the mixed BC
! ===============================================================================================

! ===============================================================================================
!  Add a Vector Symmetry BC to the matrix
!  Macro args:
!   coeff : coefficient matrix to fill in.
!   cmpu,eqnu : fill in equations eqnu,...,eqnu+nd-1 and components cmpu,...,cmpu+nd-1
!   i1,i2,i3 : boundary point, will assign ghost point
! NOTES:
! The vector symmetry condition is the normal component is even, the tangential components are odd functions:
!     E1:    n.u(-1) = - n.u(1)
!     E2:    t.u(-1) = t.u(1)        
!        or -> [ u(-1) - (n.u(-1))n ] = [ u(1) - (n.u(1))n ]
! Combine equtions:
!         [n.u(-1) + n.u(1)]n + [ u(-1) - (n.u(-1))n ] - [ u(1) - (n.u(1))n ] = 0 
! or
!         u(-1) - u(1) + 2*(n.u(1))n = 0 
! ===============================================================================================

! ===============================================================================================
!  Return the normal vector (an(0),an(1),an(2)) for a point (i1,i2,i3) on a face (side,axis)
!  This macro does nothing on Cartesian grids. 
! ===============================================================================================


! *************************************************************************************


! ==============================================================================================================
!   Fill in the coefficients for an equation
! ==============================================================================================================

! ======================================================================
! Macro to fill in the matrix with BC-s 
!  OR evaluate the residual on the boundary 
! 
! Implicit parameters: 
!    $DIM : 2 or 3 
!    $GRIDTYPE : "rectangular" or "curvilinear"
! ======================================================================

! ===================================================================================
! Macro to evaluate the RHS
! ===================================================================================


! ==============================================================================================================
!  Compute the coefficient of the artificial dissipation
! ==============================================================================================================

! Second order dissipation operators: 





! The next include file defines conservative approximations to coefficent matrices
! ========== This include file contains conservative approximations to coefficient operators ================
!
!    ajac2d(i1,i2,i3)
!    ajac3d(i1,i2,i3
!    getCoeffForDxADxPlusDyBDy(au, azmz,amzz,azzz,apzz,azpz, bzmz,bmzz,bzzz,bpzz,bzpz )
!    getCoeffForDyADx( au, azmz,amzz,azzz,apzz,azpz )
!    getCoeffForDxADy( au, azmz,amzz,azzz,apzz,azpz )
!    setDivTensorGradCoeff2d(cmp,eqn,a11ph,a11mh,a22ph,a22mh,a12pzz,a12mzz,a21zpz,a21zmz)
!    scaleCoefficients( a11ph,a11mh,a22ph,a22mh,a12pzz,a12mzz,a21zpz,a21zmz )
!    getCoeffForDxADxPlusDyBDyPlusDzCDz(au, azzm,azmz,amzz,azzz,apzz,azpz,azzp,...)
!    getCoeffForDxADy3d(au, X, Y, azzm,azmz,amzz,azzz,apzz,azpz,azzp )


! =============================================================================================================
!  Declare variables used in compute the coefficients for a non-linear viscosity
! =============================================================================================================



! ==================================================================================================
! Define the coefficients in the conservative discretization of: 
!         L = Dx( a*Dx ) + Dy( b*Dy ) 
! 
!   L   = (1/J)*[ Dr( J*(rx,ry).(aDx,bDy)) + Ds( J*(sx,sy).(aDx,bDy)) ] 
!       = (1/J)*[ Dr( J*a*rx(rx*Dr + sx*Ds) + J*b*ry*(ry*Dr + sy*Ds)
!                +Ds( J*a*sx(rx*Dr + sx*Ds) + J*b*sy*(ry*Dr + sy*Ds) ] 
!       = (1/J)*[ Dr( a11 Dr) + Dr( a12 Ds) + Ds( a21 Dr) + Ds( a22 Ds) ]
! where 
!  a11 = J ( a rx^2 + b ry^2 )
!  a12 = J ( a rx*sx + b ry*sy )
!  a21 = a12 
!  a22 = J ( a sx^2 + b sy^2 )
!  a = a(i1,i2,i3), b=b(i1,i2,i3)
!
! Macro Arguments:
!   au : prefix of the computed coefficients
!   azmz,amzz,azzz,apzz,azpz : a(i1,i2-1,i2),a(i1-1,i2,i3),a(i1,i2,i3),a(i1+1,i2,i3),a(i1,i2+1,i3)
!   bzmz,bmzz,bzzz,bpzz,bzpz : b(i1,i2-1,i2),b(i1-1,i2,i3),b(i1,i2,i3),b(i1+1,i2,i3),b(i1,i2+1,i3)
! The following jacobian values should also be defined:
!    ajzmz,ajmzz,ajzzz,ajpzz,ajzpz : aj(i1,i2-1,i2),aj(i1-1,i2,i3),aj(i1,i2,i3),aj(i1+1,i2,i3),aj(i1,i2+1,i3)
! ==================================================================================================

! ==================================================================================================
! Define the coefficients in the conservative discretization of: 
!         L = Dy( a*Dx ) 
!  L = div( (0,aDx) ) 
!  L = (1/J)*[ Dr( J*(rx,ry).(0,aDx)) + Ds( J*(sx,sy).(0,aDx)) ]
!    = (1/J)*[ Dr( J*a*ry*(rx*Dr + sx*Ds)) + Ds( J*a*sy*(rx*Dr + sx*Ds) ) ]
!    = (1/J)*( Dr( a11 Dr) + Dr( a12 Ds) + Ds( a21 Dr) + Ds( a22 Ds) ) u 
! where
!  a11 = J ( a ry*rx )
!  a12 = J ( a ry*sx )
!  a21 = J ( a sy*rx )
!  a22 = J ( a sy*sx )
!  a = a(i1,i2,i3)
!
! Macro Arguments:
!   au : prefix of the computed coefficients
!   azmz,amzz,azzz,apzz,azpz : a(i1,i2-1,i2),a(i1-1,i2,i3),a(i1,i2,i3),a(i1+1,i2,i3),a(i1,i2+1,i3)
! The following jacobian values should also be defined:
!    ajzmz,ajmzz,ajzzz,ajpzz,ajzpz : aj(i1,i2-1,i2),aj(i1-1,i2,i3),aj(i1,i2,i3),aj(i1+1,i2,i3),aj(i1,i2+1,i3)
! ==================================================================================================

! ==================================================================================================
! Define the coefficients in the conservative discretization of: 
!         L = Dx( a*Dy ) 
!
!  L = div( (aDy,0) ) 
!  L = (1/J)*[ Dr( J*(rx,ry).(aDy,0)) + Ds(J*(sx,sy).(aDy,0)) ]
!    = (1/J)*[ Dr( J*a*rx*(ry*Dr + sy*Ds)) + Ds( J*a*sx*(ry*Dr + sy*Ds) ) ]
!    = (1/J)*[ Dr( a11 Dr) + Dr( a12 Ds) + Ds( a21 Dr) + Ds( a22 Ds) ]
! where
!  a11 = J ( a rx*ry )
!  a12 = J ( a rx*sy )
!  a21 = J ( a sx*ry )
!  a22 = J ( a sx*sy )
! Macro Arguments:
!   au : prefix of the computed coefficients
!   azmz,amzz,azzz,apzz,azpz : a(i1,i2-1,i2),a(i1-1,i2,i3),a(i1,i2,i3),a(i1+1,i2,i3),a(i1,i2+1,i3)
! The following jacobian values should also be defined:
!    ajzmz,ajmzz,ajzzz,ajpzz,ajzpz : aj(i1,i2-1,i2),aj(i1-1,i2,i3),aj(i1,i2,i3),aj(i1+1,i2,i3),aj(i1,i2+1,i3)
! ==================================================================================================


! =============================================================================================================
! Assign the coefficients for a component of the conservative discretization of the div(tensor grad) operator
! =============================================================================================================


! =======================================================================================================
! This macro scaled the coefficients that appear in the discretization of the div(tensor grad) operator
! =======================================================================================================



! ****************************************************************
! ****************** THREE DIMENSIONS ****************************
! ****************************************************************


! ==================================================================================================
! Define the coefficients in the conservative discretization of: 
!         L = Dx( a*Dx ) + Dy( b*Dy ) + Dz( c*Dz )
! 
!   L   = (1/J)*[ Dr( J*(rx,ry,rz).(aDx,bDy,cDz)) + Ds( J*(sx,sy,sz).(aDx,bDy,cDz)) + Dt( J*(tx,ty,tz).(aDx,bDy,cDz)) ] 
!       = (1/J)*[ Dr( J*a*rx(rx*Dr + sx*Ds+ tx*Dt) + J*b*ry*(ry*Dr + sy*Ds+ ty*Dt) + J*c*rz*(rz*Dr + sz*Ds+ tz*Dt)
!                +Ds( J*a*sx(rx*Dr + sx*Ds+ tx*Dt) + J*b*sy*(ry*Dr + sy*Ds+ ty*Dt) + J*c*sz*(rz*Dr + sz*Ds+ tz*Dt)
!                +Dt( J*a*tx(rx*Dr + sx*Ds+ tx*Dt) + J*b*ty*(ry*Dr + sy*Ds+ ty*Dt) + J*c*tz*(rz*Dr + sz*Ds+ tz*Dt)
!       = (1/J)*[ Dr( a11 Dr) + Dr( a12 Ds) + Dr( a13 Dt) + Ds( a21 Dr) + Ds( a22 Ds) + Ds( a23 Dt) + Dt( a31 Dr) + Dt( a32 Ds) + Dt( a33 Dt) ]
! where 
!  a11 = J ( a rx^2 + b ry^2 + c rz^2 )
!  a12 = J ( a rx*sx + b ry*sy + b rz*sz )
!  a13 = J ( a rx*tx + b ry*ty + b rz*tz )
!  a21 = a12 
!  a22 = J ( a sx^2 + b sy^2 + c sz^2 )
!  a23 = J ( a sx*tx + b sy*ty + b sz*tz )
!  a31 = a13
!  a32 = a23 
!  a33 = J ( a tx^2 + b ty^2 + c tz^2 )
!  a = a(i1,i2,i3), b=b(i1,i2,i3)
!
! Macro Arguments:
!   au : prefix of the computed coefficients
!   azzm,azmz,amzz,azzz,apzz,azpz,azzp : a(i1,i2,i3-1),a(i1,i2-1,i3),a(i1-1,i2,i3),a(i1,i2,i3),a(i1+1,i2,i3),a(i1,i2+1,i3),a(i1,i2,i3+1)
!   bzzm,bzmz,bmzz,bzzz,bpzz,bzpz,bzzp : b(i1,i2,i3-1),b(i1,i2-1,i3),b(i1-1,i2,i3),b(i1,i2,i3),b(i1+1,i2,i3),b(i1,i2+1,i3),b(i1,i2,i3+1)
!   czzm,czmz,cmzz,czzz,cpzz,czpz,czzp : c(i1,i2,i3-1),c(i1,i2-1,i3),c(i1-1,i2,i3),c(i1,i2,i3),c(i1+1,i2,i3),c(i1,i2+1,i3),c(i1,i2,i3+1)
! The following jacobian values should also be defined:
!    ajzmz,ajzzm,ajmzz,ajzzz,ajpzz,ajzpz,ajzzp : aj(i1,i2,i3-1),aj(i1,i2-1,i3),aj(i1-1,i2,i3),aj(i1,i2,i3),aj(i1+1,i2,i3),aj(i1,i2+1,i3),aj(i1,i2,i3+1)
! ==================================================================================================

! ==========================================================================================================================================
! 
! Define the coefficients in the conservative discretization of any mixed or non-mixed derivative: 
! 
!     L = D_X( a*D_Y )  where X=x, y, or z and Y=x, y, or z
!
! Example: 
!  L = div( (aDy,0,0) ) 
!  L = (1/J)*[ Dr( J*(rx,ry,rx).(aDy,0,0)) + Ds(J*(sx,sy,sz).(aDy,0,0))+ Dt(J*(tx,ty,tz).(aDy,0,0))  ]
!    = (1/J)*[ Dr( J*a*rx(ry*Dr + sy*Ds+ ty*Dt) 
!             +Ds( J*a*sx(ry*Dr + sy*Ds+ ty*Dt)
!             +Dt( J*a*tx(ry*Dr + sy*Ds+ ty*Dt) ]
!    = (1/J)*[ Dr( a11 Dr) + Dr( a12 Ds) + Dr( a13 Dt) + Ds( a21 Dr) + Ds( a22 Ds) + Ds( a23 Dt) + Dt( a31 Dr) + Dt( a32 Ds) + Dt( a33 Dt) ]
! where 
!  a11 = J ( a rx*ry )
!  a12 = J ( a rx*sy )
!  a13 = J ( a rx*ty )
!  a21 = J ( a sx*ry )
!  a22 = J ( a sx*sy )
!  a23 = J ( a sx*ty )
!  a31 = J ( a tx*ry )
!  a32 = J ( a tx*sy )
!  a33 = J ( a tx*ty )
!  a = a(i1,i2,i3)
!
! Macro Arguments:
!   au : prefix of the computed coefficients
!   X,Y : X=[x,y,z] and Y=[x,y,z] to compute the coeffcients of D_X( a D_Y )
!   azzm,azmz,amzz,azzz,apzz,azpz,azzp : a(i1,i2,i3-1),a(i1,i2-1,i3),a(i1-1,i2,i3),a(i1,i2,i3),a(i1+1,i2,i3),a(i1,i2+1,i3),a(i1,i2,i3+1)
! The following jacobian values should also be defined:
!    ajzmz,ajzzm,ajmzz,ajzzz,ajpzz,ajzpz,ajzzp : aj(i1,i2,i3-1),aj(i1,i2-1,i3),aj(i1-1,i2,i3),aj(i1,i2,i3),aj(i1+1,i2,i3),aj(i1,i2+1,i3),aj(i1,i2,i3+1)
! ===========================================================================================================================================



! ================================================================================================================================================
!    Assign the coefficients for a component of the conservative 3D discretization of the div(tensor grad) operator
! 
!  L  = (1/J)*[ Dr( a11 Dr) + Dr( a12 Ds) + Dr( a13 Dt) + Ds( a21 Dr) + Ds( a22 Ds) + Ds( a23 Dt) + Dt( a31 Dr) + Dt( a32 Ds) + Dt( a33 Dt) ]
!     Dr( a11 Dr)u = a11pzz*( u(i1+1)-u(i1) ) - a11mzz*( u(i1)-u(i1-1))
!                  = a11pzz*u(i1+1) -(a11pzz+a11mzz)*u(i1) +a11mzz*u(i1-1) 
!     Dr( a13 Dt ) = D0r( a13 D0t ) = a13pzz*( u(i1+1,i2,i3+1)-u(i1+1,i2,i3-1)) - a13mzz*( u(i1-1,i2,i3+1)-u(i1-1,i2,i3-1) )
!     Ds( a23 Dt ) = D0s( a23 D0t ) = a23zpz*( u(i1,i2+1,i3+1)-u(i1,i2+1,i3-1)) - a23zmz*( u(i1,i2-1,i3+1)-u(i1,i2-1,i3-1) )
!
!     Dt( a31 Dr ) = D0t( a31 D0r ) = a31zzp*( u(i1+1,i2,i3+1)-u(i1-1,i2,i3+1)) - a31zzm*( u(i1+1,i2,i3-1)-u(i1-1,i2,i3-1) )
!     Dt( a32 Ds ) = D0t( a32 D0s ) = a32zzp*( u(i1,i2+1,i3+1)-u(i1,i2-1,i3+1)) - a32zzm*( u(i1,i2+1,i3-1)-u(i1,i2-1,i3-1) )
!
! Macro args:
!   cmp,eqn : component and equation
!   A : generic name for coefficients
! =================================================================================================================================================


! =======================================================================================================
! This macro scaled the coefficients that appear in the discretization of the div(tensor grad) operator
! =======================================================================================================


! ======================================================================================================
! Set up to 10 different local matrix operators to the global matrix coeff 
! in equation "e" and component "c" IN THE GHOST POINT (i1m,i2m,i3m) 
!
! ALSO SET EQUATION NUMBERS and CLASSIFY  
! 
! (Leave final unused arguments empty)
! ======================================================================================================


! ======================================================================================================
! Add up to 10 different local matrix operators to the global matrix coeff 
! in equation "e" and component "c" IN THE GHOST POINT (i1m,i2m,i3m) 
! 
! (Leave final unused arguments empty)
! ======================================================================================================



! Here are the coefficients of the free surface BCs -- needs normal an(0:2) and delta function

! ===============================================================================================
!  Add a FREE SURFACE (vector)  BC to the matrix
!  Macro args:
!   coeff : coefficient matrix to fill in.
!   cmpu,eqnu : fill in equations eqnu,...,eqnu+nd-1 and components cmpu,...,cmpu+nd-1
!   i1,i2,i3 : boundary point, will assign ghost point
!
! NOTES:
!  See the file surfins.pdf for a derivation of the equations used here
!    (div(v))*n + (I-n n^T)(tauv.n )/mu = RHS 
!
!   =>  sum_a sum_b  CSF(n,a,b) * (partial u_a/partial x_b)  = RHS(n),   n=0,1,2
!  
! ===============================================================================================

! Here are the coefficients of the Added Mass equation for the GHOST -- needs normal an(0:2) and delta function
! AMGDelta(i,j) =  -theta*dt*nu*[ I - P ]
!     P = (1-alpha)*n n^T
!     beta = theta*dt*nu 


! ===============================================================================================
!  
!     ***** Added-Mass Boundary Condition : FILL into the matrix  *****
! 
!  Macro args:
!   coeff : coefficient matrix to fill in.
!   cmpu,eqnu : fill in equations eqnu,...,eqnu+nd-1 and components cmpu,...,cmpu+nd-1
!   i1,i2,i3 : boundary point, will assign ghost point
!
! NOTES:
!  See the file fibr.pdf for a derivation of the equations used here
! 
!  Ghost-point equations:
!     (1) div(v)=0
!     (2) tauv.n - zs*v = RHS
!  
!  New equation on the boundary: 
!     (3a) n.v = n.( alpha * vf + (1-alpha) * vs )
!     (3b) t.v = t.vf
!          vf == interior update = v^(n-1) + dt*( theta/rho) Delta (v) + ...
!
! (3a) and (3b) combine to give the following equation that replaces the eqn on the boundary:     
! 
!     (3) v - theta*dt*nu*(I+P) Delta v = RHS
!         P = (alpha-1) n n^T 
!
! SUMMARY: (1) and (2) can be combined into a vector equation for the ghost points thus given the
!  two vector equations:
!   (I)  (div(v))*n + (I-n n^T)(tauv.n - zs*v  )/mu = RHS 
!   (II)  v - theta*dt*nu*(I+P) Delta v = RHS
!
! (I): 
!        (d_k v_k) n_i + (delta_ij - n_i n_j)*( (d_j v_k + d_k v_j) n_k  + zs v_j/mu ) = RHS(I)
!        (d_k v_j) delta_jk n_i +
!                     + (delta_ij - n_i n_j)*( d_j v_k ) n_k 
!                     + (delta_ij - n_i n_j)*( d_k v_j ) n_k 
!                     + (delta_ij - n_i n_j)* v_j/mu             = RHS(i)
!        (d_k v_j) delta_jk n_i +
!                     + (delta_ik - n_i n_k)*( d_k v_j ) n_j 
!                     + (delta_ij - n_i n_j)*( d_k v_j ) n_k 
!                     + (delta_ij - n_i n_j)* (v_j zs/mu )            = RHS(i)
!
!
!   =>  sum_j sum_k  AMG(i,j,k) * (partial v_j/partial x_k)    + sum_j AMG0(i,j) v_j  = RHS(m),  i=0,1,2
!
!      AMG(i,j,k) = delta_jk  n_i + (delta_ik - n_i n_k) n_j + (delta_ij - n_i n_j) n_k
!                 =  delta_jk  n_i + delta_ik n_j + delta_ij n_k -2* n_i n_j n_k 
!      AMG0(ij) = + (delta_ij - n_i n_j) *zs/mu 
! 
!  (II)   (I+P) Delta v = (I - (alpha-1)*n_i n_j) Delta(v_j) 
!                       = [ delta_ij - (alpha-1)*n_i n_j ] * Delta(v_j)
!        beta = -theta*dt*nu 
!        
! ===============================================================================================



! =============================================================
! macro to declare temporary variables:
! =============================================================

! =====================================================================================
! This macro is used in insImp.h and is used to look up parameters etc. for this PDE
! =====================================================================================

! =============================================================
! *** NOT USED ANYMORE ***
! macro to compute (variable) material properties
! Compute:
!   kDt : (K/(rho*cp)) * dt*implicitFactor
!       : K = thermal conductivity
! =============================================================
! #beginMacro getMaterialProperties()
!  if( materialFormat.eq.constantMaterialProperties )then
!    ! const material properties -- do nothing
!  else if( materialFormat.eq.piecewiseConstantMaterialProperties )then
!    ! piecewise constant material properties
!    kDt = dt*implicitFactor*( thermalKpc(i1,i2,i3)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) ) )
!    ! write(*,'(" (i1,i2)=",i3,",",i3,") Kpc = ",e10.2)') i1,i2,thermalKpc(i1,i2,i3)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
!  else if( materialFormat.eq.variableMaterialProperties )then 
!    ! variable material properties
!    kDt = dt*implicitFactor*( thermalKv(i1,i2,i3)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) ) )
!    ! write(*,'(" (i1,i2)=",i3,",",i3,") Kv = ",e10.2)') i1,i2,thermalKv(i1,i2,i3)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
!  end if
! #endMacro

! =============================================================================================================
!  Get the coefficients for the conservative discretization of 
!          (1/rho*cp)* div( K grad) 
!  
!  Macro parameters:
!    scale0 : scale the coefficients by this value 
! =============================================================================================================


! ==============================================================================================================
!   Fill in the coefficients for the Incompressible Navier-Stokes Equations
! ==============================================================================================================

!   coeff(MCE(-1,-1,0,cmp,eqn),i1,i2,i3)=  a12mzz+a21zmz
!   coeff(MCE( 0,-1,0,cmp,eqn),i1,i2,i3)=                      a22mh 
!   coeff(MCE( 1,-1,0,cmp,eqn),i1,i2,i3)= -a12pzz-a21zmz 
!   coeff(MCE(-1, 0,0,cmp,eqn),i1,i2,i3)=         a11mh
!   coeff(MCE( 0, 0,0,cmp,eqn),i1,i2,i3)= -a11ph-a11mh -a22ph -a22mh
!   coeff(MCE( 1, 0,0,cmp,eqn),i1,i2,i3)=  a11ph
!   coeff(MCE(-1, 1,0,cmp,eqn),i1,i2,i3)= -a12mzz-a21zpz
!   coeff(MCE( 0, 1,0,cmp,eqn),i1,i2,i3)=               a22ph
!   coeff(MCE( 1, 1,0,cmp,eqn),i1,i2,i3)=  a12pzz+a21zpz

!  coeff(MCE(-1,-1,-1,cmp,eqn),i1,i2,i3)= 0.
!  coeff(MCE( 0,-1,-1,cmp,eqn),i1,i2,i3)=         A ## 23zmz+A ## 32zzm
!  coeff(MCE( 1,-1,-1,cmp,eqn),i1,i2,i3)= 0.
!  coeff(MCE(-1, 0,-1,cmp,eqn),i1,i2,i3)=  A ## 13mzz+A ## 31zzm
!  coeff(MCE( 0, 0,-1,cmp,eqn),i1,i2,i3)=                                    A ## 33mh
!  coeff(MCE( 1, 0,-1,cmp,eqn),i1,i2,i3)= -A ## 13pzz-A ## 31zzm
!  coeff(MCE(-1, 1,-1,cmp,eqn),i1,i2,i3)= 0.
!  coeff(MCE( 0, 1,-1,cmp,eqn),i1,i2,i3)=        -A ## 23zpz-A ## 32zzm
!  coeff(MCE( 1, 1,-1,cmp,eqn),i1,i2,i3)= 0.
!
!  coeff(MCE(-1,-1, 0,cmp,eqn),i1,i2,i3)=  A ## 12mzz+A ## 21zmz
!  coeff(MCE( 0,-1, 0,cmp,eqn),i1,i2,i3)=                      A ## 22mh 
!  coeff(MCE( 1,-1, 0,cmp,eqn),i1,i2,i3)= -A ## 12pzz-A ## 21zmz 
!  coeff(MCE(-1, 0, 0,cmp,eqn),i1,i2,i3)=         A ## 11mh
!  coeff(MCE( 0, 0, 0,cmp,eqn),i1,i2,i3)= -A ## 11ph-A ## 11mh -A ## 22ph -A ## 22mh -A ## 33ph -A ## 33mh
!  coeff(MCE( 1, 0, 0,cmp,eqn),i1,i2,i3)=  A ## 11ph
!  coeff(MCE(-1, 1, 0,cmp,eqn),i1,i2,i3)= -A ## 12mzz-A ## 21zpz
!  coeff(MCE( 0, 1, 0,cmp,eqn),i1,i2,i3)=               A ## 22ph
!  coeff(MCE( 1, 1, 0,cmp,eqn),i1,i2,i3)=  A ## 12pzz+A ## 21zpz
!
!  coeff(MCE(-1,-1, 1,cmp,eqn),i1,i2,i3)= 0.
!  coeff(MCE( 0,-1, 1,cmp,eqn),i1,i2,i3)=       -A ## 23zmz-A ## 32zzp
!  coeff(MCE( 1,-1, 1,cmp,eqn),i1,i2,i3)= 0.
!  coeff(MCE(-1, 0, 1,cmp,eqn),i1,i2,i3)= -A ## 13mzz-A ## 31zzp
!  coeff(MCE( 0, 0, 1,cmp,eqn),i1,i2,i3)=                            A ## 33ph
!  coeff(MCE( 1, 0, 1,cmp,eqn),i1,i2,i3)=  A ## 13pzz+A ## 31zzp
!  coeff(MCE(-1, 1, 1,cmp,eqn),i1,i2,i3)= 0.
!  coeff(MCE( 0, 1, 1,cmp,eqn),i1,i2,i3)=        A ## 23zpz+A ## 32zzp 
!  coeff(MCE( 1, 1, 1,cmp,eqn),i1,i2,i3)= 0.

! ===========================================================================================
! Macro to evaluate 
!         dsg = div (scalar grad) u(i1,i2,i3,c)
!
! This macro assumes that the coefficients A12mzz,A21zmz, ... have already been computed 
!
! Parameters:
!   dsg (output)
!   u 
!   c = component
!   A = prefix in the names of the coefficients: A12mzz,A21zmz, ...
! Implicit parameters:
!   $ORDER
!   $DIM 
! ===========================================================================================


! ===================================================================================
! Macro to evaluate the RHS for the INS equations
! ===================================================================================


! ===============================================================================================
!  Fill in the matrix BCs on a face for the INS equations 
! ===============================================================================================


! ===============================================================================================
!  Compute the residual for BCs
! ===============================================================================================


! ********* Here we now define the suboutine insImpINS ******************
      subroutine insImpINS(nd,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,
     & mask,xy,rsxy,radiusInverse,  u, ndc, coeff, fe,fi,ul, gv,gvl,
     & dw, ndMatProp,matIndex,matValpc,matVal, bc, boundaryCondition, 
     & ndbcd1a,ndbcd1b,ndbcd2a,ndbcd2b,ndbcd3a,ndbcd3b,ndbcd4a,
     & ndbcd4b,bcData,nde, equationNumber, classify, nr1a,nr1b,nr2a,
     & nr2b,nr3a,nr3b, ipar, rpar, pdb, ierr )
!======================================================================
! 
!             Incompressible Navier Stokes IMPlicit 
!             -------------------------------------
!
!    1. Build the coefficient matrix for implicit methods
!    2. Evaluate the right-hand-side and residual 
!
! nd : number of space dimensions
! nd1a,nd1b,nd2a,nd2b,nd3a,nd3b : array dimensions
!
! mask : 
! xy : 
! rsxy : 
! coeff(m,i1,i2,i3) : array holding the matrix coefficients
! u : holds the current solution, used to form the coeff matrix.
! fe : holds the explicit part when evaluating the RHS
! fi : holds the implicit part when evaluating the RHS
! ul : holds the linearized solution, used when evaluating the linearized operator and RHS
! gv : gridVelocity for moving grids
! dw : distance to the wall for some turbulence models
! 
!======================================================================
      implicit none
      integer nd, ndc, n1a,n1b,n2a,n2b,n3a,n3b,
     & nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b
      integer nde,nr1a,nr1b,nr2a,nr2b,nr3a,nr3b
      real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real coeff(0:ndc-1,nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      real fe(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real fi(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real ul(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real gv(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
      real gvl(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
      real dw(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
      real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
      real radiusInverse(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      integer bc(0:1,0:2),boundaryCondition(0:1,0:2),indexRange(0:1,
     & 0:2),ierr
      integer ndbcd1a,ndbcd1b,ndbcd2a,ndbcd2b,ndbcd3a,ndbcd3b,ndbcd4a,
     & ndbcd4b
      real bcData(ndbcd1a:ndbcd1b,ndbcd2a:ndbcd2b,ndbcd3a:ndbcd3b,
     & ndbcd4a:ndbcd4b)
      integer equationNumber(0:nde-1,nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      integer classify(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      integer ipar(0:*)
      real rpar(0:*)
      double precision pdb  ! pointer to data base
      ! -- arrays for variable material properties --
      integer constantMaterialProperties
      integer piecewiseConstantMaterialProperties
      integer variableMaterialProperties
      parameter( constantMaterialProperties=0,
     & piecewiseConstantMaterialProperties=1,
     & variableMaterialProperties=2 )
      integer materialFormat,ndMatProp
      integer matIndex(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      real matValpc(0:ndMatProp-1,0:*)
      real matVal(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
      ! -- added mass options
      integer useAddedMassAlgorithm, projectAddedMassVelocity, 
     & useImplicitAmpBCs, isBulkSolid
      integer extrapolateGhostByDefault
      !     ---- local variables -----
      integer c,e,i1,i2,i3,m1,m2,m3,j1,j2,j3,ghostLine,n,i1m,i2m,i3m,
     & i1p,i2p,i3p,ndu
      integer side,axis,is1,is2,is3,mm,eqnTemp,debug,ntdc,normalAxis,
     & axisp1,axisp2
      integer kd,kd3,orderOfAccuracy,gridIsMoving,orderOfExtrap,
     & orderOfExtrapolation,orderOfExtrapolationForOutflow
      integer numberOfComponentsForCoefficients,stencilSize
      integer gridIsImplicit,implicitOption,implicitMethod,
     & isAxisymmetric,use2ndOrderAD,use4thOrderAD,
     & fillCoefficientsScalarSystem
      integer pc,uc,vc,wc,sc,nc,kc,ec,tc,qc,vsc,rc,grid,m,
     & advectPassiveScalar
      real nu,dt,nuPassiveScalar,adcPassiveScalar
      real gravity(0:2), thermalExpansivity, adcBoussinesq,kThermal
      real zs,alpha,beta,fluidDensity,mu
      real dxi,dyi,dzi,dri,dsi,dti,dr2i,ds2i,dt2i
      real ad21,ad22,ad41,ad42,cd22,cd42,adc,adCoeff,adCoeffl
      real ad21n,ad22n,ad41n,ad42n,cd22n,cd42n
      real yy,yEps, epsX, normalTol
      real an(0:2),anNorm, advectionCoefficient
      integer checkForInflowAtOutFlow, outflowOption
      integer ok,getInt,getReal
      integer mv(0:2)
      integer fillCoefficients,evalRightHandSide,evalResidual,
     & evalResidualForBoundaryConditions
      real ugv,vgv,wgv, ugvl,vgvl,wgvl
      integer equationNumberBase1,equationNumberLength1,
     & equationNumberBase2,equationNumberLength2,equationNumberBase3,
     & equationNumberLength3,equationOffset
      integer gridType
      integer rectangular,curvilinear
      parameter( rectangular=0, curvilinear=1 )
      integer turbulenceModel,noTurbulenceModel
      integer baldwinLomax,spalartAllmaras,kEpsilon,kOmega,
     & largeEddySimulation
      parameter (noTurbulenceModel=0,baldwinLomax=1,kEpsilon=2,
     & kOmega=3,spalartAllmaras=4,largeEddySimulation=5 )
      integer computeAllTerms,
     &     doNotComputeImplicitTerms,
     &     computeImplicitTermsSeparately,
     &     computeAllWithWeightedImplicit
      parameter( computeAllTerms=0,
     &           doNotComputeImplicitTerms=1,
     &           computeImplicitTermsSeparately=2,
     &           computeAllWithWeightedImplicit=3 )
      ! *new* 
      real nuDt,aDt,bDt,nuImp,aExp,aImp,bImp,tImp,kDt,teDt
      real ulterm,vlterm,wlterm,qlterm
      real implicitFactor
      integer nonlinearTermsAreImplicit,evalLinearizedDerivatives
      integer implicitVariation
      integer implicitViscous, implicitAdvectionAndViscous, 
     & implicitFullLinearized
      parameter( implicitViscous=0,
     &           implicitAdvectionAndViscous=1,
     &           implicitFullLinearized=2 )
      integer pdeModel,standardModel,BoussinesqModel,viscoPlasticModel,
     & twoPhaseFlowModel
      parameter( standardModel=0,BoussinesqModel=1,viscoPlasticModel=2,
     & twoPhaseFlowModel=3 )
      integer noSlipWall, inflowWithVelocityGiven, slipWall, outflow, 
     & convectiveOutflow, tractionFree, inflowWithPandTV, 
     & dirichletBoundaryCondition, symmetry, axisymmetric, 
     & interfaceBoundaryCondition,freeSurfaceBoundaryCondition,
     & neumannBoundaryCondition
      parameter( noSlipWall=1,inflowWithVelocityGiven=2,slipWall=4, 
     & outflow=5,convectiveOutflow=14,tractionFree=15, 
     & inflowWithPandTV=3, dirichletBoundaryCondition=12, symmetry=11,
     & axisymmetric=13,interfaceBoundaryCondition=17, 
     & freeSurfaceBoundaryCondition=31, neumannBoundaryCondition=101 )
      !   classifyTypes from SparseRep.h   
      integer interior,boundary,ghost1,ghost2,ghost3,ghost4,
     & interpolation,periodic,extrapolation,unused
      parameter(interior=1,boundary=2,ghost1=3,ghost2=4,ghost3=5,
     & ghost4=6,interpolation=-1,periodic=-2,extrapolation=-3,
     & unused=0 )
      ! the following define which component to fill for a scalar coeff problem
      integer fillCoeffU,fillCoeffV,fillCoeffW,fillCoeffT
      parameter( fillCoeffU=1,fillCoeffV=2,fillCoeffW=3,fillCoeffT=4 )
      real rx,ry,rz,sx,sy,sz,tx,ty,tz
      real aj
      real dr(0:2), dx(0:2)
      integer ma2(-5:5,-5:5,0:0), ma3(-5:5,-5:5,-5:5)
      real nDotL(0:2)
      real delta(0:5,0:5)
      integer ncc,width,halfWidth,halfWidth3
      integer maxWidth,maxWidthDim
      parameter( maxWidth=5,maxWidthDim=maxWidth*maxWidth*maxWidth )
      real iCoeff(0:maxWidthDim-1)
      real xCoeff(0:maxWidthDim-1)
      real yCoeff(0:maxWidthDim-1)
      real zCoeff(0:maxWidthDim-1)
      real lapCoeff(0:maxWidthDim-1)
      real divSGradCoeff(0:maxWidthDim-1)
      real dissCoeff(0:maxWidthDim-1)
      real p0x,p0y,p0z
      real ulx,uly,ulz, vlx,vly,vlz, wlx,wly,wlz, plx,ply,plz, qlx,qly,
     & qlz
      real u0x,u0y,u0z,u0xx,u0xy,u0xz,u0yy,u0yz,u0zz
      real v0x,v0y,v0z,v0xx,v0xy,v0xz,v0yy,v0yz,v0zz
      real w0x,w0y,w0z,w0xx,w0xy,w0xz,w0yy,w0yz,w0zz
      real q0x,q0y,q0z,q0xx,q0xy,q0xz,q0yy,q0yz,q0zz
      integer eqn,eqnu,eqnv,eqnw,eqnq,eqnk,eqne
      integer cmp,cmpu,cmpv,cmpw,cmpq,cmpk,cmpe
      integer mce2,mce3,ce
      ! temp variables for coeff macros: 
      real cur,cus,cut,curr,curs,curt,cuss,cust,cutt
      ! --- visco plastic variables ---
      real dr0i,dr1i,dr0dr1,dr0dr2,dr1dr2
      real divNuGradu,divNuGradv,divNuGradw,divNuGradul,divNuGradvl,
     & divNuGradwl
      real dxvsqi(0:2),dtImp
      ! This include file (created in insImpINS.bf or insImpVP, ...) declares variables needed by each version
       real t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,
     & t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30,t31,
     & t32,t33,t34,t35,t36,t37,t38,t39,t40,t41,t42,t43,t44,t45,t46,
     & t47,t48,t49,t50,t51,t52,t53,t54,t55,t56,t57,t58,t59,t60,t61,
     & t62,t63,t64,t65,t66,t67,t68,t69,t70,t71,t72,t73,t74,t75,t76,
     & t77,t78,t79,t80,t81,t82,t83,t84,t85,t86,t87,t88,t89,t90,t91,
     & t92,t93,t94,t95,t96,t97,t98,t99,t100,t101,t102,t103,t104,t105,
     & t106,t107,t108,t109,t110,t111,t112,t113,t114,t115,t116,t117,
     & t118,t119,t120,t121,t122,t123,t124,t125,t126,t127,t128,t129,
     & t130,t131,t132,t133,t134,t135,t136,t137,t138,t139,t140,t141,
     & t142,t143,t144,t145,t146,t147,t148,t149,t150,t151,t152,t153,
     & t154,t155,t156,t157,t158,t159,t160,t161,t162,t163,t164,t165,
     & t166,t167,t168,t169,t170,t171,t172,t173,t174,t175,t176,t177,
     & t178,t179,t180,t181,t182,t183,t184,t185,t186,t187,t188,t189,
     & t190,t191,t192,t193,t194,t195,t196,t197,t198,t199,t200,t201,
     & t202,t203,t204,t205,t206,t207,t208,t209,t210,t211,t212,t213,
     & t214,t215,t216,t217,t218,t219,t220,t221,t222,t223,t224,t225,
     & t226,t227,t228,t229,t230,t231,t232,t233,t234,t235,t236,t237,
     & t238,t239,t240,t241,t242,t243,t244,t245,t246,t247,t248,t249,
     & t250,t251,t252,t253,t254,t255,t256,t257,t258,t259,t260,t261,
     & t262,t263,t264,t265,t266,t267,t268,t269,t270,t271,t272,t273,
     & t274,t275,t276,t277,t278,t279,t280,t281,t282,t283,t284,t285,
     & t286,t287,t288,t289,t290,t291,t292,t293,t294,t295,t296,t297,
     & t298,t299,t300,t301,t302,t303,t304,t305,t306,t307,t308,t309,
     & t310,t311,t312,t313,t314,t315,t316,t317,t318,t319,t320,t321,
     & t322,t323,t324,t325,t326,t327,t328,t329,t330,t331,t332,t333,
     & t334,t335,t336,t337,t338,t339,t340,t341,t342,t343,t344,t345,
     & t346,t347,t348,t349,t350,t351,t352,t353,t354,t355,t356,t357,
     & t358,t359,t360,t361,t362,t363,t364,t365,t366,t367,t368,t369,
     & t370,t371,t372,t373,t374,t375,t376,t377,t378,t379,t380,t381,
     & t382,t383,t384,t385,t386,t387,t388,t389,t390,t391,t392,t393,
     & t394,t395,t396,t397,t398,t399,t400,t401,t402,t403,t404,t405,
     & t406,t407,t408,t409,t410,t411,t412,t413,t414,t415,t416,t417,
     & t418,t419,t420,t421,t422,t423,t424,t425,t426,t427,t428,t429,
     & t430,t431,t432,t433,t434,t435,t436,t437,t438,t439,t440,t441,
     & t442,t443,t444,t445,t446,t447,t448,t449,t450,t451,t452,t453,
     & t454,t455,t456,t457,t458,t459,t460,t461,t462,t463,t464,t465,
     & t466,t467,t468,t469,t470,t471,t472,t473,t474,t475,t476,t477,
     & t478,t479,t480,t481,t482,t483,t484,t485,t486,t487,t488,t489,
     & t490,t491,t492,t493,t494,t495,t496,t497,t498,t499,t500,t501,
     & t502,t503,t504,t505,t506,t507,t508,t509,t510,t511,t512,t513,
     & t514,t515,t516,t517,t518,t519,t520,t521,t522,t523,t524,t525,
     & t526,t527,t528,t529,t530,t531,t532,t533,t534,t535,t536,t537,
     & t538,t539,t540,t541,t542,t543,t544,t545,t546,t547,t548,t549,
     & t550,t551,t552,t553,t554,t555,t556,t557,t558,t559,t560,t561,
     & t562,t563,t564,t565,t566,t567,t568,t569,t570,t571,t572,t573,
     & t574,t575,t576,t577,t578,t579,t580,t581,t582,t583,t584,t585,
     & t586,t587,t588,t589,t590,t591,t592,t593,t594,t595,t596,t597,
     & t598,t599,t600,t601,t602,t603,t604,t605,t606,t607,t608,t609,
     & t610,t611,t612,t613,t614,t615,t616,t617,t618,t619,t620,t621,
     & t622,t623,t624,t625,t626,t627,t628,t629,t630,t631,t632,t633,
     & t634,t635,t636,t637,t638,t639,t640,t641,t642,t643,t644,t645,
     & t646,t647,t648,t649,t650,t651,t652,t653,t654,t655,t656,t657,
     & t658,t659,t660,t661,t662,t663,t664,t665,t666,t667,t668,t669,
     & t670,t671,t672,t673,t674,t675,t676,t677,t678,t679,t680,t681,
     & t682,t683,t684,t685,t686,t687,t688,t689,t690,t691,t692,t693,
     & t694,t695,t696,t697,t698,t699,t700,t701,t702,t703,t704,t705,
     & t706,t707,t708,t709,t710,t711,t712,t713,t714,t715,t716,t717,
     & t718,t719,t720,t721,t722,t723,t724,t725,t726,t727,t728,t729,
     & t730,t731,t732,t733,t734,t735,t736,t737,t738,t739,t740,t741,
     & t742,t743,t744,t745,t746,t747,t748,t749,t750,t751,t752,t753,
     & t754,t755,t756,t757,t758,t759,t760,t761,t762,t763,t764,t765,
     & t766,t767,t768,t769,t770,t771,t772,t773,t774,t775,t776,t777,
     & t778,t779,t780,t781,t782,t783,t784,t785,t786,t787,t788,t789,
     & t790,t791,t792,t793,t794,t795,t796,t797,t798,t799,t800,t801,
     & t802,t803,t804,t805,t806,t807,t808,t809,t810,t811,t812,t813,
     & t814,t815,t816,t817,t818,t819,t820,t821,t822,t823,t824,t825,
     & t826,t827,t828,t829,t830,t831,t832,t833,t834,t835,t836,t837,
     & t838,t839,t840,t841,t842,t843,t844,t845,t846,t847,t848,t849,
     & t850,t851,t852,t853,t854,t855,t856,t857,t858,t859,t860,t861,
     & t862,t863,t864,t865,t866,t867,t868,t869,t870,t871,t872,t873,
     & t874,t875,t876,t877,t878,t879,t880,t881,t882,t883,t884,t885,
     & t886,t887,t888,t889,t890,t891,t892,t893,t894,t895,t896,t897,
     & t898,t899,t900,t901,t902,t903,t904,t905,t906,t907,t908,t909,
     & t910,t911,t912,t913,t914,t915,t916,t917,t918,t919,t920,t921,
     & t922,t923,t924,t925,t926,t927,t928,t929,t930,t931,t932,t933,
     & t934,t935,t936,t937,t938,t939,t940,t941,t942,t943,t944,t945,
     & t946,t947,t948,t949,t950,t951,t952,t953,t954,t955,t956,t957,
     & t958,t959,t960,t961,t962,t963,t964,t965,t966,t967,t968,t969,
     & t970,t971,t972,t973,t974,t975,t976,t977,t978,t979,t980,t981,
     & t982,t983,t984,t985,t986,t987,t988,t989,t990,t991,t992,t993,
     & t994,t995,t996,t997,t998,t999,t1000,t1001,t1002,t1003,t1004,
     & t1005,t1006,t1007,t1008,t1009,t1010,t1011,t1012,t1013,t1014,
     & t1015,t1016,t1017,t1018,t1019,t1020,t1021,t1022,t1023,t1024,
     & t1025,t1026,t1027,t1028,t1029,t1030,t1031,t1032,t1033,t1034,
     & t1035,t1036,t1037,t1038,t1039,t1040,t1041,t1042,t1043,t1044,
     & t1045,t1046,t1047,t1048,t1049,t1050,t1051,t1052,t1053,t1054,
     & t1055,t1056,t1057,t1058,t1059,t1060,t1061,t1062,t1063,t1064,
     & t1065,t1066,t1067,t1068,t1069,t1070,t1071,t1072,t1073,t1074,
     & t1075,t1076,t1077,t1078,t1079,t1080,t1081,t1082,t1083,t1084,
     & t1085,t1086,t1087,t1088,t1089,t1090,t1091,t1092,t1093,t1094,
     & t1095,t1096,t1097,t1098,t1099,t1100,t1101,t1102,t1103,t1104,
     & t1105,t1106,t1107,t1108,t1109,t1110,t1111,t1112,t1113,t1114,
     & t1115,t1116,t1117,t1118,t1119,t1120,t1121,t1122,t1123,t1124,
     & t1125,t1126,t1127,t1128,t1129,t1130,t1131,t1132,t1133,t1134,
     & t1135,t1136,t1137,t1138,t1139,t1140,t1141,t1142,t1143,t1144,
     & t1145,t1146,t1147,t1148,t1149,t1150,t1151,t1152,t1153,t1154,
     & t1155,t1156,t1157,t1158,t1159,t1160,t1161,t1162,t1163,t1164,
     & t1165,t1166,t1167,t1168,t1169,t1170,t1171,t1172,t1173,t1174,
     & t1175,t1176,t1177,t1178,t1179,t1180,t1181,t1182,t1183,t1184,
     & t1185,t1186,t1187,t1188,t1189,t1190,t1191,t1192,t1193,t1194,
     & t1195,t1196,t1197,t1198,t1199,t1200,t1201,t1202,t1203,t1204,
     & t1205,t1206,t1207,t1208,t1209,t1210,t1211,t1212,t1213,t1214,
     & t1215,t1216,t1217,t1218,t1219,t1220,t1221,t1222,t1223,t1224,
     & t1225,t1226,t1227,t1228,t1229,t1230,t1231,t1232,t1233,t1234,
     & t1235,t1236,t1237,t1238,t1239,t1240,t1241,t1242,t1243,t1244,
     & t1245,t1246,t1247,t1248,t1249,t1250,t1251,t1252,t1253,t1254,
     & t1255,t1256,t1257,t1258,t1259,t1260,t1261,t1262,t1263,t1264,
     & t1265,t1266,t1267,t1268,t1269,t1270,t1271,t1272,t1273,t1274,
     & t1275,t1276,t1277,t1278,t1279,t1280,t1281,t1282,t1283,t1284,
     & t1285,t1286,t1287,t1288,t1289,t1290,t1291,t1292,t1293,t1294,
     & t1295,t1296,t1297,t1298,t1299,t1300,t1301,t1302,t1303,t1304,
     & t1305,t1306,t1307,t1308,t1309,t1310,t1311,t1312,t1313,t1314,
     & t1315,t1316,t1317,t1318,t1319,t1320,t1321,t1322,t1323,t1324,
     & t1325,t1326,t1327,t1328,t1329,t1330,t1331,t1332,t1333,t1334,
     & t1335,t1336,t1337,t1338,t1339,t1340,t1341,t1342,t1343,t1344,
     & t1345,t1346,t1347,t1348,t1349,t1350,t1351,t1352,t1353,t1354,
     & t1355,t1356,t1357,t1358,t1359,t1360,t1361,t1362,t1363,t1364,
     & t1365,t1366,t1367,t1368,t1369,t1370,t1371,t1372,t1373,t1374,
     & t1375,t1376,t1377,t1378,t1379,t1380,t1381,t1382,t1383,t1384,
     & t1385,t1386,t1387,t1388,t1389,t1390,t1391,t1392,t1393,t1394,
     & t1395,t1396,t1397,t1398,t1399,t1400,t1401,t1402,t1403,t1404,
     & t1405,t1406,t1407,t1408,t1409,t1410,t1411,t1412,t1413,t1414,
     & t1415,t1416,t1417,t1418,t1419,t1420,t1421,t1422,t1423,t1424,
     & t1425,t1426,t1427,t1428,t1429,t1430,t1431,t1432,t1433,t1434,
     & t1435,t1436,t1437,t1438,t1439,t1440,t1441,t1442,t1443,t1444,
     & t1445,t1446,t1447,t1448,t1449,t1450,t1451,t1452,t1453,t1454,
     & t1455,t1456,t1457,t1458,t1459,t1460,t1461,t1462,t1463,t1464,
     & t1465,t1466,t1467,t1468,t1469,t1470,t1471,t1472,t1473,t1474,
     & t1475,t1476,t1477,t1478,t1479,t1480,t1481,t1482,t1483,t1484,
     & t1485,t1486,t1487,t1488,t1489,t1490,t1491,t1492,t1493,t1494,
     & t1495,t1496,t1497,t1498,t1499,t1500,t1501,t1502,t1503,t1504,
     & t1505,t1506,t1507,t1508,t1509,t1510,t1511,t1512,t1513,t1514,
     & t1515,t1516,t1517,t1518,t1519,t1520,t1521,t1522,t1523,t1524,
     & t1525,t1526,t1527,t1528,t1529,t1530,t1531,t1532,t1533,t1534,
     & t1535,t1536,t1537,t1538,t1539,t1540,t1541,t1542,t1543,t1544,
     & t1545,t1546,t1547,t1548,t1549,t1550,t1551,t1552,t1553,t1554,
     & t1555,t1556,t1557,t1558,t1559,t1560,t1561,t1562,t1563,t1564,
     & t1565,t1566,t1567,t1568,t1569,t1570,t1571,t1572,t1573,t1574,
     & t1575,t1576,t1577,t1578,t1579,t1580,t1581,t1582,t1583,t1584,
     & t1585,t1586,t1587,t1588,t1589,t1590,t1591,t1592,t1593,t1594,
     & t1595,t1596,t1597,t1598,t1599,t1600,t1601,t1602,t1603,t1604,
     & t1605,t1606,t1607,t1608,t1609,t1610,t1611,t1612,t1613,t1614,
     & t1615,t1616,t1617,t1618,t1619,t1620,t1621,t1622,t1623,t1624,
     & t1625,t1626,t1627,t1628,t1629,t1630,t1631,t1632,t1633,t1634,
     & t1635,t1636,t1637,t1638,t1639,t1640,t1641,t1642,t1643,t1644,
     & t1645,t1646,t1647,t1648,t1649,t1650,t1651,t1652,t1653,t1654,
     & t1655,t1656,t1657,t1658,t1659,t1660,t1661,t1662,t1663,t1664,
     & t1665,t1666,t1667,t1668,t1669,t1670,t1671,t1672,t1673,t1674,
     & t1675,t1676,t1677,t1678,t1679,t1680,t1681,t1682,t1683,t1684,
     & t1685,t1686,t1687,t1688,t1689,t1690,t1691,t1692,t1693,t1694,
     & t1695,t1696,t1697,t1698,t1699,t1700,t1701,t1702,t1703,t1704,
     & t1705,t1706,t1707,t1708,t1709,t1710,t1711,t1712,t1713,t1714,
     & t1715,t1716,t1717,t1718,t1719,t1720,t1721,t1722,t1723,t1724,
     & t1725,t1726,t1727,t1728,t1729,t1730,t1731,t1732,t1733,t1734,
     & t1735,t1736,t1737,t1738,t1739,t1740,t1741,t1742,t1743,t1744,
     & t1745,t1746,t1747,t1748,t1749,t1750,t1751,t1752,t1753,t1754,
     & t1755,t1756,t1757,t1758,t1759,t1760,t1761,t1762,t1763,t1764,
     & t1765,t1766,t1767,t1768,t1769,t1770,t1771,t1772,t1773,t1774,
     & t1775,t1776,t1777,t1778,t1779,t1780,t1781,t1782,t1783,t1784,
     & t1785,t1786,t1787,t1788,t1789,t1790,t1791,t1792,t1793,t1794,
     & t1795,t1796,t1797,t1798,t1799,t1800,t1801,t1802,t1803,t1804,
     & t1805,t1806,t1807,t1808,t1809,t1810,t1811,t1812,t1813,t1814,
     & t1815,t1816,t1817,t1818,t1819,t1820,t1821,t1822,t1823,t1824,
     & t1825,t1826,t1827,t1828,t1829,t1830,t1831,t1832,t1833,t1834,
     & t1835,t1836,t1837,t1838,t1839,t1840,t1841,t1842,t1843,t1844,
     & t1845,t1846,t1847,t1848,t1849,t1850,t1851,t1852,t1853,t1854,
     & t1855,t1856,t1857,t1858,t1859,t1860,t1861,t1862,t1863,t1864,
     & t1865,t1866,t1867,t1868,t1869,t1870,t1871,t1872,t1873,t1874,
     & t1875,t1876,t1877,t1878,t1879,t1880,t1881,t1882,t1883,t1884,
     & t1885,t1886,t1887,t1888,t1889,t1890,t1891,t1892,t1893,t1894,
     & t1895,t1896,t1897,t1898,t1899,t1900,t1901,t1902,t1903,t1904,
     & t1905,t1906,t1907,t1908,t1909,t1910,t1911,t1912,t1913,t1914,
     & t1915,t1916,t1917,t1918,t1919,t1920,t1921,t1922,t1923,t1924,
     & t1925,t1926,t1927,t1928,t1929,t1930,t1931,t1932,t1933,t1934,
     & t1935,t1936,t1937,t1938,t1939,t1940,t1941,t1942,t1943,t1944,
     & t1945,t1946,t1947,t1948,t1949,t1950,t1951,t1952,t1953,t1954,
     & t1955,t1956,t1957,t1958,t1959,t1960,t1961,t1962,t1963,t1964,
     & t1965,t1966,t1967,t1968,t1969,t1970,t1971,t1972,t1973,t1974,
     & t1975,t1976,t1977,t1978,t1979,t1980,t1981,t1982,t1983,t1984,
     & t1985,t1986,t1987,t1988,t1989,t1990,t1991,t1992,t1993,t1994,
     & t1995,t1996,t1997,t1998,t1999,t2000,t2001,t2002,t2003,t2004,
     & t2005,t2006,t2007,t2008,t2009,t2010,t2011,t2012,t2013,t2014,
     & t2015,t2016,t2017,t2018,t2019,t2020,t2021,t2022,t2023,t2024,
     & t2025,t2026,t2027,t2028,t2029,t2030,t2031,t2032,t2033,t2034,
     & t2035,t2036,t2037,t2038,t2039,t2040,t2041,t2042,t2043,t2044,
     & t2045,t2046,t2047,t2048,t2049,t2050,t2051,t2052,t2053,t2054,
     & t2055,t2056,t2057,t2058,t2059,t2060,t2061,t2062,t2063,t2064,
     & t2065,t2066,t2067,t2068,t2069,t2070,t2071,t2072,t2073,t2074,
     & t2075,t2076,t2077,t2078,t2079,t2080,t2081,t2082,t2083,t2084,
     & t2085,t2086,t2087,t2088,t2089,t2090,t2091,t2092,t2093,t2094,
     & t2095,t2096,t2097,t2098,t2099,t2100,t2101,t2102,t2103,t2104,
     & t2105,t2106,t2107,t2108,t2109,t2110,t2111,t2112,t2113,t2114,
     & t2115,t2116,t2117,t2118,t2119,t2120,t2121,t2122,t2123,t2124,
     & t2125,t2126,t2127,t2128,t2129,t2130,t2131,t2132,t2133,t2134,
     & t2135,t2136,t2137,t2138,t2139,t2140,t2141,t2142,t2143,t2144,
     & t2145,t2146,t2147,t2148,t2149,t2150,t2151,t2152,t2153,t2154,
     & t2155,t2156,t2157,t2158,t2159,t2160,t2161,t2162,t2163,t2164,
     & t2165,t2166,t2167,t2168,t2169,t2170,t2171,t2172,t2173,t2174,
     & t2175,t2176,t2177,t2178,t2179,t2180,t2181,t2182,t2183,t2184,
     & t2185,t2186,t2187,t2188,t2189,t2190,t2191,t2192,t2193,t2194,
     & t2195,t2196,t2197,t2198,t2199,t2200,t2201,t2202,t2203,t2204,
     & t2205,t2206,t2207,t2208,t2209,t2210,t2211,t2212,t2213,t2214,
     & t2215,t2216,t2217,t2218,t2219,t2220,t2221,t2222,t2223,t2224,
     & t2225,t2226,t2227,t2228,t2229,t2230,t2231,t2232,t2233,t2234,
     & t2235,t2236,t2237,t2238,t2239,t2240,t2241,t2242,t2243,t2244,
     & t2245,t2246,t2247,t2248,t2249,t2250,t2251,t2252,t2253,t2254,
     & t2255,t2256,t2257,t2258,t2259,t2260,t2261,t2262,t2263,t2264,
     & t2265,t2266,t2267,t2268,t2269,t2270,t2271,t2272,t2273,t2274,
     & t2275,t2276,t2277,t2278,t2279,t2280,t2281,t2282,t2283,t2284,
     & t2285,t2286,t2287,t2288,t2289,t2290,t2291,t2292,t2293,t2294,
     & t2295,t2296,t2297,t2298,t2299,t2300,t2301,t2302,t2303,t2304,
     & t2305,t2306,t2307,t2308,t2309,t2310,t2311,t2312,t2313,t2314,
     & t2315,t2316,t2317,t2318,t2319,t2320,t2321,t2322,t2323,t2324,
     & t2325,t2326,t2327,t2328,t2329,t2330,t2331,t2332,t2333,t2334,
     & t2335,t2336,t2337,t2338,t2339,t2340,t2341,t2342,t2343,t2344,
     & t2345,t2346,t2347,t2348,t2349,t2350,t2351,t2352,t2353,t2354,
     & t2355,t2356,t2357,t2358,t2359,t2360,t2361,t2362,t2363,t2364,
     & t2365,t2366,t2367,t2368,t2369,t2370,t2371,t2372,t2373,t2374,
     & t2375,t2376,t2377,t2378,t2379,t2380,t2381,t2382,t2383,t2384,
     & t2385,t2386,t2387,t2388,t2389,t2390,t2391,t2392,t2393,t2394,
     & t2395,t2396,t2397,t2398,t2399,t2400,t2401,t2402,t2403,t2404,
     & t2405,t2406,t2407,t2408,t2409,t2410,t2411,t2412,t2413,t2414,
     & t2415,t2416,t2417,t2418,t2419,t2420,t2421,t2422,t2423,t2424,
     & t2425,t2426,t2427,t2428,t2429,t2430,t2431,t2432,t2433,t2434,
     & t2435,t2436,t2437,t2438,t2439,t2440,t2441,t2442,t2443,t2444,
     & t2445,t2446,t2447,t2448,t2449,t2450,t2451,t2452,t2453,t2454,
     & t2455,t2456,t2457,t2458,t2459,t2460,t2461,t2462,t2463,t2464,
     & t2465,t2466,t2467,t2468,t2469,t2470,t2471,t2472,t2473,t2474,
     & t2475,t2476,t2477,t2478,t2479,t2480,t2481,t2482,t2483,t2484,
     & t2485,t2486,t2487,t2488,t2489,t2490,t2491,t2492,t2493,t2494,
     & t2495,t2496,t2497,t2498,t2499,t2500,t2501,t2502,t2503,t2504,
     & t2505,t2506,t2507,t2508,t2509,t2510,t2511,t2512,t2513,t2514,
     & t2515,t2516,t2517,t2518,t2519,t2520,t2521,t2522,t2523,t2524,
     & t2525,t2526,t2527,t2528,t2529,t2530,t2531,t2532,t2533,t2534,
     & t2535,t2536,t2537,t2538,t2539,t2540,t2541,t2542,t2543,t2544,
     & t2545,t2546,t2547,t2548,t2549,t2550,t2551,t2552,t2553,t2554,
     & t2555,t2556,t2557,t2558,t2559,t2560,t2561,t2562,t2563,t2564,
     & t2565,t2566,t2567,t2568,t2569,t2570,t2571,t2572,t2573,t2574,
     & t2575,t2576,t2577,t2578,t2579,t2580,t2581,t2582,t2583,t2584,
     & t2585,t2586,t2587,t2588,t2589,t2590,t2591,t2592,t2593,t2594,
     & t2595,t2596,t2597,t2598,t2599,t2600,t2601,t2602,t2603,t2604,
     & t2605,t2606,t2607,t2608,t2609,t2610,t2611,t2612,t2613,t2614,
     & t2615,t2616,t2617,t2618,t2619,t2620,t2621,t2622,t2623,t2624,
     & t2625,t2626,t2627,t2628,t2629,t2630,t2631,t2632,t2633,t2634,
     & t2635,t2636,t2637,t2638,t2639,t2640,t2641,t2642,t2643,t2644,
     & t2645,t2646,t2647,t2648,t2649,t2650,t2651,t2652,t2653,t2654,
     & t2655,t2656,t2657,t2658,t2659,t2660,t2661,t2662,t2663,t2664,
     & t2665,t2666,t2667,t2668,t2669,t2670,t2671,t2672,t2673,t2674,
     & t2675,t2676,t2677,t2678,t2679,t2680,t2681,t2682,t2683,t2684,
     & t2685,t2686,t2687,t2688,t2689,t2690,t2691,t2692,t2693,t2694,
     & t2695,t2696,t2697,t2698,t2699,t2700,t2701,t2702,t2703,t2704,
     & t2705,t2706,t2707,t2708,t2709,t2710,t2711,t2712,t2713,t2714,
     & t2715,t2716,t2717,t2718,t2719,t2720,t2721,t2722,t2723,t2724,
     & t2725,t2726,t2727,t2728,t2729,t2730,t2731,t2732,t2733,t2734,
     & t2735,t2736,t2737,t2738,t2739,t2740,t2741,t2742,t2743,t2744,
     & t2745,t2746,t2747,t2748,t2749,t2750,t2751,t2752,t2753,t2754,
     & t2755,t2756,t2757,t2758,t2759,t2760,t2761,t2762,t2763,t2764,
     & t2765,t2766,t2767,t2768,t2769,t2770,t2771,t2772,t2773,t2774,
     & t2775,t2776,t2777,t2778,t2779,t2780,t2781,t2782,t2783,t2784,
     & t2785,t2786,t2787,t2788,t2789,t2790,t2791,t2792,t2793,t2794,
     & t2795,t2796,t2797,t2798,t2799,t2800,t2801,t2802,t2803,t2804,
     & t2805,t2806,t2807,t2808,t2809,t2810,t2811,t2812,t2813,t2814,
     & t2815,t2816,t2817,t2818,t2819,t2820,t2821,t2822,t2823,t2824,
     & t2825,t2826,t2827,t2828,t2829,t2830,t2831,t2832,t2833,t2834,
     & t2835,t2836,t2837,t2838,t2839,t2840,t2841,t2842,t2843,t2844,
     & t2845,t2846,t2847,t2848,t2849,t2850,t2851,t2852,t2853,t2854,
     & t2855,t2856,t2857,t2858,t2859,t2860,t2861,t2862,t2863,t2864,
     & t2865,t2866,t2867,t2868,t2869,t2870,t2871,t2872,t2873,t2874,
     & t2875,t2876,t2877,t2878,t2879,t2880,t2881,t2882,t2883,t2884,
     & t2885,t2886,t2887,t2888,t2889,t2890,t2891,t2892,t2893,t2894,
     & t2895,t2896,t2897,t2898,t2899,t2900,t2901,t2902,t2903,t2904,
     & t2905,t2906,t2907,t2908,t2909,t2910,t2911,t2912,t2913,t2914,
     & t2915,t2916,t2917,t2918,t2919,t2920,t2921,t2922,t2923,t2924,
     & t2925,t2926,t2927,t2928,t2929,t2930,t2931,t2932,t2933,t2934,
     & t2935,t2936,t2937,t2938,t2939,t2940,t2941,t2942,t2943,t2944,
     & t2945,t2946,t2947,t2948,t2949,t2950,t2951,t2952,t2953,t2954,
     & t2955,t2956,t2957,t2958,t2959,t2960,t2961,t2962,t2963,t2964,
     & t2965,t2966,t2967,t2968,t2969,t2970,t2971,t2972,t2973,t2974,
     & t2975,t2976,t2977,t2978,t2979,t2980,t2981,t2982,t2983,t2984,
     & t2985,t2986,t2987,t2988,t2989,t2990,t2991,t2992,t2993,t2994,
     & t2995,t2996,t2997,t2998,t2999,t3000
       real uu,uur,uus,uut,uurr,uurs,uuss,uurt,uust,uutt,uurrr,uurrs,
     & uurss,uusss,uurrt,uurst,uusst,uurtt,uustt,uuttt,uurrrr,uurrrs,
     & uurrss,uursss,uussss,uurrrt,uurrst,uursst,uussst,uurrtt,uurstt,
     & uusstt,uurttt,uusttt,uutttt,uurrrrr,uurrrrs,uurrrss,uurrsss,
     & uurssss,uusssss,uurrrrt,uurrrst,uurrsst,uurssst,uusssst,
     & uurrrtt,uurrstt,uursstt,uussstt,uurrttt,uursttt,uussttt,
     & uurtttt,uustttt,uuttttt,uurrrrrr,uurrrrrs,uurrrrss,uurrrsss,
     & uurrssss,uursssss,uussssss,uurrrrrt,uurrrrst,uurrrsst,uurrssst,
     & uursssst,uussssst,uurrrrtt,uurrrstt,uurrsstt,uurssstt,uusssstt,
     & uurrrttt,uurrsttt,uurssttt,uusssttt,uurrtttt,uurstttt,uusstttt,
     & uurttttt,uusttttt,uutttttt
       real vv,vvr,vvs,vvt,vvrr,vvrs,vvss,vvrt,vvst,vvtt,vvrrr,vvrrs,
     & vvrss,vvsss,vvrrt,vvrst,vvsst,vvrtt,vvstt,vvttt,vvrrrr,vvrrrs,
     & vvrrss,vvrsss,vvssss,vvrrrt,vvrrst,vvrsst,vvssst,vvrrtt,vvrstt,
     & vvsstt,vvrttt,vvsttt,vvtttt,vvrrrrr,vvrrrrs,vvrrrss,vvrrsss,
     & vvrssss,vvsssss,vvrrrrt,vvrrrst,vvrrsst,vvrssst,vvsssst,
     & vvrrrtt,vvrrstt,vvrsstt,vvssstt,vvrrttt,vvrsttt,vvssttt,
     & vvrtttt,vvstttt,vvttttt,vvrrrrrr,vvrrrrrs,vvrrrrss,vvrrrsss,
     & vvrrssss,vvrsssss,vvssssss,vvrrrrrt,vvrrrrst,vvrrrsst,vvrrssst,
     & vvrsssst,vvssssst,vvrrrrtt,vvrrrstt,vvrrsstt,vvrssstt,vvsssstt,
     & vvrrrttt,vvrrsttt,vvrssttt,vvsssttt,vvrrtttt,vvrstttt,vvsstttt,
     & vvrttttt,vvsttttt,vvtttttt
       real ww,wwr,wws,wwt,wwrr,wwrs,wwss,wwrt,wwst,wwtt,wwrrr,wwrrs,
     & wwrss,wwsss,wwrrt,wwrst,wwsst,wwrtt,wwstt,wwttt,wwrrrr,wwrrrs,
     & wwrrss,wwrsss,wwssss,wwrrrt,wwrrst,wwrsst,wwssst,wwrrtt,wwrstt,
     & wwsstt,wwrttt,wwsttt,wwtttt,wwrrrrr,wwrrrrs,wwrrrss,wwrrsss,
     & wwrssss,wwsssss,wwrrrrt,wwrrrst,wwrrsst,wwrssst,wwsssst,
     & wwrrrtt,wwrrstt,wwrsstt,wwssstt,wwrrttt,wwrsttt,wwssttt,
     & wwrtttt,wwstttt,wwttttt,wwrrrrrr,wwrrrrrs,wwrrrrss,wwrrrsss,
     & wwrrssss,wwrsssss,wwssssss,wwrrrrrt,wwrrrrst,wwrrrsst,wwrrssst,
     & wwrsssst,wwssssst,wwrrrrtt,wwrrrstt,wwrrsstt,wwrssstt,wwsssstt,
     & wwrrrttt,wwrrsttt,wwrssttt,wwsssttt,wwrrtttt,wwrstttt,wwsstttt,
     & wwrttttt,wwsttttt,wwtttttt
       real pp,ppr,pps,ppt,pprr,pprs,ppss,pprt,ppst,pptt,pprrr,pprrs,
     & pprss,ppsss,pprrt,pprst,ppsst,pprtt,ppstt,ppttt,pprrrr,pprrrs,
     & pprrss,pprsss,ppssss,pprrrt,pprrst,pprsst,ppssst,pprrtt,pprstt,
     & ppsstt,pprttt,ppsttt,pptttt,pprrrrr,pprrrrs,pprrrss,pprrsss,
     & pprssss,ppsssss,pprrrrt,pprrrst,pprrsst,pprssst,ppsssst,
     & pprrrtt,pprrstt,pprsstt,ppssstt,pprrttt,pprsttt,ppssttt,
     & pprtttt,ppstttt,ppttttt,pprrrrrr,pprrrrrs,pprrrrss,pprrrsss,
     & pprrssss,pprsssss,ppssssss,pprrrrrt,pprrrrst,pprrrsst,pprrssst,
     & pprsssst,ppssssst,pprrrrtt,pprrrstt,pprrsstt,pprssstt,ppsssstt,
     & pprrrttt,pprrsttt,pprssttt,ppsssttt,pprrtttt,pprstttt,ppsstttt,
     & pprttttt,ppsttttt,pptttttt
       real qq,qqr,qqs,qqt,qqrr,qqrs,qqss,qqrt,qqst,qqtt,qqrrr,qqrrs,
     & qqrss,qqsss,qqrrt,qqrst,qqsst,qqrtt,qqstt,qqttt,qqrrrr,qqrrrs,
     & qqrrss,qqrsss,qqssss,qqrrrt,qqrrst,qqrsst,qqssst,qqrrtt,qqrstt,
     & qqsstt,qqrttt,qqsttt,qqtttt,qqrrrrr,qqrrrrs,qqrrrss,qqrrsss,
     & qqrssss,qqsssss,qqrrrrt,qqrrrst,qqrrsst,qqrssst,qqsssst,
     & qqrrrtt,qqrrstt,qqrsstt,qqssstt,qqrrttt,qqrsttt,qqssttt,
     & qqrtttt,qqstttt,qqttttt,qqrrrrrr,qqrrrrrs,qqrrrrss,qqrrrsss,
     & qqrrssss,qqrsssss,qqssssss,qqrrrrrt,qqrrrrst,qqrrrsst,qqrrssst,
     & qqrsssst,qqssssst,qqrrrrtt,qqrrrstt,qqrrsstt,qqrssstt,qqsssstt,
     & qqrrrttt,qqrrsttt,qqrssttt,qqsssttt,qqrrtttt,qqrstttt,qqsstttt,
     & qqrttttt,qqsttttt,qqtttttt
       real uul,uulr,uuls,uult,uulrr,uulrs,uulss,uulrt,uulst,uultt,
     & uulrrr,uulrrs,uulrss,uulsss,uulrrt,uulrst,uulsst,uulrtt,uulstt,
     & uulttt,uulrrrr,uulrrrs,uulrrss,uulrsss,uulssss,uulrrrt,uulrrst,
     & uulrsst,uulssst,uulrrtt,uulrstt,uulsstt,uulrttt,uulsttt,
     & uultttt,uulrrrrr,uulrrrrs,uulrrrss,uulrrsss,uulrssss,uulsssss,
     & uulrrrrt,uulrrrst,uulrrsst,uulrssst,uulsssst,uulrrrtt,uulrrstt,
     & uulrsstt,uulssstt,uulrrttt,uulrsttt,uulssttt,uulrtttt,uulstttt,
     & uulttttt,uulrrrrrr,uulrrrrrs,uulrrrrss,uulrrrsss,uulrrssss,
     & uulrsssss,uulssssss,uulrrrrrt,uulrrrrst,uulrrrsst,uulrrssst,
     & uulrsssst,uulssssst,uulrrrrtt,uulrrrstt,uulrrsstt,uulrssstt,
     & uulsssstt,uulrrrttt,uulrrsttt,uulrssttt,uulsssttt,uulrrtttt,
     & uulrstttt,uulsstttt,uulrttttt,uulsttttt,uultttttt
       real vvl,vvlr,vvls,vvlt,vvlrr,vvlrs,vvlss,vvlrt,vvlst,vvltt,
     & vvlrrr,vvlrrs,vvlrss,vvlsss,vvlrrt,vvlrst,vvlsst,vvlrtt,vvlstt,
     & vvlttt,vvlrrrr,vvlrrrs,vvlrrss,vvlrsss,vvlssss,vvlrrrt,vvlrrst,
     & vvlrsst,vvlssst,vvlrrtt,vvlrstt,vvlsstt,vvlrttt,vvlsttt,
     & vvltttt,vvlrrrrr,vvlrrrrs,vvlrrrss,vvlrrsss,vvlrssss,vvlsssss,
     & vvlrrrrt,vvlrrrst,vvlrrsst,vvlrssst,vvlsssst,vvlrrrtt,vvlrrstt,
     & vvlrsstt,vvlssstt,vvlrrttt,vvlrsttt,vvlssttt,vvlrtttt,vvlstttt,
     & vvlttttt,vvlrrrrrr,vvlrrrrrs,vvlrrrrss,vvlrrrsss,vvlrrssss,
     & vvlrsssss,vvlssssss,vvlrrrrrt,vvlrrrrst,vvlrrrsst,vvlrrssst,
     & vvlrsssst,vvlssssst,vvlrrrrtt,vvlrrrstt,vvlrrsstt,vvlrssstt,
     & vvlsssstt,vvlrrrttt,vvlrrsttt,vvlrssttt,vvlsssttt,vvlrrtttt,
     & vvlrstttt,vvlsstttt,vvlrttttt,vvlsttttt,vvltttttt
       real wwl,wwlr,wwls,wwlt,wwlrr,wwlrs,wwlss,wwlrt,wwlst,wwltt,
     & wwlrrr,wwlrrs,wwlrss,wwlsss,wwlrrt,wwlrst,wwlsst,wwlrtt,wwlstt,
     & wwlttt,wwlrrrr,wwlrrrs,wwlrrss,wwlrsss,wwlssss,wwlrrrt,wwlrrst,
     & wwlrsst,wwlssst,wwlrrtt,wwlrstt,wwlsstt,wwlrttt,wwlsttt,
     & wwltttt,wwlrrrrr,wwlrrrrs,wwlrrrss,wwlrrsss,wwlrssss,wwlsssss,
     & wwlrrrrt,wwlrrrst,wwlrrsst,wwlrssst,wwlsssst,wwlrrrtt,wwlrrstt,
     & wwlrsstt,wwlssstt,wwlrrttt,wwlrsttt,wwlssttt,wwlrtttt,wwlstttt,
     & wwlttttt,wwlrrrrrr,wwlrrrrrs,wwlrrrrss,wwlrrrsss,wwlrrssss,
     & wwlrsssss,wwlssssss,wwlrrrrrt,wwlrrrrst,wwlrrrsst,wwlrrssst,
     & wwlrsssst,wwlssssst,wwlrrrrtt,wwlrrrstt,wwlrrsstt,wwlrssstt,
     & wwlsssstt,wwlrrrttt,wwlrrsttt,wwlrssttt,wwlsssttt,wwlrrtttt,
     & wwlrstttt,wwlsstttt,wwlrttttt,wwlsttttt,wwltttttt
       real qql,qqlr,qqls,qqlt,qqlrr,qqlrs,qqlss,qqlrt,qqlst,qqltt,
     & qqlrrr,qqlrrs,qqlrss,qqlsss,qqlrrt,qqlrst,qqlsst,qqlrtt,qqlstt,
     & qqlttt,qqlrrrr,qqlrrrs,qqlrrss,qqlrsss,qqlssss,qqlrrrt,qqlrrst,
     & qqlrsst,qqlssst,qqlrrtt,qqlrstt,qqlsstt,qqlrttt,qqlsttt,
     & qqltttt,qqlrrrrr,qqlrrrrs,qqlrrrss,qqlrrsss,qqlrssss,qqlsssss,
     & qqlrrrrt,qqlrrrst,qqlrrsst,qqlrssst,qqlsssst,qqlrrrtt,qqlrrstt,
     & qqlrsstt,qqlssstt,qqlrrttt,qqlrsttt,qqlssttt,qqlrtttt,qqlstttt,
     & qqlttttt,qqlrrrrrr,qqlrrrrrs,qqlrrrrss,qqlrrrsss,qqlrrssss,
     & qqlrsssss,qqlssssss,qqlrrrrrt,qqlrrrrst,qqlrrrsst,qqlrrssst,
     & qqlrsssst,qqlssssst,qqlrrrrtt,qqlrrrstt,qqlrrsstt,qqlrssstt,
     & qqlsssstt,qqlrrrttt,qqlrrsttt,qqlrssttt,qqlsssttt,qqlrrtttt,
     & qqlrstttt,qqlsstttt,qqlrttttt,qqlsttttt,qqltttttt
        real ajrx,ajrxr,ajrxs,ajrxt,ajrxrr,ajrxrs,ajrxss,ajrxrt,ajrxst,
     & ajrxtt,ajrxrrr,ajrxrrs,ajrxrss,ajrxsss,ajrxrrt,ajrxrst,ajrxsst,
     & ajrxrtt,ajrxstt,ajrxttt,ajrxrrrr,ajrxrrrs,ajrxrrss,ajrxrsss,
     & ajrxssss,ajrxrrrt,ajrxrrst,ajrxrsst,ajrxssst,ajrxrrtt,ajrxrstt,
     & ajrxsstt,ajrxrttt,ajrxsttt,ajrxtttt,ajrxrrrrr,ajrxrrrrs,
     & ajrxrrrss,ajrxrrsss,ajrxrssss,ajrxsssss,ajrxrrrrt,ajrxrrrst,
     & ajrxrrsst,ajrxrssst,ajrxsssst,ajrxrrrtt,ajrxrrstt,ajrxrsstt,
     & ajrxssstt,ajrxrrttt,ajrxrsttt,ajrxssttt,ajrxrtttt,ajrxstttt,
     & ajrxttttt,ajrxrrrrrr,ajrxrrrrrs,ajrxrrrrss,ajrxrrrsss,
     & ajrxrrssss,ajrxrsssss,ajrxssssss,ajrxrrrrrt,ajrxrrrrst,
     & ajrxrrrsst,ajrxrrssst,ajrxrsssst,ajrxssssst,ajrxrrrrtt,
     & ajrxrrrstt,ajrxrrsstt,ajrxrssstt,ajrxsssstt,ajrxrrrttt,
     & ajrxrrsttt,ajrxrssttt,ajrxsssttt,ajrxrrtttt,ajrxrstttt,
     & ajrxsstttt,ajrxrttttt,ajrxsttttt,ajrxtttttt
        real ajsx,ajsxr,ajsxs,ajsxt,ajsxrr,ajsxrs,ajsxss,ajsxrt,ajsxst,
     & ajsxtt,ajsxrrr,ajsxrrs,ajsxrss,ajsxsss,ajsxrrt,ajsxrst,ajsxsst,
     & ajsxrtt,ajsxstt,ajsxttt,ajsxrrrr,ajsxrrrs,ajsxrrss,ajsxrsss,
     & ajsxssss,ajsxrrrt,ajsxrrst,ajsxrsst,ajsxssst,ajsxrrtt,ajsxrstt,
     & ajsxsstt,ajsxrttt,ajsxsttt,ajsxtttt,ajsxrrrrr,ajsxrrrrs,
     & ajsxrrrss,ajsxrrsss,ajsxrssss,ajsxsssss,ajsxrrrrt,ajsxrrrst,
     & ajsxrrsst,ajsxrssst,ajsxsssst,ajsxrrrtt,ajsxrrstt,ajsxrsstt,
     & ajsxssstt,ajsxrrttt,ajsxrsttt,ajsxssttt,ajsxrtttt,ajsxstttt,
     & ajsxttttt,ajsxrrrrrr,ajsxrrrrrs,ajsxrrrrss,ajsxrrrsss,
     & ajsxrrssss,ajsxrsssss,ajsxssssss,ajsxrrrrrt,ajsxrrrrst,
     & ajsxrrrsst,ajsxrrssst,ajsxrsssst,ajsxssssst,ajsxrrrrtt,
     & ajsxrrrstt,ajsxrrsstt,ajsxrssstt,ajsxsssstt,ajsxrrrttt,
     & ajsxrrsttt,ajsxrssttt,ajsxsssttt,ajsxrrtttt,ajsxrstttt,
     & ajsxsstttt,ajsxrttttt,ajsxsttttt,ajsxtttttt
        real ajry,ajryr,ajrys,ajryt,ajryrr,ajryrs,ajryss,ajryrt,ajryst,
     & ajrytt,ajryrrr,ajryrrs,ajryrss,ajrysss,ajryrrt,ajryrst,ajrysst,
     & ajryrtt,ajrystt,ajryttt,ajryrrrr,ajryrrrs,ajryrrss,ajryrsss,
     & ajryssss,ajryrrrt,ajryrrst,ajryrsst,ajryssst,ajryrrtt,ajryrstt,
     & ajrysstt,ajryrttt,ajrysttt,ajrytttt,ajryrrrrr,ajryrrrrs,
     & ajryrrrss,ajryrrsss,ajryrssss,ajrysssss,ajryrrrrt,ajryrrrst,
     & ajryrrsst,ajryrssst,ajrysssst,ajryrrrtt,ajryrrstt,ajryrsstt,
     & ajryssstt,ajryrrttt,ajryrsttt,ajryssttt,ajryrtttt,ajrystttt,
     & ajryttttt,ajryrrrrrr,ajryrrrrrs,ajryrrrrss,ajryrrrsss,
     & ajryrrssss,ajryrsssss,ajryssssss,ajryrrrrrt,ajryrrrrst,
     & ajryrrrsst,ajryrrssst,ajryrsssst,ajryssssst,ajryrrrrtt,
     & ajryrrrstt,ajryrrsstt,ajryrssstt,ajrysssstt,ajryrrrttt,
     & ajryrrsttt,ajryrssttt,ajrysssttt,ajryrrtttt,ajryrstttt,
     & ajrysstttt,ajryrttttt,ajrysttttt,ajrytttttt
        real ajsy,ajsyr,ajsys,ajsyt,ajsyrr,ajsyrs,ajsyss,ajsyrt,ajsyst,
     & ajsytt,ajsyrrr,ajsyrrs,ajsyrss,ajsysss,ajsyrrt,ajsyrst,ajsysst,
     & ajsyrtt,ajsystt,ajsyttt,ajsyrrrr,ajsyrrrs,ajsyrrss,ajsyrsss,
     & ajsyssss,ajsyrrrt,ajsyrrst,ajsyrsst,ajsyssst,ajsyrrtt,ajsyrstt,
     & ajsysstt,ajsyrttt,ajsysttt,ajsytttt,ajsyrrrrr,ajsyrrrrs,
     & ajsyrrrss,ajsyrrsss,ajsyrssss,ajsysssss,ajsyrrrrt,ajsyrrrst,
     & ajsyrrsst,ajsyrssst,ajsysssst,ajsyrrrtt,ajsyrrstt,ajsyrsstt,
     & ajsyssstt,ajsyrrttt,ajsyrsttt,ajsyssttt,ajsyrtttt,ajsystttt,
     & ajsyttttt,ajsyrrrrrr,ajsyrrrrrs,ajsyrrrrss,ajsyrrrsss,
     & ajsyrrssss,ajsyrsssss,ajsyssssss,ajsyrrrrrt,ajsyrrrrst,
     & ajsyrrrsst,ajsyrrssst,ajsyrsssst,ajsyssssst,ajsyrrrrtt,
     & ajsyrrrstt,ajsyrrsstt,ajsyrssstt,ajsysssstt,ajsyrrrttt,
     & ajsyrrsttt,ajsyrssttt,ajsysssttt,ajsyrrtttt,ajsyrstttt,
     & ajsysstttt,ajsyrttttt,ajsysttttt,ajsytttttt
        real ajrxx,ajrxy,ajrxz,ajrxxx,ajrxxy,ajrxyy,ajrxxz,ajrxyz,
     & ajrxzz,ajrxxxx,ajrxxxy,ajrxxyy,ajrxyyy,ajrxxxz,ajrxxyz,ajrxyyz,
     & ajrxxzz,ajrxyzz,ajrxzzz,ajrxxxxx,ajrxxxxy,ajrxxxyy,ajrxxyyy,
     & ajrxyyyy,ajrxxxxz,ajrxxxyz,ajrxxyyz,ajrxyyyz,ajrxxxzz,ajrxxyzz,
     & ajrxyyzz,ajrxxzzz,ajrxyzzz,ajrxzzzz,ajrxxxxxx,ajrxxxxxy,
     & ajrxxxxyy,ajrxxxyyy,ajrxxyyyy,ajrxyyyyy,ajrxxxxxz,ajrxxxxyz,
     & ajrxxxyyz,ajrxxyyyz,ajrxyyyyz,ajrxxxxzz,ajrxxxyzz,ajrxxyyzz,
     & ajrxyyyzz,ajrxxxzzz,ajrxxyzzz,ajrxyyzzz,ajrxxzzzz,ajrxyzzzz,
     & ajrxzzzzz,ajrxxxxxxx,ajrxxxxxxy,ajrxxxxxyy,ajrxxxxyyy,
     & ajrxxxyyyy,ajrxxyyyyy,ajrxyyyyyy,ajrxxxxxxz,ajrxxxxxyz,
     & ajrxxxxyyz,ajrxxxyyyz,ajrxxyyyyz,ajrxyyyyyz,ajrxxxxxzz,
     & ajrxxxxyzz,ajrxxxyyzz,ajrxxyyyzz,ajrxyyyyzz,ajrxxxxzzz,
     & ajrxxxyzzz,ajrxxyyzzz,ajrxyyyzzz,ajrxxxzzzz,ajrxxyzzzz,
     & ajrxyyzzzz,ajrxxzzzzz,ajrxyzzzzz,ajrxzzzzzz
        real ajsxx,ajsxy,ajsxz,ajsxxx,ajsxxy,ajsxyy,ajsxxz,ajsxyz,
     & ajsxzz,ajsxxxx,ajsxxxy,ajsxxyy,ajsxyyy,ajsxxxz,ajsxxyz,ajsxyyz,
     & ajsxxzz,ajsxyzz,ajsxzzz,ajsxxxxx,ajsxxxxy,ajsxxxyy,ajsxxyyy,
     & ajsxyyyy,ajsxxxxz,ajsxxxyz,ajsxxyyz,ajsxyyyz,ajsxxxzz,ajsxxyzz,
     & ajsxyyzz,ajsxxzzz,ajsxyzzz,ajsxzzzz,ajsxxxxxx,ajsxxxxxy,
     & ajsxxxxyy,ajsxxxyyy,ajsxxyyyy,ajsxyyyyy,ajsxxxxxz,ajsxxxxyz,
     & ajsxxxyyz,ajsxxyyyz,ajsxyyyyz,ajsxxxxzz,ajsxxxyzz,ajsxxyyzz,
     & ajsxyyyzz,ajsxxxzzz,ajsxxyzzz,ajsxyyzzz,ajsxxzzzz,ajsxyzzzz,
     & ajsxzzzzz,ajsxxxxxxx,ajsxxxxxxy,ajsxxxxxyy,ajsxxxxyyy,
     & ajsxxxyyyy,ajsxxyyyyy,ajsxyyyyyy,ajsxxxxxxz,ajsxxxxxyz,
     & ajsxxxxyyz,ajsxxxyyyz,ajsxxyyyyz,ajsxyyyyyz,ajsxxxxxzz,
     & ajsxxxxyzz,ajsxxxyyzz,ajsxxyyyzz,ajsxyyyyzz,ajsxxxxzzz,
     & ajsxxxyzzz,ajsxxyyzzz,ajsxyyyzzz,ajsxxxzzzz,ajsxxyzzzz,
     & ajsxyyzzzz,ajsxxzzzzz,ajsxyzzzzz,ajsxzzzzzz
        real ajryx,ajryy,ajryz,ajryxx,ajryxy,ajryyy,ajryxz,ajryyz,
     & ajryzz,ajryxxx,ajryxxy,ajryxyy,ajryyyy,ajryxxz,ajryxyz,ajryyyz,
     & ajryxzz,ajryyzz,ajryzzz,ajryxxxx,ajryxxxy,ajryxxyy,ajryxyyy,
     & ajryyyyy,ajryxxxz,ajryxxyz,ajryxyyz,ajryyyyz,ajryxxzz,ajryxyzz,
     & ajryyyzz,ajryxzzz,ajryyzzz,ajryzzzz,ajryxxxxx,ajryxxxxy,
     & ajryxxxyy,ajryxxyyy,ajryxyyyy,ajryyyyyy,ajryxxxxz,ajryxxxyz,
     & ajryxxyyz,ajryxyyyz,ajryyyyyz,ajryxxxzz,ajryxxyzz,ajryxyyzz,
     & ajryyyyzz,ajryxxzzz,ajryxyzzz,ajryyyzzz,ajryxzzzz,ajryyzzzz,
     & ajryzzzzz,ajryxxxxxx,ajryxxxxxy,ajryxxxxyy,ajryxxxyyy,
     & ajryxxyyyy,ajryxyyyyy,ajryyyyyyy,ajryxxxxxz,ajryxxxxyz,
     & ajryxxxyyz,ajryxxyyyz,ajryxyyyyz,ajryyyyyyz,ajryxxxxzz,
     & ajryxxxyzz,ajryxxyyzz,ajryxyyyzz,ajryyyyyzz,ajryxxxzzz,
     & ajryxxyzzz,ajryxyyzzz,ajryyyyzzz,ajryxxzzzz,ajryxyzzzz,
     & ajryyyzzzz,ajryxzzzzz,ajryyzzzzz,ajryzzzzzz
        real ajsyx,ajsyy,ajsyz,ajsyxx,ajsyxy,ajsyyy,ajsyxz,ajsyyz,
     & ajsyzz,ajsyxxx,ajsyxxy,ajsyxyy,ajsyyyy,ajsyxxz,ajsyxyz,ajsyyyz,
     & ajsyxzz,ajsyyzz,ajsyzzz,ajsyxxxx,ajsyxxxy,ajsyxxyy,ajsyxyyy,
     & ajsyyyyy,ajsyxxxz,ajsyxxyz,ajsyxyyz,ajsyyyyz,ajsyxxzz,ajsyxyzz,
     & ajsyyyzz,ajsyxzzz,ajsyyzzz,ajsyzzzz,ajsyxxxxx,ajsyxxxxy,
     & ajsyxxxyy,ajsyxxyyy,ajsyxyyyy,ajsyyyyyy,ajsyxxxxz,ajsyxxxyz,
     & ajsyxxyyz,ajsyxyyyz,ajsyyyyyz,ajsyxxxzz,ajsyxxyzz,ajsyxyyzz,
     & ajsyyyyzz,ajsyxxzzz,ajsyxyzzz,ajsyyyzzz,ajsyxzzzz,ajsyyzzzz,
     & ajsyzzzzz,ajsyxxxxxx,ajsyxxxxxy,ajsyxxxxyy,ajsyxxxyyy,
     & ajsyxxyyyy,ajsyxyyyyy,ajsyyyyyyy,ajsyxxxxxz,ajsyxxxxyz,
     & ajsyxxxyyz,ajsyxxyyyz,ajsyxyyyyz,ajsyyyyyyz,ajsyxxxxzz,
     & ajsyxxxyzz,ajsyxxyyzz,ajsyxyyyzz,ajsyyyyyzz,ajsyxxxzzz,
     & ajsyxxyzzz,ajsyxyyzzz,ajsyyyyzzz,ajsyxxzzzz,ajsyxyzzzz,
     & ajsyyyzzzz,ajsyxzzzzz,ajsyyzzzzz,ajsyzzzzzz
        real ajrz,ajrzr,ajrzs,ajrzt,ajrzrr,ajrzrs,ajrzss,ajrzrt,ajrzst,
     & ajrztt,ajrzrrr,ajrzrrs,ajrzrss,ajrzsss,ajrzrrt,ajrzrst,ajrzsst,
     & ajrzrtt,ajrzstt,ajrzttt,ajrzrrrr,ajrzrrrs,ajrzrrss,ajrzrsss,
     & ajrzssss,ajrzrrrt,ajrzrrst,ajrzrsst,ajrzssst,ajrzrrtt,ajrzrstt,
     & ajrzsstt,ajrzrttt,ajrzsttt,ajrztttt,ajrzrrrrr,ajrzrrrrs,
     & ajrzrrrss,ajrzrrsss,ajrzrssss,ajrzsssss,ajrzrrrrt,ajrzrrrst,
     & ajrzrrsst,ajrzrssst,ajrzsssst,ajrzrrrtt,ajrzrrstt,ajrzrsstt,
     & ajrzssstt,ajrzrrttt,ajrzrsttt,ajrzssttt,ajrzrtttt,ajrzstttt,
     & ajrzttttt,ajrzrrrrrr,ajrzrrrrrs,ajrzrrrrss,ajrzrrrsss,
     & ajrzrrssss,ajrzrsssss,ajrzssssss,ajrzrrrrrt,ajrzrrrrst,
     & ajrzrrrsst,ajrzrrssst,ajrzrsssst,ajrzssssst,ajrzrrrrtt,
     & ajrzrrrstt,ajrzrrsstt,ajrzrssstt,ajrzsssstt,ajrzrrrttt,
     & ajrzrrsttt,ajrzrssttt,ajrzsssttt,ajrzrrtttt,ajrzrstttt,
     & ajrzsstttt,ajrzrttttt,ajrzsttttt,ajrztttttt
        real ajsz,ajszr,ajszs,ajszt,ajszrr,ajszrs,ajszss,ajszrt,ajszst,
     & ajsztt,ajszrrr,ajszrrs,ajszrss,ajszsss,ajszrrt,ajszrst,ajszsst,
     & ajszrtt,ajszstt,ajszttt,ajszrrrr,ajszrrrs,ajszrrss,ajszrsss,
     & ajszssss,ajszrrrt,ajszrrst,ajszrsst,ajszssst,ajszrrtt,ajszrstt,
     & ajszsstt,ajszrttt,ajszsttt,ajsztttt,ajszrrrrr,ajszrrrrs,
     & ajszrrrss,ajszrrsss,ajszrssss,ajszsssss,ajszrrrrt,ajszrrrst,
     & ajszrrsst,ajszrssst,ajszsssst,ajszrrrtt,ajszrrstt,ajszrsstt,
     & ajszssstt,ajszrrttt,ajszrsttt,ajszssttt,ajszrtttt,ajszstttt,
     & ajszttttt,ajszrrrrrr,ajszrrrrrs,ajszrrrrss,ajszrrrsss,
     & ajszrrssss,ajszrsssss,ajszssssss,ajszrrrrrt,ajszrrrrst,
     & ajszrrrsst,ajszrrssst,ajszrsssst,ajszssssst,ajszrrrrtt,
     & ajszrrrstt,ajszrrsstt,ajszrssstt,ajszsssstt,ajszrrrttt,
     & ajszrrsttt,ajszrssttt,ajszsssttt,ajszrrtttt,ajszrstttt,
     & ajszsstttt,ajszrttttt,ajszsttttt,ajsztttttt
        real ajtx,ajtxr,ajtxs,ajtxt,ajtxrr,ajtxrs,ajtxss,ajtxrt,ajtxst,
     & ajtxtt,ajtxrrr,ajtxrrs,ajtxrss,ajtxsss,ajtxrrt,ajtxrst,ajtxsst,
     & ajtxrtt,ajtxstt,ajtxttt,ajtxrrrr,ajtxrrrs,ajtxrrss,ajtxrsss,
     & ajtxssss,ajtxrrrt,ajtxrrst,ajtxrsst,ajtxssst,ajtxrrtt,ajtxrstt,
     & ajtxsstt,ajtxrttt,ajtxsttt,ajtxtttt,ajtxrrrrr,ajtxrrrrs,
     & ajtxrrrss,ajtxrrsss,ajtxrssss,ajtxsssss,ajtxrrrrt,ajtxrrrst,
     & ajtxrrsst,ajtxrssst,ajtxsssst,ajtxrrrtt,ajtxrrstt,ajtxrsstt,
     & ajtxssstt,ajtxrrttt,ajtxrsttt,ajtxssttt,ajtxrtttt,ajtxstttt,
     & ajtxttttt,ajtxrrrrrr,ajtxrrrrrs,ajtxrrrrss,ajtxrrrsss,
     & ajtxrrssss,ajtxrsssss,ajtxssssss,ajtxrrrrrt,ajtxrrrrst,
     & ajtxrrrsst,ajtxrrssst,ajtxrsssst,ajtxssssst,ajtxrrrrtt,
     & ajtxrrrstt,ajtxrrsstt,ajtxrssstt,ajtxsssstt,ajtxrrrttt,
     & ajtxrrsttt,ajtxrssttt,ajtxsssttt,ajtxrrtttt,ajtxrstttt,
     & ajtxsstttt,ajtxrttttt,ajtxsttttt,ajtxtttttt
        real ajty,ajtyr,ajtys,ajtyt,ajtyrr,ajtyrs,ajtyss,ajtyrt,ajtyst,
     & ajtytt,ajtyrrr,ajtyrrs,ajtyrss,ajtysss,ajtyrrt,ajtyrst,ajtysst,
     & ajtyrtt,ajtystt,ajtyttt,ajtyrrrr,ajtyrrrs,ajtyrrss,ajtyrsss,
     & ajtyssss,ajtyrrrt,ajtyrrst,ajtyrsst,ajtyssst,ajtyrrtt,ajtyrstt,
     & ajtysstt,ajtyrttt,ajtysttt,ajtytttt,ajtyrrrrr,ajtyrrrrs,
     & ajtyrrrss,ajtyrrsss,ajtyrssss,ajtysssss,ajtyrrrrt,ajtyrrrst,
     & ajtyrrsst,ajtyrssst,ajtysssst,ajtyrrrtt,ajtyrrstt,ajtyrsstt,
     & ajtyssstt,ajtyrrttt,ajtyrsttt,ajtyssttt,ajtyrtttt,ajtystttt,
     & ajtyttttt,ajtyrrrrrr,ajtyrrrrrs,ajtyrrrrss,ajtyrrrsss,
     & ajtyrrssss,ajtyrsssss,ajtyssssss,ajtyrrrrrt,ajtyrrrrst,
     & ajtyrrrsst,ajtyrrssst,ajtyrsssst,ajtyssssst,ajtyrrrrtt,
     & ajtyrrrstt,ajtyrrsstt,ajtyrssstt,ajtysssstt,ajtyrrrttt,
     & ajtyrrsttt,ajtyrssttt,ajtysssttt,ajtyrrtttt,ajtyrstttt,
     & ajtysstttt,ajtyrttttt,ajtysttttt,ajtytttttt
        real ajtz,ajtzr,ajtzs,ajtzt,ajtzrr,ajtzrs,ajtzss,ajtzrt,ajtzst,
     & ajtztt,ajtzrrr,ajtzrrs,ajtzrss,ajtzsss,ajtzrrt,ajtzrst,ajtzsst,
     & ajtzrtt,ajtzstt,ajtzttt,ajtzrrrr,ajtzrrrs,ajtzrrss,ajtzrsss,
     & ajtzssss,ajtzrrrt,ajtzrrst,ajtzrsst,ajtzssst,ajtzrrtt,ajtzrstt,
     & ajtzsstt,ajtzrttt,ajtzsttt,ajtztttt,ajtzrrrrr,ajtzrrrrs,
     & ajtzrrrss,ajtzrrsss,ajtzrssss,ajtzsssss,ajtzrrrrt,ajtzrrrst,
     & ajtzrrsst,ajtzrssst,ajtzsssst,ajtzrrrtt,ajtzrrstt,ajtzrsstt,
     & ajtzssstt,ajtzrrttt,ajtzrsttt,ajtzssttt,ajtzrtttt,ajtzstttt,
     & ajtzttttt,ajtzrrrrrr,ajtzrrrrrs,ajtzrrrrss,ajtzrrrsss,
     & ajtzrrssss,ajtzrsssss,ajtzssssss,ajtzrrrrrt,ajtzrrrrst,
     & ajtzrrrsst,ajtzrrssst,ajtzrsssst,ajtzssssst,ajtzrrrrtt,
     & ajtzrrrstt,ajtzrrsstt,ajtzrssstt,ajtzsssstt,ajtzrrrttt,
     & ajtzrrsttt,ajtzrssttt,ajtzsssttt,ajtzrrtttt,ajtzrstttt,
     & ajtzsstttt,ajtzrttttt,ajtzsttttt,ajtztttttt
        real ajrzx,ajrzy,ajrzz,ajrzxx,ajrzxy,ajrzyy,ajrzxz,ajrzyz,
     & ajrzzz,ajrzxxx,ajrzxxy,ajrzxyy,ajrzyyy,ajrzxxz,ajrzxyz,ajrzyyz,
     & ajrzxzz,ajrzyzz,ajrzzzz,ajrzxxxx,ajrzxxxy,ajrzxxyy,ajrzxyyy,
     & ajrzyyyy,ajrzxxxz,ajrzxxyz,ajrzxyyz,ajrzyyyz,ajrzxxzz,ajrzxyzz,
     & ajrzyyzz,ajrzxzzz,ajrzyzzz,ajrzzzzz,ajrzxxxxx,ajrzxxxxy,
     & ajrzxxxyy,ajrzxxyyy,ajrzxyyyy,ajrzyyyyy,ajrzxxxxz,ajrzxxxyz,
     & ajrzxxyyz,ajrzxyyyz,ajrzyyyyz,ajrzxxxzz,ajrzxxyzz,ajrzxyyzz,
     & ajrzyyyzz,ajrzxxzzz,ajrzxyzzz,ajrzyyzzz,ajrzxzzzz,ajrzyzzzz,
     & ajrzzzzzz,ajrzxxxxxx,ajrzxxxxxy,ajrzxxxxyy,ajrzxxxyyy,
     & ajrzxxyyyy,ajrzxyyyyy,ajrzyyyyyy,ajrzxxxxxz,ajrzxxxxyz,
     & ajrzxxxyyz,ajrzxxyyyz,ajrzxyyyyz,ajrzyyyyyz,ajrzxxxxzz,
     & ajrzxxxyzz,ajrzxxyyzz,ajrzxyyyzz,ajrzyyyyzz,ajrzxxxzzz,
     & ajrzxxyzzz,ajrzxyyzzz,ajrzyyyzzz,ajrzxxzzzz,ajrzxyzzzz,
     & ajrzyyzzzz,ajrzxzzzzz,ajrzyzzzzz,ajrzzzzzzz
        real ajszx,ajszy,ajszz,ajszxx,ajszxy,ajszyy,ajszxz,ajszyz,
     & ajszzz,ajszxxx,ajszxxy,ajszxyy,ajszyyy,ajszxxz,ajszxyz,ajszyyz,
     & ajszxzz,ajszyzz,ajszzzz,ajszxxxx,ajszxxxy,ajszxxyy,ajszxyyy,
     & ajszyyyy,ajszxxxz,ajszxxyz,ajszxyyz,ajszyyyz,ajszxxzz,ajszxyzz,
     & ajszyyzz,ajszxzzz,ajszyzzz,ajszzzzz,ajszxxxxx,ajszxxxxy,
     & ajszxxxyy,ajszxxyyy,ajszxyyyy,ajszyyyyy,ajszxxxxz,ajszxxxyz,
     & ajszxxyyz,ajszxyyyz,ajszyyyyz,ajszxxxzz,ajszxxyzz,ajszxyyzz,
     & ajszyyyzz,ajszxxzzz,ajszxyzzz,ajszyyzzz,ajszxzzzz,ajszyzzzz,
     & ajszzzzzz,ajszxxxxxx,ajszxxxxxy,ajszxxxxyy,ajszxxxyyy,
     & ajszxxyyyy,ajszxyyyyy,ajszyyyyyy,ajszxxxxxz,ajszxxxxyz,
     & ajszxxxyyz,ajszxxyyyz,ajszxyyyyz,ajszyyyyyz,ajszxxxxzz,
     & ajszxxxyzz,ajszxxyyzz,ajszxyyyzz,ajszyyyyzz,ajszxxxzzz,
     & ajszxxyzzz,ajszxyyzzz,ajszyyyzzz,ajszxxzzzz,ajszxyzzzz,
     & ajszyyzzzz,ajszxzzzzz,ajszyzzzzz,ajszzzzzzz
        real ajtxx,ajtxy,ajtxz,ajtxxx,ajtxxy,ajtxyy,ajtxxz,ajtxyz,
     & ajtxzz,ajtxxxx,ajtxxxy,ajtxxyy,ajtxyyy,ajtxxxz,ajtxxyz,ajtxyyz,
     & ajtxxzz,ajtxyzz,ajtxzzz,ajtxxxxx,ajtxxxxy,ajtxxxyy,ajtxxyyy,
     & ajtxyyyy,ajtxxxxz,ajtxxxyz,ajtxxyyz,ajtxyyyz,ajtxxxzz,ajtxxyzz,
     & ajtxyyzz,ajtxxzzz,ajtxyzzz,ajtxzzzz,ajtxxxxxx,ajtxxxxxy,
     & ajtxxxxyy,ajtxxxyyy,ajtxxyyyy,ajtxyyyyy,ajtxxxxxz,ajtxxxxyz,
     & ajtxxxyyz,ajtxxyyyz,ajtxyyyyz,ajtxxxxzz,ajtxxxyzz,ajtxxyyzz,
     & ajtxyyyzz,ajtxxxzzz,ajtxxyzzz,ajtxyyzzz,ajtxxzzzz,ajtxyzzzz,
     & ajtxzzzzz,ajtxxxxxxx,ajtxxxxxxy,ajtxxxxxyy,ajtxxxxyyy,
     & ajtxxxyyyy,ajtxxyyyyy,ajtxyyyyyy,ajtxxxxxxz,ajtxxxxxyz,
     & ajtxxxxyyz,ajtxxxyyyz,ajtxxyyyyz,ajtxyyyyyz,ajtxxxxxzz,
     & ajtxxxxyzz,ajtxxxyyzz,ajtxxyyyzz,ajtxyyyyzz,ajtxxxxzzz,
     & ajtxxxyzzz,ajtxxyyzzz,ajtxyyyzzz,ajtxxxzzzz,ajtxxyzzzz,
     & ajtxyyzzzz,ajtxxzzzzz,ajtxyzzzzz,ajtxzzzzzz
        real ajtyx,ajtyy,ajtyz,ajtyxx,ajtyxy,ajtyyy,ajtyxz,ajtyyz,
     & ajtyzz,ajtyxxx,ajtyxxy,ajtyxyy,ajtyyyy,ajtyxxz,ajtyxyz,ajtyyyz,
     & ajtyxzz,ajtyyzz,ajtyzzz,ajtyxxxx,ajtyxxxy,ajtyxxyy,ajtyxyyy,
     & ajtyyyyy,ajtyxxxz,ajtyxxyz,ajtyxyyz,ajtyyyyz,ajtyxxzz,ajtyxyzz,
     & ajtyyyzz,ajtyxzzz,ajtyyzzz,ajtyzzzz,ajtyxxxxx,ajtyxxxxy,
     & ajtyxxxyy,ajtyxxyyy,ajtyxyyyy,ajtyyyyyy,ajtyxxxxz,ajtyxxxyz,
     & ajtyxxyyz,ajtyxyyyz,ajtyyyyyz,ajtyxxxzz,ajtyxxyzz,ajtyxyyzz,
     & ajtyyyyzz,ajtyxxzzz,ajtyxyzzz,ajtyyyzzz,ajtyxzzzz,ajtyyzzzz,
     & ajtyzzzzz,ajtyxxxxxx,ajtyxxxxxy,ajtyxxxxyy,ajtyxxxyyy,
     & ajtyxxyyyy,ajtyxyyyyy,ajtyyyyyyy,ajtyxxxxxz,ajtyxxxxyz,
     & ajtyxxxyyz,ajtyxxyyyz,ajtyxyyyyz,ajtyyyyyyz,ajtyxxxxzz,
     & ajtyxxxyzz,ajtyxxyyzz,ajtyxyyyzz,ajtyyyyyzz,ajtyxxxzzz,
     & ajtyxxyzzz,ajtyxyyzzz,ajtyyyyzzz,ajtyxxzzzz,ajtyxyzzzz,
     & ajtyyyzzzz,ajtyxzzzzz,ajtyyzzzzz,ajtyzzzzzz
        real ajtzx,ajtzy,ajtzz,ajtzxx,ajtzxy,ajtzyy,ajtzxz,ajtzyz,
     & ajtzzz,ajtzxxx,ajtzxxy,ajtzxyy,ajtzyyy,ajtzxxz,ajtzxyz,ajtzyyz,
     & ajtzxzz,ajtzyzz,ajtzzzz,ajtzxxxx,ajtzxxxy,ajtzxxyy,ajtzxyyy,
     & ajtzyyyy,ajtzxxxz,ajtzxxyz,ajtzxyyz,ajtzyyyz,ajtzxxzz,ajtzxyzz,
     & ajtzyyzz,ajtzxzzz,ajtzyzzz,ajtzzzzz,ajtzxxxxx,ajtzxxxxy,
     & ajtzxxxyy,ajtzxxyyy,ajtzxyyyy,ajtzyyyyy,ajtzxxxxz,ajtzxxxyz,
     & ajtzxxyyz,ajtzxyyyz,ajtzyyyyz,ajtzxxxzz,ajtzxxyzz,ajtzxyyzz,
     & ajtzyyyzz,ajtzxxzzz,ajtzxyzzz,ajtzyyzzz,ajtzxzzzz,ajtzyzzzz,
     & ajtzzzzzz,ajtzxxxxxx,ajtzxxxxxy,ajtzxxxxyy,ajtzxxxyyy,
     & ajtzxxyyyy,ajtzxyyyyy,ajtzyyyyyy,ajtzxxxxxz,ajtzxxxxyz,
     & ajtzxxxyyz,ajtzxxyyyz,ajtzxyyyyz,ajtzyyyyyz,ajtzxxxxzz,
     & ajtzxxxyzz,ajtzxxyyzz,ajtzxyyyzz,ajtzyyyyzz,ajtzxxxzzz,
     & ajtzxxyzzz,ajtzxyyzzz,ajtzyyyzzz,ajtzxxzzzz,ajtzxyzzzz,
     & ajtzyyzzzz,ajtzxzzzzz,ajtzyzzzzz,ajtzzzzzzz
       real radi
       real yyCoeff(0:maxWidthDim-1)
       integer bc0
       real scale,dsgT
       real K0ph,K0mh,K1ph,K1mh,K2ph,K2mh
       real Kzzm,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz,Kzzp
       real ajzzm,ajzmz,ajmzz,ajzzz,ajpzz,ajzpz,ajzzp
       real au11ph,au11mh,au22ph,au22mh,au33ph,au33mh,au11mzz,au11zzz,
     & au11pzz,au22zmz,au22zzz,au22zpz,au33zzm,au33zzz,au33zzp,
     & au12pzz,au12zzz,au12mzz,au13pzz,au13zzz,au13mzz,au21zpz,
     & au21zzz,au21zmz,au23zpz,au23zzz,au23zmz,au31zzp,au31zzz,
     & au31zzm,au32zzp,au32zzz,au32zzm
      integer maxOrderOfExtrapolation
      parameter( maxOrderOfExtrapolation=9 )
      real extrapCoeff(0:maxOrderOfExtrapolation,
     & 1:maxOrderOfExtrapolation)
      integer numberOfComponents
      real mixedRHS,mixedCoeff,mixedNormalCoeff,a0,a1
      real rhopc,rhov,   Cppc, Cpv, thermalKpc, thermalKv, Kx, Ky, Kz, 
     & Kr, Ks, Kt
      !     --- begin statement functions
      rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
      ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
      rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
      sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
      sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
      sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
      tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
      ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
      tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)
      ! c=component, e=equation
      ! ncc = number of components for coefficients 
      mce2(m1,m2,m3,c,e) = ma2(m1,m2,m3) + stencilSize*(c+ncc*e)
      mce3(m1,m2,m3,c,e) = ma3(m1,m2,m3) + stencilSize*(c+ncc*e)
      ce(c,e) = stencilSize*(c+ncc*e)
      ! statement functions to access coefficients of mixed-boundary conditions
      mixedRHS(c,side,axis,grid)         =bcData(c+numberOfComponents*(
     & 0),side,axis,grid)
      mixedCoeff(c,side,axis,grid)       =bcData(c+numberOfComponents*(
     & 1),side,axis,grid)
      mixedNormalCoeff(c,side,axis,grid) =bcData(c+numberOfComponents*(
     & 2),side,axis,grid)
      ! -- statement functions for variable material properties
      ! (rho,Cp,k) for materialFormat=piecewiseConstantMaterialProperties
      rhopc(i1,i2,i3)      = matValpc( 0, matIndex(i1,i2,i3))
      Cppc(i1,i2,i3)       = matValpc( 1, matIndex(i1,i2,i3))
      thermalKpc(i1,i2,i3) = matValpc( 2, matIndex(i1,i2,i3))
      ! (rho,Cp,k) for materialFormat=variableMaterialProperties
      rhov(i1,i2,i3)      = matVal(i1,i2,i3,0)
      Cpv(i1,i2,i3)       = matVal(i1,i2,i3,1)
      thermalKv(i1,i2,i3) = matVal(i1,i2,i3,2)
      !     --- end statement functions
      data extrapCoeff/                                         1.,-1.,
     & 0.,0.,0.,0.,0.,0.,0.,0.,          1.,-2.,1.,0.,0.,0.,0.,0.,0.,
     & 0.,          1.,-3.,3.,-1.,0.,0.,0.,0.,0.,0.,         1.,-4.,
     & 6.,-4.,1.,0.,0.,0.,0.,0.,         1.,-5.,10.,-10.,5.,-1.,0.,0.,
     & 0.,0.,      1.,-6.,15.,-20.,15.,-6.,1.,0.,0.,0., 1.,-7.,21.,-
     & 35.,35.,-21.,7.,-1.,0.,0., 1.,-8.,28.,-56.,70.,-56.,28.,-8.,1.,
     & 0.,          1.,-9.,36.,-84.,126.,-126.,84.,-36.,9.,-1./
      ierr=0
      ! write(*,'("Inside insdt: gridType=",i2)') gridType
      n1a                =ipar(0)
      n1b                =ipar(1)
      n2a                =ipar(2)
      n2b                =ipar(3)
      n3a                =ipar(4)
      n3b                =ipar(5)
      pc                 =ipar(6)
      uc                 =ipar(7)
      vc                 =ipar(8)
      wc                 =ipar(9)
      nc                 =ipar(10)
      sc                 =ipar(11)
      tc                 =ipar(12)
      grid               =ipar(13)
      orderOfAccuracy    =ipar(14)
      gridIsMoving       =ipar(15) ! *************
      implicitVariation  =ipar(16) ! **new**
      fillCoefficients   =ipar(17) ! new
      evalRightHandSide  =ipar(18) ! new
      gridIsImplicit     =ipar(19)
      implicitMethod     =ipar(20)
      implicitOption     =ipar(21)
      isAxisymmetric     =ipar(22)
      use2ndOrderAD      =ipar(23)
      use4thOrderAD      =ipar(24)
      advectPassiveScalar=ipar(25)
      gridType           =ipar(26)
      turbulenceModel    =ipar(27)
      pdeModel           =ipar(28)
      numberOfComponentsForCoefficients =ipar(29) ! number of components for coefficients
      stencilSize        =ipar(30)
      equationOffset        = ipar(31)
      equationNumberBase1   = ipar(32)
      equationNumberLength1 = ipar(33)
      equationNumberBase2   = ipar(34)
      equationNumberLength2 = ipar(35)
      equationNumberBase3   = ipar(36)
      equationNumberLength3 = ipar(37)
      indexRange(0,0)    =ipar(38)
      indexRange(1,0)    =ipar(39)
      indexRange(0,1)    =ipar(40)
      indexRange(1,1)    =ipar(41)
      indexRange(0,2)    =ipar(42)
      indexRange(1,2)    =ipar(43)
      orderOfExtrapolation=ipar(44)
      orderOfExtrapolationForOutflow=ipar(45)
      evalResidual      = ipar(46)
      evalResidualForBoundaryConditions=ipar(47)
      debug             = ipar(48)
      numberOfComponents= ipar(49)
      rc                =ipar(50)
      materialFormat    =ipar(51)
      useAddedMassAlgorithm = ipar(52)
      projectAddedMassVelocity = ipar(53)
      useImplicitAmpBCs = ipar(54)
      isBulkSolid       = ipar(55)
      dr(0)             =rpar(0)
      dr(1)             =rpar(1)
      dr(2)             =rpar(2)
      dx(0)             =rpar(3)
      dx(1)             =rpar(4)
      dx(2)             =rpar(5)
      dt                =rpar(6) ! **new**
      implicitFactor    =rpar(7) ! **new**
      nu                =rpar(8)
      ad21              =rpar(9)
      ad22              =rpar(10)
      ad41              =rpar(11)
      ad42              =rpar(12)
      nuPassiveScalar   =rpar(13)
      adcPassiveScalar  =rpar(14)
      ad21n             =rpar(15)
      ad22n             =rpar(16)
      ad41n             =rpar(17)
      ad42n             =rpar(18)
      yEps              =rpar(19) ! for axisymmetric
      gravity(0)        =rpar(20)
      gravity(1)        =rpar(21)
      gravity(2)        =rpar(22)
      thermalExpansivity=rpar(23)
      adcBoussinesq     =rpar(24) ! coefficient of artificial diffusion for Boussinesq T equation
      kThermal          =rpar(25)
      ! The AMP BC requires zs and alpha
      zs                =rpar(26)
      alpha             =rpar(27)
      fluidDensity      =rpar(28)
      mu = nu*fluidDensity
      epsX = 1.e-30  ! epsilon used to avoid division by zero in the normal computation -- should be REAL_MIN*100 ??
      normalTol=1.e-10  ! tolerance for a face being flat
      ncc=numberOfComponentsForCoefficients ! number of components for coefficients
      ! Some Bc's like no-slip wall use extrapolation for ghost, sometimes we turn this off
      extrapolateGhostByDefault=1
      ok = getInt(pdb,'checkForInflowAtOutFlow',
     & checkForInflowAtOutFlow)
      if( ok.eq.0 )then
        write(*,'("*** insImpINS:ERROR: checkForInflowAtOutFlow NOT 
     & FOUND")')
      else
        if( debug.gt.4 )then
         write(*,'("*** insImpINS:checkForInflowAtOutFlow=",i6)') 
     & checkForInflowAtOutFlow
        end if
      end if
      ok = getInt(pdb,'outflowOption',outflowOption)
      if( ok.eq.0 )then
        write(*,'("*** insImpINS:ERROR: outflowOption NOT FOUND")')
      else
        if( debug.gt.4 )then
         write(*,'("*** insImpINS:outflowOption=",i6)') outflowOption
        end if
      end if
      ok = getReal(pdb,'advectionCoefficient',advectionCoefficient)
      if( ok.eq.0 )then
        write(*,'("*** insImpINS:ERROR: advectionCoefficient NOT 
     & FOUND")')
      else
        if( debug.gt.4 )then
         write(*,'("*** insImpINS:advectionCoefficient=",f5.2)') 
     & advectionCoefficient
        end if
      end if
      ok = getInt(pdb,'vsc',vsc)
      if( ok.eq.0 )then
        write(*,'("*** insImpINS:ERROR: vsc NOT FOUND")')
      end if
      ntdc = nd   ! number of time dependent components
      if( pdeModel.eq.BoussinesqModel .or. 
     & pdeModel.eq.viscoPlasticModel )then
       ntdc = ntdc+1   ! include Temperature
      end if
      kc=nc
      ec=kc+1
      ok = getInt(pdb,'fillCoefficientsScalarSystem',
     & fillCoefficientsScalarSystem)
      if( ok.eq.0 )then
        write(*,'("*** insImpINS:ERROR: fillCoefficientsScalarSystem 
     & NOT FOUND")')
      else
        if( debug.gt.4 )then
         write(*,'("*** insImpINS:fillCoefficientsScalarSystem=",i6)') 
     & fillCoefficientsScalarSystem
        end if
      end if
      if( orderOfAccuracy.ne.2 .and. orderOfAccuracy.ne.4 )then
        write(*,'("insImpINS:ERROR orderOfAccuracy=",i6)') 
     & orderOfAccuracy
        stop 1
      end if
      if( gridType.ne.rectangular .and. gridType.ne.curvilinear )then
        write(*,'("insImpINS:ERROR gridType=",i6)') gridType
        stop 2
      end if
      if( uc.lt.0 .or. vc.lt.0 .or. (nd.eq.3 .and. wc.lt.0) )then
        write(*,'("insImpINS:ERROR uc,vc,ws=",3i6)') uc,vc,wc
        stop 4
      end if
!      write(*,'("insImpINS: turbulenceModel=",2i6)') turbulenceModel
!      write(*,'("insImpINS: nd,uc,vc,wc,kc=",2i6)') nd,uc,vc,wc,kc
      if( turbulenceModel.eq.kEpsilon .and. (kc.lt.uc+nd .or. 
     & kc.gt.1000) )then
        write(*,'("insImpINS:ERROR in kc: nd,uc,vc,wc,kc=",2i6)') nd,
     & uc,vc,wc,kc
        stop 5
      end if
! *****************************************************************************************************8
      ! ** it did not affect performance to use an array to index coeff ***
      width = orderOfAccuracy+1      ! width of the MATRIX stencil   *********** fix this **********
      halfWidth = (width-1)/2
      if( nd.eq.2 )then
       halfWidth3=0
       do i2=-halfWidth,halfWidth
         do i1=-halfWidth,halfWidth
          ma2(i1,i2,0)=i1+halfWidth+width*(i2+halfWidth)
         end do
       end do
      else if( nd.eq.3 )then
       halfWidth3=halfWidth
       do i3=-halfWidth,halfWidth
         do i2=-halfWidth,halfWidth
           do i1=-halfWidth,halfWidth
             ma3(i1,i2,i3)=i1+halfWidth+width*(i2+halfWidth+width*(i3+
     & halfWidth))
           end do
         end do
       end do
      end if
      do e=0,5
      do c=0,5
        if( e.eq.c )then
          delta(c,e)=1.
        else
        delta(c,e)=0.
        end if
      end do
      end do
      do m=0,2
       dxvsqi(m)=1./(dx(m)**2)
      end do
      if( use2ndOrderAD.ne.0 )then
        if( debug .gt.3 )then
          write(*,'(" insImpINS: INFO: 2nd order art-diss is on: ad21,
     & ad22=",2(e9.2,1x))') ad21,ad22
        end if
      else
        ad21=0.
        ad22=0.
      end if
      cd22=ad22/(nd**2)  ! for 2nd-order artificial dissipation
      if( pdeModel.eq.BoussinesqModel )then
        if( debug .gt.3 )then
          write(*,'(" insImpINS: INFO: Boussinesq: kThermal,
     & adcBoussinesq=",2(e9.2,1x))') kThermal,adcBoussinesq
        end if
      end if
      ! *** define constants in the implicit operator
      ! 
      cmpu=uc-uc ! component number for u in the matrix
      cmpv=vc-uc
      cmpw=wc-uc
      qc=tc      ! another name for tc
      cmpq=tc-uc ! temperature
      cmpk=kc-uc ! k
      cmpe=ec-uc ! eps
      ndu=nd     ! number of velocity components in the matrix
      if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
        ! we are filling a scalar matrix for one component of the velocity 
        ndu=1
        cmpv=cmpu
        cmpw=cmpu
        cmpq=cmpu
      else if( fillCoefficientsScalarSystem.eq.fillCoeffT )then
        ! we are filling a scalar matrix for T 
        ndu=0
        cmpv=cmpu
        cmpw=cmpu
        cmpq=cmpu
      end if
      eqnu=cmpu  ! equation number for u  in the matrix
      eqnv=cmpv
      eqnw=cmpw
      eqnq=cmpq
      eqnk=cmpk
      eqne=cmpe
      dtImp=dt*implicitFactor
      nuDt= nu*dt*implicitFactor  ! matrix: coefficient of Laplacian in the matrix
      kDt = kThermal*dt*implicitFactor ! for T equation
      aDt = dt*implicitFactor      ! matrix: coefficient of advection terms in the matrix
      bDt = dt*implicitFactor      ! matrix: coefficient of extra zero-order linearized terms such as u0.x
      teDt = dt*thermalExpansivity*implicitFactor  ! matrix: coeff of buoyancy term
      nuImp=nu                     ! RHS : nu
      aImp=1.                      ! RHS: coeff of implicit advection terms
      bImp=1.                      ! RHS: coefficient of extra zero-order linearized terms such as u0.x
      ! nuImp=nu*(1.-implicitFactor) ! for RHS
      ! aImp=(1.-implicitFactor)     ! RHS: coeff of implicit advection terms
      ! aExp=0.                      ! advection terms are implicit 
      ! ** NOTE: we force the buoyancy terms to be explicit below **
      tImp=1.                      ! coefficient of the implicit buoyancy term (set to zero if not implicit)
      if( fillCoefficientsScalarSystem.ne.0 )then
        tImp=0.  ! buoyancy term is not implicit when we solve scalar systems
      end if
      nonlinearTermsAreImplicit=0
      if( implicitVariation.eq.implicitViscous )then
        aDt=0.   ! matrix: advection terms are NOT implicit
        bDt=0.   ! matrix: zero-order linearized terms are NOT implicit
        ! aExp=1.  ! advection terms are explicit
        aImp=0.  ! RHS: coeff of implicit advection terms
        bImp=0.
        tImp=0.  ! Boussinesq terms are explicit
      else if( implicitVariation.eq.implicitAdvectionAndViscous )then
        nonlinearTermsAreImplicit=1
        bDt=0.
        bImp=0.
        tImp=1.
      else if( implicitVariation.eq.implicitFullLinearized )then
        nonlinearTermsAreImplicit=1
        ! ++ bDt=0.
        ! ++ bImp=0.
        tImp=1.
      else
        write(*,'(" insImpINS: ERROR: unexpected implicitVariation=",
     & i6)') implicitVariation
        stop 7200
      end if
      ! *** force the buoyancy term to be explicit : (we could add this as an option)
      !    if the main balance in the momentum is grad(p) = - alpha*g*T then we want both these
      !    terms to be explicit. 
      teDt=0.
      tImp=0.
      ! The next macro is defined in insImpXX.bf and is used to look up parameters etc. 
       if( pdeModel.ne.standardModel .and. pdeModel.ne.BoussinesqModel 
     & )then
         write(*,'("insImpINS:ERROR: unexpected pdeModel=",i3)') 
     & pdeModel
         stop 2734
       end if
       ! make sure these are initialized (used in evaluation of adCoeffl even if cd22=0. )
       ulx=0.
       uly=0.
       ulz=0.
       vlx=0.
       vly=0.
       vlz=0.
       wlx=0.
       wly=0.
       wlz=0.
       ! write(*,'("insImpINS: Entering ... fillCoefficientsScalarSystem=",i2," materialFormat=",i3)') fillCoefficientsScalarSystem,materialFormat
       ! write(*,'("insImpINS: kDt=",e10.2)') kDt
       ! --- Output rho, Cp and kThermal t=0 for testing ---
       if( .false. .and. materialFormat.ne.0 .and. (nd1b-nd1a)*(nd2b-
     & nd2a).lt. 1000 )then
        write(*,'("insImpINS: variable material properties rho,Cp,
     & kThermal for T")')
        write(*,'("insImpINS: rho:")')
        i3=nd3a
        do i2=nd2b,nd2a,-1
          if( materialFormat.eq.piecewiseConstantMaterialProperties )
     & then
           write(*,'(100(f5.1))') (rhopc(i1,i2,i3),i1=nd1a,nd1b)
          else
           write(*,'(100(f5.1))') (rhov(i1,i2,i3),i1=nd1a,nd1b)
          end if
        end do
        write(*,'("insImpINS: Cp:")')
        do i2=nd2b,nd2a,-1
          if( materialFormat.eq.piecewiseConstantMaterialProperties )
     & then
           write(*,'(100(f5.1))') (Cppc(i1,i2,i3),i1=nd1a,nd1b)
          else
           write(*,'(100(f5.1))') (Cpv(i1,i2,i3),i1=nd1a,nd1b)
          end if
        end do
        write(*,'("insImpINS: thermalConductivity:")')
        do i2=nd2b,nd2a,-1
          if( materialFormat.eq.piecewiseConstantMaterialProperties )
     & then
           write(*,'(100(f5.1))') (thermalKpc(i1,i2,i3),i1=nd1a,nd1b)
          else
           write(*,'(100(f5.1))') (thermalKv(i1,i2,i3),i1=nd1a,nd1b)
          end if
        end do
       end if
      if( debug.gt.3 )then
        if( evalRightHandSide.eq.1 )then
          write(*,'("insImpINS: *EVAL RHS : implicitOption=",i2," (
     & 0=all,1=none,2=sep,3=all)")')  implicitOption
        endif
      endif
      if( debug.gt.7 )then
        if( evalRightHandSide.eq.1 )then
          write(*,'("insImpINS: ******** EVAL RHS **********")')
        end if
        if( evalResidual.eq.1 )then
          write(*,'("insImpINS: ******** EVAL RESIDUAL **********")')
        end if
        if( fillCoefficients.eq.1 )then
          write(*,'("insImpINS: ******** FILL COEFF **********")')
        end if
        ! ' 
        write(*,'("insImpINS: pdeModel,nonLinear,impVar=",3i4)') 
     & pdeModel,nonlinearTermsAreImplicit,implicitVariation
        if( fillCoefficients.eq.1 )then
          write(*,'("insImpINS: stencilSize,ncc=",2i4)') stencilSize,
     & ncc
        end if
        write(*,'("insImpINS: aDt,bDt,nuDt=",3e10.2)') aDt,bDt,nuDt
        write(*,'("insImpINS: implicitFactor,nuImp,aImp=",f4.2,1x,
     & 3e10.2)') implicitFactor,nuImp,aImp
        !'
      end if
      if( evalRightHandSide.eq.1 .and. (nonlinearTermsAreImplicit.eq.1 
     & .or. use2ndOrderAD.ne.0) )then
        evalLinearizedDerivatives = 1
      else
        evalLinearizedDerivatives = 0
      end if
! Define operator parameters
!   $DIM : number of spatial dimensions
!   $ORDER : order of accuracy of an approximation
!   $GRIDTYPE : rectangular or curvilinear
!   $MATRIX_STENCIL_WIDTH : space in the global coeff matrix was allocated to hold this size stencil
!   $STENCIL_WIDTH : stencil width of the local coeff-matrix (such as xCoeff, yCoeff, lapCoeff, ...)
      if(  nd.eq.2 .and. gridType.eq.rectangular .and. 
     & orderOfAccuracy.eq.2 )then
       ! fill the coefficients:
        ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
        if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           ! --- fill coefficients for a scalar system for a velocity component: I - nu*Delta - A.D. 
           ! write(*,'("@@@@ insImpINS: (u,v,w) fillCoefficientsScalarSystem=",i4)') fillCoefficientsScalarSystem
           ! '
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
            ! Operator laplacian = uxx+uyy
             lapCoeff(ma2(-1,-1, 0)) = 0
             lapCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
             lapCoeff(ma2( 1,-1, 0)) = 0
             lapCoeff(ma2(-1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma2( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2
             lapCoeff(ma2( 1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma2(-1, 1, 0)) = 0
             lapCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
             lapCoeff(ma2( 1, 1, 0)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss
             dissCoeff(ma2(-1,-1, 0)) = 0
             dissCoeff(ma2( 0,-1, 0)) = 1
             dissCoeff(ma2( 1,-1, 0)) = 0
             dissCoeff(ma2(-1, 0, 0)) = 1
             dissCoeff(ma2( 0, 0, 0)) = -4
             dissCoeff(ma2( 1, 0, 0)) = 1
             dissCoeff(ma2(-1, 1, 0)) = 0
             dissCoeff(ma2( 0, 1, 0)) = 1
             dissCoeff(ma2( 1, 1, 0)) = 0
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dx(0))
            u0y = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dx(1))
          ! parametric derivatives of v: 
           vv=u(i1,i2,i3,vc) ! in the rectangular case just eval the solution
            v0x = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dx(0))
            v0y = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dx(1))
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y) + abs(v0x)+abs(
     & v0y) )
         ! Form : I - nuDt*Delta -adCoeff*dt*( urr + uss + .. )
          do m3=-halfWidth3,halfWidth3
          do m2=-halfWidth,halfWidth
          do m1=-halfWidth,halfWidth
            coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(m1,m2,
     & m3)))+(-nuDt*lapCoeff(ma2(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(
     & ma2(m1,m2,m3)))
          end do
          end do
          end do
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
               ! Operator y = uy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = 0
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 0
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma2( 1, 1, 0)) = 0
             if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3))
     & )
               end do
               end do
               end do
             else
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3))
     & )+(nuDt*radi**2*iCoeff(ma2(m1,m2,m3)))
               end do
               end do
               end do
             end if
            else
             ! corrections on the axis
               ! Operator yy = uyy
                yyCoeff(ma2(-1,-1, 0)) = 0
                yyCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1,-1, 0)) = 0
                yyCoeff(ma2(-1, 0, 0)) = 0
                yyCoeff(ma2( 0, 0, 0)) = -2./dx(1)**2
                yyCoeff(ma2( 1, 0, 0)) = 0
                yyCoeff(ma2(-1, 1, 0)) = 0
                yyCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 0
             if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*yyCoeff(ma2(m1,m2,m3)))
               end do
               end do
               end do
             else
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*.5*yyCoeff(ma2(m1,m2,m3)))
               end do
               end do
               end do
             end if
            end if
          end if
           end if
          end do
          end do
          end do
         else if( fillCoefficientsScalarSystem.eq.fillCoeffT )then
           ! --- fill coefficients for a scalar system for the Temperature: I - kappa*Delta - A.D. 
          write(*,'("@@@@ insImpINS: T: fillCoefficientsScalarSystem=",
     & i4)') fillCoefficientsScalarSystem
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
            ! Operator laplacian = uxx+uyy
             lapCoeff(ma2(-1,-1, 0)) = 0
             lapCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
             lapCoeff(ma2( 1,-1, 0)) = 0
             lapCoeff(ma2(-1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma2( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2
             lapCoeff(ma2( 1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma2(-1, 1, 0)) = 0
             lapCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
             lapCoeff(ma2( 1, 1, 0)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss
             dissCoeff(ma2(-1,-1, 0)) = 0
             dissCoeff(ma2( 0,-1, 0)) = 1
             dissCoeff(ma2( 1,-1, 0)) = 0
             dissCoeff(ma2(-1, 0, 0)) = 1
             dissCoeff(ma2( 0, 0, 0)) = -4
             dissCoeff(ma2( 1, 0, 0)) = 1
             dissCoeff(ma2(-1, 1, 0)) = 0
             dissCoeff(ma2( 0, 1, 0)) = 1
             dissCoeff(ma2( 1, 1, 0)) = 0
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma2(m1,m2,m3)))+(-adcBoussinesq*dt*
     & dissCoeff(ma2(m1,m2,m3)))
             end do
             end do
             end do
          else
           ! -- variable material properties : 
           ! get coefficients scaled by -dt*implicitFactor: 
            ! ---------- 2D -----------
            ! Get coefficients at nearby points: 
            if( materialFormat.eq.constantMaterialProperties )then
              ! const material properties 
              stop 11199
            else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
              ! piecewise constant material properties
              scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
              Kzmz=thermalKpc(i1  ,i2-1,i3)
              Kmzz=thermalKpc(i1-1,i2  ,i3)
              Kzzz=thermalKpc(i1  ,i2  ,i3)
              Kpzz=thermalKpc(i1+1,i2  ,i3)
              Kzpz=thermalKpc(i1  ,i2+1,i3)
            else if( materialFormat.eq.variableMaterialProperties )then
              ! variable material properties
              scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
              Kzmz=thermalKv(i1  ,i2-1,i3)
              Kmzz=thermalKv(i1-1,i2  ,i3)
              Kzzz=thermalKv(i1  ,i2  ,i3)
              Kpzz=thermalKv(i1+1,i2  ,i3)
              Kzpz=thermalKv(i1  ,i2+1,i3)
            end if
            !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
              K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
              K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
              K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
              K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
              au11ph = K0ph*dxvsqi(0)*(scale)
              au11mh = K0mh*dxvsqi(0)*(scale)
              au22ph = K1ph*dxvsqi(1)*(scale)
              au22mh = K1mh*dxvsqi(1)*(scale)
              au12pzz=0.
              au12mzz=0.
              au21zpz=0.
              au21zmz=0.
            ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
            ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
            ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
           ! Set coeff = - dtImp*div( K grad)
               coeff(mce2(-1,-1,0,cmpu,eqnu),i1,i2,i3)=  au12mzz+
     & au21zmz
               coeff(mce2(0,-1,0,cmpu,eqnu),i1,i2,i3)=                 
     &      au22mh
               coeff(mce2(1,-1,0,cmpu,eqnu),i1,i2,i3)= -au12pzz-au21zmz
               coeff(mce2(-1,0,0,cmpu,eqnu),i1,i2,i3)=         au11mh
               coeff(mce2(0,0,0,cmpu,eqnu),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh
               coeff(mce2(1,0,0,cmpu,eqnu),i1,i2,i3)=  au11ph
               coeff(mce2(-1,1,0,cmpu,eqnu),i1,i2,i3)= -au12mzz-au21zpz
               coeff(mce2(0,1,0,cmpu,eqnu),i1,i2,i3)=               
     & au22ph
               coeff(mce2(1,1,0,cmpu,eqnu),i1,i2,i3)=  au12pzz+au21zpz
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
              coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(iCoeff(ma2(m1,m2,m3)))+(-
     & adcBoussinesq*dt*dissCoeff(ma2(m1,m2,m3)))
            end do
            end do
            end do
          endif
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            ! *** FIX ME FOR variable material properties ***
            if( materialFormat.ne.constantMaterialProperties )then
              stop 6205
            end if
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
               ! Operator y = uy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = 0
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 0
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma2( 1, 1, 0)) = 0
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-kDt*radi*yCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            else
             ! corrections on the axis
               ! Operator yy = uyy
                yyCoeff(ma2(-1,-1, 0)) = 0
                yyCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1,-1, 0)) = 0
                yyCoeff(ma2(-1, 0, 0)) = 0
                yyCoeff(ma2( 0, 0, 0)) = -2./dx(1)**2
                yyCoeff(ma2( 1, 0, 0)) = 0
                yyCoeff(ma2(-1, 1, 0)) = 0
                yyCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 0
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-kDt*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            end if
          end if
           end if
          end do
          end do
          end do
         else
           ! --- fill coefficients for the full system ---
         ! write(*,'("&&&&& insImpINS: fill coefficients for a full system, pdeModel=",i3)') pdeModel
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
            ! Operator laplacian = uxx+uyy
             lapCoeff(ma2(-1,-1, 0)) = 0
             lapCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
             lapCoeff(ma2( 1,-1, 0)) = 0
             lapCoeff(ma2(-1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma2( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2
             lapCoeff(ma2( 1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma2(-1, 1, 0)) = 0
             lapCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
             lapCoeff(ma2( 1, 1, 0)) = 0
            ! Operator x = ux
             xCoeff(ma2(-1,-1, 0)) = 0
             xCoeff(ma2( 0,-1, 0)) = 0
             xCoeff(ma2( 1,-1, 0)) = 0
             xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
             xCoeff(ma2( 0, 0, 0)) = 0
             xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
             xCoeff(ma2(-1, 1, 0)) = 0
             xCoeff(ma2( 0, 1, 0)) = 0
             xCoeff(ma2( 1, 1, 0)) = 0
            ! Operator y = uy
             yCoeff(ma2(-1,-1, 0)) = 0
             yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
             yCoeff(ma2( 1,-1, 0)) = 0
             yCoeff(ma2(-1, 0, 0)) = 0
             yCoeff(ma2( 0, 0, 0)) = 0
             yCoeff(ma2( 1, 0, 0)) = 0
             yCoeff(ma2(-1, 1, 0)) = 0
             yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
             yCoeff(ma2( 1, 1, 0)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss
             dissCoeff(ma2(-1,-1, 0)) = 0
             dissCoeff(ma2( 0,-1, 0)) = 1
             dissCoeff(ma2( 1,-1, 0)) = 0
             dissCoeff(ma2(-1, 0, 0)) = 1
             dissCoeff(ma2( 0, 0, 0)) = -4
             dissCoeff(ma2( 1, 0, 0)) = 1
             dissCoeff(ma2(-1, 1, 0)) = 0
             dissCoeff(ma2( 0, 1, 0)) = 1
             dissCoeff(ma2( 1, 1, 0)) = 0
          ! for testing, get coeff for div( s grad )
          ! getOpCoeffDivScalarGrad(s(i1,i2,i3,0))
          ! **** get a fourth order dissipation u.rrrr + u.ssss 
          ! evaluate forward derivatives of the current solution: 
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dx(0))
            u0y = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dx(1))
          ! parametric derivatives of v: 
           vv=u(i1,i2,i3,vc) ! in the rectangular case just eval the solution
            v0x = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dx(0))
            v0y = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dx(1))
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y) + abs(v0x)+abs(
     & v0y) )
         if( gridIsMoving.ne.0 )then
           ugv = uu - gv(i1,i2,i3,0)
           vgv = vv - gv(i1,i2,i3,1)
         else
           ugv = uu
           vgv = vv
         end if
          ! Form : I - nuDt*Delta + aDt*u*Dx + aDt*v*Dy + ...
          !    u0*ux + v0*uy + u*u0x + v*u0y 
          ! moving: (u-gv)*ux =  u*ux - gv*ux -> u0*ux+u*u0x-gv*ux = (u0-gv)*ux + u0x*u (linearized form)
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma2(m1,m2,m3)))+(adt*ugv*xCoeff(ma2(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(bDt*u0x*iCoeff(
     & ma2(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpv,eqnu),i1,i2,i3)+(bDt*u0y*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
          ! addCoeff1(cmpv,eqnu,coeff, bDt*iCoeff)  ! for testing -- add v to u-eqn
          !    u0*vx + v0*vy + u*v0x + v*v0y 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma2(m1,m2,m3)))+(adt*ugv*xCoeff(ma2(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(bDt*v0y*iCoeff(
     & ma2(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpu,eqnv),i1,i2,i3)+(bDt*v0x*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpv,eqnv),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3)))+(
     & nuDt*radi**2*iCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            else
             ! corrections on the axis
               ! Operator yy = uyy
                yyCoeff(ma2(-1,-1, 0)) = 0
                yyCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1,-1, 0)) = 0
                yyCoeff(ma2(-1, 0, 0)) = 0
                yyCoeff(ma2( 0, 0, 0)) = -2./dx(1)**2
                yyCoeff(ma2( 1, 0, 0)) = 0
                yyCoeff(ma2(-1, 1, 0)) = 0
                yyCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 0
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpv,eqnv),i1,i2,i3)+(-nuDt*.5*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            end if
          end if
         if( pdeModel.eq.BoussinesqModel )then
          ! ----------------------------------------------------------------------------
          ! ---------- add the temperature equation to the full system -----------------
          ! ----------------------------------------------------------------------------
           qq=u(i1,i2,i3,qc) ! in the rectangular case just eval the solution
            q0x = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dx(0))
            q0y = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dx(1))
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties:
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma2(m1,m2,m3)))+(adt*ugv*xCoeff(ma2(m1,
     & m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(-adcBoussinesq*dt*
     & dissCoeff(ma2(m1,m2,m3)))
             end do
             end do
             end do
          else
           ! get coefficients scaled by -dt*implicitFactor: 
            ! ---------- 2D -----------
            ! Get coefficients at nearby points: 
            if( materialFormat.eq.constantMaterialProperties )then
              ! const material properties 
              stop 11199
            else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
              ! piecewise constant material properties
              scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
              Kzmz=thermalKpc(i1  ,i2-1,i3)
              Kmzz=thermalKpc(i1-1,i2  ,i3)
              Kzzz=thermalKpc(i1  ,i2  ,i3)
              Kpzz=thermalKpc(i1+1,i2  ,i3)
              Kzpz=thermalKpc(i1  ,i2+1,i3)
            else if( materialFormat.eq.variableMaterialProperties )then
              ! variable material properties
              scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
              Kzmz=thermalKv(i1  ,i2-1,i3)
              Kmzz=thermalKv(i1-1,i2  ,i3)
              Kzzz=thermalKv(i1  ,i2  ,i3)
              Kpzz=thermalKv(i1+1,i2  ,i3)
              Kzpz=thermalKv(i1  ,i2+1,i3)
            end if
            !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
              K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
              K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
              K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
              K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
              au11ph = K0ph*dxvsqi(0)*(scale)
              au11mh = K0mh*dxvsqi(0)*(scale)
              au22ph = K1ph*dxvsqi(1)*(scale)
              au22mh = K1mh*dxvsqi(1)*(scale)
              au12pzz=0.
              au12mzz=0.
              au21zpz=0.
              au21zmz=0.
            ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
            ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
            ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
             coeff(mce2(-1,-1,0,cmpq,eqnq),i1,i2,i3)=  au12mzz+au21zmz
             coeff(mce2(0,-1,0,cmpq,eqnq),i1,i2,i3)=                   
     &    au22mh
             coeff(mce2(1,-1,0,cmpq,eqnq),i1,i2,i3)= -au12pzz-au21zmz
             coeff(mce2(-1,0,0,cmpq,eqnq),i1,i2,i3)=         au11mh
             coeff(mce2(0,0,0,cmpq,eqnq),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh
             coeff(mce2(1,0,0,cmpq,eqnq),i1,i2,i3)=  au11ph
             coeff(mce2(-1,1,0,cmpq,eqnq),i1,i2,i3)= -au12mzz-au21zpz
             coeff(mce2(0,1,0,cmpq,eqnq),i1,i2,i3)=               
     & au22ph
             coeff(mce2(1,1,0,cmpq,eqnq),i1,i2,i3)=  au12pzz+au21zpz
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
              coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(iCoeff(ma2(m1,m2,m3)))+(adt*ugv*
     & xCoeff(ma2(m1,m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(-
     & adcBoussinesq*dt*dissCoeff(ma2(m1,m2,m3)))
            end do
            end do
            end do
          endif
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpu,eqnq),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpu,eqnq),i1,i2,i3)+(bDt*q0x*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpv,eqnq),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpv,eqnq),i1,i2,i3)+(bDt*q0y*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpq,eqnu),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpq,eqnu),i1,i2,i3)+(teDt*gravity(0)*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpq,eqnv),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpq,eqnv),i1,i2,i3)+(teDt*gravity(1)*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            ! *** FIX ME FOR variable material properties ***
            if( materialFormat.ne.constantMaterialProperties )then
              stop 6206
            end if
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(-kDt*radi*yCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            else
             ! corrections on the axis
               ! Operator yy = uyy
                yyCoeff(ma2(-1,-1, 0)) = 0
                yyCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1,-1, 0)) = 0
                yyCoeff(ma2(-1, 0, 0)) = 0
                yyCoeff(ma2( 0, 0, 0)) = -2./dx(1)**2
                yyCoeff(ma2( 1, 0, 0)) = 0
                yyCoeff(ma2(-1, 1, 0)) = 0
                yyCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 0
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(-kDt*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            end if
          end if
         endif  ! pdeModel.eq.BoussinesqModel
           end if
          end do
          end do
          end do
        end if
        end if
       ! fill matrix BCs
       if( fillCoefficients.eq.1 .or. 
     & evalResidualForBoundaryConditions.eq.1 )then
        indexRange(0,0)=n1a
        indexRange(1,0)=n1b
        indexRange(0,1)=n2a
        indexRange(1,1)=n2b
        indexRange(0,2)=n3a
        indexRange(1,2)=n3b
        do axis=0,nd-1
        do side=0,1
         is1=0
         is2=0
         is3=0
         if( axis.eq.0 )then
           is1=1-2*side
           n1a=indexRange(side,axis)
           n1b=n1a
         else if( axis.eq.1 )then
           is2=1-2*side
           n2a=indexRange(side,axis)
           n2b=n2a
         else
           is3=1-2*side
           n3a=indexRange(side,axis)
           n3b=n3a
         end if
           ! define the outward normal for Cartesian grids
           an(0)=0.
           an(1)=0.
           an(2)=0.
           an(axis)=2*side-1
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( bc0.eq.noSlipWall )then
            write(*,'(" ")')
            write(*,'(">>> insImpINS: fill Matrix Boundary Conditions: 
     & useImplicitAmpBCs=",i4," isBulkSolid=",i2)') useImplicitAmpBCs,
     & isBulkSolid
            write(*,'(">>> insImpINS: fill useAddedMassAlgorithm=",i4,
     & " projectAddedMassVelocity=",i4)') useAddedMassAlgorithm,
     & projectAddedMassVelocity
            write(*,'(">>> insImpINS: nu,dt,alpha,beta=",4e10.2)') nu,
     & dt,alpha,beta
         end if
         ! Some Bc's like no-slip wall use extrapolation for ghost, sometimes we turn this off, for example,
         ! for the AMP "no-slip wall" BCs
         extrapolateGhostByDefault=1
         if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ne.fillCoeffT )then
           ! ---- fill BC coeffs for (u,v,w) ---
           bc0 = bc(side,axis)
           if( bc0.eq.slipWall .and. fillCoefficientsScalarSystem.gt.0 
     & )then
             if( fillCoefficientsScalarSystem.eq.(axis+1) )then
               bc0=dirichletBoundaryCondition
             else
               bc0=neumannBoundaryCondition
             end if
           end if
         if( bc0.eq.noSlipWall .and. useAddedMassAlgorithm.eq.1 .and. 
     & projectAddedMassVelocity.eq.1 .and. isBulkSolid.eq.1 )then
           ! ** AMP NO-SLIP WALL BCs FOR A BULK SOLID INTERFACE *** 
           !  The AMP conditions (see fib and fibr papers) have a limit of
           !  a no-slip wall for a heavy solid and a free surface for a light solid
          write(*,'(" insImpINS: FILL IMPLICIT AMP velocity BCs: 
     & fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
          if( mu.eq.0. )then
            write(*,'(" insImpINS:ERROR: mu=0 : nu,fluidDensity=",
     & 2e10.2)') nu,fluidDensity
            stop 0099
          end if
          extrapolateGhostByDefault=0 ! do NOT extrapolate ghost points (below)
          if( useImplicitAmpBCs.eq.0 )then
            write(*,'(" --- USE OLD WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=0 --- ")')
            ! *** DO THIS FOR NOW ***
            ! Dirichlet BC
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
             do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           !   opEvalJacobianDerivatives(aj,1)
             ! evaluate the coeff operators 
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
           !   getCoeff(x, xCoeff,aj)
           !   getCoeff(y, yCoeff,aj)
             do n=0,ndu-1
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma2(m1,m2,m3)))
               end do
               end do
               end do
             end do
              end if
             end do
             end do
             end do
          else
           write(*,'("  ")')
           write(*,'(" --- USE NEW WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=1 --- ")')
           ! ********* NEW ADDED MASS BULK SOLID VELOCITY BCS ********
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
             write(*,'(" IMP: AMP BC i1,i2=",2i2," ndu=",i4," normal=",
     & 2e10.2)') i1,i2,ndu,an(0),an(1)
             ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
             ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') AMG(0,0,0),AMG(0,0,1),AMG(0,1,0),AMG(0,1,1)
             ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') AMG(1,0,0),AMG(1,0,1),AMG(1,1,0),AMG(1,1,1)
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = ux
                xCoeff(ma2(-1,-1, 0)) = 0
                xCoeff(ma2( 0,-1, 0)) = 0
                xCoeff(ma2( 1,-1, 0)) = 0
                xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                xCoeff(ma2( 0, 0, 0)) = 0
                xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                xCoeff(ma2(-1, 1, 0)) = 0
                xCoeff(ma2( 0, 1, 0)) = 0
                xCoeff(ma2( 1, 1, 0)) = 0
               ! Operator y = uy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = 0
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 0
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma2( 1, 1, 0)) = 0
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
               ! Operator laplacian = uxx+uyy
                lapCoeff(ma2(-1,-1, 0)) = 0
                lapCoeff(ma2( 0,-1, 0)) = 1./dx(1)**2
                lapCoeff(ma2( 1,-1, 0)) = 0
                lapCoeff(ma2(-1, 0, 0)) = 1./dx(0)**2
                lapCoeff(ma2( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2
                lapCoeff(ma2( 1, 0, 0)) = 1./dx(0)**2
                lapCoeff(ma2(-1, 1, 0)) = 0
                lapCoeff(ma2( 0, 1, 0)) = 1./dx(1)**2
                lapCoeff(ma2( 1, 1, 0)) = 0
             ! Equations on the ghost point:
             do m=0,ndc-1
              coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
             end do
             ! Equations on the boundary:
             do m=0,ndc-1
              coeff(m,i1,i2,i3)=0.  ! init all elements to zero
             end do
             beta = implicitFactor*nu*dt
             !! beta = 0. ! TEST
              ! ******************************** TWO DIMENSIONS ***********************************
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled BC equations for u and v  
               ! -------------Coefficients in the the ghost point equation ----------
               do n=0,nd-1
                 ! equation n:  (equation numbers and classify  are set in these calls)
                 ! write(*,'(" (i1,i2,n)=(",i3,",",i3,",",i2,") amg-coeff=",6e10.2)') i1,i2,n,AMG(n,0,0),AMG(n,0,1),AMG0(n,0),AMG(n,1,0),AMG(n,1,1),AMG0(n,1)
                   classify(i1m,i2m,i3m,eqnu+n)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))+((+(delta(n,0)-an(n)*an(0))*(zs/mu))*iCoeff(ma2(m1,m2,m3)
     & ))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,m3)))+(
     & (+(delta(n,1)-an(n)*an(1))*(zs/mu))*iCoeff(ma2(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
                ! We decouple the coupled velocity components: Only add coefficients of u 
                n=0
                  classify(i1m,i2m,i3m,eqnu)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((delta(
     & 0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(0)*an(
     & 0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*an(1)+
     & delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,m3)))+(
     & (+(delta(n,0)-an(n)*an(0))*(zs/mu))*iCoeff(ma2(m1,m2,m3)))
                  ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                   equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)
     & =(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
                ! We decouple the coupled velocity components: Only add components of v 
                n=1
                  classify(i1m,i2m,i3m,eqnu)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((delta(
     & 1,0)*an(n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(
     & 0))*xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,m3)))+(
     & (+(delta(n,1)-an(n)*an(1))*(zs/mu))*iCoeff(ma2(m1,m2,m3)))
                  ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                   equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)
     & =(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              end if
              ! ------------- Coefficients on the boundary ----------------
              ! evaluate the coeff operators 
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled equations for u and v  
               write(*,'(" insImpINS: beta=",e10.3," amg-delta=",
     & 4e10.3)') beta,(-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0))),(-
     & beta*(delta(0,1)-(1.-alpha)*an(0)*an(1))),(-beta*(delta(1,0)-(
     & 1.-alpha)*an(1)*an(0))),(-beta*(delta(1,1)-(1.-alpha)*an(1)*an(
     & 1)))
               ! u equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpv,eqnu),i1,i2,i3)+((-beta*(delta(0,1)-(1.-alpha)*
     & an(0)*an(1)))*lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
               ! v equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnv),i1,i2,i3)+((-beta*(delta(1,0)-(1.-alpha)*
     & an(1)*an(0)))*lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               ! We decouple the coupled velocity components: Only add coefficients of u 
               n=0
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
               ! We decouple the coupled velocity components: Only add components of v 
               n=1
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
              end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent AMP NO-SLIP WALLS  -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.noSlipWall .or. bc(1,axisp1)
     & .eq.noSlipWall .or. bc(0,axisp2).eq.noSlipWall .or. bc(1,
     & axisp2).eq.noSlipWall )then
             write(*,'("insImpINS: ERROR: two AMP no-slip walls meet 
     & at a corner -- not implemented -- fix me")')
             stop 9099
           end if
           ! write(*,'(" Finished filling in implicit AMP velocity BCs -- stop for now")')
           ! stop 1004
          end if
         else if( bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
           do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
            coeff(m,i1,i2,i3)=0.
           end do
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
         !   opEvalJacobianDerivatives(aj,1)
           ! evaluate the coeff operators 
             ! Operator identity 
              iCoeff(ma2(-1,-1, 0)) = 0
              iCoeff(ma2( 0,-1, 0)) = 0
              iCoeff(ma2( 1,-1, 0)) = 0
              iCoeff(ma2(-1, 0, 0)) = 0
              iCoeff(ma2( 0, 0, 0)) = 1.
              iCoeff(ma2( 1, 0, 0)) = 0
              iCoeff(ma2(-1, 1, 0)) = 0
              iCoeff(ma2( 0, 1, 0)) = 0
              iCoeff(ma2( 1, 1, 0)) = 0
         !   getCoeff(x, xCoeff,aj)
         !   getCoeff(y, yCoeff,aj)
           do n=0,ndu-1
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma2(m1,m2,m3)))
             end do
             end do
             end do
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.outflow )then
          ! NOTE: outflowOption==0 is done below (extrapolation)
          if( outflowOption.eq.1 )then
           ! Neumann BC at outflow if outflowOption==1
            ! write(*,'("insImpINS: fill outflow BC into matrix: Neumann BC")')
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = ux
                  xCoeff(ma2(-1,-1, 0)) = 0
                  xCoeff(ma2( 0,-1, 0)) = 0
                  xCoeff(ma2( 1,-1, 0)) = 0
                  xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                  xCoeff(ma2( 0, 0, 0)) = 0
                  xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                  xCoeff(ma2(-1, 1, 0)) = 0
                  xCoeff(ma2( 0, 1, 0)) = 0
                  xCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator y = uy
                  yCoeff(ma2(-1,-1, 0)) = 0
                  yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                  yCoeff(ma2( 1,-1, 0)) = 0
                  yCoeff(ma2(-1, 0, 0)) = 0
                  yCoeff(ma2( 0, 0, 0)) = 0
                  yCoeff(ma2( 1, 0, 0)) = 0
                  yCoeff(ma2(-1, 1, 0)) = 0
                  yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                  yCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator identity 
                  iCoeff(ma2(-1,-1, 0)) = 0
                  iCoeff(ma2( 0,-1, 0)) = 0
                  iCoeff(ma2( 1,-1, 0)) = 0
                  iCoeff(ma2(-1, 0, 0)) = 0
                  iCoeff(ma2( 0, 0, 0)) = 1.
                  iCoeff(ma2( 1, 0, 0)) = 0
                  iCoeff(ma2(-1, 1, 0)) = 0
                  iCoeff(ma2( 0, 1, 0)) = 0
                  iCoeff(ma2( 1, 1, 0)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma2(m1,m2,m3)
                mm=mce2(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
          else if( outflowOption.ne.0 )then
            write(*,'("insImpINS: fill outflow BC into matrix: ERROR: 
     & outflowOption=",i6)') outflowOption
          end if
         else if( bc0.eq.neumannBoundaryCondition )then
           ! Neumann BC (used by slipWall and scalar systems)
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = ux
                  xCoeff(ma2(-1,-1, 0)) = 0
                  xCoeff(ma2( 0,-1, 0)) = 0
                  xCoeff(ma2( 1,-1, 0)) = 0
                  xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                  xCoeff(ma2( 0, 0, 0)) = 0
                  xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                  xCoeff(ma2(-1, 1, 0)) = 0
                  xCoeff(ma2( 0, 1, 0)) = 0
                  xCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator y = uy
                  yCoeff(ma2(-1,-1, 0)) = 0
                  yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                  yCoeff(ma2( 1,-1, 0)) = 0
                  yCoeff(ma2(-1, 0, 0)) = 0
                  yCoeff(ma2( 0, 0, 0)) = 0
                  yCoeff(ma2( 1, 0, 0)) = 0
                  yCoeff(ma2(-1, 1, 0)) = 0
                  yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                  yCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator identity 
                  iCoeff(ma2(-1,-1, 0)) = 0
                  iCoeff(ma2( 0,-1, 0)) = 0
                  iCoeff(ma2( 1,-1, 0)) = 0
                  iCoeff(ma2(-1, 0, 0)) = 0
                  iCoeff(ma2( 0, 0, 0)) = 1.
                  iCoeff(ma2( 1, 0, 0)) = 0
                  iCoeff(ma2(-1, 1, 0)) = 0
                  iCoeff(ma2( 0, 1, 0)) = 0
                  iCoeff(ma2( 1, 1, 0)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma2(m1,m2,m3)
                mm=mce2(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
         else if( bc0.eq.freeSurfaceBoundaryCondition )then
           ! **FREE SURFACE BCs *** 
           ! NEW way: proper free-surface conditions *wdh* Sept 30, 2017
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
              ! write(*,'(" IMP: FREE SURFACE i1,i2=",2i2," ndu=",i4," normal=",2e10.2)') i1,i2,ndu,an(0),an(1)
              ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
              ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') CSF(0,0,0),CSF(0,0,1),CSF(0,1,0),CSF(0,1,1)
              ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') CSF(1,0,0),CSF(1,0,1),CSF(1,1,0),CSF(1,1,1)
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = ux
                 xCoeff(ma2(-1,-1, 0)) = 0
                 xCoeff(ma2( 0,-1, 0)) = 0
                 xCoeff(ma2( 1,-1, 0)) = 0
                 xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                 xCoeff(ma2( 0, 0, 0)) = 0
                 xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                 xCoeff(ma2(-1, 1, 0)) = 0
                 xCoeff(ma2( 0, 1, 0)) = 0
                 xCoeff(ma2( 1, 1, 0)) = 0
                ! Operator y = uy
                 yCoeff(ma2(-1,-1, 0)) = 0
                 yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                 yCoeff(ma2( 1,-1, 0)) = 0
                 yCoeff(ma2(-1, 0, 0)) = 0
                 yCoeff(ma2( 0, 0, 0)) = 0
                 yCoeff(ma2( 1, 0, 0)) = 0
                 yCoeff(ma2(-1, 1, 0)) = 0
                 yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                 yCoeff(ma2( 1, 1, 0)) = 0
              do m=0,ndc-1
               coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
              end do
               ! --- 2D ---
               if( fillCoefficientsScalarSystem.eq.0 )then
                ! Fill in the coupled equations for u and v  
                do n=0,nd-1
                  ! equation n:  (equation numbers and classify  are set in these calls)
                    classify(i1m,i2m,i3m,eqnu+n)=ghost1
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                     equationNumber(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                     equationNumber(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffU )
     & then
                 ! We decouple the coupled velocity components: Only add coefficients of u 
                 n=0
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffv )
     & then
                 ! We decouple the coupled velocity components: Only add components of v 
                 n=1
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(1,0)*an(n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(
     & 1)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*
     & an(1)+delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent free surface BCs -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.freeSurfaceBoundaryCondition .or. bc(1,
     & axisp1).eq.freeSurfaceBoundaryCondition .or. bc(0,axisp2)
     & .eq.freeSurfaceBoundaryCondition .or. bc(1,axisp2)
     & .eq.freeSurfaceBoundaryCondition )then
             write(*,'("insImpINS: ERROR: two free surfaces meet at a 
     & corner -- not implemented -- fix me")')
             stop 9099
           end if
         else if( bc0.eq.slipWall )then
           ! SLIP-WALL
           ! NOTE: Here we assume the matrix already includes the interior equations on the boundary 
           ! NOTE: what about corners ???
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
            write(*,'(" insImpINS: slipWall BC not finished for scalar 
     & systems")')
            stop 8130
          end if
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.u"  -->  nDot(mc3(m1,m2,m3,c)) = iCoeff(m1,m2,m3)*an(c-cmpu)
           !nDot=0
           !nDot(mc3(0,0,0,cmpu))=an(0)
           !nDot(mc3(0,0,0,cmpv))=an(1)
           !nDot(mc3(0,0,0,cmpw))=an(2)
           ! Form the matrix for "n.Lu"
           nDotL(0)=an(0)*coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)
           nDotL(1)=an(0)*coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)
           ! form the matrix for  Lu + [ (n.u) - (n.(Lu)) ] n 
           !  eqnu:  (n1*u1+n2*u2+n3*u3)*n1 + L1(u) - nDotL*n1    
           !  eqnv:  (n1*u1+n2*u2+n3*u3)*n2 + L2(u) - nDotL*n2
           !  eqnw:  (n1*u1+n2*u2+n3*u3)*n3 + L3(u) - nDotL*n3
           !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
           do e=eqnu,eqnu+nd-1
           do c=cmpu,cmpu+nd-1
            coeff(mce2(m1,m2,m3,c,e),i1,i2,i3)= coeff(mce2(m1,m2,m3,c,
     & e),i1,i2,i3) + an(e-eqnu)*(iCoeff(ma2(m1,m2,m3))*an(c-cmpu)-
     & nDotL(c-cmpu))
           end do
           end do
           end do
           end do
           end do
          ! fill ghost pt eqn's with a vector symmetry condition:
           ! write(*,'(" VS: i1,i2=",2i2," normal=",2f5.2)') i1,i2,an(0),an(1)
           i1m=i1-is1  ! ghost point
           i2m=i2-is2
           i3m=i3-is3
           do m=0,ndc-1
            coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
           end do
           mv(0)=0
           mv(1)=0
           mv(2)=0
           do e=eqnu,eqnu+nd-1
            c=cmpu+e-eqnu
            mv(axis)=2*side-1
            mm=mce2(mv(0),mv(1),mv(2),c,e)  ! matrix index for ghost pt
            coeff(mm,i1m,i2m,i3m)=1.  ! coeff of ghost point
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            mv(axis)=-(2*side-1)
            mm=mce2(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
            coeff(mm,i1m,i2m,i3m)=-1.
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            ! now add on the term: 2*(n.u(1))n 
            do c=cmpu,cmpu+nd-1
             mm=mce2(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
             ! write(*,'(" VS: mm,i1,i2,e,c=",5i2," n,n=",2f5.2)') mm,i1,i2,e,c,an(c-cmpu),an(e-eqnu)
             coeff(mm,i1m,i2m,i3m)=coeff(mm,i1m,i2m,i3m) + 2.*an(c-
     & cmpu)*an(e-eqnu)
              equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            end do
             classify(i1m,i2m,i3m,e)=ghost1
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.inflowWithPandTV )then
           ! ------------------------------------------------
           ! ---- pressure and tangential velocity given ----
           ! ------------------------------------------------
          write(*,'("insImpINS: fill in BC pressure and tangential 
     & velocity ** check me** ")')
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           write(*,'(" fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
           ! --- fill coefficients for scalar systems ---
           ! This only works if the boundary face is on a plane x=constant, y=constant or z=constant 
           ! Added May 13, 2017 *wdh*
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
            ! -- The grid face should be in a coordinate direction,
            !   normalAxis = 0,1, or 2 indicates this direction
            if( abs(abs(an(0))-1.) .lt. normalTol )then
             normalAxis=0
            else if( abs(abs(an(1))-1.) .lt. normalTol )then
             normalAxis=1
            else if(  abs(abs(an(2))-1.) .lt. normalTol )then
             normalAxis=2
            else
              write(*,'(" insImpINS: ERROR: inflowWithPandTV, scalar 
     & systems but normals funny")')
              write(*,'("  --> the normals should be in a coordinate 
     & direction")')
              stop 1287
            end if
            !  --- equations for u ---
            if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
              if( normalAxis.eq.0 )then
               ! boundary face is x=constant:
               !  Give u.n = 0 
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = ux
                   xCoeff(ma2(-1,-1, 0)) = 0
                   xCoeff(ma2( 0,-1, 0)) = 0
                   xCoeff(ma2( 1,-1, 0)) = 0
                   xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                   xCoeff(ma2( 0, 0, 0)) = 0
                   xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                   xCoeff(ma2(-1, 1, 0)) = 0
                   xCoeff(ma2( 0, 1, 0)) = 0
                   xCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator y = uy
                   yCoeff(ma2(-1,-1, 0)) = 0
                   yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                   yCoeff(ma2( 1,-1, 0)) = 0
                   yCoeff(ma2(-1, 0, 0)) = 0
                   yCoeff(ma2( 0, 0, 0)) = 0
                   yCoeff(ma2( 1, 0, 0)) = 0
                   yCoeff(ma2(-1, 1, 0)) = 0
                   yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                   yCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator identity 
                   iCoeff(ma2(-1,-1, 0)) = 0
                   iCoeff(ma2( 0,-1, 0)) = 0
                   iCoeff(ma2( 1,-1, 0)) = 0
                   iCoeff(ma2(-1, 0, 0)) = 0
                   iCoeff(ma2( 0, 0, 0)) = 1.
                   iCoeff(ma2( 1, 0, 0)) = 0
                   iCoeff(ma2(-1, 1, 0)) = 0
                   iCoeff(ma2( 0, 1, 0)) = 0
                   iCoeff(ma2( 1, 1, 0)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma2(m1,m2,m3)
                 mm=mce2(m1,m2,m3,cmpu,eqnu)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnu)=ghost1
              else
               ! boundary face is y=constant, or z=constant : give u=0 
               do m=ce(0,eqnu),ce(0,eqnu+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpu,eqnu)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnu)=extrapolation
              end if
            !  --- equations for v ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
              if( normalAxis.eq.1 )then
               ! boundary face is y=constant:
               !  Give v.n = 0 
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = ux
                   xCoeff(ma2(-1,-1, 0)) = 0
                   xCoeff(ma2( 0,-1, 0)) = 0
                   xCoeff(ma2( 1,-1, 0)) = 0
                   xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                   xCoeff(ma2( 0, 0, 0)) = 0
                   xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                   xCoeff(ma2(-1, 1, 0)) = 0
                   xCoeff(ma2( 0, 1, 0)) = 0
                   xCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator y = uy
                   yCoeff(ma2(-1,-1, 0)) = 0
                   yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                   yCoeff(ma2( 1,-1, 0)) = 0
                   yCoeff(ma2(-1, 0, 0)) = 0
                   yCoeff(ma2( 0, 0, 0)) = 0
                   yCoeff(ma2( 1, 0, 0)) = 0
                   yCoeff(ma2(-1, 1, 0)) = 0
                   yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                   yCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator identity 
                   iCoeff(ma2(-1,-1, 0)) = 0
                   iCoeff(ma2( 0,-1, 0)) = 0
                   iCoeff(ma2( 1,-1, 0)) = 0
                   iCoeff(ma2(-1, 0, 0)) = 0
                   iCoeff(ma2( 0, 0, 0)) = 1.
                   iCoeff(ma2( 1, 0, 0)) = 0
                   iCoeff(ma2(-1, 1, 0)) = 0
                   iCoeff(ma2( 0, 1, 0)) = 0
                   iCoeff(ma2( 1, 1, 0)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma2(m1,m2,m3)
                 mm=mce2(m1,m2,m3,cmpv,eqnv)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnv,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnv)=ghost1
              else
               ! boundary face is x=constant, or z=constant : give v=0 
               do m=ce(0,eqnv),ce(0,eqnv+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpv,eqnv)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnv)=extrapolation
              end if
            !  --- equations for w ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffW )then
              if( normalAxis.eq.2 )then
               ! boundary face is z=constant:
               !  Give w.n = 0 
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = ux
                   xCoeff(ma2(-1,-1, 0)) = 0
                   xCoeff(ma2( 0,-1, 0)) = 0
                   xCoeff(ma2( 1,-1, 0)) = 0
                   xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                   xCoeff(ma2( 0, 0, 0)) = 0
                   xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                   xCoeff(ma2(-1, 1, 0)) = 0
                   xCoeff(ma2( 0, 1, 0)) = 0
                   xCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator y = uy
                   yCoeff(ma2(-1,-1, 0)) = 0
                   yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                   yCoeff(ma2( 1,-1, 0)) = 0
                   yCoeff(ma2(-1, 0, 0)) = 0
                   yCoeff(ma2( 0, 0, 0)) = 0
                   yCoeff(ma2( 1, 0, 0)) = 0
                   yCoeff(ma2(-1, 1, 0)) = 0
                   yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                   yCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator identity 
                   iCoeff(ma2(-1,-1, 0)) = 0
                   iCoeff(ma2( 0,-1, 0)) = 0
                   iCoeff(ma2( 1,-1, 0)) = 0
                   iCoeff(ma2(-1, 0, 0)) = 0
                   iCoeff(ma2( 0, 0, 0)) = 1.
                   iCoeff(ma2( 1, 0, 0)) = 0
                   iCoeff(ma2(-1, 1, 0)) = 0
                   iCoeff(ma2( 0, 1, 0)) = 0
                   iCoeff(ma2( 1, 1, 0)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma2(m1,m2,m3)
                 mm=mce2(m1,m2,m3,cmpw,eqnw)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnw,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnw)=ghost1
              else
               ! boundary face is x=constant, or y=constant : give w=0 
               do m=ce(0,eqnw),ce(0,eqnw+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpw,eqnw)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnw)=extrapolation
              end if
            else
              write(*,'(" insImpINS: bc0.eq.inflowWithPandTV -- 
     & unknown option")')
              stop 8141
            end if
             end if
            end do
            end do
            end do
         else
           ! ****** inflowWithPandTV: vector system *********
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.Lu"
            nDotL(0)=an(0)*coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)
            nDotL(1)=an(0)*coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)
            ! form the matrix for  Iu + [ (n.(Lu)) - (n.u) ] n 
            !  eqnu:     u1 + nDotL*n1 - (n1*u1+n2*u2+n3*u3)*n1 
            !  eqnv:     u2 + nDotL*n2 - (n1*u1+n2*u2+n3*u3)*n2
            !  eqnw:     u3 + nDotL*n3 - (n1*u1+n2*u2+n3*u3)*n3
            !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
            do e=eqnu,eqnu+nd-1
            do c=cmpu,cmpu+nd-1
             ! *** check this ***
             coeff(mce2(m1,m2,m3,c,e),i1,i2,i3)= iCoeff(ma2(m1,m2,m3))*
     & delta(c-cmpu,e-eqnu) + an(e-eqnu)*( nDotL(c-cmpu) - iCoeff(ma2(
     & m1,m2,m3))*an(c-cmpu) )
            end do
            end do
            end do
            end do
            end do
           ! Neumann condition for ghost: **** is this right? or extrapolate ?? ****
           do n=0,ndu-1
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = ux
                 xCoeff(ma2(-1,-1, 0)) = 0
                 xCoeff(ma2( 0,-1, 0)) = 0
                 xCoeff(ma2( 1,-1, 0)) = 0
                 xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                 xCoeff(ma2( 0, 0, 0)) = 0
                 xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                 xCoeff(ma2(-1, 1, 0)) = 0
                 xCoeff(ma2( 0, 1, 0)) = 0
                 xCoeff(ma2( 1, 1, 0)) = 0
                ! Operator y = uy
                 yCoeff(ma2(-1,-1, 0)) = 0
                 yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                 yCoeff(ma2( 1,-1, 0)) = 0
                 yCoeff(ma2(-1, 0, 0)) = 0
                 yCoeff(ma2( 0, 0, 0)) = 0
                 yCoeff(ma2( 1, 0, 0)) = 0
                 yCoeff(ma2(-1, 1, 0)) = 0
                 yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                 yCoeff(ma2( 1, 1, 0)) = 0
                ! Operator identity 
                 iCoeff(ma2(-1,-1, 0)) = 0
                 iCoeff(ma2( 0,-1, 0)) = 0
                 iCoeff(ma2( 1,-1, 0)) = 0
                 iCoeff(ma2(-1, 0, 0)) = 0
                 iCoeff(ma2( 0, 0, 0)) = 1.
                 iCoeff(ma2( 1, 0, 0)) = 0
                 iCoeff(ma2(-1, 1, 0)) = 0
                 iCoeff(ma2( 0, 1, 0)) = 0
                 iCoeff(ma2( 1, 1, 0)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma2(m1,m2,m3)
               mm=mce2(m1,m2,m3,cmpu+n,eqnu+n)
                coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+0.*iCoeff(m)
               ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnu+n)=ghost1
           end do
            end if
           end do
           end do
           end do
         end if  ! end vector system
         else if( bc0.eq.axisymmetric )then
          if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
           ! BC on an axisymmetric side : scalar matrix for U 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
            ! getCoeff(identity, iCoeff,aj)
            !zeroMatrixCoefficients( coeff,eqnv,eqnv, i1,i2,i3 )  ! set v eqn coeffs to zero
            !setCoeff1(cmpv,eqnv,coeff,iCoeff)                ! dirichlet: V= 
            !fillMatrixExtrapolation(coe<ff,cmpv,eqnv,i1,i2,i3,orderOfExtrapolation,1)  ! extrap ghost for V 
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = ux
                xCoeff(ma2(-1,-1, 0)) = 0
                xCoeff(ma2( 0,-1, 0)) = 0
                xCoeff(ma2( 1,-1, 0)) = 0
                xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                xCoeff(ma2( 0, 0, 0)) = 0
                xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                xCoeff(ma2(-1, 1, 0)) = 0
                xCoeff(ma2( 0, 1, 0)) = 0
                xCoeff(ma2( 1, 1, 0)) = 0
               ! Operator y = uy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = 0
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 0
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma2( 1, 1, 0)) = 0
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma2(m1,m2,m3)
              mm=mce2(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
           ! BC on an axisymmetric side : scalar matrix for V 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
            !getNormalForCurvilinearGrid(side,axis,i1,i2,i3)
            !fillMatrixNeumann(coeff, cmpu,eqnu, i1,i2,i3, an,0.,1. )  ! Neuman: U_r = 
             end if
            end do
            end do
            end do
          else
           ! BC on an axisymmetric side  
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = ux
                xCoeff(ma2(-1,-1, 0)) = 0
                xCoeff(ma2( 0,-1, 0)) = 0
                xCoeff(ma2( 1,-1, 0)) = 0
                xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                xCoeff(ma2( 0, 0, 0)) = 0
                xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                xCoeff(ma2(-1, 1, 0)) = 0
                xCoeff(ma2( 0, 1, 0)) = 0
                xCoeff(ma2( 1, 1, 0)) = 0
               ! Operator y = uy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = 0
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 0
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma2( 1, 1, 0)) = 0
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma2(m1,m2,m3)
              mm=mce2(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          end if
         else if( bc0.gt.0 )then
           write(*,'("insimp:BC: ERROR unknown bc=",i4)') bc0
           stop 5501
         end if
         if( extrapolateGhostByDefault.eq.1 .and. (
     & bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall.or.bc0.eq.inflowWithVelocityGiven .or.(
     & bc0.eq.outflow .and. outflowOption.eq.0) 
     & .or.bc0.eq.interfaceBoundaryCondition) )then
          ! === extrapolation ===
          orderOfExtrap=orderOfExtrapolation
          if( bc0.eq.outflow .and. orderOfExtrapolationForOutflow.gt.0 
     & )then
            orderOfExtrap=orderOfExtrapolationForOutflow
          end if
          if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
           write(*,'("insimp:BC:ERROR: requesting orderOfExtrap=",i6)')
     &  orderOfExtrap
           stop 5502
          end if
          if( .false. .and. bc0.eq.outflow )then
           write(*,'("insimp:BC: fill extrap outflow BC into matrix, 
     & orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') 
     & orderOfExtrap,orderOfExtrapolationForOutflow
          end if
          ! write(*,'("insimp:BC: orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') orderOfExtrap,orderOfExtrapolationForOutflow
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! i1m=i1-is1  ! ghost point
           ! i2m=i2-is2
           ! i3m=i3-is3
           ! zeroMatrixCoefficients( coeff,eqnu,eqnu+ndu-1, i1,i2,i3 )
           do n=0,ndu-1
            c=cmpu+n
            e=eqnu+n
             if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrap
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(c,e)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrap) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,e)=extrapolation
           end do
            end if
           end do
           end do
           end do
         end if
         end if
         if( pdeModel.eq.BoussinesqModel .and. (
     & fillCoefficientsScalarSystem.eq.0 .or. 
     & fillCoefficientsScalarSystem.eq.fillCoeffT) )then
          ! ----------------------------
          ! --- Assign the BCs for T --- (this is duplicated from insImpVP.bf : we could share 
          ! ----------------------------
          bc0 = bc(side,axis)
          a0 = mixedCoeff(tc,side,axis,grid)
          a1 = mixedNormalCoeff(tc,side,axis,grid)
          if( debug.gt.3 )then
            write(*,'(" insImpINS: T BC: bc=",i3," (a0,a1)=(",f5.1,",",
     & f5.1,") for side,axis,grid=",3i3)') bc0,a0,a1,side,axis,grid
            write(*,'(" cmpu,eqnu=",2i2," cmpq,eqnq=",2i2," 
     & orderOfExtrap=",i2)') cmpu,eqnu, cmpq,eqnq,orderOfExtrap
          endif
          ! '
          if( bc0.eq.dirichletBoundaryCondition .or.bc0.eq.noSlipWall 
     & .or.bc0.eq.slipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.outflow .or.bc0.eq.axisymmetric 
     & .or.bc0.eq.interfaceBoundaryCondition .or. 
     & bc0.eq.freeSurfaceBoundaryCondition )then
            if( bc0.eq.outflow .or. bc0.eq.axisymmetric )then
             ! outflow is Neumann
             a0=0.
             a1=1.
            end if
           if( a1.ne.0. )then
            ! Mixed BC 
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = ux
                 xCoeff(ma2(-1,-1, 0)) = 0
                 xCoeff(ma2( 0,-1, 0)) = 0
                 xCoeff(ma2( 1,-1, 0)) = 0
                 xCoeff(ma2(-1, 0, 0)) = -1./2./dx(0)
                 xCoeff(ma2( 0, 0, 0)) = 0
                 xCoeff(ma2( 1, 0, 0)) = 1./2./dx(0)
                 xCoeff(ma2(-1, 1, 0)) = 0
                 xCoeff(ma2( 0, 1, 0)) = 0
                 xCoeff(ma2( 1, 1, 0)) = 0
                ! Operator y = uy
                 yCoeff(ma2(-1,-1, 0)) = 0
                 yCoeff(ma2( 0,-1, 0)) = -1./2./dx(1)
                 yCoeff(ma2( 1,-1, 0)) = 0
                 yCoeff(ma2(-1, 0, 0)) = 0
                 yCoeff(ma2( 0, 0, 0)) = 0
                 yCoeff(ma2( 1, 0, 0)) = 0
                 yCoeff(ma2(-1, 1, 0)) = 0
                 yCoeff(ma2( 0, 1, 0)) = 1./2./dx(1)
                 yCoeff(ma2( 1, 1, 0)) = 0
                ! Operator identity 
                 iCoeff(ma2(-1,-1, 0)) = 0
                 iCoeff(ma2( 0,-1, 0)) = 0
                 iCoeff(ma2( 1,-1, 0)) = 0
                 iCoeff(ma2(-1, 0, 0)) = 0
                 iCoeff(ma2( 0, 0, 0)) = 1.
                 iCoeff(ma2( 1, 0, 0)) = 0
                 iCoeff(ma2(-1, 1, 0)) = 0
                 iCoeff(ma2( 0, 1, 0)) = 0
                 iCoeff(ma2( 1, 1, 0)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma2(m1,m2,m3)
               mm=mce2(m1,m2,m3,cmpq,eqnq)
                coeff(mm,i1m,i2m,i3m)=a1*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+a0*iCoeff(m)
               ! The equation for pt (eqnq,i1m,i2m,i3m) is centered on (cmpq,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnq)=ghost1
              end if
             end do
             end do
             end do
           else
            ! Dirichlet + extrap ghost line values
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             do m=ce(0,eqnq),ce(0,eqnq+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(a0*iCoeff(
     & ma2(m1,m2,m3)))
              end do
              end do
              end do
              if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                stop 7734
              end if
              i1m=i1-is1*(1)  ! 1 point
              i2m=i2-is2*(1)
              i3m=i3-is3*(1)
              do m=0,orderOfExtrapolation
               j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
               j2=i2m+is2*m
               j3=i3m+is3*m
               mm = ce(cmpq,eqnq)+m
               coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
              end do
               classify(i1m,i2m,i3m,eqnq)=extrapolation
              end if
             end do
             end do
             end do
           end if
         !  else if( bc0.eq.outflow )then
         !    ! === extrapolation ===
         !   beginLoopsMixedBoundary()
         !    fillMatrixExtrapolation(coeff,cmpq,eqnq,i1,i2,i3,orderOfExtrap,1)
         !   endLoops()
          else if( bc0.gt.0 )then
           write(*,'("insImpINS:T: ERROR unknown bc=",i4)') bc0
           stop 9167
          end if
         endif
         end if ! end if( fillCoefficients.eq.1 )
         if( evalResidualForBoundaryConditions.eq.1 )then
         if( bc(side,axis).eq.dirichletBoundaryCondition .or.bc(side,
     & axis).eq.noSlipWall.or.bc(side,axis)
     & .eq.inflowWithVelocityGiven.or.bc(side,axis)
     & .eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           ! do n=0,ntdc-1             ! ntdc = number of time depenedent components
           do n=0,nd-1  ! ntdc = number of time depenedent components
            ! fe(i1,i2,i3,uc+n)=0.  
            fe(i1,i2,i3,uc+n)=fi(i1,i2,i3,uc+n)-u(i1,i2,i3,uc+n)
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.outflow )then
         else if( bc(side,axis).eq.axisymmetric )then
         ! do nothing for now
         else if( bc(side,axis).eq.freeSurfaceBoundaryCondition )then
         ! do nothing for now
         else if( bc(side,axis).eq.slipWall )then
           ! SLIP-WALL
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.inflowWithPandTV )then
          ! pressure and tangential velocity given
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).gt.0 )then
           write(*,'("insimp:residual:BC: ERROR unknown bc=",i4)') bc(
     & side,axis)
           stop 9099
         end if
         end if ! end if( evalResidualForBoundaryConditions.eq.1 )
       !*   if( side.eq.0 .and. axis.eq.0 )then
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal00)
       !*    getBoundaryResidualINS(normal00)
       !*   else if( side.eq.1 .and. axis.eq.0 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal10)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.0 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal01)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.1 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal11)
       !*    getBoundaryResidualINS(normal11)
       !*   else if( side.eq.0 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal02)
       !*    getBoundaryResidualINS(normal02)
       !*   else if( side.eq.1 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal12)
       !*    getBoundaryResidualINS(normal12)
       !*  else
       !* !    stop 2077
       !*  end if
         ! reset values
         if( axis.eq.0 )then
           n1a=indexRange(0,axis)
           n1b=indexRange(1,axis)
         else if( axis.eq.1 )then
           n2a=indexRange(0,axis)
           n2b=indexRange(1,axis)
         else
           n3a=indexRange(0,axis)
           n3b=indexRange(1,axis)
         end if
        end do ! side
        end do ! axis
       end if
       ! assign the RHS:
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( evalRightHandSide.eq.1 .or. evalResidual.eq.1 )then
         ! **** to do : optimize this for backward-Euler : fe=0, fi=0 !!
         ! NOTE: For moving grid problems we must eval the RHS as some mask==0 (exposed) points
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! evaluate forward derivatives of the current solution: 
           ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
           ! MAXDER = max number of parametric derivatives to precompute.
            uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
           ! Evaluate the spatial derivatives of u:
             u0x = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dx(0))
             u0y = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dx(1))
             u0xx = (u(i1-1,i2,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1+1,i2,i3,
     & uc))/(dx(0)**2)
             u0yy = (u(i1,i2-1,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1,i2+1,i3,
     & uc))/(dx(1)**2)
           ! Evaluate the spatial derivatives of v:
            vv=u(i1,i2,i3,vc) ! in the rectangular case just eval the solution
             v0x = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dx(0))
             v0y = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dx(1))
             v0xx = (u(i1-1,i2,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1+1,i2,i3,
     & vc))/(dx(0)**2)
             v0yy = (u(i1,i2-1,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1,i2+1,i3,
     & vc))/(dx(1)**2)
           ! Evaluate the spatial derivatives of p:
            pp=u(i1,i2,i3,pc) ! in the rectangular case just eval the solution
             p0x = (-u(i1-1,i2,i3,pc)+u(i1+1,i2,i3,pc))/(2.*dx(0))
             p0y = (-u(i1,i2-1,i3,pc)+u(i1,i2+1,i3,pc))/(2.*dx(1))
          if( evalLinearizedDerivatives.eq.1 )then
             uul=ul(i1,i2,i3,uc) ! in the rectangular case just eval the solution
              ulx = (-ul(i1-1,i2,i3,uc)+ul(i1+1,i2,i3,uc))/(2.*dx(0))
              uly = (-ul(i1,i2-1,i3,uc)+ul(i1,i2+1,i3,uc))/(2.*dx(1))
             vvl=ul(i1,i2,i3,vc) ! in the rectangular case just eval the solution
              vlx = (-ul(i1-1,i2,i3,vc)+ul(i1+1,i2,i3,vc))/(2.*dx(0))
              vly = (-ul(i1,i2-1,i3,vc)+ul(i1,i2+1,i3,vc))/(2.*dx(1))
          end if
          if( pdeModel.eq.BoussinesqModel )then
           ! Evaluate the spatial derivatives of q:
            qq=u(i1,i2,i3,qc) ! in the rectangular case just eval the solution
             q0x = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dx(0))
             q0y = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dx(1))
             q0xx = (u(i1-1,i2,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1+1,i2,i3,
     & qc))/(dx(0)**2)
             q0yy = (u(i1,i2-1,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1,i2+1,i3,
     & qc))/(dx(1)**2)
          end if
          if( gridIsMoving.ne.0 )then
            ugv = uu - gv(i1,i2,i3,0)
            vgv = vv - gv(i1,i2,i3,1)
          else
            ugv = uu
            vgv = vv
          end if
          ! eval the nonlinear coeff. of artificial dissipation: 
            adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y) + abs(v0x)+abs(
     & v0y) )
          if( evalRightHandSide.eq.1 )then
           if( gridIsImplicit.eq.0 )then
             ! ********** explicit *********
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y - p0x + nu*(u0xx+u0yy)
     &  + adCoeff*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1+1,i2,i3,uc)+
     & u(i1,i2+1,i3,uc)-4.*u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y - p0y + nu*(v0xx+v0yy)
     &  + adCoeff*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1+1,i2,i3,vc)+
     & u(i1,i2+1,i3,vc)-4.*u(i1,i2,i3,vc))
             if( isAxisymmetric.eq.1 )then
               radi=radiusInverse(i1,i2,i3)
               if( radi.ne.0. )then
                 fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0y*radi )   
     &          ! add u_r/r
                 fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( (v0y -vv*
     & radi)*radi ) ! add v_r/r - v/r^2
               else
                 fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0yy )    ! add u_rr
                 fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( .5*v0yy ) ! add .5*vrr
               end if
             end if
             if( pdeModel.eq.BoussinesqModel )then
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y + adcBoussinesq*(u(
     & i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,
     & qc)-4.*u(i1,i2,i3,qc))
              if( materialFormat.eq.constantMaterialProperties )then
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*(q0xx+
     & q0yy)
              else
               ! -- variable material properties : 
               ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                ! ---------- 2D -----------
                ! Get coefficients at nearby points: 
                if( materialFormat.eq.constantMaterialProperties )then
                  ! const material properties 
                  stop 11199
                else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                  ! piecewise constant material properties
                  scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                  Kzmz=thermalKpc(i1  ,i2-1,i3)
                  Kmzz=thermalKpc(i1-1,i2  ,i3)
                  Kzzz=thermalKpc(i1  ,i2  ,i3)
                  Kpzz=thermalKpc(i1+1,i2  ,i3)
                  Kzpz=thermalKpc(i1  ,i2+1,i3)
                else if( materialFormat.eq.variableMaterialProperties )
     & then
                  ! variable material properties
                  scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                  Kzmz=thermalKv(i1  ,i2-1,i3)
                  Kmzz=thermalKv(i1-1,i2  ,i3)
                  Kzzz=thermalKv(i1  ,i2  ,i3)
                  Kpzz=thermalKv(i1+1,i2  ,i3)
                  Kzpz=thermalKv(i1  ,i2+1,i3)
                end if
                !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
                  K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
                  K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
                  K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
                  K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
                  au11ph = K0ph*dxvsqi(0)*(scale)
                  au11mh = K0mh*dxvsqi(0)*(scale)
                  au22ph = K1ph*dxvsqi(1)*(scale)
                  au22mh = K1mh*dxvsqi(1)*(scale)
                  au12pzz=0.
                  au12mzz=0.
                  au21zpz=0.
                  au21zmz=0.
                ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
                ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
                ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
                 ! 2D, order 2:
                 dsgT = ( (au12mzz+au21zmz)*u(i1-1,i2-1,i3,qc) + (
     & au22mh)*u(i1,i2-1,i3,qc)+(-au12pzz-au21zmz)*u(i1+1,i2-1,i3,qc)+
     & (au11mh)*u(i1-1,i2,i3,qc)+(-au11ph-au11mh -au22ph -au22mh)*u(
     & i1,i2,i3,qc)+(au11ph)*u(i1+1,i2,i3,qc)+(-au12mzz-au21zpz)*u(i1-
     & 1,i2+1,i3,qc)+(au22ph)*u(i1,i2+1,i3,qc)+(au12pzz+au21zpz)*u(i1+
     & 1,i2+1,i3,qc) )
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
              endif
              if( isAxisymmetric.eq.1 )then
                if( materialFormat.ne.constantMaterialProperties )then
                  stop 6644
                end if
                radi=radiusInverse(i1,i2,i3)
                if( radi.ne.0. )then
                  fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0y*
     & radi )            ! add u_r/r
                else
                  fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0yy )
     &     ! add u_rr
                end if
              end if
             end if
           else
             ! ********** implicit *********
             ! eval the nonlinear coeff. of artificial dissipation for the linearized solution:
               adCoeffl = ad21 + cd22*( abs(ulx)+abs(uly) + abs(vlx)+
     & abs(vly) )
             ! implicit method -- compute explicit part
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y - p0x + (adCoeff-
     & adCoeffl)*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1+1,i2,i3,uc)+
     & u(i1,i2+1,i3,uc)-4.*u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y - p0y + (adCoeff-
     & adCoeffl)*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1+1,i2,i3,vc)+
     & u(i1,i2+1,i3,vc)-4.*u(i1,i2,i3,vc))
             if( nonlinearTermsAreImplicit.eq.1 )then
               ! include linearized terms u0*ulx + ul*u0x 
               if( gridIsMoving.ne.0 )then
                ugvl = uul - gvl(i1,i2,i3,0)
                vgvl = vvl - gvl(i1,i2,i3,1)
               else
                ugvl = uul
                vgvl = vvl
               end if
               ! ulterm = uul*u0x + vvl*u0y + bImp*(uu*ulx +  vv*uly)
               ! vlterm = uul*v0x + vvl*v0y + bImp*(uu*vlx +  vv*vly)
               ! moving: (u-gv)*ux ->  u*ux - gv*ux -> ul*ux +u*ulx +gvl*ux = (ul-gvl)*ux + ulx*u 
               ulterm = ugvl*u0x + vgvl*u0y + bImp*(uu*ulx +  vv*uly)
               vlterm = ugvl*v0x + vgvl*v0y + bImp*(uu*vlx +  vv*vly)
               ! ++ ulterm = uul*u0x + vvl*u0y + bImp*(uu*ulx )
               ! ++ vlterm = uul*v0x + vvl*v0y + bImp*(vv*vly)
               ! ++ ulterm = uul*u0x + vvl*u0y + bImp*( vv )
               ! ++ ulterm = uul*u0x + vvl*u0y 
               ! ++ vlterm = uul*v0x + vvl*v0y 
               fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + ulterm
               fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + vlterm
             end if
             if( implicitOption.eq.computeImplicitTermsSeparately )then
               ! implicit method -- compute implicit part 
               fi(i1,i2,i3,uc) = nuImp*(u0xx+u0yy)+ adCoeffl*(u(i1-1,
     & i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)-
     & 4.*u(i1,i2,i3,uc))   !  I think nuImp==nu now
               fi(i1,i2,i3,vc) = nuImp*(v0xx+v0yy)+ adCoeffl*(u(i1-1,
     & i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)-
     & 4.*u(i1,i2,i3,vc))
               if( nonlinearTermsAreImplicit.eq.1 )then
                 ! include linearized terms u0*ulx + ul*u0x 
                 fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) - aImp*( ulterm )
                 fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) - aImp*( vlterm )
               end if
               if( isAxisymmetric.eq.1 )then
                radi=radiusInverse(i1,i2,i3)
                if( radi.ne.0. )then
                  fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) + nuImp*( u0y*radi 
     & )            ! add u_r/r
                  fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) + nuImp*( (v0y -vv*
     & radi)*radi ) ! add v_r/r - v/r^2
                else
                  fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) + nuImp*( u0yy )    ! add u_rr
                  fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) + nuImp*( .5*v0yy ) ! add .5*vrr
                end if
               end if
             end if
             if( pdeModel.eq.BoussinesqModel )then
              ! tImp=1 if the buoyancy term is implicit, 0 if explicit
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -(1.-tImp)*
     & thermalExpansivity*gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -(1.-tImp)*
     & thermalExpansivity*gravity(1)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y
              if( nonlinearTermsAreImplicit.eq.1 )then
                ! include linearized terms u0*ulx + ul*u0x 
                 qql=ul(i1,i2,i3,qc) ! in the rectangular case just eval the solution
                  qlx = (-ul(i1-1,i2,i3,qc)+ul(i1+1,i2,i3,qc))/(2.*dx(
     & 0))
                  qly = (-ul(i1,i2-1,i3,qc)+ul(i1,i2+1,i3,qc))/(2.*dx(
     & 1))
                qlterm = ugvl*q0x + vgvl*q0y + bImp*(uu*qlx +  vv*qly)
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + qlterm
              end if
              if( implicitOption.eq.computeImplicitTermsSeparately )
     & then
                ! implicit method -- compute implicit part 
                fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) -tImp*
     & thermalExpansivity*gravity(0)*qq
                fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) -tImp*
     & thermalExpansivity*gravity(1)*qq
                fi(i1,i2,i3,qc) = adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,
     & i2-1,i3,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)-4.*u(i1,i2,i3,qc)
     & )
                if( materialFormat.eq.constantMaterialProperties )then
                  fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + kThermal*(q0xx+
     & q0yy)
                else
                 ! -- variable material properties : 
                 ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                  ! ---------- 2D -----------
                  ! Get coefficients at nearby points: 
                  if( materialFormat.eq.constantMaterialProperties )
     & then
                    ! const material properties 
                    stop 11199
                  else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                    ! piecewise constant material properties
                    scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                    Kzmz=thermalKpc(i1  ,i2-1,i3)
                    Kmzz=thermalKpc(i1-1,i2  ,i3)
                    Kzzz=thermalKpc(i1  ,i2  ,i3)
                    Kpzz=thermalKpc(i1+1,i2  ,i3)
                    Kzpz=thermalKpc(i1  ,i2+1,i3)
                  else if( 
     & materialFormat.eq.variableMaterialProperties )then
                    ! variable material properties
                    scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                    Kzmz=thermalKv(i1  ,i2-1,i3)
                    Kmzz=thermalKv(i1-1,i2  ,i3)
                    Kzzz=thermalKv(i1  ,i2  ,i3)
                    Kpzz=thermalKv(i1+1,i2  ,i3)
                    Kzpz=thermalKv(i1  ,i2+1,i3)
                  end if
                  !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
                    K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
                    K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
                    K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
                    K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
                    au11ph = K0ph*dxvsqi(0)*(scale)
                    au11mh = K0mh*dxvsqi(0)*(scale)
                    au22ph = K1ph*dxvsqi(1)*(scale)
                    au22mh = K1mh*dxvsqi(1)*(scale)
                    au12pzz=0.
                    au12mzz=0.
                    au21zpz=0.
                    au21zmz=0.
                  ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
                  ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
                  ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
                   ! 2D, order 2:
                   dsgT = ( (au12mzz+au21zmz)*u(i1-1,i2-1,i3,qc) + (
     & au22mh)*u(i1,i2-1,i3,qc)+(-au12pzz-au21zmz)*u(i1+1,i2-1,i3,qc)+
     & (au11mh)*u(i1-1,i2,i3,qc)+(-au11ph-au11mh -au22ph -au22mh)*u(
     & i1,i2,i3,qc)+(au11ph)*u(i1+1,i2,i3,qc)+(-au12mzz-au21zpz)*u(i1-
     & 1,i2+1,i3,qc)+(au22ph)*u(i1,i2+1,i3,qc)+(au12pzz+au21zpz)*u(i1+
     & 1,i2+1,i3,qc) )
                 fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + dsgT
                endif
                if( nonlinearTermsAreImplicit.eq.1 )then
                  ! include linearized terms u0*ulx + ul*u0x 
                  fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) - aImp*( qlterm )
                end if
                if( isAxisymmetric.eq.1 )then
                 radi=radiusInverse(i1,i2,i3)
                 if( radi.ne.0. )then
                   fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + kThermal*( q0y*
     & radi )
                 else
                   fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + kThermal*( q0yy 
     & )
                 end if
                end if
              end if
             end if
           end if
          end if
          if( evalResidual.eq.1 )then
            ! residual in 2D: (NOTE: currently ul is not available when evaluating the residual)
            fe(i1,i2,i3,uc) = fi(i1,i2,i3,uc) - ugv*u0x -vgv*u0y - p0x 
     & + nu*(u0xx+u0yy)+ adCoeff*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(
     & i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)-4.*u(i1,i2,i3,uc))
            fe(i1,i2,i3,vc) = fi(i1,i2,i3,vc) - ugv*v0x -vgv*v0y - p0y 
     & + nu*(v0xx+v0yy)+ adCoeff*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(
     & i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)-4.*u(i1,i2,i3,vc))
            if( isAxisymmetric.eq.1 )then
              radi=radiusInverse(i1,i2,i3)
              if( radi.ne.0. )then
                fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0y*radi )    
     &         ! add u_r/r
                fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( (v0y -vv*radi)
     & *radi ) ! add v_r/r - v/r^2
              else
                fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0yy )    ! add u_rr
                fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( .5*v0yy ) ! add .5*vrr
              end if
            end if
            if( pdeModel.eq.BoussinesqModel )then
             fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
             fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
             fe(i1,i2,i3,qc) = fi(i1,i2,i3,qc) - ugv*q0x -vgv*q0y  + 
     & adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1+1,i2,i3,
     & qc)+u(i1,i2+1,i3,qc)-4.*u(i1,i2,i3,qc))
             if( materialFormat.eq.constantMaterialProperties )then
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*(q0xx+q0yy)
             else
              ! -- variable material properties : 
              ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
               ! ---------- 2D -----------
               ! Get coefficients at nearby points: 
               if( materialFormat.eq.constantMaterialProperties )then
                 ! const material properties 
                 stop 11199
               else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                 ! piecewise constant material properties
                 scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                 Kzmz=thermalKpc(i1  ,i2-1,i3)
                 Kmzz=thermalKpc(i1-1,i2  ,i3)
                 Kzzz=thermalKpc(i1  ,i2  ,i3)
                 Kpzz=thermalKpc(i1+1,i2  ,i3)
                 Kzpz=thermalKpc(i1  ,i2+1,i3)
               else if( materialFormat.eq.variableMaterialProperties )
     & then
                 ! variable material properties
                 scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                 Kzmz=thermalKv(i1  ,i2-1,i3)
                 Kmzz=thermalKv(i1-1,i2  ,i3)
                 Kzzz=thermalKv(i1  ,i2  ,i3)
                 Kpzz=thermalKv(i1+1,i2  ,i3)
                 Kzpz=thermalKv(i1  ,i2+1,i3)
               end if
               !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
                 K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
                 K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
                 K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
                 K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
                 au11ph = K0ph*dxvsqi(0)*(scale)
                 au11mh = K0mh*dxvsqi(0)*(scale)
                 au22ph = K1ph*dxvsqi(1)*(scale)
                 au22mh = K1mh*dxvsqi(1)*(scale)
                 au12pzz=0.
                 au12mzz=0.
                 au21zpz=0.
                 au21zmz=0.
               ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
               ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
               ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
                ! 2D, order 2:
                dsgT = ( (au12mzz+au21zmz)*u(i1-1,i2-1,i3,qc) + (
     & au22mh)*u(i1,i2-1,i3,qc)+(-au12pzz-au21zmz)*u(i1+1,i2-1,i3,qc)+
     & (au11mh)*u(i1-1,i2,i3,qc)+(-au11ph-au11mh -au22ph -au22mh)*u(
     & i1,i2,i3,qc)+(au11ph)*u(i1+1,i2,i3,qc)+(-au12mzz-au21zpz)*u(i1-
     & 1,i2+1,i3,qc)+(au22ph)*u(i1,i2+1,i3,qc)+(au12pzz+au21zpz)*u(i1+
     & 1,i2+1,i3,qc) )
              fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
             endif
             if( isAxisymmetric.eq.1 )then
              radi=radiusInverse(i1,i2,i3)
              if( radi.ne.0. )then
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0y*
     & radi )  ! add u_r/r
              else
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0yy )  
     &     ! add u_rr
              end if
             end if
            end if
          end if
          end do
          end do
          end do
         end if
      else if( nd.eq.2 .and. gridType.eq.curvilinear .and. 
     & orderOfAccuracy.eq.2 )then
       ! fill the coefficients:
        ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
        if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           ! --- fill coefficients for a scalar system for a velocity component: I - nu*Delta - A.D. 
           ! write(*,'("@@@@ insImpINS: (u,v,w) fillCoefficientsScalarSystem=",i4)') fillCoefficientsScalarSystem
           ! '
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! this next call will define the jacobian and its derivatives (parameteric and spatial)
           ajrx = rsxy(i1,i2,i3,0,0)
           ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*dr(
     & 0))
           ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*dr(
     & 1))
           ajsx = rsxy(i1,i2,i3,1,0)
           ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*dr(
     & 0))
           ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*dr(
     & 1))
           ajry = rsxy(i1,i2,i3,0,1)
           ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*dr(
     & 0))
           ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*dr(
     & 1))
           ajsy = rsxy(i1,i2,i3,1,1)
           ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*dr(
     & 0))
           ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*dr(
     & 1))
           ajrxx = ajrx*ajrxr+ajsx*ajrxs
           ajrxy = ajry*ajrxr+ajsy*ajrxs
           ajsxx = ajrx*ajsxr+ajsx*ajsxs
           ajsxy = ajry*ajsxr+ajsy*ajsxs
           ajryx = ajrx*ajryr+ajsx*ajrys
           ajryy = ajry*ajryr+ajsy*ajrys
           ajsyx = ajrx*ajsyr+ajsx*ajsys
           ajsyy = ajry*ajsyr+ajsy*ajsys
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
            ! Operator laplacian = rx^2*urr+2*rx*sx*urs+sx^2*uss+rxx*ur+sxx*us+ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
             cur = ajrxx+ajryy
             curr = ajrx**2+ajry**2
             cus = ajsxx+ajsyy
             curs = 2.*ajrx*ajsx+2.*ajry*ajsy
             cuss = ajsx**2+ajsy**2
             lapCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(1)*
     & *2
             lapCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss
             dissCoeff(ma2(-1,-1, 0)) = 0
             dissCoeff(ma2( 0,-1, 0)) = 1
             dissCoeff(ma2( 1,-1, 0)) = 0
             dissCoeff(ma2(-1, 0, 0)) = 1
             dissCoeff(ma2( 0, 0, 0)) = -4
             dissCoeff(ma2( 1, 0, 0)) = 1
             dissCoeff(ma2(-1, 1, 0)) = 0
             dissCoeff(ma2( 0, 1, 0)) = 1
             dissCoeff(ma2( 1, 1, 0)) = 0
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu = u(i1,i2,i3,uc)
           uur = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
           uus = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = ajrx*uur+ajsx*uus
            u0y = ajry*uur+ajsy*uus
          ! parametric derivatives of v: 
           vv = u(i1,i2,i3,vc)
           vvr = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dr(0))
           vvs = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dr(1))
            v0x = ajrx*vvr+ajsx*vvs
            v0y = ajry*vvr+ajsy*vvs
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y) + abs(v0x)+abs(
     & v0y) )
         ! Form : I - nuDt*Delta -adCoeff*dt*( urr + uss + .. )
          do m3=-halfWidth3,halfWidth3
          do m2=-halfWidth,halfWidth
          do m1=-halfWidth,halfWidth
            coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(m1,m2,
     & m3)))+(-nuDt*lapCoeff(ma2(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(
     & ma2(m1,m2,m3)))
          end do
          end do
          end do
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
               ! Operator y = ry*ur+sy*us
                cur = ajry
                cus = ajsy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma2( 1, 1, 0)) = 0
             if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3))
     & )
               end do
               end do
               end do
             else
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3))
     & )+(nuDt*radi**2*iCoeff(ma2(m1,m2,m3)))
               end do
               end do
               end do
             end if
            else
             ! corrections on the axis
               ! Operator yy = ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
                cur = ajryy
                curr = ajry**2
                cus = ajsyy
                curs = 2.*ajry*ajsy
                cuss = ajsy**2
                yyCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(
     & 1)**2
                yyCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*yyCoeff(ma2(m1,m2,m3)))
               end do
               end do
               end do
             else
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*.5*yyCoeff(ma2(m1,m2,m3)))
               end do
               end do
               end do
             end if
            end if
          end if
           end if
          end do
          end do
          end do
         else if( fillCoefficientsScalarSystem.eq.fillCoeffT )then
           ! --- fill coefficients for a scalar system for the Temperature: I - kappa*Delta - A.D. 
          write(*,'("@@@@ insImpINS: T: fillCoefficientsScalarSystem=",
     & i4)') fillCoefficientsScalarSystem
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! this next call will define the jacobian and its derivatives (parameteric and spatial)
           ajrx = rsxy(i1,i2,i3,0,0)
           ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*dr(
     & 0))
           ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*dr(
     & 1))
           ajsx = rsxy(i1,i2,i3,1,0)
           ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*dr(
     & 0))
           ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*dr(
     & 1))
           ajry = rsxy(i1,i2,i3,0,1)
           ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*dr(
     & 0))
           ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*dr(
     & 1))
           ajsy = rsxy(i1,i2,i3,1,1)
           ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*dr(
     & 0))
           ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*dr(
     & 1))
           ajrxx = ajrx*ajrxr+ajsx*ajrxs
           ajrxy = ajry*ajrxr+ajsy*ajrxs
           ajsxx = ajrx*ajsxr+ajsx*ajsxs
           ajsxy = ajry*ajsxr+ajsy*ajsxs
           ajryx = ajrx*ajryr+ajsx*ajrys
           ajryy = ajry*ajryr+ajsy*ajrys
           ajsyx = ajrx*ajsyr+ajsx*ajsys
           ajsyy = ajry*ajsyr+ajsy*ajsys
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
            ! Operator laplacian = rx^2*urr+2*rx*sx*urs+sx^2*uss+rxx*ur+sxx*us+ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
             cur = ajrxx+ajryy
             curr = ajrx**2+ajry**2
             cus = ajsxx+ajsyy
             curs = 2.*ajrx*ajsx+2.*ajry*ajsy
             cuss = ajsx**2+ajsy**2
             lapCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(1)*
     & *2
             lapCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss
             dissCoeff(ma2(-1,-1, 0)) = 0
             dissCoeff(ma2( 0,-1, 0)) = 1
             dissCoeff(ma2( 1,-1, 0)) = 0
             dissCoeff(ma2(-1, 0, 0)) = 1
             dissCoeff(ma2( 0, 0, 0)) = -4
             dissCoeff(ma2( 1, 0, 0)) = 1
             dissCoeff(ma2(-1, 1, 0)) = 0
             dissCoeff(ma2( 0, 1, 0)) = 1
             dissCoeff(ma2( 1, 1, 0)) = 0
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma2(m1,m2,m3)))+(-adcBoussinesq*dt*
     & dissCoeff(ma2(m1,m2,m3)))
             end do
             end do
             end do
          else
           ! -- variable material properties : 
           ! get coefficients scaled by -dt*implicitFactor: 
            ! ---------- 2D -----------
            ! Get coefficients at nearby points: 
            if( materialFormat.eq.constantMaterialProperties )then
              ! const material properties 
              stop 11199
            else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
              ! piecewise constant material properties
              scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
              Kzmz=thermalKpc(i1  ,i2-1,i3)
              Kmzz=thermalKpc(i1-1,i2  ,i3)
              Kzzz=thermalKpc(i1  ,i2  ,i3)
              Kpzz=thermalKpc(i1+1,i2  ,i3)
              Kzpz=thermalKpc(i1  ,i2+1,i3)
            else if( materialFormat.eq.variableMaterialProperties )then
              ! variable material properties
              scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
              Kzmz=thermalKv(i1  ,i2-1,i3)
              Kmzz=thermalKv(i1-1,i2  ,i3)
              Kzzz=thermalKv(i1  ,i2  ,i3)
              Kpzz=thermalKv(i1+1,i2  ,i3)
              Kzpz=thermalKv(i1  ,i2+1,i3)
            end if
            !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
             ! evaluate the jacobian at nearby points:
             ajzmz = (1./(rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,i3)*
     & sx(i1,i2-1,i3)))
             ajmzz = (1./(rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,i3)*
     & sx(i1-1,i2,i3)))
             ajzzz = (1./(rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*sx(i1,
     & i2,i3)))
             ajpzz = (1./(rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,i3)*
     & sx(i1+1,i2,i3)))
             ajzpz = (1./(rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,i3)*
     & sx(i1,i2+1,i3)))
             ! 1. Get coefficients au11ph, au11mh, au22ph, etc. for 
             !          Dx( K*u.x ) + Dy( K*u.y ) 
              au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) )
              au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) )
              au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) )
              au11ph = .5*( au11zzz+au11pzz )
              au11mh = .5*( au11zzz+au11mzz )
              au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) )
              au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) )
              au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) )
              au22ph = .5*( au22zzz+au22zpz )
              au22mh = .5*( au22zzz+au22zmz )
              au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) )
              au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) )
              au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) )
              au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) )
              au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) )
              au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) )
             ! scaling factors: 
             dr0i = (scale)/(ajzzz*dr(0)**2)
             dr1i = (scale)/(ajzzz*dr(1)**2)
             dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
              au11ph=au11ph*dr0i
              au11mh=au11mh*dr0i
              au22ph=au22ph*dr1i
              au22mh=au22mh*dr1i
              au12pzz=au12pzz*dr0dr1
              au12mzz=au12mzz*dr0dr1
              au21zpz=au21zpz*dr0dr1
              au21zmz=au21zmz*dr0dr1
            ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
            ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
            ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
           ! Set coeff = - dtImp*div( K grad)
               coeff(mce2(-1,-1,0,cmpu,eqnu),i1,i2,i3)=  au12mzz+
     & au21zmz
               coeff(mce2(0,-1,0,cmpu,eqnu),i1,i2,i3)=                 
     &      au22mh
               coeff(mce2(1,-1,0,cmpu,eqnu),i1,i2,i3)= -au12pzz-au21zmz
               coeff(mce2(-1,0,0,cmpu,eqnu),i1,i2,i3)=         au11mh
               coeff(mce2(0,0,0,cmpu,eqnu),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh
               coeff(mce2(1,0,0,cmpu,eqnu),i1,i2,i3)=  au11ph
               coeff(mce2(-1,1,0,cmpu,eqnu),i1,i2,i3)= -au12mzz-au21zpz
               coeff(mce2(0,1,0,cmpu,eqnu),i1,i2,i3)=               
     & au22ph
               coeff(mce2(1,1,0,cmpu,eqnu),i1,i2,i3)=  au12pzz+au21zpz
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
              coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(iCoeff(ma2(m1,m2,m3)))+(-
     & adcBoussinesq*dt*dissCoeff(ma2(m1,m2,m3)))
            end do
            end do
            end do
          endif
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            ! *** FIX ME FOR variable material properties ***
            if( materialFormat.ne.constantMaterialProperties )then
              stop 6205
            end if
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
               ! Operator y = ry*ur+sy*us
                cur = ajry
                cus = ajsy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma2( 1, 1, 0)) = 0
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-kDt*radi*yCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            else
             ! corrections on the axis
               ! Operator yy = ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
                cur = ajryy
                curr = ajry**2
                cus = ajsyy
                curs = 2.*ajry*ajsy
                cuss = ajsy**2
                yyCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(
     & 1)**2
                yyCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-kDt*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            end if
          end if
           end if
          end do
          end do
          end do
         else
           ! --- fill coefficients for the full system ---
         ! write(*,'("&&&&& insImpINS: fill coefficients for a full system, pdeModel=",i3)') pdeModel
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! this next call will define the jacobian and its derivatives (parameteric and spatial)
           ajrx = rsxy(i1,i2,i3,0,0)
           ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*dr(
     & 0))
           ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*dr(
     & 1))
           ajsx = rsxy(i1,i2,i3,1,0)
           ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*dr(
     & 0))
           ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*dr(
     & 1))
           ajry = rsxy(i1,i2,i3,0,1)
           ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*dr(
     & 0))
           ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*dr(
     & 1))
           ajsy = rsxy(i1,i2,i3,1,1)
           ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*dr(
     & 0))
           ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*dr(
     & 1))
           ajrxx = ajrx*ajrxr+ajsx*ajrxs
           ajrxy = ajry*ajrxr+ajsy*ajrxs
           ajsxx = ajrx*ajsxr+ajsx*ajsxs
           ajsxy = ajry*ajsxr+ajsy*ajsxs
           ajryx = ajrx*ajryr+ajsx*ajrys
           ajryy = ajry*ajryr+ajsy*ajrys
           ajsyx = ajrx*ajsyr+ajsx*ajsys
           ajsyy = ajry*ajsyr+ajsy*ajsys
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
            ! Operator laplacian = rx^2*urr+2*rx*sx*urs+sx^2*uss+rxx*ur+sxx*us+ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
             cur = ajrxx+ajryy
             curr = ajrx**2+ajry**2
             cus = ajsxx+ajsyy
             curs = 2.*ajrx*ajsx+2.*ajry*ajsy
             cuss = ajsx**2+ajsy**2
             lapCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(1)*
     & *2
             lapCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
            ! Operator x = rx*ur+sx*us
             cur = ajrx
             cus = ajsx
             xCoeff(ma2(-1,-1, 0)) = 0
             xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
             xCoeff(ma2( 1,-1, 0)) = 0
             xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
             xCoeff(ma2( 0, 0, 0)) = 0
             xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
             xCoeff(ma2(-1, 1, 0)) = 0
             xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
             xCoeff(ma2( 1, 1, 0)) = 0
            ! Operator y = ry*ur+sy*us
             cur = ajry
             cus = ajsy
             yCoeff(ma2(-1,-1, 0)) = 0
             yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
             yCoeff(ma2( 1,-1, 0)) = 0
             yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
             yCoeff(ma2( 0, 0, 0)) = 0
             yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
             yCoeff(ma2(-1, 1, 0)) = 0
             yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
             yCoeff(ma2( 1, 1, 0)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss
             dissCoeff(ma2(-1,-1, 0)) = 0
             dissCoeff(ma2( 0,-1, 0)) = 1
             dissCoeff(ma2( 1,-1, 0)) = 0
             dissCoeff(ma2(-1, 0, 0)) = 1
             dissCoeff(ma2( 0, 0, 0)) = -4
             dissCoeff(ma2( 1, 0, 0)) = 1
             dissCoeff(ma2(-1, 1, 0)) = 0
             dissCoeff(ma2( 0, 1, 0)) = 1
             dissCoeff(ma2( 1, 1, 0)) = 0
          ! for testing, get coeff for div( s grad )
          ! getOpCoeffDivScalarGrad(s(i1,i2,i3,0))
          ! **** get a fourth order dissipation u.rrrr + u.ssss 
          ! evaluate forward derivatives of the current solution: 
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu = u(i1,i2,i3,uc)
           uur = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
           uus = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = ajrx*uur+ajsx*uus
            u0y = ajry*uur+ajsy*uus
          ! parametric derivatives of v: 
           vv = u(i1,i2,i3,vc)
           vvr = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dr(0))
           vvs = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dr(1))
            v0x = ajrx*vvr+ajsx*vvs
            v0y = ajry*vvr+ajsy*vvs
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y) + abs(v0x)+abs(
     & v0y) )
         if( gridIsMoving.ne.0 )then
           ugv = uu - gv(i1,i2,i3,0)
           vgv = vv - gv(i1,i2,i3,1)
         else
           ugv = uu
           vgv = vv
         end if
          ! Form : I - nuDt*Delta + aDt*u*Dx + aDt*v*Dy + ...
          !    u0*ux + v0*uy + u*u0x + v*u0y 
          ! moving: (u-gv)*ux =  u*ux - gv*ux -> u0*ux+u*u0x-gv*ux = (u0-gv)*ux + u0x*u (linearized form)
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma2(m1,m2,m3)))+(adt*ugv*xCoeff(ma2(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(bDt*u0x*iCoeff(
     & ma2(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpv,eqnu),i1,i2,i3)+(bDt*u0y*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
          ! addCoeff1(cmpv,eqnu,coeff, bDt*iCoeff)  ! for testing -- add v to u-eqn
          !    u0*vx + v0*vy + u*v0x + v*v0y 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma2(m1,m2,m3)))+(adt*ugv*xCoeff(ma2(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(bDt*v0y*iCoeff(
     & ma2(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpu,eqnv),i1,i2,i3)+(bDt*v0x*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpv,eqnv),i1,i2,i3)+(-nuDt*radi*yCoeff(ma2(m1,m2,m3)))+(
     & nuDt*radi**2*iCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            else
             ! corrections on the axis
               ! Operator yy = ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
                cur = ajryy
                curr = ajry**2
                cus = ajsyy
                curs = 2.*ajry*ajsy
                cuss = ajsy**2
                yyCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(
     & 1)**2
                yyCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(-nuDt*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpv,eqnv),i1,i2,i3)+(-nuDt*.5*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            end if
          end if
         if( pdeModel.eq.BoussinesqModel )then
          ! ----------------------------------------------------------------------------
          ! ---------- add the temperature equation to the full system -----------------
          ! ----------------------------------------------------------------------------
           qq = u(i1,i2,i3,qc)
           qqr = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dr(0))
           qqs = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dr(1))
            q0x = ajrx*qqr+ajsx*qqs
            q0y = ajry*qqr+ajsy*qqs
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties:
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma2(m1,m2,m3)))+(adt*ugv*xCoeff(ma2(m1,
     & m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(-adcBoussinesq*dt*
     & dissCoeff(ma2(m1,m2,m3)))
             end do
             end do
             end do
          else
           ! get coefficients scaled by -dt*implicitFactor: 
            ! ---------- 2D -----------
            ! Get coefficients at nearby points: 
            if( materialFormat.eq.constantMaterialProperties )then
              ! const material properties 
              stop 11199
            else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
              ! piecewise constant material properties
              scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
              Kzmz=thermalKpc(i1  ,i2-1,i3)
              Kmzz=thermalKpc(i1-1,i2  ,i3)
              Kzzz=thermalKpc(i1  ,i2  ,i3)
              Kpzz=thermalKpc(i1+1,i2  ,i3)
              Kzpz=thermalKpc(i1  ,i2+1,i3)
            else if( materialFormat.eq.variableMaterialProperties )then
              ! variable material properties
              scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
              Kzmz=thermalKv(i1  ,i2-1,i3)
              Kmzz=thermalKv(i1-1,i2  ,i3)
              Kzzz=thermalKv(i1  ,i2  ,i3)
              Kpzz=thermalKv(i1+1,i2  ,i3)
              Kzpz=thermalKv(i1  ,i2+1,i3)
            end if
            !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
             ! evaluate the jacobian at nearby points:
             ajzmz = (1./(rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,i3)*
     & sx(i1,i2-1,i3)))
             ajmzz = (1./(rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,i3)*
     & sx(i1-1,i2,i3)))
             ajzzz = (1./(rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*sx(i1,
     & i2,i3)))
             ajpzz = (1./(rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,i3)*
     & sx(i1+1,i2,i3)))
             ajzpz = (1./(rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,i3)*
     & sx(i1,i2+1,i3)))
             ! 1. Get coefficients au11ph, au11mh, au22ph, etc. for 
             !          Dx( K*u.x ) + Dy( K*u.y ) 
              au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) )
              au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) )
              au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) )
              au11ph = .5*( au11zzz+au11pzz )
              au11mh = .5*( au11zzz+au11mzz )
              au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) )
              au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) )
              au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) )
              au22ph = .5*( au22zzz+au22zpz )
              au22mh = .5*( au22zzz+au22zmz )
              au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) )
              au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) )
              au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) )
              au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) )
              au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) )
              au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) )
             ! scaling factors: 
             dr0i = (scale)/(ajzzz*dr(0)**2)
             dr1i = (scale)/(ajzzz*dr(1)**2)
             dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
              au11ph=au11ph*dr0i
              au11mh=au11mh*dr0i
              au22ph=au22ph*dr1i
              au22mh=au22mh*dr1i
              au12pzz=au12pzz*dr0dr1
              au12mzz=au12mzz*dr0dr1
              au21zpz=au21zpz*dr0dr1
              au21zmz=au21zmz*dr0dr1
            ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
            ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
            ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
             coeff(mce2(-1,-1,0,cmpq,eqnq),i1,i2,i3)=  au12mzz+au21zmz
             coeff(mce2(0,-1,0,cmpq,eqnq),i1,i2,i3)=                   
     &    au22mh
             coeff(mce2(1,-1,0,cmpq,eqnq),i1,i2,i3)= -au12pzz-au21zmz
             coeff(mce2(-1,0,0,cmpq,eqnq),i1,i2,i3)=         au11mh
             coeff(mce2(0,0,0,cmpq,eqnq),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh
             coeff(mce2(1,0,0,cmpq,eqnq),i1,i2,i3)=  au11ph
             coeff(mce2(-1,1,0,cmpq,eqnq),i1,i2,i3)= -au12mzz-au21zpz
             coeff(mce2(0,1,0,cmpq,eqnq),i1,i2,i3)=               
     & au22ph
             coeff(mce2(1,1,0,cmpq,eqnq),i1,i2,i3)=  au12pzz+au21zpz
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
              coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(iCoeff(ma2(m1,m2,m3)))+(adt*ugv*
     & xCoeff(ma2(m1,m2,m3)))+(adt*vgv*yCoeff(ma2(m1,m2,m3)))+(-
     & adcBoussinesq*dt*dissCoeff(ma2(m1,m2,m3)))
            end do
            end do
            end do
          endif
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpu,eqnq),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpu,eqnq),i1,i2,i3)+(bDt*q0x*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpv,eqnq),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpv,eqnq),i1,i2,i3)+(bDt*q0y*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpq,eqnu),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpq,eqnu),i1,i2,i3)+(teDt*gravity(0)*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce2(m1,m2,m3,cmpq,eqnv),i1,i2,i3)=coeff(mce2(m1,m2,
     & m3,cmpq,eqnv),i1,i2,i3)+(teDt*gravity(1)*iCoeff(ma2(m1,m2,m3)))
           end do
           end do
           end do
          if( isAxisymmetric.eq.1 )then
            ! add axisymmetric corrections 
            ! *** FIX ME FOR variable material properties ***
            if( materialFormat.ne.constantMaterialProperties )then
              stop 6206
            end if
            radi = radiusInverse(i1,i2,i3)
            if( radi.ne.0. )then
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(-kDt*radi*yCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            else
             ! corrections on the axis
               ! Operator yy = ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
                cur = ajryy
                curr = ajry**2
                cus = ajsyy
                curs = 2.*ajry*ajsy
                cuss = ajsy**2
                yyCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(
     & 1)**2
                yyCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
                yyCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                yyCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
                yyCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce2(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(-kDt*yyCoeff(ma2(m1,m2,m3)))
              end do
              end do
              end do
            end if
          end if
         endif  ! pdeModel.eq.BoussinesqModel
           end if
          end do
          end do
          end do
        end if
        end if
       ! fill matrix BCs
       if( fillCoefficients.eq.1 .or. 
     & evalResidualForBoundaryConditions.eq.1 )then
        indexRange(0,0)=n1a
        indexRange(1,0)=n1b
        indexRange(0,1)=n2a
        indexRange(1,1)=n2b
        indexRange(0,2)=n3a
        indexRange(1,2)=n3b
        do axis=0,nd-1
        do side=0,1
         is1=0
         is2=0
         is3=0
         if( axis.eq.0 )then
           is1=1-2*side
           n1a=indexRange(side,axis)
           n1b=n1a
         else if( axis.eq.1 )then
           is2=1-2*side
           n2a=indexRange(side,axis)
           n2b=n2a
         else
           is3=1-2*side
           n3a=indexRange(side,axis)
           n3b=n3a
         end if
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( bc0.eq.noSlipWall )then
            write(*,'(" ")')
            write(*,'(">>> insImpINS: fill Matrix Boundary Conditions: 
     & useImplicitAmpBCs=",i4," isBulkSolid=",i2)') useImplicitAmpBCs,
     & isBulkSolid
            write(*,'(">>> insImpINS: fill useAddedMassAlgorithm=",i4,
     & " projectAddedMassVelocity=",i4)') useAddedMassAlgorithm,
     & projectAddedMassVelocity
            write(*,'(">>> insImpINS: nu,dt,alpha,beta=",4e10.2)') nu,
     & dt,alpha,beta
         end if
         ! Some Bc's like no-slip wall use extrapolation for ghost, sometimes we turn this off, for example,
         ! for the AMP "no-slip wall" BCs
         extrapolateGhostByDefault=1
         if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ne.fillCoeffT )then
           ! ---- fill BC coeffs for (u,v,w) ---
           bc0 = bc(side,axis)
           if( bc0.eq.slipWall .and. fillCoefficientsScalarSystem.gt.0 
     & )then
             if( fillCoefficientsScalarSystem.eq.(axis+1) )then
               bc0=dirichletBoundaryCondition
             else
               bc0=neumannBoundaryCondition
             end if
           end if
         if( bc0.eq.noSlipWall .and. useAddedMassAlgorithm.eq.1 .and. 
     & projectAddedMassVelocity.eq.1 .and. isBulkSolid.eq.1 )then
           ! ** AMP NO-SLIP WALL BCs FOR A BULK SOLID INTERFACE *** 
           !  The AMP conditions (see fib and fibr papers) have a limit of
           !  a no-slip wall for a heavy solid and a free surface for a light solid
          write(*,'(" insImpINS: FILL IMPLICIT AMP velocity BCs: 
     & fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
          if( mu.eq.0. )then
            write(*,'(" insImpINS:ERROR: mu=0 : nu,fluidDensity=",
     & 2e10.2)') nu,fluidDensity
            stop 0099
          end if
          extrapolateGhostByDefault=0 ! do NOT extrapolate ghost points (below)
          if( useImplicitAmpBCs.eq.0 )then
            write(*,'(" --- USE OLD WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=0 --- ")')
            ! *** DO THIS FOR NOW ***
            ! Dirichlet BC
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
             do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           !   opEvalJacobianDerivatives(aj,1)
             ! evaluate the coeff operators 
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
           !   getCoeff(x, xCoeff,aj)
           !   getCoeff(y, yCoeff,aj)
             do n=0,ndu-1
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce2(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma2(m1,m2,m3)))
               end do
               end do
               end do
             end do
              end if
             end do
             end do
             end do
          else
           write(*,'("  ")')
           write(*,'(" --- USE NEW WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=1 --- ")')
           ! ********* NEW ADDED MASS BULK SOLID VELOCITY BCS ********
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
                 ! get the outward normal for curvilinear grids
                 an(0)=rsxy(i1,i2,i3,axis,0)
                 an(1)=rsxy(i1,i2,i3,axis,1)
                   anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(
     & 1)**2 ) )
                   an(0)=an(0)*anNorm
                   an(1)=an(1)*anNorm
             write(*,'(" IMP: AMP BC i1,i2=",2i2," ndu=",i4," normal=",
     & 2e10.2)') i1,i2,ndu,an(0),an(1)
             ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
             ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') AMG(0,0,0),AMG(0,0,1),AMG(0,1,0),AMG(0,1,1)
             ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') AMG(1,0,0),AMG(1,0,1),AMG(1,1,0),AMG(1,1,1)
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! this next call will define the jacobian and its derivatives (parameteric and spatial)
              ajrx = rsxy(i1,i2,i3,0,0)
              ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
              ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
              ajsx = rsxy(i1,i2,i3,1,0)
              ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
              ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
              ajry = rsxy(i1,i2,i3,0,1)
              ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
              ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
              ajsy = rsxy(i1,i2,i3,1,1)
              ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
              ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
              ajrxx = ajrx*ajrxr+ajsx*ajrxs
              ajrxy = ajry*ajrxr+ajsy*ajrxs
              ajsxx = ajrx*ajsxr+ajsx*ajsxs
              ajsxy = ajry*ajsxr+ajsy*ajsxs
              ajryx = ajrx*ajryr+ajsx*ajrys
              ajryy = ajry*ajryr+ajsy*ajrys
              ajsyx = ajrx*ajsyr+ajsx*ajsys
              ajsyy = ajry*ajsyr+ajsy*ajsys
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = rx*ur+sx*us
                cur = ajrx
                cus = ajsx
                xCoeff(ma2(-1,-1, 0)) = 0
                xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                xCoeff(ma2( 1,-1, 0)) = 0
                xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                xCoeff(ma2( 0, 0, 0)) = 0
                xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                xCoeff(ma2(-1, 1, 0)) = 0
                xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                xCoeff(ma2( 1, 1, 0)) = 0
               ! Operator y = ry*ur+sy*us
                cur = ajry
                cus = ajsy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma2( 1, 1, 0)) = 0
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
               ! Operator laplacian = rx^2*urr+2*rx*sx*urs+sx^2*uss+rxx*ur+sxx*us+ry^2*urr+2*ry*sy*urs+sy^2*uss+ryy*ur+syy*us
                cur = ajrxx+ajryy
                curr = ajrx**2+ajry**2
                cus = ajsxx+ajsyy
                curs = 2.*ajrx*ajsx+2.*ajry*ajsy
                cuss = ajsx**2+ajsy**2
                lapCoeff(ma2(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**
     & 2
                lapCoeff(ma2( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**
     & 2
                lapCoeff(ma2( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(
     & 1)**2
                lapCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
                lapCoeff(ma2(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
                lapCoeff(ma2( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             ! Equations on the ghost point:
             do m=0,ndc-1
              coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
             end do
             ! Equations on the boundary:
             do m=0,ndc-1
              coeff(m,i1,i2,i3)=0.  ! init all elements to zero
             end do
             beta = implicitFactor*nu*dt
             !! beta = 0. ! TEST
              ! ******************************** TWO DIMENSIONS ***********************************
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled BC equations for u and v  
               ! -------------Coefficients in the the ghost point equation ----------
               do n=0,nd-1
                 ! equation n:  (equation numbers and classify  are set in these calls)
                 ! write(*,'(" (i1,i2,n)=(",i3,",",i3,",",i2,") amg-coeff=",6e10.2)') i1,i2,n,AMG(n,0,0),AMG(n,0,1),AMG0(n,0),AMG(n,1,0),AMG(n,1,1),AMG0(n,1)
                   classify(i1m,i2m,i3m,eqnu+n)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))+((+(delta(n,0)-an(n)*an(0))*(zs/mu))*iCoeff(ma2(m1,m2,m3)
     & ))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,m3)))+(
     & (+(delta(n,1)-an(n)*an(1))*(zs/mu))*iCoeff(ma2(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
                ! We decouple the coupled velocity components: Only add coefficients of u 
                n=0
                  classify(i1m,i2m,i3m,eqnu)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((delta(
     & 0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(0)*an(
     & 0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*an(1)+
     & delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,m3)))+(
     & (+(delta(n,0)-an(n)*an(0))*(zs/mu))*iCoeff(ma2(m1,m2,m3)))
                  ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                   equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)
     & =(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
                ! We decouple the coupled velocity components: Only add components of v 
                n=1
                  classify(i1m,i2m,i3m,eqnu)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((delta(
     & 1,0)*an(n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(
     & 0))*xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,m3)))+(
     & (+(delta(n,1)-an(n)*an(1))*(zs/mu))*iCoeff(ma2(m1,m2,m3)))
                  ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                   equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)
     & =(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              end if
              ! ------------- Coefficients on the boundary ----------------
              ! evaluate the coeff operators 
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled equations for u and v  
               write(*,'(" insImpINS: beta=",e10.3," amg-delta=",
     & 4e10.3)') beta,(-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0))),(-
     & beta*(delta(0,1)-(1.-alpha)*an(0)*an(1))),(-beta*(delta(1,0)-(
     & 1.-alpha)*an(1)*an(0))),(-beta*(delta(1,1)-(1.-alpha)*an(1)*an(
     & 1)))
               ! u equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpv,eqnu),i1,i2,i3)+((-beta*(delta(0,1)-(1.-alpha)*
     & an(0)*an(1)))*lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
               ! v equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce2(
     & m1,m2,m3,cmpu,eqnv),i1,i2,i3)+((-beta*(delta(1,0)-(1.-alpha)*
     & an(1)*an(0)))*lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               ! We decouple the coupled velocity components: Only add coefficients of u 
               n=0
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
               ! We decouple the coupled velocity components: Only add components of v 
               n=1
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma2(m1,m2,m3)))
                end do
                end do
                end do
              end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent AMP NO-SLIP WALLS  -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.noSlipWall .or. bc(1,axisp1)
     & .eq.noSlipWall .or. bc(0,axisp2).eq.noSlipWall .or. bc(1,
     & axisp2).eq.noSlipWall )then
             write(*,'("insImpINS: ERROR: two AMP no-slip walls meet 
     & at a corner -- not implemented -- fix me")')
             stop 9099
           end if
           ! write(*,'(" Finished filling in implicit AMP velocity BCs -- stop for now")')
           ! stop 1004
          end if
         else if( bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
           do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
            coeff(m,i1,i2,i3)=0.
           end do
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
         !   opEvalJacobianDerivatives(aj,1)
           ! evaluate the coeff operators 
             ! Operator identity 
              iCoeff(ma2(-1,-1, 0)) = 0
              iCoeff(ma2( 0,-1, 0)) = 0
              iCoeff(ma2( 1,-1, 0)) = 0
              iCoeff(ma2(-1, 0, 0)) = 0
              iCoeff(ma2( 0, 0, 0)) = 1.
              iCoeff(ma2( 1, 0, 0)) = 0
              iCoeff(ma2(-1, 1, 0)) = 0
              iCoeff(ma2( 0, 1, 0)) = 0
              iCoeff(ma2( 1, 1, 0)) = 0
         !   getCoeff(x, xCoeff,aj)
         !   getCoeff(y, yCoeff,aj)
           do n=0,ndu-1
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma2(m1,m2,m3)))
             end do
             end do
             end do
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.outflow )then
          ! NOTE: outflowOption==0 is done below (extrapolation)
          if( outflowOption.eq.1 )then
           ! Neumann BC at outflow if outflowOption==1
            ! write(*,'("insImpINS: fill outflow BC into matrix: Neumann BC")')
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                ajrx = rsxy(i1,i2,i3,0,0)
                ajsx = rsxy(i1,i2,i3,1,0)
                ajry = rsxy(i1,i2,i3,0,1)
                ajsy = rsxy(i1,i2,i3,1,1)
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = rx*ur+sx*us
                  cur = ajrx
                  cus = ajsx
                  xCoeff(ma2(-1,-1, 0)) = 0
                  xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                  xCoeff(ma2( 1,-1, 0)) = 0
                  xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                  xCoeff(ma2( 0, 0, 0)) = 0
                  xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                  xCoeff(ma2(-1, 1, 0)) = 0
                  xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                  xCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator y = ry*ur+sy*us
                  cur = ajry
                  cus = ajsy
                  yCoeff(ma2(-1,-1, 0)) = 0
                  yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                  yCoeff(ma2( 1,-1, 0)) = 0
                  yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                  yCoeff(ma2( 0, 0, 0)) = 0
                  yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                  yCoeff(ma2(-1, 1, 0)) = 0
                  yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                  yCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator identity 
                  iCoeff(ma2(-1,-1, 0)) = 0
                  iCoeff(ma2( 0,-1, 0)) = 0
                  iCoeff(ma2( 1,-1, 0)) = 0
                  iCoeff(ma2(-1, 0, 0)) = 0
                  iCoeff(ma2( 0, 0, 0)) = 1.
                  iCoeff(ma2( 1, 0, 0)) = 0
                  iCoeff(ma2(-1, 1, 0)) = 0
                  iCoeff(ma2( 0, 1, 0)) = 0
                  iCoeff(ma2( 1, 1, 0)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma2(m1,m2,m3)
                mm=mce2(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
          else if( outflowOption.ne.0 )then
            write(*,'("insImpINS: fill outflow BC into matrix: ERROR: 
     & outflowOption=",i6)') outflowOption
          end if
         else if( bc0.eq.neumannBoundaryCondition )then
           ! Neumann BC (used by slipWall and scalar systems)
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                ajrx = rsxy(i1,i2,i3,0,0)
                ajsx = rsxy(i1,i2,i3,1,0)
                ajry = rsxy(i1,i2,i3,0,1)
                ajsy = rsxy(i1,i2,i3,1,1)
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = rx*ur+sx*us
                  cur = ajrx
                  cus = ajsx
                  xCoeff(ma2(-1,-1, 0)) = 0
                  xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                  xCoeff(ma2( 1,-1, 0)) = 0
                  xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                  xCoeff(ma2( 0, 0, 0)) = 0
                  xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                  xCoeff(ma2(-1, 1, 0)) = 0
                  xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                  xCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator y = ry*ur+sy*us
                  cur = ajry
                  cus = ajsy
                  yCoeff(ma2(-1,-1, 0)) = 0
                  yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                  yCoeff(ma2( 1,-1, 0)) = 0
                  yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                  yCoeff(ma2( 0, 0, 0)) = 0
                  yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                  yCoeff(ma2(-1, 1, 0)) = 0
                  yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                  yCoeff(ma2( 1, 1, 0)) = 0
                 ! Operator identity 
                  iCoeff(ma2(-1,-1, 0)) = 0
                  iCoeff(ma2( 0,-1, 0)) = 0
                  iCoeff(ma2( 1,-1, 0)) = 0
                  iCoeff(ma2(-1, 0, 0)) = 0
                  iCoeff(ma2( 0, 0, 0)) = 1.
                  iCoeff(ma2( 1, 0, 0)) = 0
                  iCoeff(ma2(-1, 1, 0)) = 0
                  iCoeff(ma2( 0, 1, 0)) = 0
                  iCoeff(ma2( 1, 1, 0)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma2(m1,m2,m3)
                mm=mce2(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
         else if( bc0.eq.freeSurfaceBoundaryCondition )then
           ! **FREE SURFACE BCs *** 
           ! NEW way: proper free-surface conditions *wdh* Sept 30, 2017
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
                  ! get the outward normal for curvilinear grids
                  an(0)=rsxy(i1,i2,i3,axis,0)
                  an(1)=rsxy(i1,i2,i3,axis,1)
                    anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(
     & 1)**2 ) )
                    an(0)=an(0)*anNorm
                    an(1)=an(1)*anNorm
              ! write(*,'(" IMP: FREE SURFACE i1,i2=",2i2," ndu=",i4," normal=",2e10.2)') i1,i2,ndu,an(0),an(1)
              ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
              ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') CSF(0,0,0),CSF(0,0,1),CSF(0,1,0),CSF(0,1,1)
              ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') CSF(1,0,0),CSF(1,0,1),CSF(1,1,0),CSF(1,1,1)
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! this next call will define the jacobian and its derivatives (parameteric and spatial)
               ajrx = rsxy(i1,i2,i3,0,0)
               ajsx = rsxy(i1,i2,i3,1,0)
               ajry = rsxy(i1,i2,i3,0,1)
               ajsy = rsxy(i1,i2,i3,1,1)
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = rx*ur+sx*us
                 cur = ajrx
                 cus = ajsx
                 xCoeff(ma2(-1,-1, 0)) = 0
                 xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                 xCoeff(ma2( 1,-1, 0)) = 0
                 xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                 xCoeff(ma2( 0, 0, 0)) = 0
                 xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                 xCoeff(ma2(-1, 1, 0)) = 0
                 xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                 xCoeff(ma2( 1, 1, 0)) = 0
                ! Operator y = ry*ur+sy*us
                 cur = ajry
                 cus = ajsy
                 yCoeff(ma2(-1,-1, 0)) = 0
                 yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                 yCoeff(ma2( 1,-1, 0)) = 0
                 yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                 yCoeff(ma2( 0, 0, 0)) = 0
                 yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                 yCoeff(ma2(-1, 1, 0)) = 0
                 yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                 yCoeff(ma2( 1, 1, 0)) = 0
              do m=0,ndc-1
               coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
              end do
               ! --- 2D ---
               if( fillCoefficientsScalarSystem.eq.0 )then
                ! Fill in the coupled equations for u and v  
                do n=0,nd-1
                  ! equation n:  (equation numbers and classify  are set in these calls)
                    classify(i1m,i2m,i3m,eqnu+n)=ghost1
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                     equationNumber(mce2(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                     equationNumber(mce2(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffU )
     & then
                 ! We decouple the coupled velocity components: Only add coefficients of u 
                 n=0
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffv )
     & then
                 ! We decouple the coupled velocity components: Only add components of v 
                 n=1
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(1,0)*an(n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(
     & 1)*an(0))*xCoeff(ma2(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*
     & an(1)+delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma2(m1,m2,
     & m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce2(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent free surface BCs -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.freeSurfaceBoundaryCondition .or. bc(1,
     & axisp1).eq.freeSurfaceBoundaryCondition .or. bc(0,axisp2)
     & .eq.freeSurfaceBoundaryCondition .or. bc(1,axisp2)
     & .eq.freeSurfaceBoundaryCondition )then
             write(*,'("insImpINS: ERROR: two free surfaces meet at a 
     & corner -- not implemented -- fix me")')
             stop 9099
           end if
         else if( bc0.eq.slipWall )then
           ! SLIP-WALL
           ! NOTE: Here we assume the matrix already includes the interior equations on the boundary 
           ! NOTE: what about corners ???
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
            write(*,'(" insImpINS: slipWall BC not finished for scalar 
     & systems")')
            stop 8130
          end if
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
               ! get the outward normal for curvilinear grids
               an(0)=rsxy(i1,i2,i3,axis,0)
               an(1)=rsxy(i1,i2,i3,axis,1)
                 anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)*
     & *2 ) )
                 an(0)=an(0)*anNorm
                 an(1)=an(1)*anNorm
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.u"  -->  nDot(mc3(m1,m2,m3,c)) = iCoeff(m1,m2,m3)*an(c-cmpu)
           !nDot=0
           !nDot(mc3(0,0,0,cmpu))=an(0)
           !nDot(mc3(0,0,0,cmpv))=an(1)
           !nDot(mc3(0,0,0,cmpw))=an(2)
           ! Form the matrix for "n.Lu"
           nDotL(0)=an(0)*coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)
           nDotL(1)=an(0)*coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)
           ! form the matrix for  Lu + [ (n.u) - (n.(Lu)) ] n 
           !  eqnu:  (n1*u1+n2*u2+n3*u3)*n1 + L1(u) - nDotL*n1    
           !  eqnv:  (n1*u1+n2*u2+n3*u3)*n2 + L2(u) - nDotL*n2
           !  eqnw:  (n1*u1+n2*u2+n3*u3)*n3 + L3(u) - nDotL*n3
           !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
           do e=eqnu,eqnu+nd-1
           do c=cmpu,cmpu+nd-1
            coeff(mce2(m1,m2,m3,c,e),i1,i2,i3)= coeff(mce2(m1,m2,m3,c,
     & e),i1,i2,i3) + an(e-eqnu)*(iCoeff(ma2(m1,m2,m3))*an(c-cmpu)-
     & nDotL(c-cmpu))
           end do
           end do
           end do
           end do
           end do
          ! fill ghost pt eqn's with a vector symmetry condition:
           ! write(*,'(" VS: i1,i2=",2i2," normal=",2f5.2)') i1,i2,an(0),an(1)
           i1m=i1-is1  ! ghost point
           i2m=i2-is2
           i3m=i3-is3
           do m=0,ndc-1
            coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
           end do
           mv(0)=0
           mv(1)=0
           mv(2)=0
           do e=eqnu,eqnu+nd-1
            c=cmpu+e-eqnu
            mv(axis)=2*side-1
            mm=mce2(mv(0),mv(1),mv(2),c,e)  ! matrix index for ghost pt
            coeff(mm,i1m,i2m,i3m)=1.  ! coeff of ghost point
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            mv(axis)=-(2*side-1)
            mm=mce2(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
            coeff(mm,i1m,i2m,i3m)=-1.
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            ! now add on the term: 2*(n.u(1))n 
            do c=cmpu,cmpu+nd-1
             mm=mce2(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
             ! write(*,'(" VS: mm,i1,i2,e,c=",5i2," n,n=",2f5.2)') mm,i1,i2,e,c,an(c-cmpu),an(e-eqnu)
             coeff(mm,i1m,i2m,i3m)=coeff(mm,i1m,i2m,i3m) + 2.*an(c-
     & cmpu)*an(e-eqnu)
              equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            end do
             classify(i1m,i2m,i3m,e)=ghost1
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.inflowWithPandTV )then
           ! ------------------------------------------------
           ! ---- pressure and tangential velocity given ----
           ! ------------------------------------------------
          write(*,'("insImpINS: fill in BC pressure and tangential 
     & velocity ** check me** ")')
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           write(*,'(" fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
           ! --- fill coefficients for scalar systems ---
           ! This only works if the boundary face is on a plane x=constant, y=constant or z=constant 
           ! Added May 13, 2017 *wdh*
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs
             ajrxy = ajry*ajrxr+ajsy*ajrxs
             ajsxx = ajrx*ajsxr+ajsx*ajsxs
             ajsxy = ajry*ajsxr+ajsy*ajsxs
             ajryx = ajrx*ajryr+ajsx*ajrys
             ajryy = ajry*ajryr+ajsy*ajrys
             ajsyx = ajrx*ajsyr+ajsx*ajsys
             ajsyy = ajry*ajsyr+ajsy*ajsys
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
            ! -- The grid face should be in a coordinate direction,
            !   normalAxis = 0,1, or 2 indicates this direction
            if( abs(abs(an(0))-1.) .lt. normalTol )then
             normalAxis=0
            else if( abs(abs(an(1))-1.) .lt. normalTol )then
             normalAxis=1
            else if(  abs(abs(an(2))-1.) .lt. normalTol )then
             normalAxis=2
            else
              write(*,'(" insImpINS: ERROR: inflowWithPandTV, scalar 
     & systems but normals funny")')
              write(*,'("  --> the normals should be in a coordinate 
     & direction")')
              stop 1287
            end if
            !  --- equations for u ---
            if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
              if( normalAxis.eq.0 )then
               ! boundary face is x=constant:
               !  Give u.n = 0 
                   ! get the outward normal for curvilinear grids
                   an(0)=rsxy(i1,i2,i3,axis,0)
                   an(1)=rsxy(i1,i2,i3,axis,1)
                     anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + 
     & an(1)**2 ) )
                     an(0)=an(0)*anNorm
                     an(1)=an(1)*anNorm
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                 ajrx = rsxy(i1,i2,i3,0,0)
                 ajsx = rsxy(i1,i2,i3,1,0)
                 ajry = rsxy(i1,i2,i3,0,1)
                 ajsy = rsxy(i1,i2,i3,1,1)
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = rx*ur+sx*us
                   cur = ajrx
                   cus = ajsx
                   xCoeff(ma2(-1,-1, 0)) = 0
                   xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                   xCoeff(ma2( 1,-1, 0)) = 0
                   xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                   xCoeff(ma2( 0, 0, 0)) = 0
                   xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                   xCoeff(ma2(-1, 1, 0)) = 0
                   xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                   xCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator y = ry*ur+sy*us
                   cur = ajry
                   cus = ajsy
                   yCoeff(ma2(-1,-1, 0)) = 0
                   yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                   yCoeff(ma2( 1,-1, 0)) = 0
                   yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                   yCoeff(ma2( 0, 0, 0)) = 0
                   yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                   yCoeff(ma2(-1, 1, 0)) = 0
                   yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                   yCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator identity 
                   iCoeff(ma2(-1,-1, 0)) = 0
                   iCoeff(ma2( 0,-1, 0)) = 0
                   iCoeff(ma2( 1,-1, 0)) = 0
                   iCoeff(ma2(-1, 0, 0)) = 0
                   iCoeff(ma2( 0, 0, 0)) = 1.
                   iCoeff(ma2( 1, 0, 0)) = 0
                   iCoeff(ma2(-1, 1, 0)) = 0
                   iCoeff(ma2( 0, 1, 0)) = 0
                   iCoeff(ma2( 1, 1, 0)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma2(m1,m2,m3)
                 mm=mce2(m1,m2,m3,cmpu,eqnu)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnu)=ghost1
              else
               ! boundary face is y=constant, or z=constant : give u=0 
               do m=ce(0,eqnu),ce(0,eqnu+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpu,eqnu)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnu)=extrapolation
              end if
            !  --- equations for v ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
              if( normalAxis.eq.1 )then
               ! boundary face is y=constant:
               !  Give v.n = 0 
                   ! get the outward normal for curvilinear grids
                   an(0)=rsxy(i1,i2,i3,axis,0)
                   an(1)=rsxy(i1,i2,i3,axis,1)
                     anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + 
     & an(1)**2 ) )
                     an(0)=an(0)*anNorm
                     an(1)=an(1)*anNorm
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                 ajrx = rsxy(i1,i2,i3,0,0)
                 ajsx = rsxy(i1,i2,i3,1,0)
                 ajry = rsxy(i1,i2,i3,0,1)
                 ajsy = rsxy(i1,i2,i3,1,1)
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = rx*ur+sx*us
                   cur = ajrx
                   cus = ajsx
                   xCoeff(ma2(-1,-1, 0)) = 0
                   xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                   xCoeff(ma2( 1,-1, 0)) = 0
                   xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                   xCoeff(ma2( 0, 0, 0)) = 0
                   xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                   xCoeff(ma2(-1, 1, 0)) = 0
                   xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                   xCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator y = ry*ur+sy*us
                   cur = ajry
                   cus = ajsy
                   yCoeff(ma2(-1,-1, 0)) = 0
                   yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                   yCoeff(ma2( 1,-1, 0)) = 0
                   yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                   yCoeff(ma2( 0, 0, 0)) = 0
                   yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                   yCoeff(ma2(-1, 1, 0)) = 0
                   yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                   yCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator identity 
                   iCoeff(ma2(-1,-1, 0)) = 0
                   iCoeff(ma2( 0,-1, 0)) = 0
                   iCoeff(ma2( 1,-1, 0)) = 0
                   iCoeff(ma2(-1, 0, 0)) = 0
                   iCoeff(ma2( 0, 0, 0)) = 1.
                   iCoeff(ma2( 1, 0, 0)) = 0
                   iCoeff(ma2(-1, 1, 0)) = 0
                   iCoeff(ma2( 0, 1, 0)) = 0
                   iCoeff(ma2( 1, 1, 0)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma2(m1,m2,m3)
                 mm=mce2(m1,m2,m3,cmpv,eqnv)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnv,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnv)=ghost1
              else
               ! boundary face is x=constant, or z=constant : give v=0 
               do m=ce(0,eqnv),ce(0,eqnv+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpv,eqnv)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnv)=extrapolation
              end if
            !  --- equations for w ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffW )then
              if( normalAxis.eq.2 )then
               ! boundary face is z=constant:
               !  Give w.n = 0 
                   ! get the outward normal for curvilinear grids
                   an(0)=rsxy(i1,i2,i3,axis,0)
                   an(1)=rsxy(i1,i2,i3,axis,1)
                     anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + 
     & an(1)**2 ) )
                     an(0)=an(0)*anNorm
                     an(1)=an(1)*anNorm
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                 ajrx = rsxy(i1,i2,i3,0,0)
                 ajsx = rsxy(i1,i2,i3,1,0)
                 ajry = rsxy(i1,i2,i3,0,1)
                 ajsy = rsxy(i1,i2,i3,1,1)
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = rx*ur+sx*us
                   cur = ajrx
                   cus = ajsx
                   xCoeff(ma2(-1,-1, 0)) = 0
                   xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                   xCoeff(ma2( 1,-1, 0)) = 0
                   xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                   xCoeff(ma2( 0, 0, 0)) = 0
                   xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                   xCoeff(ma2(-1, 1, 0)) = 0
                   xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                   xCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator y = ry*ur+sy*us
                   cur = ajry
                   cus = ajsy
                   yCoeff(ma2(-1,-1, 0)) = 0
                   yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                   yCoeff(ma2( 1,-1, 0)) = 0
                   yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                   yCoeff(ma2( 0, 0, 0)) = 0
                   yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                   yCoeff(ma2(-1, 1, 0)) = 0
                   yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                   yCoeff(ma2( 1, 1, 0)) = 0
                  ! Operator identity 
                   iCoeff(ma2(-1,-1, 0)) = 0
                   iCoeff(ma2( 0,-1, 0)) = 0
                   iCoeff(ma2( 1,-1, 0)) = 0
                   iCoeff(ma2(-1, 0, 0)) = 0
                   iCoeff(ma2( 0, 0, 0)) = 1.
                   iCoeff(ma2( 1, 0, 0)) = 0
                   iCoeff(ma2(-1, 1, 0)) = 0
                   iCoeff(ma2( 0, 1, 0)) = 0
                   iCoeff(ma2( 1, 1, 0)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma2(m1,m2,m3)
                 mm=mce2(m1,m2,m3,cmpw,eqnw)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnw,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnw)=ghost1
              else
               ! boundary face is x=constant, or y=constant : give w=0 
               do m=ce(0,eqnw),ce(0,eqnw+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce2(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma2(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpw,eqnw)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnw)=extrapolation
              end if
            else
              write(*,'(" insImpINS: bc0.eq.inflowWithPandTV -- 
     & unknown option")')
              stop 8141
            end if
             end if
            end do
            end do
            end do
         else
           ! ****** inflowWithPandTV: vector system *********
            ! Operator identity 
             iCoeff(ma2(-1,-1, 0)) = 0
             iCoeff(ma2( 0,-1, 0)) = 0
             iCoeff(ma2( 1,-1, 0)) = 0
             iCoeff(ma2(-1, 0, 0)) = 0
             iCoeff(ma2( 0, 0, 0)) = 1.
             iCoeff(ma2( 1, 0, 0)) = 0
             iCoeff(ma2(-1, 1, 0)) = 0
             iCoeff(ma2( 0, 1, 0)) = 0
             iCoeff(ma2( 1, 1, 0)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
               ! get the outward normal for curvilinear grids
               an(0)=rsxy(i1,i2,i3,axis,0)
               an(1)=rsxy(i1,i2,i3,axis,1)
                 anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)*
     & *2 ) )
                 an(0)=an(0)*anNorm
                 an(1)=an(1)*anNorm
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.Lu"
            nDotL(0)=an(0)*coeff(mce2(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpu,eqnv),i1,i2,i3)
            nDotL(1)=an(0)*coeff(mce2(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)
            ! form the matrix for  Iu + [ (n.(Lu)) - (n.u) ] n 
            !  eqnu:     u1 + nDotL*n1 - (n1*u1+n2*u2+n3*u3)*n1 
            !  eqnv:     u2 + nDotL*n2 - (n1*u1+n2*u2+n3*u3)*n2
            !  eqnw:     u3 + nDotL*n3 - (n1*u1+n2*u2+n3*u3)*n3
            !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
            do e=eqnu,eqnu+nd-1
            do c=cmpu,cmpu+nd-1
             ! *** check this ***
             coeff(mce2(m1,m2,m3,c,e),i1,i2,i3)= iCoeff(ma2(m1,m2,m3))*
     & delta(c-cmpu,e-eqnu) + an(e-eqnu)*( nDotL(c-cmpu) - iCoeff(ma2(
     & m1,m2,m3))*an(c-cmpu) )
            end do
            end do
            end do
            end do
            end do
           ! Neumann condition for ghost: **** is this right? or extrapolate ?? ****
           do n=0,ndu-1
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! this next call will define the jacobian and its derivatives (parameteric and spatial)
               ajrx = rsxy(i1,i2,i3,0,0)
               ajsx = rsxy(i1,i2,i3,1,0)
               ajry = rsxy(i1,i2,i3,0,1)
               ajsy = rsxy(i1,i2,i3,1,1)
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = rx*ur+sx*us
                 cur = ajrx
                 cus = ajsx
                 xCoeff(ma2(-1,-1, 0)) = 0
                 xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                 xCoeff(ma2( 1,-1, 0)) = 0
                 xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                 xCoeff(ma2( 0, 0, 0)) = 0
                 xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                 xCoeff(ma2(-1, 1, 0)) = 0
                 xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                 xCoeff(ma2( 1, 1, 0)) = 0
                ! Operator y = ry*ur+sy*us
                 cur = ajry
                 cus = ajsy
                 yCoeff(ma2(-1,-1, 0)) = 0
                 yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                 yCoeff(ma2( 1,-1, 0)) = 0
                 yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                 yCoeff(ma2( 0, 0, 0)) = 0
                 yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                 yCoeff(ma2(-1, 1, 0)) = 0
                 yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                 yCoeff(ma2( 1, 1, 0)) = 0
                ! Operator identity 
                 iCoeff(ma2(-1,-1, 0)) = 0
                 iCoeff(ma2( 0,-1, 0)) = 0
                 iCoeff(ma2( 1,-1, 0)) = 0
                 iCoeff(ma2(-1, 0, 0)) = 0
                 iCoeff(ma2( 0, 0, 0)) = 1.
                 iCoeff(ma2( 1, 0, 0)) = 0
                 iCoeff(ma2(-1, 1, 0)) = 0
                 iCoeff(ma2( 0, 1, 0)) = 0
                 iCoeff(ma2( 1, 1, 0)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma2(m1,m2,m3)
               mm=mce2(m1,m2,m3,cmpu+n,eqnu+n)
                coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+0.*iCoeff(m)
               ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnu+n)=ghost1
           end do
            end if
           end do
           end do
           end do
         end if  ! end vector system
         else if( bc0.eq.axisymmetric )then
          if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
           ! BC on an axisymmetric side : scalar matrix for U 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs
             ajrxy = ajry*ajrxr+ajsy*ajrxs
             ajsxx = ajrx*ajsxr+ajsx*ajsxs
             ajsxy = ajry*ajsxr+ajsy*ajsxs
             ajryx = ajrx*ajryr+ajsx*ajrys
             ajryy = ajry*ajryr+ajsy*ajrys
             ajsyx = ajrx*ajsyr+ajsx*ajsys
             ajsyy = ajry*ajsyr+ajsy*ajsys
            ! getCoeff(identity, iCoeff,aj)
            !zeroMatrixCoefficients( coeff,eqnv,eqnv, i1,i2,i3 )  ! set v eqn coeffs to zero
            !setCoeff1(cmpv,eqnv,coeff,iCoeff)                ! dirichlet: V= 
            !fillMatrixExtrapolation(coe<ff,cmpv,eqnv,i1,i2,i3,orderOfExtrapolation,1)  ! extrap ghost for V 
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! this next call will define the jacobian and its derivatives (parameteric and spatial)
              ajrx = rsxy(i1,i2,i3,0,0)
              ajsx = rsxy(i1,i2,i3,1,0)
              ajry = rsxy(i1,i2,i3,0,1)
              ajsy = rsxy(i1,i2,i3,1,1)
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = rx*ur+sx*us
                cur = ajrx
                cus = ajsx
                xCoeff(ma2(-1,-1, 0)) = 0
                xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                xCoeff(ma2( 1,-1, 0)) = 0
                xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                xCoeff(ma2( 0, 0, 0)) = 0
                xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                xCoeff(ma2(-1, 1, 0)) = 0
                xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                xCoeff(ma2( 1, 1, 0)) = 0
               ! Operator y = ry*ur+sy*us
                cur = ajry
                cus = ajsy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma2( 1, 1, 0)) = 0
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma2(m1,m2,m3)
              mm=mce2(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
           ! BC on an axisymmetric side : scalar matrix for V 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs
             ajrxy = ajry*ajrxr+ajsy*ajrxs
             ajsxx = ajrx*ajsxr+ajsx*ajsxs
             ajsxy = ajry*ajsxr+ajsy*ajsxs
             ajryx = ajrx*ajryr+ajsx*ajrys
             ajryy = ajry*ajryr+ajsy*ajrys
             ajsyx = ajrx*ajsyr+ajsx*ajsys
             ajsyy = ajry*ajsyr+ajsy*ajsys
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
            !getNormalForCurvilinearGrid(side,axis,i1,i2,i3)
            !fillMatrixNeumann(coeff, cmpu,eqnu, i1,i2,i3, an,0.,1. )  ! Neuman: U_r = 
             end if
            end do
            end do
            end do
          else
           ! BC on an axisymmetric side  
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs
             ajrxy = ajry*ajrxr+ajsy*ajrxs
             ajsxx = ajrx*ajsxr+ajsx*ajsxs
             ajsxy = ajry*ajsxr+ajsy*ajsxs
             ajryx = ajrx*ajryr+ajsx*ajrys
             ajryy = ajry*ajryr+ajsy*ajrys
             ajsyx = ajrx*ajsyr+ajsx*ajsys
             ajsyy = ajry*ajsyr+ajsy*ajsys
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce2(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma2(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! this next call will define the jacobian and its derivatives (parameteric and spatial)
              ajrx = rsxy(i1,i2,i3,0,0)
              ajsx = rsxy(i1,i2,i3,1,0)
              ajry = rsxy(i1,i2,i3,0,1)
              ajsy = rsxy(i1,i2,i3,1,1)
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = rx*ur+sx*us
                cur = ajrx
                cus = ajsx
                xCoeff(ma2(-1,-1, 0)) = 0
                xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                xCoeff(ma2( 1,-1, 0)) = 0
                xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                xCoeff(ma2( 0, 0, 0)) = 0
                xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                xCoeff(ma2(-1, 1, 0)) = 0
                xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                xCoeff(ma2( 1, 1, 0)) = 0
               ! Operator y = ry*ur+sy*us
                cur = ajry
                cus = ajsy
                yCoeff(ma2(-1,-1, 0)) = 0
                yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma2( 1,-1, 0)) = 0
                yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma2( 0, 0, 0)) = 0
                yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma2(-1, 1, 0)) = 0
                yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma2( 1, 1, 0)) = 0
               ! Operator identity 
                iCoeff(ma2(-1,-1, 0)) = 0
                iCoeff(ma2( 0,-1, 0)) = 0
                iCoeff(ma2( 1,-1, 0)) = 0
                iCoeff(ma2(-1, 0, 0)) = 0
                iCoeff(ma2( 0, 0, 0)) = 1.
                iCoeff(ma2( 1, 0, 0)) = 0
                iCoeff(ma2(-1, 1, 0)) = 0
                iCoeff(ma2( 0, 1, 0)) = 0
                iCoeff(ma2( 1, 1, 0)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma2(m1,m2,m3)
              mm=mce2(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          end if
         else if( bc0.gt.0 )then
           write(*,'("insimp:BC: ERROR unknown bc=",i4)') bc0
           stop 5501
         end if
         if( extrapolateGhostByDefault.eq.1 .and. (
     & bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall.or.bc0.eq.inflowWithVelocityGiven .or.(
     & bc0.eq.outflow .and. outflowOption.eq.0) 
     & .or.bc0.eq.interfaceBoundaryCondition) )then
          ! === extrapolation ===
          orderOfExtrap=orderOfExtrapolation
          if( bc0.eq.outflow .and. orderOfExtrapolationForOutflow.gt.0 
     & )then
            orderOfExtrap=orderOfExtrapolationForOutflow
          end if
          if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
           write(*,'("insimp:BC:ERROR: requesting orderOfExtrap=",i6)')
     &  orderOfExtrap
           stop 5502
          end if
          if( .false. .and. bc0.eq.outflow )then
           write(*,'("insimp:BC: fill extrap outflow BC into matrix, 
     & orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') 
     & orderOfExtrap,orderOfExtrapolationForOutflow
          end if
          ! write(*,'("insimp:BC: orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') orderOfExtrap,orderOfExtrapolationForOutflow
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! i1m=i1-is1  ! ghost point
           ! i2m=i2-is2
           ! i3m=i3-is3
           ! zeroMatrixCoefficients( coeff,eqnu,eqnu+ndu-1, i1,i2,i3 )
           do n=0,ndu-1
            c=cmpu+n
            e=eqnu+n
             if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrap
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(c,e)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrap) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,e)=extrapolation
           end do
            end if
           end do
           end do
           end do
         end if
         end if
         if( pdeModel.eq.BoussinesqModel .and. (
     & fillCoefficientsScalarSystem.eq.0 .or. 
     & fillCoefficientsScalarSystem.eq.fillCoeffT) )then
          ! ----------------------------
          ! --- Assign the BCs for T --- (this is duplicated from insImpVP.bf : we could share 
          ! ----------------------------
          bc0 = bc(side,axis)
          a0 = mixedCoeff(tc,side,axis,grid)
          a1 = mixedNormalCoeff(tc,side,axis,grid)
          if( debug.gt.3 )then
            write(*,'(" insImpINS: T BC: bc=",i3," (a0,a1)=(",f5.1,",",
     & f5.1,") for side,axis,grid=",3i3)') bc0,a0,a1,side,axis,grid
            write(*,'(" cmpu,eqnu=",2i2," cmpq,eqnq=",2i2," 
     & orderOfExtrap=",i2)') cmpu,eqnu, cmpq,eqnq,orderOfExtrap
          endif
          ! '
          if( bc0.eq.dirichletBoundaryCondition .or.bc0.eq.noSlipWall 
     & .or.bc0.eq.slipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.outflow .or.bc0.eq.axisymmetric 
     & .or.bc0.eq.interfaceBoundaryCondition .or. 
     & bc0.eq.freeSurfaceBoundaryCondition )then
            if( bc0.eq.outflow .or. bc0.eq.axisymmetric )then
             ! outflow is Neumann
             a0=0.
             a1=1.
            end if
           if( a1.ne.0. )then
            ! Mixed BC 
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
                 ! get the outward normal for curvilinear grids
                 an(0)=rsxy(i1,i2,i3,axis,0)
                 an(1)=rsxy(i1,i2,i3,axis,1)
                   anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(
     & 1)**2 ) )
                   an(0)=an(0)*anNorm
                   an(1)=an(1)*anNorm
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! this next call will define the jacobian and its derivatives (parameteric and spatial)
               ajrx = rsxy(i1,i2,i3,0,0)
               ajsx = rsxy(i1,i2,i3,1,0)
               ajry = rsxy(i1,i2,i3,0,1)
               ajsy = rsxy(i1,i2,i3,1,1)
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = rx*ur+sx*us
                 cur = ajrx
                 cus = ajsx
                 xCoeff(ma2(-1,-1, 0)) = 0
                 xCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                 xCoeff(ma2( 1,-1, 0)) = 0
                 xCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                 xCoeff(ma2( 0, 0, 0)) = 0
                 xCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                 xCoeff(ma2(-1, 1, 0)) = 0
                 xCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                 xCoeff(ma2( 1, 1, 0)) = 0
                ! Operator y = ry*ur+sy*us
                 cur = ajry
                 cus = ajsy
                 yCoeff(ma2(-1,-1, 0)) = 0
                 yCoeff(ma2( 0,-1, 0)) = -1./2.*cus/dr(1)
                 yCoeff(ma2( 1,-1, 0)) = 0
                 yCoeff(ma2(-1, 0, 0)) = -1./2.*cur/dr(0)
                 yCoeff(ma2( 0, 0, 0)) = 0
                 yCoeff(ma2( 1, 0, 0)) = 1./2.*cur/dr(0)
                 yCoeff(ma2(-1, 1, 0)) = 0
                 yCoeff(ma2( 0, 1, 0)) = 1./2.*cus/dr(1)
                 yCoeff(ma2( 1, 1, 0)) = 0
                ! Operator identity 
                 iCoeff(ma2(-1,-1, 0)) = 0
                 iCoeff(ma2( 0,-1, 0)) = 0
                 iCoeff(ma2( 1,-1, 0)) = 0
                 iCoeff(ma2(-1, 0, 0)) = 0
                 iCoeff(ma2( 0, 0, 0)) = 1.
                 iCoeff(ma2( 1, 0, 0)) = 0
                 iCoeff(ma2(-1, 1, 0)) = 0
                 iCoeff(ma2( 0, 1, 0)) = 0
                 iCoeff(ma2( 1, 1, 0)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma2(m1,m2,m3)
               mm=mce2(m1,m2,m3,cmpq,eqnq)
                coeff(mm,i1m,i2m,i3m)=a1*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m))+a0*iCoeff(m)
               ! The equation for pt (eqnq,i1m,i2m,i3m) is centered on (cmpq,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnq)=ghost1
              end if
             end do
             end do
             end do
           else
            ! Dirichlet + extrap ghost line values
              ! Operator identity 
               iCoeff(ma2(-1,-1, 0)) = 0
               iCoeff(ma2( 0,-1, 0)) = 0
               iCoeff(ma2( 1,-1, 0)) = 0
               iCoeff(ma2(-1, 0, 0)) = 0
               iCoeff(ma2( 0, 0, 0)) = 1.
               iCoeff(ma2( 1, 0, 0)) = 0
               iCoeff(ma2(-1, 1, 0)) = 0
               iCoeff(ma2( 0, 1, 0)) = 0
               iCoeff(ma2( 1, 1, 0)) = 0
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             do m=ce(0,eqnq),ce(0,eqnq+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce2(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(a0*iCoeff(
     & ma2(m1,m2,m3)))
              end do
              end do
              end do
              if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                stop 7734
              end if
              i1m=i1-is1*(1)  ! 1 point
              i2m=i2-is2*(1)
              i3m=i3-is3*(1)
              do m=0,orderOfExtrapolation
               j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
               j2=i2m+is2*m
               j3=i3m+is3*m
               mm = ce(cmpq,eqnq)+m
               coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
              end do
               classify(i1m,i2m,i3m,eqnq)=extrapolation
              end if
             end do
             end do
             end do
           end if
         !  else if( bc0.eq.outflow )then
         !    ! === extrapolation ===
         !   beginLoopsMixedBoundary()
         !    fillMatrixExtrapolation(coeff,cmpq,eqnq,i1,i2,i3,orderOfExtrap,1)
         !   endLoops()
          else if( bc0.gt.0 )then
           write(*,'("insImpINS:T: ERROR unknown bc=",i4)') bc0
           stop 9167
          end if
         endif
         end if ! end if( fillCoefficients.eq.1 )
         if( evalResidualForBoundaryConditions.eq.1 )then
         if( bc(side,axis).eq.dirichletBoundaryCondition .or.bc(side,
     & axis).eq.noSlipWall.or.bc(side,axis)
     & .eq.inflowWithVelocityGiven.or.bc(side,axis)
     & .eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           ! do n=0,ntdc-1             ! ntdc = number of time depenedent components
           do n=0,nd-1  ! ntdc = number of time depenedent components
            ! fe(i1,i2,i3,uc+n)=0.  
            fe(i1,i2,i3,uc+n)=fi(i1,i2,i3,uc+n)-u(i1,i2,i3,uc+n)
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.outflow )then
         else if( bc(side,axis).eq.axisymmetric )then
         ! do nothing for now
         else if( bc(side,axis).eq.freeSurfaceBoundaryCondition )then
         ! do nothing for now
         else if( bc(side,axis).eq.slipWall )then
           ! SLIP-WALL
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.inflowWithPandTV )then
          ! pressure and tangential velocity given
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).gt.0 )then
           write(*,'("insimp:residual:BC: ERROR unknown bc=",i4)') bc(
     & side,axis)
           stop 9099
         end if
         end if ! end if( evalResidualForBoundaryConditions.eq.1 )
       !*   if( side.eq.0 .and. axis.eq.0 )then
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal00)
       !*    getBoundaryResidualINS(normal00)
       !*   else if( side.eq.1 .and. axis.eq.0 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal10)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.0 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal01)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.1 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal11)
       !*    getBoundaryResidualINS(normal11)
       !*   else if( side.eq.0 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal02)
       !*    getBoundaryResidualINS(normal02)
       !*   else if( side.eq.1 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal12)
       !*    getBoundaryResidualINS(normal12)
       !*  else
       !* !    stop 2077
       !*  end if
         ! reset values
         if( axis.eq.0 )then
           n1a=indexRange(0,axis)
           n1b=indexRange(1,axis)
         else if( axis.eq.1 )then
           n2a=indexRange(0,axis)
           n2b=indexRange(1,axis)
         else
           n3a=indexRange(0,axis)
           n3b=indexRange(1,axis)
         end if
        end do ! side
        end do ! axis
       end if
       ! assign the RHS:
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( evalRightHandSide.eq.1 .or. evalResidual.eq.1 )then
         ! **** to do : optimize this for backward-Euler : fe=0, fi=0 !!
         ! NOTE: For moving grid problems we must eval the RHS as some mask==0 (exposed) points
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
            ! this next call will define the jacobian and its derivatives (parameteric and spatial)
            ajrx = rsxy(i1,i2,i3,0,0)
            ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
            ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
            ajsx = rsxy(i1,i2,i3,1,0)
            ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
            ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
            ajry = rsxy(i1,i2,i3,0,1)
            ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
            ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
            ajsy = rsxy(i1,i2,i3,1,1)
            ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
            ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
            ajrxx = ajrx*ajrxr+ajsx*ajrxs
            ajrxy = ajry*ajrxr+ajsy*ajrxs
            ajsxx = ajrx*ajsxr+ajsx*ajsxs
            ajsxy = ajry*ajsxr+ajsy*ajsxs
            ajryx = ajrx*ajryr+ajsx*ajrys
            ajryy = ajry*ajryr+ajsy*ajrys
            ajsyx = ajrx*ajsyr+ajsx*ajsys
            ajsyy = ajry*ajsyr+ajsy*ajsys
           ! evaluate forward derivatives of the current solution: 
           ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
           ! MAXDER = max number of parametric derivatives to precompute.
            uu = u(i1,i2,i3,uc)
            uur = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
            uus = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
            uurr = (u(i1-1,i2,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1+1,i2,i3,uc)
     & )/(dr(0)**2)
            uurs = (-(-u(i1-1,i2-1,i3,uc)+u(i1-1,i2+1,i3,uc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,uc)+u(i1+1,i2+1,i3,uc))/(2.*dr(1)))/(2.*dr(
     & 0))
            uuss = (u(i1,i2-1,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1,i2+1,i3,uc)
     & )/(dr(1)**2)
           ! Evaluate the spatial derivatives of u:
             u0x = ajrx*uur+ajsx*uus
             u0y = ajry*uur+ajsy*uus
             t1 = ajrx**2
             t6 = ajsx**2
             u0xx = t1*uurr+2*ajrx*ajsx*uurs+t6*uuss+ajrxx*uur+ajsxx*
     & uus
             t1 = ajry**2
             t6 = ajsy**2
             u0yy = t1*uurr+2*ajry*ajsy*uurs+t6*uuss+ajryy*uur+ajsyy*
     & uus
           ! Evaluate the spatial derivatives of v:
            vv = u(i1,i2,i3,vc)
            vvr = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dr(0))
            vvs = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dr(1))
            vvrr = (u(i1-1,i2,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1+1,i2,i3,vc)
     & )/(dr(0)**2)
            vvrs = (-(-u(i1-1,i2-1,i3,vc)+u(i1-1,i2+1,i3,vc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,vc)+u(i1+1,i2+1,i3,vc))/(2.*dr(1)))/(2.*dr(
     & 0))
            vvss = (u(i1,i2-1,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1,i2+1,i3,vc)
     & )/(dr(1)**2)
             v0x = ajrx*vvr+ajsx*vvs
             v0y = ajry*vvr+ajsy*vvs
             t1 = ajrx**2
             t6 = ajsx**2
             v0xx = t1*vvrr+2*ajrx*ajsx*vvrs+t6*vvss+ajrxx*vvr+ajsxx*
     & vvs
             t1 = ajry**2
             t6 = ajsy**2
             v0yy = t1*vvrr+2*ajry*ajsy*vvrs+t6*vvss+ajryy*vvr+ajsyy*
     & vvs
           ! Evaluate the spatial derivatives of p:
            pp = u(i1,i2,i3,pc)
            ppr = (-u(i1-1,i2,i3,pc)+u(i1+1,i2,i3,pc))/(2.*dr(0))
            pps = (-u(i1,i2-1,i3,pc)+u(i1,i2+1,i3,pc))/(2.*dr(1))
             p0x = ajrx*ppr+ajsx*pps
             p0y = ajry*ppr+ajsy*pps
          if( evalLinearizedDerivatives.eq.1 )then
             uul = ul(i1,i2,i3,uc)
             uulr = (-ul(i1-1,i2,i3,uc)+ul(i1+1,i2,i3,uc))/(2.*dr(0))
             uuls = (-ul(i1,i2-1,i3,uc)+ul(i1,i2+1,i3,uc))/(2.*dr(1))
              ulx = ajrx*uulr+ajsx*uuls
              uly = ajry*uulr+ajsy*uuls
             vvl = ul(i1,i2,i3,vc)
             vvlr = (-ul(i1-1,i2,i3,vc)+ul(i1+1,i2,i3,vc))/(2.*dr(0))
             vvls = (-ul(i1,i2-1,i3,vc)+ul(i1,i2+1,i3,vc))/(2.*dr(1))
              vlx = ajrx*vvlr+ajsx*vvls
              vly = ajry*vvlr+ajsy*vvls
          end if
          if( pdeModel.eq.BoussinesqModel )then
           ! Evaluate the spatial derivatives of q:
            qq = u(i1,i2,i3,qc)
            qqr = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dr(0))
            qqs = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dr(1))
            qqrr = (u(i1-1,i2,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1+1,i2,i3,qc)
     & )/(dr(0)**2)
            qqrs = (-(-u(i1-1,i2-1,i3,qc)+u(i1-1,i2+1,i3,qc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,qc)+u(i1+1,i2+1,i3,qc))/(2.*dr(1)))/(2.*dr(
     & 0))
            qqss = (u(i1,i2-1,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1,i2+1,i3,qc)
     & )/(dr(1)**2)
             q0x = ajrx*qqr+ajsx*qqs
             q0y = ajry*qqr+ajsy*qqs
             t1 = ajrx**2
             t6 = ajsx**2
             q0xx = t1*qqrr+2*ajrx*ajsx*qqrs+t6*qqss+ajrxx*qqr+ajsxx*
     & qqs
             t1 = ajry**2
             t6 = ajsy**2
             q0yy = t1*qqrr+2*ajry*ajsy*qqrs+t6*qqss+ajryy*qqr+ajsyy*
     & qqs
          end if
          if( gridIsMoving.ne.0 )then
            ugv = uu - gv(i1,i2,i3,0)
            vgv = vv - gv(i1,i2,i3,1)
          else
            ugv = uu
            vgv = vv
          end if
          ! eval the nonlinear coeff. of artificial dissipation: 
            adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y) + abs(v0x)+abs(
     & v0y) )
          if( evalRightHandSide.eq.1 )then
           if( gridIsImplicit.eq.0 )then
             ! ********** explicit *********
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y - p0x + nu*(u0xx+u0yy)
     &  + adCoeff*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1+1,i2,i3,uc)+
     & u(i1,i2+1,i3,uc)-4.*u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y - p0y + nu*(v0xx+v0yy)
     &  + adCoeff*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1+1,i2,i3,vc)+
     & u(i1,i2+1,i3,vc)-4.*u(i1,i2,i3,vc))
             if( isAxisymmetric.eq.1 )then
               radi=radiusInverse(i1,i2,i3)
               if( radi.ne.0. )then
                 fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0y*radi )   
     &          ! add u_r/r
                 fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( (v0y -vv*
     & radi)*radi ) ! add v_r/r - v/r^2
               else
                 fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0yy )    ! add u_rr
                 fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( .5*v0yy ) ! add .5*vrr
               end if
             end if
             if( pdeModel.eq.BoussinesqModel )then
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y + adcBoussinesq*(u(
     & i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,
     & qc)-4.*u(i1,i2,i3,qc))
              if( materialFormat.eq.constantMaterialProperties )then
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*(q0xx+
     & q0yy)
              else
               ! -- variable material properties : 
               ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                ! ---------- 2D -----------
                ! Get coefficients at nearby points: 
                if( materialFormat.eq.constantMaterialProperties )then
                  ! const material properties 
                  stop 11199
                else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                  ! piecewise constant material properties
                  scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                  Kzmz=thermalKpc(i1  ,i2-1,i3)
                  Kmzz=thermalKpc(i1-1,i2  ,i3)
                  Kzzz=thermalKpc(i1  ,i2  ,i3)
                  Kpzz=thermalKpc(i1+1,i2  ,i3)
                  Kzpz=thermalKpc(i1  ,i2+1,i3)
                else if( materialFormat.eq.variableMaterialProperties )
     & then
                  ! variable material properties
                  scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                  Kzmz=thermalKv(i1  ,i2-1,i3)
                  Kmzz=thermalKv(i1-1,i2  ,i3)
                  Kzzz=thermalKv(i1  ,i2  ,i3)
                  Kpzz=thermalKv(i1+1,i2  ,i3)
                  Kzpz=thermalKv(i1  ,i2+1,i3)
                end if
                !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
                 ! evaluate the jacobian at nearby points:
                 ajzmz = (1./(rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,
     & i3)*sx(i1,i2-1,i3)))
                 ajmzz = (1./(rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,
     & i3)*sx(i1-1,i2,i3)))
                 ajzzz = (1./(rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*
     & sx(i1,i2,i3)))
                 ajpzz = (1./(rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,
     & i3)*sx(i1+1,i2,i3)))
                 ajzpz = (1./(rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,
     & i3)*sx(i1,i2+1,i3)))
                 ! 1. Get coefficients au11ph, au11mh, au22ph, etc. for 
                 !          Dx( K*u.x ) + Dy( K*u.y ) 
                  au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) )
                  au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) )
                  au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) )
                  au11ph = .5*( au11zzz+au11pzz )
                  au11mh = .5*( au11zzz+au11mzz )
                  au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) )
                  au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) )
                  au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) )
                  au22ph = .5*( au22zzz+au22zpz )
                  au22mh = .5*( au22zzz+au22zmz )
                  au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) )
                  au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) )
                  au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) )
                  au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) )
                  au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) )
                  au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) )
                 ! scaling factors: 
                 dr0i = (scale)/(ajzzz*dr(0)**2)
                 dr1i = (scale)/(ajzzz*dr(1)**2)
                 dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
                  au11ph=au11ph*dr0i
                  au11mh=au11mh*dr0i
                  au22ph=au22ph*dr1i
                  au22mh=au22mh*dr1i
                  au12pzz=au12pzz*dr0dr1
                  au12mzz=au12mzz*dr0dr1
                  au21zpz=au21zpz*dr0dr1
                  au21zmz=au21zmz*dr0dr1
                ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
                ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
                ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
                 ! 2D, order 2:
                 dsgT = ( (au12mzz+au21zmz)*u(i1-1,i2-1,i3,qc) + (
     & au22mh)*u(i1,i2-1,i3,qc)+(-au12pzz-au21zmz)*u(i1+1,i2-1,i3,qc)+
     & (au11mh)*u(i1-1,i2,i3,qc)+(-au11ph-au11mh -au22ph -au22mh)*u(
     & i1,i2,i3,qc)+(au11ph)*u(i1+1,i2,i3,qc)+(-au12mzz-au21zpz)*u(i1-
     & 1,i2+1,i3,qc)+(au22ph)*u(i1,i2+1,i3,qc)+(au12pzz+au21zpz)*u(i1+
     & 1,i2+1,i3,qc) )
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
              endif
              if( isAxisymmetric.eq.1 )then
                if( materialFormat.ne.constantMaterialProperties )then
                  stop 6644
                end if
                radi=radiusInverse(i1,i2,i3)
                if( radi.ne.0. )then
                  fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0y*
     & radi )            ! add u_r/r
                else
                  fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0yy )
     &     ! add u_rr
                end if
              end if
             end if
           else
             ! ********** implicit *********
             ! eval the nonlinear coeff. of artificial dissipation for the linearized solution:
               adCoeffl = ad21 + cd22*( abs(ulx)+abs(uly) + abs(vlx)+
     & abs(vly) )
             ! implicit method -- compute explicit part
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y - p0x + (adCoeff-
     & adCoeffl)*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1+1,i2,i3,uc)+
     & u(i1,i2+1,i3,uc)-4.*u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y - p0y + (adCoeff-
     & adCoeffl)*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1+1,i2,i3,vc)+
     & u(i1,i2+1,i3,vc)-4.*u(i1,i2,i3,vc))
             if( nonlinearTermsAreImplicit.eq.1 )then
               ! include linearized terms u0*ulx + ul*u0x 
               if( gridIsMoving.ne.0 )then
                ugvl = uul - gvl(i1,i2,i3,0)
                vgvl = vvl - gvl(i1,i2,i3,1)
               else
                ugvl = uul
                vgvl = vvl
               end if
               ! ulterm = uul*u0x + vvl*u0y + bImp*(uu*ulx +  vv*uly)
               ! vlterm = uul*v0x + vvl*v0y + bImp*(uu*vlx +  vv*vly)
               ! moving: (u-gv)*ux ->  u*ux - gv*ux -> ul*ux +u*ulx +gvl*ux = (ul-gvl)*ux + ulx*u 
               ulterm = ugvl*u0x + vgvl*u0y + bImp*(uu*ulx +  vv*uly)
               vlterm = ugvl*v0x + vgvl*v0y + bImp*(uu*vlx +  vv*vly)
               ! ++ ulterm = uul*u0x + vvl*u0y + bImp*(uu*ulx )
               ! ++ vlterm = uul*v0x + vvl*v0y + bImp*(vv*vly)
               ! ++ ulterm = uul*u0x + vvl*u0y + bImp*( vv )
               ! ++ ulterm = uul*u0x + vvl*u0y 
               ! ++ vlterm = uul*v0x + vvl*v0y 
               fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + ulterm
               fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + vlterm
             end if
             if( implicitOption.eq.computeImplicitTermsSeparately )then
               ! implicit method -- compute implicit part 
               fi(i1,i2,i3,uc) = nuImp*(u0xx+u0yy)+ adCoeffl*(u(i1-1,
     & i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)-
     & 4.*u(i1,i2,i3,uc))   !  I think nuImp==nu now
               fi(i1,i2,i3,vc) = nuImp*(v0xx+v0yy)+ adCoeffl*(u(i1-1,
     & i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)-
     & 4.*u(i1,i2,i3,vc))
               if( nonlinearTermsAreImplicit.eq.1 )then
                 ! include linearized terms u0*ulx + ul*u0x 
                 fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) - aImp*( ulterm )
                 fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) - aImp*( vlterm )
               end if
               if( isAxisymmetric.eq.1 )then
                radi=radiusInverse(i1,i2,i3)
                if( radi.ne.0. )then
                  fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) + nuImp*( u0y*radi 
     & )            ! add u_r/r
                  fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) + nuImp*( (v0y -vv*
     & radi)*radi ) ! add v_r/r - v/r^2
                else
                  fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) + nuImp*( u0yy )    ! add u_rr
                  fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) + nuImp*( .5*v0yy ) ! add .5*vrr
                end if
               end if
             end if
             if( pdeModel.eq.BoussinesqModel )then
              ! tImp=1 if the buoyancy term is implicit, 0 if explicit
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -(1.-tImp)*
     & thermalExpansivity*gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -(1.-tImp)*
     & thermalExpansivity*gravity(1)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y
              if( nonlinearTermsAreImplicit.eq.1 )then
                ! include linearized terms u0*ulx + ul*u0x 
                 qql = ul(i1,i2,i3,qc)
                 qqlr = (-ul(i1-1,i2,i3,qc)+ul(i1+1,i2,i3,qc))/(2.*dr(
     & 0))
                 qqls = (-ul(i1,i2-1,i3,qc)+ul(i1,i2+1,i3,qc))/(2.*dr(
     & 1))
                  qlx = ajrx*qqlr+ajsx*qqls
                  qly = ajry*qqlr+ajsy*qqls
                qlterm = ugvl*q0x + vgvl*q0y + bImp*(uu*qlx +  vv*qly)
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + qlterm
              end if
              if( implicitOption.eq.computeImplicitTermsSeparately )
     & then
                ! implicit method -- compute implicit part 
                fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) -tImp*
     & thermalExpansivity*gravity(0)*qq
                fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) -tImp*
     & thermalExpansivity*gravity(1)*qq
                fi(i1,i2,i3,qc) = adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,
     & i2-1,i3,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)-4.*u(i1,i2,i3,qc)
     & )
                if( materialFormat.eq.constantMaterialProperties )then
                  fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + kThermal*(q0xx+
     & q0yy)
                else
                 ! -- variable material properties : 
                 ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                  ! ---------- 2D -----------
                  ! Get coefficients at nearby points: 
                  if( materialFormat.eq.constantMaterialProperties )
     & then
                    ! const material properties 
                    stop 11199
                  else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                    ! piecewise constant material properties
                    scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                    Kzmz=thermalKpc(i1  ,i2-1,i3)
                    Kmzz=thermalKpc(i1-1,i2  ,i3)
                    Kzzz=thermalKpc(i1  ,i2  ,i3)
                    Kpzz=thermalKpc(i1+1,i2  ,i3)
                    Kzpz=thermalKpc(i1  ,i2+1,i3)
                  else if( 
     & materialFormat.eq.variableMaterialProperties )then
                    ! variable material properties
                    scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                    Kzmz=thermalKv(i1  ,i2-1,i3)
                    Kmzz=thermalKv(i1-1,i2  ,i3)
                    Kzzz=thermalKv(i1  ,i2  ,i3)
                    Kpzz=thermalKv(i1+1,i2  ,i3)
                    Kzpz=thermalKv(i1  ,i2+1,i3)
                  end if
                  !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
                   ! evaluate the jacobian at nearby points:
                   ajzmz = (1./(rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-
     & 1,i3)*sx(i1,i2-1,i3)))
                   ajmzz = (1./(rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,
     & i2,i3)*sx(i1-1,i2,i3)))
                   ajzzz = (1./(rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*
     & sx(i1,i2,i3)))
                   ajpzz = (1./(rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,
     & i2,i3)*sx(i1+1,i2,i3)))
                   ajzpz = (1./(rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+
     & 1,i3)*sx(i1,i2+1,i3)))
                   ! 1. Get coefficients au11ph, au11mh, au22ph, etc. for 
                   !          Dx( K*u.x ) + Dy( K*u.y ) 
                    au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) )
                    au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) )
                    au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) )
                    au11ph = .5*( au11zzz+au11pzz )
                    au11mh = .5*( au11zzz+au11mzz )
                    au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) )
                    au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) )
                    au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) )
                    au22ph = .5*( au22zzz+au22zpz )
                    au22mh = .5*( au22zzz+au22zmz )
                    au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) )
                    au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) )
                    au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) )
                    au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) )
                    au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) )
                    au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) )
                   ! scaling factors: 
                   dr0i = (scale)/(ajzzz*dr(0)**2)
                   dr1i = (scale)/(ajzzz*dr(1)**2)
                   dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
                    au11ph=au11ph*dr0i
                    au11mh=au11mh*dr0i
                    au22ph=au22ph*dr1i
                    au22mh=au22mh*dr1i
                    au12pzz=au12pzz*dr0dr1
                    au12mzz=au12mzz*dr0dr1
                    au21zpz=au21zpz*dr0dr1
                    au21zmz=au21zmz*dr0dr1
                  ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
                  ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
                  ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
                   ! 2D, order 2:
                   dsgT = ( (au12mzz+au21zmz)*u(i1-1,i2-1,i3,qc) + (
     & au22mh)*u(i1,i2-1,i3,qc)+(-au12pzz-au21zmz)*u(i1+1,i2-1,i3,qc)+
     & (au11mh)*u(i1-1,i2,i3,qc)+(-au11ph-au11mh -au22ph -au22mh)*u(
     & i1,i2,i3,qc)+(au11ph)*u(i1+1,i2,i3,qc)+(-au12mzz-au21zpz)*u(i1-
     & 1,i2+1,i3,qc)+(au22ph)*u(i1,i2+1,i3,qc)+(au12pzz+au21zpz)*u(i1+
     & 1,i2+1,i3,qc) )
                 fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + dsgT
                endif
                if( nonlinearTermsAreImplicit.eq.1 )then
                  ! include linearized terms u0*ulx + ul*u0x 
                  fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) - aImp*( qlterm )
                end if
                if( isAxisymmetric.eq.1 )then
                 radi=radiusInverse(i1,i2,i3)
                 if( radi.ne.0. )then
                   fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + kThermal*( q0y*
     & radi )
                 else
                   fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) + kThermal*( q0yy 
     & )
                 end if
                end if
              end if
             end if
           end if
          end if
          if( evalResidual.eq.1 )then
            ! residual in 2D: (NOTE: currently ul is not available when evaluating the residual)
            fe(i1,i2,i3,uc) = fi(i1,i2,i3,uc) - ugv*u0x -vgv*u0y - p0x 
     & + nu*(u0xx+u0yy)+ adCoeff*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(
     & i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)-4.*u(i1,i2,i3,uc))
            fe(i1,i2,i3,vc) = fi(i1,i2,i3,vc) - ugv*v0x -vgv*v0y - p0y 
     & + nu*(v0xx+v0yy)+ adCoeff*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(
     & i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)-4.*u(i1,i2,i3,vc))
            if( isAxisymmetric.eq.1 )then
              radi=radiusInverse(i1,i2,i3)
              if( radi.ne.0. )then
                fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0y*radi )    
     &         ! add u_r/r
                fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( (v0y -vv*radi)
     & *radi ) ! add v_r/r - v/r^2
              else
                fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + nu*( u0yy )    ! add u_rr
                fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + nu*( .5*v0yy ) ! add .5*vrr
              end if
            end if
            if( pdeModel.eq.BoussinesqModel )then
             fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
             fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
             fe(i1,i2,i3,qc) = fi(i1,i2,i3,qc) - ugv*q0x -vgv*q0y  + 
     & adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1+1,i2,i3,
     & qc)+u(i1,i2+1,i3,qc)-4.*u(i1,i2,i3,qc))
             if( materialFormat.eq.constantMaterialProperties )then
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*(q0xx+q0yy)
             else
              ! -- variable material properties : 
              ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
               ! ---------- 2D -----------
               ! Get coefficients at nearby points: 
               if( materialFormat.eq.constantMaterialProperties )then
                 ! const material properties 
                 stop 11199
               else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                 ! piecewise constant material properties
                 scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                 Kzmz=thermalKpc(i1  ,i2-1,i3)
                 Kmzz=thermalKpc(i1-1,i2  ,i3)
                 Kzzz=thermalKpc(i1  ,i2  ,i3)
                 Kpzz=thermalKpc(i1+1,i2  ,i3)
                 Kzpz=thermalKpc(i1  ,i2+1,i3)
               else if( materialFormat.eq.variableMaterialProperties )
     & then
                 ! variable material properties
                 scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                 Kzmz=thermalKv(i1  ,i2-1,i3)
                 Kmzz=thermalKv(i1-1,i2  ,i3)
                 Kzzz=thermalKv(i1  ,i2  ,i3)
                 Kpzz=thermalKv(i1+1,i2  ,i3)
                 Kzpz=thermalKv(i1  ,i2+1,i3)
               end if
               !  ---- Dx( K*u.x ) + Dy( K*u.y ) ----
                ! evaluate the jacobian at nearby points:
                ajzmz = (1./(rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,
     & i3)*sx(i1,i2-1,i3)))
                ajmzz = (1./(rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,
     & i3)*sx(i1-1,i2,i3)))
                ajzzz = (1./(rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*sx(
     & i1,i2,i3)))
                ajpzz = (1./(rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,
     & i3)*sx(i1+1,i2,i3)))
                ajzpz = (1./(rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,
     & i3)*sx(i1,i2+1,i3)))
                ! 1. Get coefficients au11ph, au11mh, au22ph, etc. for 
                !          Dx( K*u.x ) + Dy( K*u.y ) 
                 au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,i3)
     &  + (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) )
                 au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,i3)
     &  + (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) )
                 au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,i3)
     &  + (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) )
                 au11ph = .5*( au11zzz+au11pzz )
                 au11mh = .5*( au11zzz+au11mzz )
                 au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,i3)
     &  + (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) )
                 au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,i3)
     &  + (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) )
                 au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,i3)
     &  + (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) )
                 au22ph = .5*( au22zzz+au22zpz )
                 au22mh = .5*( au22zzz+au22zmz )
                 au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,i3)
     &  + (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) )
                 au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,i3)
     &  + (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) )
                 au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,i3)
     &  + (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) )
                 au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,i3)
     &  + (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) )
                 au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,i3)
     &  + (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) )
                 au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,i3)
     &  + (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) )
                ! scaling factors: 
                dr0i = (scale)/(ajzzz*dr(0)**2)
                dr1i = (scale)/(ajzzz*dr(1)**2)
                dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
                 au11ph=au11ph*dr0i
                 au11mh=au11mh*dr0i
                 au22ph=au22ph*dr1i
                 au22mh=au22mh*dr1i
                 au12pzz=au12pzz*dr0dr1
                 au12mzz=au12mzz*dr0dr1
                 au21zpz=au21zpz*dr0dr1
                 au21zmz=au21zmz*dr0dr1
               ! write(*,'(" (i1,i2)=(",i3,",",i3,") Kzmz,Kmzz,Kzz,Kpzz,Kzpz = ",5e10.2)') i1,i2,Kzmz,Kmzz,Kzzz,Kpzz,Kzpz
               ! write(*,'(" scale,dtImp =",2e10.2)') scale,dtImp
               ! write(*,'(" au11ph,au11mh,au22ph,au22mh=",4e10.2)') au11ph,au11mh,au22ph,au22mh
                ! 2D, order 2:
                dsgT = ( (au12mzz+au21zmz)*u(i1-1,i2-1,i3,qc) + (
     & au22mh)*u(i1,i2-1,i3,qc)+(-au12pzz-au21zmz)*u(i1+1,i2-1,i3,qc)+
     & (au11mh)*u(i1-1,i2,i3,qc)+(-au11ph-au11mh -au22ph -au22mh)*u(
     & i1,i2,i3,qc)+(au11ph)*u(i1+1,i2,i3,qc)+(-au12mzz-au21zpz)*u(i1-
     & 1,i2+1,i3,qc)+(au22ph)*u(i1,i2+1,i3,qc)+(au12pzz+au21zpz)*u(i1+
     & 1,i2+1,i3,qc) )
              fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
             endif
             if( isAxisymmetric.eq.1 )then
              radi=radiusInverse(i1,i2,i3)
              if( radi.ne.0. )then
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0y*
     & radi )  ! add u_r/r
              else
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*( q0yy )  
     &     ! add u_rr
              end if
             end if
            end if
          end if
          end do
          end do
          end do
         end if
      else if(  nd.eq.3 .and. gridType.eq.rectangular .and. 
     & orderOfAccuracy.eq.2 )then
       ! fill the coefficients:
        ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
        if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           ! --- fill coefficients for a scalar system for a velocity component: I - nu*Delta - A.D. 
           ! write(*,'("@@@@ insImpINS: (u,v,w) fillCoefficientsScalarSystem=",i4)') fillCoefficientsScalarSystem
           ! '
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
            ! Operator laplacian = uxx+uyy+uzz
             lapCoeff(ma3(-1,-1,-1)) = 0
             lapCoeff(ma3( 0,-1,-1)) = 0
             lapCoeff(ma3( 1,-1,-1)) = 0
             lapCoeff(ma3(-1, 0,-1)) = 0
             lapCoeff(ma3( 0, 0,-1)) = 1./dx(2)**2
             lapCoeff(ma3( 1, 0,-1)) = 0
             lapCoeff(ma3(-1, 1,-1)) = 0
             lapCoeff(ma3( 0, 1,-1)) = 0
             lapCoeff(ma3( 1, 1,-1)) = 0
             lapCoeff(ma3(-1,-1, 0)) = 0
             lapCoeff(ma3( 0,-1, 0)) = 1./dx(1)**2
             lapCoeff(ma3( 1,-1, 0)) = 0
             lapCoeff(ma3(-1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma3( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2-2./dx(
     & 2)**2
             lapCoeff(ma3( 1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma3(-1, 1, 0)) = 0
             lapCoeff(ma3( 0, 1, 0)) = 1./dx(1)**2
             lapCoeff(ma3( 1, 1, 0)) = 0
             lapCoeff(ma3(-1,-1, 1)) = 0
             lapCoeff(ma3( 0,-1, 1)) = 0
             lapCoeff(ma3( 1,-1, 1)) = 0
             lapCoeff(ma3(-1, 0, 1)) = 0
             lapCoeff(ma3( 0, 0, 1)) = 1./dx(2)**2
             lapCoeff(ma3( 1, 0, 1)) = 0
             lapCoeff(ma3(-1, 1, 1)) = 0
             lapCoeff(ma3( 0, 1, 1)) = 0
             lapCoeff(ma3( 1, 1, 1)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss+utt
             dissCoeff(ma3(-1,-1,-1)) = 0
             dissCoeff(ma3( 0,-1,-1)) = 0
             dissCoeff(ma3( 1,-1,-1)) = 0
             dissCoeff(ma3(-1, 0,-1)) = 0
             dissCoeff(ma3( 0, 0,-1)) = 1
             dissCoeff(ma3( 1, 0,-1)) = 0
             dissCoeff(ma3(-1, 1,-1)) = 0
             dissCoeff(ma3( 0, 1,-1)) = 0
             dissCoeff(ma3( 1, 1,-1)) = 0
             dissCoeff(ma3(-1,-1, 0)) = 0
             dissCoeff(ma3( 0,-1, 0)) = 1
             dissCoeff(ma3( 1,-1, 0)) = 0
             dissCoeff(ma3(-1, 0, 0)) = 1
             dissCoeff(ma3( 0, 0, 0)) = -6
             dissCoeff(ma3( 1, 0, 0)) = 1
             dissCoeff(ma3(-1, 1, 0)) = 0
             dissCoeff(ma3( 0, 1, 0)) = 1
             dissCoeff(ma3( 1, 1, 0)) = 0
             dissCoeff(ma3(-1,-1, 1)) = 0
             dissCoeff(ma3( 0,-1, 1)) = 0
             dissCoeff(ma3( 1,-1, 1)) = 0
             dissCoeff(ma3(-1, 0, 1)) = 0
             dissCoeff(ma3( 0, 0, 1)) = 1
             dissCoeff(ma3( 1, 0, 1)) = 0
             dissCoeff(ma3(-1, 1, 1)) = 0
             dissCoeff(ma3( 0, 1, 1)) = 0
             dissCoeff(ma3( 1, 1, 1)) = 0
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dx(0))
            u0y = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dx(1))
             u0z = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dx(2))
          ! parametric derivatives of v: 
           vv=u(i1,i2,i3,vc) ! in the rectangular case just eval the solution
            v0x = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dx(0))
            v0y = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dx(1))
             v0z = (-u(i1,i2,i3-1,vc)+u(i1,i2,i3+1,vc))/(2.*dx(2))
            ww=u(i1,i2,i3,wc) ! in the rectangular case just eval the solution
             w0x = (-u(i1-1,i2,i3,wc)+u(i1+1,i2,i3,wc))/(2.*dx(0))
             w0y = (-u(i1,i2-1,i3,wc)+u(i1,i2+1,i3,wc))/(2.*dx(1))
             w0z = (-u(i1,i2,i3-1,wc)+u(i1,i2,i3+1,wc))/(2.*dx(2))
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y)+abs(u0z) + abs(
     & v0x)+abs(v0y)+abs(v0z) + abs(w0x)+abs(w0y)+abs(w0z) )
         ! Form : I - nuDt*Delta -adCoeff*dt*( urr + uss + .. )
          do m3=-halfWidth3,halfWidth3
          do m2=-halfWidth,halfWidth
          do m1=-halfWidth,halfWidth
            coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(m1,m2,
     & m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(
     & ma3(m1,m2,m3)))
          end do
          end do
          end do
           end if
          end do
          end do
          end do
         else if( fillCoefficientsScalarSystem.eq.fillCoeffT )then
           ! --- fill coefficients for a scalar system for the Temperature: I - kappa*Delta - A.D. 
          write(*,'("@@@@ insImpINS: T: fillCoefficientsScalarSystem=",
     & i4)') fillCoefficientsScalarSystem
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
            ! Operator laplacian = uxx+uyy+uzz
             lapCoeff(ma3(-1,-1,-1)) = 0
             lapCoeff(ma3( 0,-1,-1)) = 0
             lapCoeff(ma3( 1,-1,-1)) = 0
             lapCoeff(ma3(-1, 0,-1)) = 0
             lapCoeff(ma3( 0, 0,-1)) = 1./dx(2)**2
             lapCoeff(ma3( 1, 0,-1)) = 0
             lapCoeff(ma3(-1, 1,-1)) = 0
             lapCoeff(ma3( 0, 1,-1)) = 0
             lapCoeff(ma3( 1, 1,-1)) = 0
             lapCoeff(ma3(-1,-1, 0)) = 0
             lapCoeff(ma3( 0,-1, 0)) = 1./dx(1)**2
             lapCoeff(ma3( 1,-1, 0)) = 0
             lapCoeff(ma3(-1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma3( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2-2./dx(
     & 2)**2
             lapCoeff(ma3( 1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma3(-1, 1, 0)) = 0
             lapCoeff(ma3( 0, 1, 0)) = 1./dx(1)**2
             lapCoeff(ma3( 1, 1, 0)) = 0
             lapCoeff(ma3(-1,-1, 1)) = 0
             lapCoeff(ma3( 0,-1, 1)) = 0
             lapCoeff(ma3( 1,-1, 1)) = 0
             lapCoeff(ma3(-1, 0, 1)) = 0
             lapCoeff(ma3( 0, 0, 1)) = 1./dx(2)**2
             lapCoeff(ma3( 1, 0, 1)) = 0
             lapCoeff(ma3(-1, 1, 1)) = 0
             lapCoeff(ma3( 0, 1, 1)) = 0
             lapCoeff(ma3( 1, 1, 1)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss+utt
             dissCoeff(ma3(-1,-1,-1)) = 0
             dissCoeff(ma3( 0,-1,-1)) = 0
             dissCoeff(ma3( 1,-1,-1)) = 0
             dissCoeff(ma3(-1, 0,-1)) = 0
             dissCoeff(ma3( 0, 0,-1)) = 1
             dissCoeff(ma3( 1, 0,-1)) = 0
             dissCoeff(ma3(-1, 1,-1)) = 0
             dissCoeff(ma3( 0, 1,-1)) = 0
             dissCoeff(ma3( 1, 1,-1)) = 0
             dissCoeff(ma3(-1,-1, 0)) = 0
             dissCoeff(ma3( 0,-1, 0)) = 1
             dissCoeff(ma3( 1,-1, 0)) = 0
             dissCoeff(ma3(-1, 0, 0)) = 1
             dissCoeff(ma3( 0, 0, 0)) = -6
             dissCoeff(ma3( 1, 0, 0)) = 1
             dissCoeff(ma3(-1, 1, 0)) = 0
             dissCoeff(ma3( 0, 1, 0)) = 1
             dissCoeff(ma3( 1, 1, 0)) = 0
             dissCoeff(ma3(-1,-1, 1)) = 0
             dissCoeff(ma3( 0,-1, 1)) = 0
             dissCoeff(ma3( 1,-1, 1)) = 0
             dissCoeff(ma3(-1, 0, 1)) = 0
             dissCoeff(ma3( 0, 0, 1)) = 1
             dissCoeff(ma3( 1, 0, 1)) = 0
             dissCoeff(ma3(-1, 1, 1)) = 0
             dissCoeff(ma3( 0, 1, 1)) = 0
             dissCoeff(ma3( 1, 1, 1)) = 0
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma3(m1,m2,m3)))+(-adcBoussinesq*dt*
     & dissCoeff(ma3(m1,m2,m3)))
             end do
             end do
             end do
          else
           ! -- variable material properties : 
           ! get coefficients scaled by -dt*implicitFactor: 
            ! ---------- 3D -----------
            ! Get coefficients at nearby points: 
            if( materialFormat.eq.constantMaterialProperties )then
              ! const material properties 
              stop 11199
            else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
              ! piecewise constant material properties
              scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
              Kzzm=thermalKpc(i1  ,i2  ,i3-1)
              Kzmz=thermalKpc(i1  ,i2-1,i3  )
              Kmzz=thermalKpc(i1-1,i2  ,i3  )
              Kzzz=thermalKpc(i1  ,i2  ,i3  )
              Kpzz=thermalKpc(i1+1,i2  ,i3  )
              Kzpz=thermalKpc(i1  ,i2+1,i3  )
              Kzzp=thermalKpc(i1  ,i2  ,i3+1)
            else if( materialFormat.eq.variableMaterialProperties )then
              ! variable material properties
              scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
              Kzzm=thermalKv(i1  ,i2  ,i3-1)
              Kzmz=thermalKv(i1  ,i2-1,i3  )
              Kmzz=thermalKv(i1-1,i2  ,i3  )
              Kzzz=thermalKv(i1  ,i2  ,i3  )
              Kpzz=thermalKv(i1+1,i2  ,i3  )
              Kzpz=thermalKv(i1  ,i2+1,i3  )
              Kzzp=thermalKv(i1  ,i2  ,i3+1)
            end if
            !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
              K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
              K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
              K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
              K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
              K2ph = .5*( Kzzp+Kzzz )  ! K(i1,i2,i3+1/2)
              K2mh = .5*( Kzzz+Kzzm )  ! K(i1,i2,i3-1/2)
              ! equation for T
              !    Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z )  
              au11ph = K0ph*dxvsqi(0)*(scale)
              au11mh = K0mh*dxvsqi(0)*(scale)
              au22ph = K1ph*dxvsqi(1)*(scale)
              au22mh = K1mh*dxvsqi(1)*(scale)
              au33ph = K2ph*dxvsqi(2)*(scale)
              au33mh = K2mh*dxvsqi(2)*(scale)
              au12pzz=0.
              au12mzz=0.
              au13pzz=0.
              au13mzz=0.
              au21zpz=0.
              au21zmz=0.
              au23zpz=0.
              au23zmz=0.
              au31zzp=0.
              au31zzm=0.
              au32zzp=0.
              au32zzm=0.
           ! Set coeff = - dtImp*div( K grad)
               coeff(mce3(-1,-1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,-1,-1,cmpu,eqnu),i1,i2,i3)=         
     & au23zmz+au32zzm
               coeff(mce3(1,-1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(-1,0,-1,cmpu,eqnu),i1,i2,i3)=  au13mzz+
     & au31zzm
               coeff(mce3(0,0,-1,cmpu,eqnu),i1,i2,i3)=                 
     &                    au33mh
               coeff(mce3(1,0,-1,cmpu,eqnu),i1,i2,i3)= -au13pzz-au31zzm
               coeff(mce3(-1,1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,1,-1,cmpu,eqnu),i1,i2,i3)=        -au23zpz-
     & au32zzm
               coeff(mce3(1,1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(-1,-1,0,cmpu,eqnu),i1,i2,i3)=  au12mzz+
     & au21zmz
               coeff(mce3(0,-1,0,cmpu,eqnu),i1,i2,i3)=                 
     &      au22mh
               coeff(mce3(1,-1,0,cmpu,eqnu),i1,i2,i3)= -au12pzz-au21zmz
               coeff(mce3(-1,0,0,cmpu,eqnu),i1,i2,i3)=         au11mh
               coeff(mce3(0,0,0,cmpu,eqnu),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh -au33ph -au33mh
               coeff(mce3(1,0,0,cmpu,eqnu),i1,i2,i3)=  au11ph
               coeff(mce3(-1,1,0,cmpu,eqnu),i1,i2,i3)= -au12mzz-au21zpz
               coeff(mce3(0,1,0,cmpu,eqnu),i1,i2,i3)=               
     & au22ph
               coeff(mce3(1,1,0,cmpu,eqnu),i1,i2,i3)=  au12pzz+au21zpz
               coeff(mce3(-1,-1,1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,-1,1,cmpu,eqnu),i1,i2,i3)=       -au23zmz-
     & au32zzp
               coeff(mce3(1,-1,1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(-1,0,1,cmpu,eqnu),i1,i2,i3)= -au13mzz-au31zzp
               coeff(mce3(0,0,1,cmpu,eqnu),i1,i2,i3)=                  
     &           au33ph
               coeff(mce3(1,0,1,cmpu,eqnu),i1,i2,i3)=  au13pzz+au31zzp
               coeff(mce3(-1,1,1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,1,1,cmpu,eqnu),i1,i2,i3)=        au23zpz+
     & au32zzp
               coeff(mce3(1,1,1,cmpu,eqnu),i1,i2,i3)= 0.
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
              coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce3(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(iCoeff(ma3(m1,m2,m3)))+(-
     & adcBoussinesq*dt*dissCoeff(ma3(m1,m2,m3)))
            end do
            end do
            end do
          endif
           end if
          end do
          end do
          end do
         else
           ! --- fill coefficients for the full system ---
         ! write(*,'("&&&&& insImpINS: fill coefficients for a full system, pdeModel=",i3)') pdeModel
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
            ! Operator laplacian = uxx+uyy+uzz
             lapCoeff(ma3(-1,-1,-1)) = 0
             lapCoeff(ma3( 0,-1,-1)) = 0
             lapCoeff(ma3( 1,-1,-1)) = 0
             lapCoeff(ma3(-1, 0,-1)) = 0
             lapCoeff(ma3( 0, 0,-1)) = 1./dx(2)**2
             lapCoeff(ma3( 1, 0,-1)) = 0
             lapCoeff(ma3(-1, 1,-1)) = 0
             lapCoeff(ma3( 0, 1,-1)) = 0
             lapCoeff(ma3( 1, 1,-1)) = 0
             lapCoeff(ma3(-1,-1, 0)) = 0
             lapCoeff(ma3( 0,-1, 0)) = 1./dx(1)**2
             lapCoeff(ma3( 1,-1, 0)) = 0
             lapCoeff(ma3(-1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma3( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2-2./dx(
     & 2)**2
             lapCoeff(ma3( 1, 0, 0)) = 1./dx(0)**2
             lapCoeff(ma3(-1, 1, 0)) = 0
             lapCoeff(ma3( 0, 1, 0)) = 1./dx(1)**2
             lapCoeff(ma3( 1, 1, 0)) = 0
             lapCoeff(ma3(-1,-1, 1)) = 0
             lapCoeff(ma3( 0,-1, 1)) = 0
             lapCoeff(ma3( 1,-1, 1)) = 0
             lapCoeff(ma3(-1, 0, 1)) = 0
             lapCoeff(ma3( 0, 0, 1)) = 1./dx(2)**2
             lapCoeff(ma3( 1, 0, 1)) = 0
             lapCoeff(ma3(-1, 1, 1)) = 0
             lapCoeff(ma3( 0, 1, 1)) = 0
             lapCoeff(ma3( 1, 1, 1)) = 0
            ! Operator x = ux
             xCoeff(ma3(-1,-1,-1)) = 0
             xCoeff(ma3( 0,-1,-1)) = 0
             xCoeff(ma3( 1,-1,-1)) = 0
             xCoeff(ma3(-1, 0,-1)) = 0
             xCoeff(ma3( 0, 0,-1)) = 0
             xCoeff(ma3( 1, 0,-1)) = 0
             xCoeff(ma3(-1, 1,-1)) = 0
             xCoeff(ma3( 0, 1,-1)) = 0
             xCoeff(ma3( 1, 1,-1)) = 0
             xCoeff(ma3(-1,-1, 0)) = 0
             xCoeff(ma3( 0,-1, 0)) = 0
             xCoeff(ma3( 1,-1, 0)) = 0
             xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
             xCoeff(ma3( 0, 0, 0)) = 0
             xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
             xCoeff(ma3(-1, 1, 0)) = 0
             xCoeff(ma3( 0, 1, 0)) = 0
             xCoeff(ma3( 1, 1, 0)) = 0
             xCoeff(ma3(-1,-1, 1)) = 0
             xCoeff(ma3( 0,-1, 1)) = 0
             xCoeff(ma3( 1,-1, 1)) = 0
             xCoeff(ma3(-1, 0, 1)) = 0
             xCoeff(ma3( 0, 0, 1)) = 0
             xCoeff(ma3( 1, 0, 1)) = 0
             xCoeff(ma3(-1, 1, 1)) = 0
             xCoeff(ma3( 0, 1, 1)) = 0
             xCoeff(ma3( 1, 1, 1)) = 0
            ! Operator y = uy
             yCoeff(ma3(-1,-1,-1)) = 0
             yCoeff(ma3( 0,-1,-1)) = 0
             yCoeff(ma3( 1,-1,-1)) = 0
             yCoeff(ma3(-1, 0,-1)) = 0
             yCoeff(ma3( 0, 0,-1)) = 0
             yCoeff(ma3( 1, 0,-1)) = 0
             yCoeff(ma3(-1, 1,-1)) = 0
             yCoeff(ma3( 0, 1,-1)) = 0
             yCoeff(ma3( 1, 1,-1)) = 0
             yCoeff(ma3(-1,-1, 0)) = 0
             yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
             yCoeff(ma3( 1,-1, 0)) = 0
             yCoeff(ma3(-1, 0, 0)) = 0
             yCoeff(ma3( 0, 0, 0)) = 0
             yCoeff(ma3( 1, 0, 0)) = 0
             yCoeff(ma3(-1, 1, 0)) = 0
             yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
             yCoeff(ma3( 1, 1, 0)) = 0
             yCoeff(ma3(-1,-1, 1)) = 0
             yCoeff(ma3( 0,-1, 1)) = 0
             yCoeff(ma3( 1,-1, 1)) = 0
             yCoeff(ma3(-1, 0, 1)) = 0
             yCoeff(ma3( 0, 0, 1)) = 0
             yCoeff(ma3( 1, 0, 1)) = 0
             yCoeff(ma3(-1, 1, 1)) = 0
             yCoeff(ma3( 0, 1, 1)) = 0
             yCoeff(ma3( 1, 1, 1)) = 0
             ! Operator z = uz
              zCoeff(ma3(-1,-1,-1)) = 0
              zCoeff(ma3( 0,-1,-1)) = 0
              zCoeff(ma3( 1,-1,-1)) = 0
              zCoeff(ma3(-1, 0,-1)) = 0
              zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
              zCoeff(ma3( 1, 0,-1)) = 0
              zCoeff(ma3(-1, 1,-1)) = 0
              zCoeff(ma3( 0, 1,-1)) = 0
              zCoeff(ma3( 1, 1,-1)) = 0
              zCoeff(ma3(-1,-1, 0)) = 0
              zCoeff(ma3( 0,-1, 0)) = 0
              zCoeff(ma3( 1,-1, 0)) = 0
              zCoeff(ma3(-1, 0, 0)) = 0
              zCoeff(ma3( 0, 0, 0)) = 0
              zCoeff(ma3( 1, 0, 0)) = 0
              zCoeff(ma3(-1, 1, 0)) = 0
              zCoeff(ma3( 0, 1, 0)) = 0
              zCoeff(ma3( 1, 1, 0)) = 0
              zCoeff(ma3(-1,-1, 1)) = 0
              zCoeff(ma3( 0,-1, 1)) = 0
              zCoeff(ma3( 1,-1, 1)) = 0
              zCoeff(ma3(-1, 0, 1)) = 0
              zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
              zCoeff(ma3( 1, 0, 1)) = 0
              zCoeff(ma3(-1, 1, 1)) = 0
              zCoeff(ma3( 0, 1, 1)) = 0
              zCoeff(ma3( 1, 1, 1)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss+utt
             dissCoeff(ma3(-1,-1,-1)) = 0
             dissCoeff(ma3( 0,-1,-1)) = 0
             dissCoeff(ma3( 1,-1,-1)) = 0
             dissCoeff(ma3(-1, 0,-1)) = 0
             dissCoeff(ma3( 0, 0,-1)) = 1
             dissCoeff(ma3( 1, 0,-1)) = 0
             dissCoeff(ma3(-1, 1,-1)) = 0
             dissCoeff(ma3( 0, 1,-1)) = 0
             dissCoeff(ma3( 1, 1,-1)) = 0
             dissCoeff(ma3(-1,-1, 0)) = 0
             dissCoeff(ma3( 0,-1, 0)) = 1
             dissCoeff(ma3( 1,-1, 0)) = 0
             dissCoeff(ma3(-1, 0, 0)) = 1
             dissCoeff(ma3( 0, 0, 0)) = -6
             dissCoeff(ma3( 1, 0, 0)) = 1
             dissCoeff(ma3(-1, 1, 0)) = 0
             dissCoeff(ma3( 0, 1, 0)) = 1
             dissCoeff(ma3( 1, 1, 0)) = 0
             dissCoeff(ma3(-1,-1, 1)) = 0
             dissCoeff(ma3( 0,-1, 1)) = 0
             dissCoeff(ma3( 1,-1, 1)) = 0
             dissCoeff(ma3(-1, 0, 1)) = 0
             dissCoeff(ma3( 0, 0, 1)) = 1
             dissCoeff(ma3( 1, 0, 1)) = 0
             dissCoeff(ma3(-1, 1, 1)) = 0
             dissCoeff(ma3( 0, 1, 1)) = 0
             dissCoeff(ma3( 1, 1, 1)) = 0
          ! for testing, get coeff for div( s grad )
          ! getOpCoeffDivScalarGrad(s(i1,i2,i3,0))
          ! **** get a fourth order dissipation u.rrrr + u.ssss 
          ! evaluate forward derivatives of the current solution: 
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dx(0))
            u0y = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dx(1))
             u0z = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dx(2))
          ! parametric derivatives of v: 
           vv=u(i1,i2,i3,vc) ! in the rectangular case just eval the solution
            v0x = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dx(0))
            v0y = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dx(1))
             v0z = (-u(i1,i2,i3-1,vc)+u(i1,i2,i3+1,vc))/(2.*dx(2))
            ww=u(i1,i2,i3,wc) ! in the rectangular case just eval the solution
             w0x = (-u(i1-1,i2,i3,wc)+u(i1+1,i2,i3,wc))/(2.*dx(0))
             w0y = (-u(i1,i2-1,i3,wc)+u(i1,i2+1,i3,wc))/(2.*dx(1))
             w0z = (-u(i1,i2,i3-1,wc)+u(i1,i2,i3+1,wc))/(2.*dx(2))
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y)+abs(u0z) + abs(
     & v0x)+abs(v0y)+abs(v0z) + abs(w0x)+abs(w0y)+abs(w0z) )
         if( gridIsMoving.ne.0 )then
           ugv = uu - gv(i1,i2,i3,0)
           vgv = vv - gv(i1,i2,i3,1)
           wgv = ww - gv(i1,i3,i3,2)
         else
           ugv = uu
           vgv = vv
           wgv = ww
         end if
          ! Form : I - nuDt*Delta + aDt*u*Dx + aDt*v*Dy + aDt*w*dz
          !    u0*ux + v0*uy + w0*uz + u*u0x + v*u0y + w*u0z 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(
     & ma3(m1,m2,m3)))+(bDt*u0x*iCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*
     & dissCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpv,eqnu),i1,i2,i3)+(bDt*u0y*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpw,eqnu),i1,i2,i3)+(bDt*u0z*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
          !    u0*vx + v0*vy + w0*vz + u*v0x + v*v0y + w*v0z 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(
     & ma3(m1,m2,m3)))+(bDt*v0y*iCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*
     & dissCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpu,eqnv),i1,i2,i3)+(bDt*v0x*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpw,eqnv),i1,i2,i3)+(bDt*v0z*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
          !    u0*wx + v0*wy + w0*wz + u*w0x + v*w0y + w*w0z 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(
     & ma3(m1,m2,m3)))+(bDt*w0z*iCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*
     & dissCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnw),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpu,eqnw),i1,i2,i3)+(bDt*w0x*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnw),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpv,eqnw),i1,i2,i3)+(bDt*w0y*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
         if( pdeModel.eq.BoussinesqModel )then
          ! ----------------------------------------------------------------------------
          ! ---------- add the temperature equation to the full system -----------------
          ! ----------------------------------------------------------------------------
           qq=u(i1,i2,i3,qc) ! in the rectangular case just eval the solution
            q0x = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dx(0))
            q0y = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dx(1))
             q0z = (-u(i1,i2,i3-1,qc)+u(i1,i2,i3+1,qc))/(2.*dx(2))
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties:
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(m1,
     & m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(ma3(
     & m1,m2,m3)))+(-adcBoussinesq*dt*dissCoeff(ma3(m1,m2,m3)))
             end do
             end do
             end do
          else
            ! get coefficients scaled by -dt*implicitFactor: 
             ! ---------- 3D -----------
             ! Get coefficients at nearby points: 
             if( materialFormat.eq.constantMaterialProperties )then
               ! const material properties 
               stop 11199
             else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
               ! piecewise constant material properties
               scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
               Kzzm=thermalKpc(i1  ,i2  ,i3-1)
               Kzmz=thermalKpc(i1  ,i2-1,i3  )
               Kmzz=thermalKpc(i1-1,i2  ,i3  )
               Kzzz=thermalKpc(i1  ,i2  ,i3  )
               Kpzz=thermalKpc(i1+1,i2  ,i3  )
               Kzpz=thermalKpc(i1  ,i2+1,i3  )
               Kzzp=thermalKpc(i1  ,i2  ,i3+1)
             else if( materialFormat.eq.variableMaterialProperties )
     & then
               ! variable material properties
               scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
               Kzzm=thermalKv(i1  ,i2  ,i3-1)
               Kzmz=thermalKv(i1  ,i2-1,i3  )
               Kmzz=thermalKv(i1-1,i2  ,i3  )
               Kzzz=thermalKv(i1  ,i2  ,i3  )
               Kpzz=thermalKv(i1+1,i2  ,i3  )
               Kzpz=thermalKv(i1  ,i2+1,i3  )
               Kzzp=thermalKv(i1  ,i2  ,i3+1)
             end if
             !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
               K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
               K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
               K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
               K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
               K2ph = .5*( Kzzp+Kzzz )  ! K(i1,i2,i3+1/2)
               K2mh = .5*( Kzzz+Kzzm )  ! K(i1,i2,i3-1/2)
               ! equation for T
               !    Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z )  
               au11ph = K0ph*dxvsqi(0)*(scale)
               au11mh = K0mh*dxvsqi(0)*(scale)
               au22ph = K1ph*dxvsqi(1)*(scale)
               au22mh = K1mh*dxvsqi(1)*(scale)
               au33ph = K2ph*dxvsqi(2)*(scale)
               au33mh = K2mh*dxvsqi(2)*(scale)
               au12pzz=0.
               au12mzz=0.
               au13pzz=0.
               au13mzz=0.
               au21zpz=0.
               au21zmz=0.
               au23zpz=0.
               au23zmz=0.
               au31zzp=0.
               au31zzm=0.
               au32zzp=0.
               au32zzm=0.
              coeff(mce3(-1,-1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,-1,-1,cmpq,eqnq),i1,i2,i3)=         au23zmz+
     & au32zzm
              coeff(mce3(1,-1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(-1,0,-1,cmpq,eqnq),i1,i2,i3)=  au13mzz+au31zzm
              coeff(mce3(0,0,-1,cmpq,eqnq),i1,i2,i3)=                  
     &                   au33mh
              coeff(mce3(1,0,-1,cmpq,eqnq),i1,i2,i3)= -au13pzz-au31zzm
              coeff(mce3(-1,1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,1,-1,cmpq,eqnq),i1,i2,i3)=        -au23zpz-
     & au32zzm
              coeff(mce3(1,1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(-1,-1,0,cmpq,eqnq),i1,i2,i3)=  au12mzz+au21zmz
              coeff(mce3(0,-1,0,cmpq,eqnq),i1,i2,i3)=                  
     &     au22mh
              coeff(mce3(1,-1,0,cmpq,eqnq),i1,i2,i3)= -au12pzz-au21zmz
              coeff(mce3(-1,0,0,cmpq,eqnq),i1,i2,i3)=         au11mh
              coeff(mce3(0,0,0,cmpq,eqnq),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh -au33ph -au33mh
              coeff(mce3(1,0,0,cmpq,eqnq),i1,i2,i3)=  au11ph
              coeff(mce3(-1,1,0,cmpq,eqnq),i1,i2,i3)= -au12mzz-au21zpz
              coeff(mce3(0,1,0,cmpq,eqnq),i1,i2,i3)=               
     & au22ph
              coeff(mce3(1,1,0,cmpq,eqnq),i1,i2,i3)=  au12pzz+au21zpz
              coeff(mce3(-1,-1,1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,-1,1,cmpq,eqnq),i1,i2,i3)=       -au23zmz-
     & au32zzp
              coeff(mce3(1,-1,1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(-1,0,1,cmpq,eqnq),i1,i2,i3)= -au13mzz-au31zzp
              coeff(mce3(0,0,1,cmpq,eqnq),i1,i2,i3)=                   
     &          au33ph
              coeff(mce3(1,0,1,cmpq,eqnq),i1,i2,i3)=  au13pzz+au31zzp
              coeff(mce3(-1,1,1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,1,1,cmpq,eqnq),i1,i2,i3)=        au23zpz+
     & au32zzp
              coeff(mce3(1,1,1,cmpq,eqnq),i1,i2,i3)= 0.
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce3(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(iCoeff(ma3(m1,m2,m3)))+(adt*ugv*
     & xCoeff(ma3(m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*
     & wgv*zCoeff(ma3(m1,m2,m3)))+(-adcBoussinesq*dt*dissCoeff(ma3(m1,
     & m2,m3)))
             end do
             end do
             end do
          endif
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnq),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpu,eqnq),i1,i2,i3)+(bDt*q0x*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnq),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpv,eqnq),i1,i2,i3)+(bDt*q0y*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnq),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpw,eqnq),i1,i2,i3)+(bDt*q0z*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpq,eqnu),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpq,eqnu),i1,i2,i3)+(teDt*gravity(0)*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpq,eqnv),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpq,eqnv),i1,i2,i3)+(teDt*gravity(1)*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpq,eqnw),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpq,eqnw),i1,i2,i3)+(teDt*gravity(2)*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
         endif  ! pdeModel.eq.BoussinesqModel
           end if
          end do
          end do
          end do
        end if
        end if
       ! fill matrix BCs
       if( fillCoefficients.eq.1 .or. 
     & evalResidualForBoundaryConditions.eq.1 )then
        indexRange(0,0)=n1a
        indexRange(1,0)=n1b
        indexRange(0,1)=n2a
        indexRange(1,1)=n2b
        indexRange(0,2)=n3a
        indexRange(1,2)=n3b
        do axis=0,nd-1
        do side=0,1
         is1=0
         is2=0
         is3=0
         if( axis.eq.0 )then
           is1=1-2*side
           n1a=indexRange(side,axis)
           n1b=n1a
         else if( axis.eq.1 )then
           is2=1-2*side
           n2a=indexRange(side,axis)
           n2b=n2a
         else
           is3=1-2*side
           n3a=indexRange(side,axis)
           n3b=n3a
         end if
           ! define the outward normal for Cartesian grids
           an(0)=0.
           an(1)=0.
           an(2)=0.
           an(axis)=2*side-1
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( bc0.eq.noSlipWall )then
            write(*,'(" ")')
            write(*,'(">>> insImpINS: fill Matrix Boundary Conditions: 
     & useImplicitAmpBCs=",i4," isBulkSolid=",i2)') useImplicitAmpBCs,
     & isBulkSolid
            write(*,'(">>> insImpINS: fill useAddedMassAlgorithm=",i4,
     & " projectAddedMassVelocity=",i4)') useAddedMassAlgorithm,
     & projectAddedMassVelocity
            write(*,'(">>> insImpINS: nu,dt,alpha,beta=",4e10.2)') nu,
     & dt,alpha,beta
         end if
         ! Some Bc's like no-slip wall use extrapolation for ghost, sometimes we turn this off, for example,
         ! for the AMP "no-slip wall" BCs
         extrapolateGhostByDefault=1
         if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ne.fillCoeffT )then
           ! ---- fill BC coeffs for (u,v,w) ---
           bc0 = bc(side,axis)
           if( bc0.eq.slipWall .and. fillCoefficientsScalarSystem.gt.0 
     & )then
             if( fillCoefficientsScalarSystem.eq.(axis+1) )then
               bc0=dirichletBoundaryCondition
             else
               bc0=neumannBoundaryCondition
             end if
           end if
         if( bc0.eq.noSlipWall .and. useAddedMassAlgorithm.eq.1 .and. 
     & projectAddedMassVelocity.eq.1 .and. isBulkSolid.eq.1 )then
           ! ** AMP NO-SLIP WALL BCs FOR A BULK SOLID INTERFACE *** 
           !  The AMP conditions (see fib and fibr papers) have a limit of
           !  a no-slip wall for a heavy solid and a free surface for a light solid
          write(*,'(" insImpINS: FILL IMPLICIT AMP velocity BCs: 
     & fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
          if( mu.eq.0. )then
            write(*,'(" insImpINS:ERROR: mu=0 : nu,fluidDensity=",
     & 2e10.2)') nu,fluidDensity
            stop 0099
          end if
          extrapolateGhostByDefault=0 ! do NOT extrapolate ghost points (below)
          if( useImplicitAmpBCs.eq.0 )then
            write(*,'(" --- USE OLD WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=0 --- ")')
            ! *** DO THIS FOR NOW ***
            ! Dirichlet BC
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
             do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           !   opEvalJacobianDerivatives(aj,1)
             ! evaluate the coeff operators 
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
           !   getCoeff(x, xCoeff,aj)
           !   getCoeff(y, yCoeff,aj)
           !    getCoeff(z, zCoeff,aj)
             do n=0,ndu-1
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce3(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma3(m1,m2,m3)))
               end do
               end do
               end do
             end do
              end if
             end do
             end do
             end do
          else
           write(*,'("  ")')
           write(*,'(" --- USE NEW WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=1 --- ")')
           ! ********* NEW ADDED MASS BULK SOLID VELOCITY BCS ********
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
             write(*,'(" IMP: AMP BC i1,i2=",2i2," ndu=",i4," normal=",
     & 2e10.2)') i1,i2,ndu,an(0),an(1)
             ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
             ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') AMG(0,0,0),AMG(0,0,1),AMG(0,1,0),AMG(0,1,1)
             ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') AMG(1,0,0),AMG(1,0,1),AMG(1,1,0),AMG(1,1,1)
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = ux
                xCoeff(ma3(-1,-1,-1)) = 0
                xCoeff(ma3( 0,-1,-1)) = 0
                xCoeff(ma3( 1,-1,-1)) = 0
                xCoeff(ma3(-1, 0,-1)) = 0
                xCoeff(ma3( 0, 0,-1)) = 0
                xCoeff(ma3( 1, 0,-1)) = 0
                xCoeff(ma3(-1, 1,-1)) = 0
                xCoeff(ma3( 0, 1,-1)) = 0
                xCoeff(ma3( 1, 1,-1)) = 0
                xCoeff(ma3(-1,-1, 0)) = 0
                xCoeff(ma3( 0,-1, 0)) = 0
                xCoeff(ma3( 1,-1, 0)) = 0
                xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                xCoeff(ma3( 0, 0, 0)) = 0
                xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                xCoeff(ma3(-1, 1, 0)) = 0
                xCoeff(ma3( 0, 1, 0)) = 0
                xCoeff(ma3( 1, 1, 0)) = 0
                xCoeff(ma3(-1,-1, 1)) = 0
                xCoeff(ma3( 0,-1, 1)) = 0
                xCoeff(ma3( 1,-1, 1)) = 0
                xCoeff(ma3(-1, 0, 1)) = 0
                xCoeff(ma3( 0, 0, 1)) = 0
                xCoeff(ma3( 1, 0, 1)) = 0
                xCoeff(ma3(-1, 1, 1)) = 0
                xCoeff(ma3( 0, 1, 1)) = 0
                xCoeff(ma3( 1, 1, 1)) = 0
               ! Operator y = uy
                yCoeff(ma3(-1,-1,-1)) = 0
                yCoeff(ma3( 0,-1,-1)) = 0
                yCoeff(ma3( 1,-1,-1)) = 0
                yCoeff(ma3(-1, 0,-1)) = 0
                yCoeff(ma3( 0, 0,-1)) = 0
                yCoeff(ma3( 1, 0,-1)) = 0
                yCoeff(ma3(-1, 1,-1)) = 0
                yCoeff(ma3( 0, 1,-1)) = 0
                yCoeff(ma3( 1, 1,-1)) = 0
                yCoeff(ma3(-1,-1, 0)) = 0
                yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma3( 1,-1, 0)) = 0
                yCoeff(ma3(-1, 0, 0)) = 0
                yCoeff(ma3( 0, 0, 0)) = 0
                yCoeff(ma3( 1, 0, 0)) = 0
                yCoeff(ma3(-1, 1, 0)) = 0
                yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma3( 1, 1, 0)) = 0
                yCoeff(ma3(-1,-1, 1)) = 0
                yCoeff(ma3( 0,-1, 1)) = 0
                yCoeff(ma3( 1,-1, 1)) = 0
                yCoeff(ma3(-1, 0, 1)) = 0
                yCoeff(ma3( 0, 0, 1)) = 0
                yCoeff(ma3( 1, 0, 1)) = 0
                yCoeff(ma3(-1, 1, 1)) = 0
                yCoeff(ma3( 0, 1, 1)) = 0
                yCoeff(ma3( 1, 1, 1)) = 0
                ! Operator z = uz
                 zCoeff(ma3(-1,-1,-1)) = 0
                 zCoeff(ma3( 0,-1,-1)) = 0
                 zCoeff(ma3( 1,-1,-1)) = 0
                 zCoeff(ma3(-1, 0,-1)) = 0
                 zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                 zCoeff(ma3( 1, 0,-1)) = 0
                 zCoeff(ma3(-1, 1,-1)) = 0
                 zCoeff(ma3( 0, 1,-1)) = 0
                 zCoeff(ma3( 1, 1,-1)) = 0
                 zCoeff(ma3(-1,-1, 0)) = 0
                 zCoeff(ma3( 0,-1, 0)) = 0
                 zCoeff(ma3( 1,-1, 0)) = 0
                 zCoeff(ma3(-1, 0, 0)) = 0
                 zCoeff(ma3( 0, 0, 0)) = 0
                 zCoeff(ma3( 1, 0, 0)) = 0
                 zCoeff(ma3(-1, 1, 0)) = 0
                 zCoeff(ma3( 0, 1, 0)) = 0
                 zCoeff(ma3( 1, 1, 0)) = 0
                 zCoeff(ma3(-1,-1, 1)) = 0
                 zCoeff(ma3( 0,-1, 1)) = 0
                 zCoeff(ma3( 1,-1, 1)) = 0
                 zCoeff(ma3(-1, 0, 1)) = 0
                 zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                 zCoeff(ma3( 1, 0, 1)) = 0
                 zCoeff(ma3(-1, 1, 1)) = 0
                 zCoeff(ma3( 0, 1, 1)) = 0
                 zCoeff(ma3( 1, 1, 1)) = 0
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
               ! Operator laplacian = uxx+uyy+uzz
                lapCoeff(ma3(-1,-1,-1)) = 0
                lapCoeff(ma3( 0,-1,-1)) = 0
                lapCoeff(ma3( 1,-1,-1)) = 0
                lapCoeff(ma3(-1, 0,-1)) = 0
                lapCoeff(ma3( 0, 0,-1)) = 1./dx(2)**2
                lapCoeff(ma3( 1, 0,-1)) = 0
                lapCoeff(ma3(-1, 1,-1)) = 0
                lapCoeff(ma3( 0, 1,-1)) = 0
                lapCoeff(ma3( 1, 1,-1)) = 0
                lapCoeff(ma3(-1,-1, 0)) = 0
                lapCoeff(ma3( 0,-1, 0)) = 1./dx(1)**2
                lapCoeff(ma3( 1,-1, 0)) = 0
                lapCoeff(ma3(-1, 0, 0)) = 1./dx(0)**2
                lapCoeff(ma3( 0, 0, 0)) = -2./dx(0)**2-2./dx(1)**2-
     & 2./dx(2)**2
                lapCoeff(ma3( 1, 0, 0)) = 1./dx(0)**2
                lapCoeff(ma3(-1, 1, 0)) = 0
                lapCoeff(ma3( 0, 1, 0)) = 1./dx(1)**2
                lapCoeff(ma3( 1, 1, 0)) = 0
                lapCoeff(ma3(-1,-1, 1)) = 0
                lapCoeff(ma3( 0,-1, 1)) = 0
                lapCoeff(ma3( 1,-1, 1)) = 0
                lapCoeff(ma3(-1, 0, 1)) = 0
                lapCoeff(ma3( 0, 0, 1)) = 1./dx(2)**2
                lapCoeff(ma3( 1, 0, 1)) = 0
                lapCoeff(ma3(-1, 1, 1)) = 0
                lapCoeff(ma3( 0, 1, 1)) = 0
                lapCoeff(ma3( 1, 1, 1)) = 0
             ! Equations on the ghost point:
             do m=0,ndc-1
              coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
             end do
             ! Equations on the boundary:
             do m=0,ndc-1
              coeff(m,i1,i2,i3)=0.  ! init all elements to zero
             end do
             beta = implicitFactor*nu*dt
             !! beta = 0. ! TEST
              ! ************************ THREE DIMENSIONS ****************************
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled BC equations for u and v and w 
               ! -------------Coefficients in the the ghost point equation ----------
               do n=0,nd-1
                 ! equation n:  (equation numbers and classify  are set in these calls)
                   classify(i1m,i2m,i3m,eqnu+n)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,0)-an(n)*
     & an(0))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(1,2)*an(n)+delta(n,1)*an(2)+delta(n,2)*an(1)-2.*an(n)*
     & an(1)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,1)-an(n)*an(1))
     & *(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)+((delta(2,0)*an(
     & n)+delta(n,2)*an(0)+delta(n,0)*an(2)-2.*an(n)*an(2)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(2,1)*an(n)+delta(n,2)*an(1)+
     & delta(n,1)*an(2)-2.*an(n)*an(2)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(2,2)*an(n)+delta(n,2)*an(2)+delta(n,2)*an(2)-2.*an(n)*
     & an(2)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,2)-an(n)*an(2))
     & *(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,
     & i3m)=(cmpw+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
                ! We decouple the coupled velocity components: Only add coefficients of u 
                n=0
                  classify(i1m,i2m,i3m,eqnu+n)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,0)-an(n)*
     & an(0))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                  ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                   equationNumber(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
                ! We decouple the coupled velocity components: Only add components of v 
                n=1
                  classify(i1m,i2m,i3m,eqnu+n)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)=((
     & delta(1,0)*an(n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(
     & 1)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*
     & an(1)+delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(1,2)*an(n)+delta(n,1)*an(2)+delta(n,2)*an(1)-2.*
     & an(n)*an(1)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,1)-an(n)*
     & an(1))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                  ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                   equationNumber(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffw )then
                ! We decouple the coupled velocity components: Only add components of w
                n=2
                  classify(i1m,i2m,i3m,eqnu+n)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)=((
     & delta(2,0)*an(n)+delta(n,2)*an(0)+delta(n,0)*an(2)-2.*an(n)*an(
     & 2)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(2,1)*an(n)+delta(n,2)*
     & an(1)+delta(n,1)*an(2)-2.*an(n)*an(2)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(2,2)*an(n)+delta(n,2)*an(2)+delta(n,2)*an(2)-2.*
     & an(n)*an(2)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,2)-an(n)*
     & an(2))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                  ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                   equationNumber(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,
     & i3m)=(cmpw+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              end if
              ! ------------- Coefficients on the boundary ----------------
              ! evaluate the coeff operators 
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled equations for u and v  
               ! u equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpv,eqnu),i1,i2,i3)+((-beta*(delta(0,1)-(1.-alpha)*
     & an(0)*an(1)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpw,eqnu),i1,i2,i3)+((-beta*(delta(0,2)-(1.-alpha)*
     & an(0)*an(2)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
               ! v equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpu,eqnv),i1,i2,i3)+((-beta*(delta(1,0)-(1.-alpha)*
     & an(1)*an(0)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpw,eqnv),i1,i2,i3)+((-beta*(delta(1,2)-(1.-alpha)*
     & an(1)*an(2)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
               ! w equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(2,2)-(1.-alpha)*an(2)*an(2)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnw),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpu,eqnw),i1,i2,i3)+((-beta*(delta(2,0)-(1.-alpha)*
     & an(2)*an(0)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpw,eqnw),i1,i2,i3)+((-beta*(delta(2,1)-(1.-alpha)*
     & an(2)*an(1)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               ! We decouple the coupled velocity components: Only add coefficients of u 
               n=0
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
               ! We decouple the coupled velocity components: Only add components of v 
               n=1
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffw )then
               ! We decouple the coupled velocity components: Only add components of w
               n=2
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(2,2)-(1.-alpha)*an(2)*an(2)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent AMP NO-SLIP WALLS  -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.noSlipWall .or. bc(1,axisp1)
     & .eq.noSlipWall .or. bc(0,axisp2).eq.noSlipWall .or. bc(1,
     & axisp2).eq.noSlipWall )then
             write(*,'("insImpINS: ERROR: two AMP no-slip walls meet 
     & at a corner -- not implemented -- fix me")')
             stop 9099
           end if
           ! write(*,'(" Finished filling in implicit AMP velocity BCs -- stop for now")')
           ! stop 1004
          end if
         else if( bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
           do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
            coeff(m,i1,i2,i3)=0.
           end do
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
         !   opEvalJacobianDerivatives(aj,1)
           ! evaluate the coeff operators 
             ! Operator identity 
              iCoeff(ma3(-1,-1,-1)) = 0
              iCoeff(ma3( 0,-1,-1)) = 0
              iCoeff(ma3( 1,-1,-1)) = 0
              iCoeff(ma3(-1, 0,-1)) = 0
              iCoeff(ma3( 0, 0,-1)) = 0
              iCoeff(ma3( 1, 0,-1)) = 0
              iCoeff(ma3(-1, 1,-1)) = 0
              iCoeff(ma3( 0, 1,-1)) = 0
              iCoeff(ma3( 1, 1,-1)) = 0
              iCoeff(ma3(-1,-1, 0)) = 0
              iCoeff(ma3( 0,-1, 0)) = 0
              iCoeff(ma3( 1,-1, 0)) = 0
              iCoeff(ma3(-1, 0, 0)) = 0
              iCoeff(ma3( 0, 0, 0)) = 1.
              iCoeff(ma3( 1, 0, 0)) = 0
              iCoeff(ma3(-1, 1, 0)) = 0
              iCoeff(ma3( 0, 1, 0)) = 0
              iCoeff(ma3( 1, 1, 0)) = 0
              iCoeff(ma3(-1,-1, 1)) = 0
              iCoeff(ma3( 0,-1, 1)) = 0
              iCoeff(ma3( 1,-1, 1)) = 0
              iCoeff(ma3(-1, 0, 1)) = 0
              iCoeff(ma3( 0, 0, 1)) = 0
              iCoeff(ma3( 1, 0, 1)) = 0
              iCoeff(ma3(-1, 1, 1)) = 0
              iCoeff(ma3( 0, 1, 1)) = 0
              iCoeff(ma3( 1, 1, 1)) = 0
         !   getCoeff(x, xCoeff,aj)
         !   getCoeff(y, yCoeff,aj)
         !    getCoeff(z, zCoeff,aj)
           do n=0,ndu-1
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma3(m1,m2,m3)))
             end do
             end do
             end do
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.outflow )then
          ! NOTE: outflowOption==0 is done below (extrapolation)
          if( outflowOption.eq.1 )then
           ! Neumann BC at outflow if outflowOption==1
            ! write(*,'("insImpINS: fill outflow BC into matrix: Neumann BC")')
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = ux
                  xCoeff(ma3(-1,-1,-1)) = 0
                  xCoeff(ma3( 0,-1,-1)) = 0
                  xCoeff(ma3( 1,-1,-1)) = 0
                  xCoeff(ma3(-1, 0,-1)) = 0
                  xCoeff(ma3( 0, 0,-1)) = 0
                  xCoeff(ma3( 1, 0,-1)) = 0
                  xCoeff(ma3(-1, 1,-1)) = 0
                  xCoeff(ma3( 0, 1,-1)) = 0
                  xCoeff(ma3( 1, 1,-1)) = 0
                  xCoeff(ma3(-1,-1, 0)) = 0
                  xCoeff(ma3( 0,-1, 0)) = 0
                  xCoeff(ma3( 1,-1, 0)) = 0
                  xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                  xCoeff(ma3( 0, 0, 0)) = 0
                  xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                  xCoeff(ma3(-1, 1, 0)) = 0
                  xCoeff(ma3( 0, 1, 0)) = 0
                  xCoeff(ma3( 1, 1, 0)) = 0
                  xCoeff(ma3(-1,-1, 1)) = 0
                  xCoeff(ma3( 0,-1, 1)) = 0
                  xCoeff(ma3( 1,-1, 1)) = 0
                  xCoeff(ma3(-1, 0, 1)) = 0
                  xCoeff(ma3( 0, 0, 1)) = 0
                  xCoeff(ma3( 1, 0, 1)) = 0
                  xCoeff(ma3(-1, 1, 1)) = 0
                  xCoeff(ma3( 0, 1, 1)) = 0
                  xCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator y = uy
                  yCoeff(ma3(-1,-1,-1)) = 0
                  yCoeff(ma3( 0,-1,-1)) = 0
                  yCoeff(ma3( 1,-1,-1)) = 0
                  yCoeff(ma3(-1, 0,-1)) = 0
                  yCoeff(ma3( 0, 0,-1)) = 0
                  yCoeff(ma3( 1, 0,-1)) = 0
                  yCoeff(ma3(-1, 1,-1)) = 0
                  yCoeff(ma3( 0, 1,-1)) = 0
                  yCoeff(ma3( 1, 1,-1)) = 0
                  yCoeff(ma3(-1,-1, 0)) = 0
                  yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                  yCoeff(ma3( 1,-1, 0)) = 0
                  yCoeff(ma3(-1, 0, 0)) = 0
                  yCoeff(ma3( 0, 0, 0)) = 0
                  yCoeff(ma3( 1, 0, 0)) = 0
                  yCoeff(ma3(-1, 1, 0)) = 0
                  yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                  yCoeff(ma3( 1, 1, 0)) = 0
                  yCoeff(ma3(-1,-1, 1)) = 0
                  yCoeff(ma3( 0,-1, 1)) = 0
                  yCoeff(ma3( 1,-1, 1)) = 0
                  yCoeff(ma3(-1, 0, 1)) = 0
                  yCoeff(ma3( 0, 0, 1)) = 0
                  yCoeff(ma3( 1, 0, 1)) = 0
                  yCoeff(ma3(-1, 1, 1)) = 0
                  yCoeff(ma3( 0, 1, 1)) = 0
                  yCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator identity 
                  iCoeff(ma3(-1,-1,-1)) = 0
                  iCoeff(ma3( 0,-1,-1)) = 0
                  iCoeff(ma3( 1,-1,-1)) = 0
                  iCoeff(ma3(-1, 0,-1)) = 0
                  iCoeff(ma3( 0, 0,-1)) = 0
                  iCoeff(ma3( 1, 0,-1)) = 0
                  iCoeff(ma3(-1, 1,-1)) = 0
                  iCoeff(ma3( 0, 1,-1)) = 0
                  iCoeff(ma3( 1, 1,-1)) = 0
                  iCoeff(ma3(-1,-1, 0)) = 0
                  iCoeff(ma3( 0,-1, 0)) = 0
                  iCoeff(ma3( 1,-1, 0)) = 0
                  iCoeff(ma3(-1, 0, 0)) = 0
                  iCoeff(ma3( 0, 0, 0)) = 1.
                  iCoeff(ma3( 1, 0, 0)) = 0
                  iCoeff(ma3(-1, 1, 0)) = 0
                  iCoeff(ma3( 0, 1, 0)) = 0
                  iCoeff(ma3( 1, 1, 0)) = 0
                  iCoeff(ma3(-1,-1, 1)) = 0
                  iCoeff(ma3( 0,-1, 1)) = 0
                  iCoeff(ma3( 1,-1, 1)) = 0
                  iCoeff(ma3(-1, 0, 1)) = 0
                  iCoeff(ma3( 0, 0, 1)) = 0
                  iCoeff(ma3( 1, 0, 1)) = 0
                  iCoeff(ma3(-1, 1, 1)) = 0
                  iCoeff(ma3( 0, 1, 1)) = 0
                  iCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator z = uz
                   zCoeff(ma3(-1,-1,-1)) = 0
                   zCoeff(ma3( 0,-1,-1)) = 0
                   zCoeff(ma3( 1,-1,-1)) = 0
                   zCoeff(ma3(-1, 0,-1)) = 0
                   zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                   zCoeff(ma3( 1, 0,-1)) = 0
                   zCoeff(ma3(-1, 1,-1)) = 0
                   zCoeff(ma3( 0, 1,-1)) = 0
                   zCoeff(ma3( 1, 1,-1)) = 0
                   zCoeff(ma3(-1,-1, 0)) = 0
                   zCoeff(ma3( 0,-1, 0)) = 0
                   zCoeff(ma3( 1,-1, 0)) = 0
                   zCoeff(ma3(-1, 0, 0)) = 0
                   zCoeff(ma3( 0, 0, 0)) = 0
                   zCoeff(ma3( 1, 0, 0)) = 0
                   zCoeff(ma3(-1, 1, 0)) = 0
                   zCoeff(ma3( 0, 1, 0)) = 0
                   zCoeff(ma3( 1, 1, 0)) = 0
                   zCoeff(ma3(-1,-1, 1)) = 0
                   zCoeff(ma3( 0,-1, 1)) = 0
                   zCoeff(ma3( 1,-1, 1)) = 0
                   zCoeff(ma3(-1, 0, 1)) = 0
                   zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                   zCoeff(ma3( 1, 0, 1)) = 0
                   zCoeff(ma3(-1, 1, 1)) = 0
                   zCoeff(ma3( 0, 1, 1)) = 0
                   zCoeff(ma3( 1, 1, 1)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma3(m1,m2,m3)
                mm=mce3(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
          else if( outflowOption.ne.0 )then
            write(*,'("insImpINS: fill outflow BC into matrix: ERROR: 
     & outflowOption=",i6)') outflowOption
          end if
         else if( bc0.eq.neumannBoundaryCondition )then
           ! Neumann BC (used by slipWall and scalar systems)
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = ux
                  xCoeff(ma3(-1,-1,-1)) = 0
                  xCoeff(ma3( 0,-1,-1)) = 0
                  xCoeff(ma3( 1,-1,-1)) = 0
                  xCoeff(ma3(-1, 0,-1)) = 0
                  xCoeff(ma3( 0, 0,-1)) = 0
                  xCoeff(ma3( 1, 0,-1)) = 0
                  xCoeff(ma3(-1, 1,-1)) = 0
                  xCoeff(ma3( 0, 1,-1)) = 0
                  xCoeff(ma3( 1, 1,-1)) = 0
                  xCoeff(ma3(-1,-1, 0)) = 0
                  xCoeff(ma3( 0,-1, 0)) = 0
                  xCoeff(ma3( 1,-1, 0)) = 0
                  xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                  xCoeff(ma3( 0, 0, 0)) = 0
                  xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                  xCoeff(ma3(-1, 1, 0)) = 0
                  xCoeff(ma3( 0, 1, 0)) = 0
                  xCoeff(ma3( 1, 1, 0)) = 0
                  xCoeff(ma3(-1,-1, 1)) = 0
                  xCoeff(ma3( 0,-1, 1)) = 0
                  xCoeff(ma3( 1,-1, 1)) = 0
                  xCoeff(ma3(-1, 0, 1)) = 0
                  xCoeff(ma3( 0, 0, 1)) = 0
                  xCoeff(ma3( 1, 0, 1)) = 0
                  xCoeff(ma3(-1, 1, 1)) = 0
                  xCoeff(ma3( 0, 1, 1)) = 0
                  xCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator y = uy
                  yCoeff(ma3(-1,-1,-1)) = 0
                  yCoeff(ma3( 0,-1,-1)) = 0
                  yCoeff(ma3( 1,-1,-1)) = 0
                  yCoeff(ma3(-1, 0,-1)) = 0
                  yCoeff(ma3( 0, 0,-1)) = 0
                  yCoeff(ma3( 1, 0,-1)) = 0
                  yCoeff(ma3(-1, 1,-1)) = 0
                  yCoeff(ma3( 0, 1,-1)) = 0
                  yCoeff(ma3( 1, 1,-1)) = 0
                  yCoeff(ma3(-1,-1, 0)) = 0
                  yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                  yCoeff(ma3( 1,-1, 0)) = 0
                  yCoeff(ma3(-1, 0, 0)) = 0
                  yCoeff(ma3( 0, 0, 0)) = 0
                  yCoeff(ma3( 1, 0, 0)) = 0
                  yCoeff(ma3(-1, 1, 0)) = 0
                  yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                  yCoeff(ma3( 1, 1, 0)) = 0
                  yCoeff(ma3(-1,-1, 1)) = 0
                  yCoeff(ma3( 0,-1, 1)) = 0
                  yCoeff(ma3( 1,-1, 1)) = 0
                  yCoeff(ma3(-1, 0, 1)) = 0
                  yCoeff(ma3( 0, 0, 1)) = 0
                  yCoeff(ma3( 1, 0, 1)) = 0
                  yCoeff(ma3(-1, 1, 1)) = 0
                  yCoeff(ma3( 0, 1, 1)) = 0
                  yCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator identity 
                  iCoeff(ma3(-1,-1,-1)) = 0
                  iCoeff(ma3( 0,-1,-1)) = 0
                  iCoeff(ma3( 1,-1,-1)) = 0
                  iCoeff(ma3(-1, 0,-1)) = 0
                  iCoeff(ma3( 0, 0,-1)) = 0
                  iCoeff(ma3( 1, 0,-1)) = 0
                  iCoeff(ma3(-1, 1,-1)) = 0
                  iCoeff(ma3( 0, 1,-1)) = 0
                  iCoeff(ma3( 1, 1,-1)) = 0
                  iCoeff(ma3(-1,-1, 0)) = 0
                  iCoeff(ma3( 0,-1, 0)) = 0
                  iCoeff(ma3( 1,-1, 0)) = 0
                  iCoeff(ma3(-1, 0, 0)) = 0
                  iCoeff(ma3( 0, 0, 0)) = 1.
                  iCoeff(ma3( 1, 0, 0)) = 0
                  iCoeff(ma3(-1, 1, 0)) = 0
                  iCoeff(ma3( 0, 1, 0)) = 0
                  iCoeff(ma3( 1, 1, 0)) = 0
                  iCoeff(ma3(-1,-1, 1)) = 0
                  iCoeff(ma3( 0,-1, 1)) = 0
                  iCoeff(ma3( 1,-1, 1)) = 0
                  iCoeff(ma3(-1, 0, 1)) = 0
                  iCoeff(ma3( 0, 0, 1)) = 0
                  iCoeff(ma3( 1, 0, 1)) = 0
                  iCoeff(ma3(-1, 1, 1)) = 0
                  iCoeff(ma3( 0, 1, 1)) = 0
                  iCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator z = uz
                   zCoeff(ma3(-1,-1,-1)) = 0
                   zCoeff(ma3( 0,-1,-1)) = 0
                   zCoeff(ma3( 1,-1,-1)) = 0
                   zCoeff(ma3(-1, 0,-1)) = 0
                   zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                   zCoeff(ma3( 1, 0,-1)) = 0
                   zCoeff(ma3(-1, 1,-1)) = 0
                   zCoeff(ma3( 0, 1,-1)) = 0
                   zCoeff(ma3( 1, 1,-1)) = 0
                   zCoeff(ma3(-1,-1, 0)) = 0
                   zCoeff(ma3( 0,-1, 0)) = 0
                   zCoeff(ma3( 1,-1, 0)) = 0
                   zCoeff(ma3(-1, 0, 0)) = 0
                   zCoeff(ma3( 0, 0, 0)) = 0
                   zCoeff(ma3( 1, 0, 0)) = 0
                   zCoeff(ma3(-1, 1, 0)) = 0
                   zCoeff(ma3( 0, 1, 0)) = 0
                   zCoeff(ma3( 1, 1, 0)) = 0
                   zCoeff(ma3(-1,-1, 1)) = 0
                   zCoeff(ma3( 0,-1, 1)) = 0
                   zCoeff(ma3( 1,-1, 1)) = 0
                   zCoeff(ma3(-1, 0, 1)) = 0
                   zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                   zCoeff(ma3( 1, 0, 1)) = 0
                   zCoeff(ma3(-1, 1, 1)) = 0
                   zCoeff(ma3( 0, 1, 1)) = 0
                   zCoeff(ma3( 1, 1, 1)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma3(m1,m2,m3)
                mm=mce3(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
         else if( bc0.eq.freeSurfaceBoundaryCondition )then
           ! **FREE SURFACE BCs *** 
           ! NEW way: proper free-surface conditions *wdh* Sept 30, 2017
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
              ! write(*,'(" IMP: FREE SURFACE i1,i2=",2i2," ndu=",i4," normal=",2e10.2)') i1,i2,ndu,an(0),an(1)
              ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
              ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') CSF(0,0,0),CSF(0,0,1),CSF(0,1,0),CSF(0,1,1)
              ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') CSF(1,0,0),CSF(1,0,1),CSF(1,1,0),CSF(1,1,1)
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = ux
                 xCoeff(ma3(-1,-1,-1)) = 0
                 xCoeff(ma3( 0,-1,-1)) = 0
                 xCoeff(ma3( 1,-1,-1)) = 0
                 xCoeff(ma3(-1, 0,-1)) = 0
                 xCoeff(ma3( 0, 0,-1)) = 0
                 xCoeff(ma3( 1, 0,-1)) = 0
                 xCoeff(ma3(-1, 1,-1)) = 0
                 xCoeff(ma3( 0, 1,-1)) = 0
                 xCoeff(ma3( 1, 1,-1)) = 0
                 xCoeff(ma3(-1,-1, 0)) = 0
                 xCoeff(ma3( 0,-1, 0)) = 0
                 xCoeff(ma3( 1,-1, 0)) = 0
                 xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                 xCoeff(ma3( 0, 0, 0)) = 0
                 xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                 xCoeff(ma3(-1, 1, 0)) = 0
                 xCoeff(ma3( 0, 1, 0)) = 0
                 xCoeff(ma3( 1, 1, 0)) = 0
                 xCoeff(ma3(-1,-1, 1)) = 0
                 xCoeff(ma3( 0,-1, 1)) = 0
                 xCoeff(ma3( 1,-1, 1)) = 0
                 xCoeff(ma3(-1, 0, 1)) = 0
                 xCoeff(ma3( 0, 0, 1)) = 0
                 xCoeff(ma3( 1, 0, 1)) = 0
                 xCoeff(ma3(-1, 1, 1)) = 0
                 xCoeff(ma3( 0, 1, 1)) = 0
                 xCoeff(ma3( 1, 1, 1)) = 0
                ! Operator y = uy
                 yCoeff(ma3(-1,-1,-1)) = 0
                 yCoeff(ma3( 0,-1,-1)) = 0
                 yCoeff(ma3( 1,-1,-1)) = 0
                 yCoeff(ma3(-1, 0,-1)) = 0
                 yCoeff(ma3( 0, 0,-1)) = 0
                 yCoeff(ma3( 1, 0,-1)) = 0
                 yCoeff(ma3(-1, 1,-1)) = 0
                 yCoeff(ma3( 0, 1,-1)) = 0
                 yCoeff(ma3( 1, 1,-1)) = 0
                 yCoeff(ma3(-1,-1, 0)) = 0
                 yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                 yCoeff(ma3( 1,-1, 0)) = 0
                 yCoeff(ma3(-1, 0, 0)) = 0
                 yCoeff(ma3( 0, 0, 0)) = 0
                 yCoeff(ma3( 1, 0, 0)) = 0
                 yCoeff(ma3(-1, 1, 0)) = 0
                 yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                 yCoeff(ma3( 1, 1, 0)) = 0
                 yCoeff(ma3(-1,-1, 1)) = 0
                 yCoeff(ma3( 0,-1, 1)) = 0
                 yCoeff(ma3( 1,-1, 1)) = 0
                 yCoeff(ma3(-1, 0, 1)) = 0
                 yCoeff(ma3( 0, 0, 1)) = 0
                 yCoeff(ma3( 1, 0, 1)) = 0
                 yCoeff(ma3(-1, 1, 1)) = 0
                 yCoeff(ma3( 0, 1, 1)) = 0
                 yCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator z = uz
                  zCoeff(ma3(-1,-1,-1)) = 0
                  zCoeff(ma3( 0,-1,-1)) = 0
                  zCoeff(ma3( 1,-1,-1)) = 0
                  zCoeff(ma3(-1, 0,-1)) = 0
                  zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                  zCoeff(ma3( 1, 0,-1)) = 0
                  zCoeff(ma3(-1, 1,-1)) = 0
                  zCoeff(ma3( 0, 1,-1)) = 0
                  zCoeff(ma3( 1, 1,-1)) = 0
                  zCoeff(ma3(-1,-1, 0)) = 0
                  zCoeff(ma3( 0,-1, 0)) = 0
                  zCoeff(ma3( 1,-1, 0)) = 0
                  zCoeff(ma3(-1, 0, 0)) = 0
                  zCoeff(ma3( 0, 0, 0)) = 0
                  zCoeff(ma3( 1, 0, 0)) = 0
                  zCoeff(ma3(-1, 1, 0)) = 0
                  zCoeff(ma3( 0, 1, 0)) = 0
                  zCoeff(ma3( 1, 1, 0)) = 0
                  zCoeff(ma3(-1,-1, 1)) = 0
                  zCoeff(ma3( 0,-1, 1)) = 0
                  zCoeff(ma3( 1,-1, 1)) = 0
                  zCoeff(ma3(-1, 0, 1)) = 0
                  zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                  zCoeff(ma3( 1, 0, 1)) = 0
                  zCoeff(ma3(-1, 1, 1)) = 0
                  zCoeff(ma3( 0, 1, 1)) = 0
                  zCoeff(ma3( 1, 1, 1)) = 0
              do m=0,ndc-1
               coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
              end do
               ! ---  3D ---
               if( fillCoefficientsScalarSystem.eq.0 )then
                ! Fill in the coupled equations for u, v and w
                ! write(*,'("(i1,i2,i3) = ",3i3)') i1,i2,i3
                do n=0,nd-1
                  ! equation n:   (equation numbers and classify  are set in these calls)
                  ! write(*,'("n = ",1i3)') n
                  ! write(*,'("    : cn00,cn01,cn02",3e10.2)') CSF(n,0,0),CSF(n,0,1),CSF(n,0,2)
                  ! write(*,'("    : cn10,cn11,cn12",3e10.2)') CSF(n,1,0),CSF(n,1,1),CSF(n,1,2)
                  ! write(*,'("    : cn20,cn21,cn22",3e10.2)') CSF(n,2,0),CSF(n,2,1),CSF(n,2,2)
                    classify(i1m,i2m,i3m,eqnu+n)=ghost1
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                     equationNumber(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(1,2)*an(n)+delta(n,1)*an(2)+delta(n,2)*an(1)-2.*an(n)*
     & an(1)*an(2))*zCoeff(ma3(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                     equationNumber(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)+((delta(2,0)*an(
     & n)+delta(n,2)*an(0)+delta(n,0)*an(2)-2.*an(n)*an(2)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(2,1)*an(n)+delta(n,2)*an(1)+
     & delta(n,1)*an(2)-2.*an(n)*an(2)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(2,2)*an(n)+delta(n,2)*an(2)+delta(n,2)*an(2)-2.*an(n)*
     & an(2)*an(2))*zCoeff(ma3(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                     equationNumber(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,
     & i3m)=(cmpw+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffU )
     & then
                 ! We decouple the coupled velocity components: Only add coefficients of u 
                 n=0
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffv )
     & then
                 ! We decouple the coupled velocity components: Only add components of v 
                 n=1
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffw )
     & then
                 ! We decouple the coupled velocity components: Only add components of w
                 n=2
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent free surface BCs -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.freeSurfaceBoundaryCondition .or. bc(1,
     & axisp1).eq.freeSurfaceBoundaryCondition .or. bc(0,axisp2)
     & .eq.freeSurfaceBoundaryCondition .or. bc(1,axisp2)
     & .eq.freeSurfaceBoundaryCondition )then
             write(*,'("insImpINS: ERROR: two free surfaces meet at a 
     & corner -- not implemented -- fix me")')
             stop 9099
           end if
         else if( bc0.eq.slipWall )then
           ! SLIP-WALL
           ! NOTE: Here we assume the matrix already includes the interior equations on the boundary 
           ! NOTE: what about corners ???
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
            write(*,'(" insImpINS: slipWall BC not finished for scalar 
     & systems")')
            stop 8130
          end if
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.u"  -->  nDot(mc3(m1,m2,m3,c)) = iCoeff(m1,m2,m3)*an(c-cmpu)
           !nDot=0
           !nDot(mc3(0,0,0,cmpu))=an(0)
           !nDot(mc3(0,0,0,cmpv))=an(1)
           !nDot(mc3(0,0,0,cmpw))=an(2)
           ! Form the matrix for "n.Lu"
           nDotL(0)=an(0)*coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpu,eqnw),i1,i2,i3)
           nDotL(1)=an(0)*coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpv,eqnw),i1,i2,i3)
           nDotL(2)=an(0)*coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpw,eqnw),i1,i2,i3)
           ! form the matrix for  Lu + [ (n.u) - (n.(Lu)) ] n 
           !  eqnu:  (n1*u1+n2*u2+n3*u3)*n1 + L1(u) - nDotL*n1    
           !  eqnv:  (n1*u1+n2*u2+n3*u3)*n2 + L2(u) - nDotL*n2
           !  eqnw:  (n1*u1+n2*u2+n3*u3)*n3 + L3(u) - nDotL*n3
           !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
           do e=eqnu,eqnu+nd-1
           do c=cmpu,cmpu+nd-1
            coeff(mce3(m1,m2,m3,c,e),i1,i2,i3)= coeff(mce3(m1,m2,m3,c,
     & e),i1,i2,i3) + an(e-eqnu)*(iCoeff(ma3(m1,m2,m3))*an(c-cmpu)-
     & nDotL(c-cmpu))
           end do
           end do
           end do
           end do
           end do
          ! fill ghost pt eqn's with a vector symmetry condition:
           ! write(*,'(" VS: i1,i2=",2i2," normal=",2f5.2)') i1,i2,an(0),an(1)
           i1m=i1-is1  ! ghost point
           i2m=i2-is2
           i3m=i3-is3
           do m=0,ndc-1
            coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
           end do
           mv(0)=0
           mv(1)=0
           mv(2)=0
           do e=eqnu,eqnu+nd-1
            c=cmpu+e-eqnu
            mv(axis)=2*side-1
            mm=mce3(mv(0),mv(1),mv(2),c,e)  ! matrix index for ghost pt
            coeff(mm,i1m,i2m,i3m)=1.  ! coeff of ghost point
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            mv(axis)=-(2*side-1)
            mm=mce3(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
            coeff(mm,i1m,i2m,i3m)=-1.
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            ! now add on the term: 2*(n.u(1))n 
            do c=cmpu,cmpu+nd-1
             mm=mce3(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
             ! write(*,'(" VS: mm,i1,i2,e,c=",5i2," n,n=",2f5.2)') mm,i1,i2,e,c,an(c-cmpu),an(e-eqnu)
             coeff(mm,i1m,i2m,i3m)=coeff(mm,i1m,i2m,i3m) + 2.*an(c-
     & cmpu)*an(e-eqnu)
              equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            end do
             classify(i1m,i2m,i3m,e)=ghost1
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.inflowWithPandTV )then
           ! ------------------------------------------------
           ! ---- pressure and tangential velocity given ----
           ! ------------------------------------------------
          write(*,'("insImpINS: fill in BC pressure and tangential 
     & velocity ** check me** ")')
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           write(*,'(" fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
           ! --- fill coefficients for scalar systems ---
           ! This only works if the boundary face is on a plane x=constant, y=constant or z=constant 
           ! Added May 13, 2017 *wdh*
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
            ! -- The grid face should be in a coordinate direction,
            !   normalAxis = 0,1, or 2 indicates this direction
            if( abs(abs(an(0))-1.) .lt. normalTol )then
             normalAxis=0
            else if( abs(abs(an(1))-1.) .lt. normalTol )then
             normalAxis=1
            else if(  abs(abs(an(2))-1.) .lt. normalTol )then
             normalAxis=2
            else
              write(*,'(" insImpINS: ERROR: inflowWithPandTV, scalar 
     & systems but normals funny")')
              write(*,'("  --> the normals should be in a coordinate 
     & direction")')
              stop 1287
            end if
            !  --- equations for u ---
            if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
              if( normalAxis.eq.0 )then
               ! boundary face is x=constant:
               !  Give u.n = 0 
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = ux
                   xCoeff(ma3(-1,-1,-1)) = 0
                   xCoeff(ma3( 0,-1,-1)) = 0
                   xCoeff(ma3( 1,-1,-1)) = 0
                   xCoeff(ma3(-1, 0,-1)) = 0
                   xCoeff(ma3( 0, 0,-1)) = 0
                   xCoeff(ma3( 1, 0,-1)) = 0
                   xCoeff(ma3(-1, 1,-1)) = 0
                   xCoeff(ma3( 0, 1,-1)) = 0
                   xCoeff(ma3( 1, 1,-1)) = 0
                   xCoeff(ma3(-1,-1, 0)) = 0
                   xCoeff(ma3( 0,-1, 0)) = 0
                   xCoeff(ma3( 1,-1, 0)) = 0
                   xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                   xCoeff(ma3( 0, 0, 0)) = 0
                   xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                   xCoeff(ma3(-1, 1, 0)) = 0
                   xCoeff(ma3( 0, 1, 0)) = 0
                   xCoeff(ma3( 1, 1, 0)) = 0
                   xCoeff(ma3(-1,-1, 1)) = 0
                   xCoeff(ma3( 0,-1, 1)) = 0
                   xCoeff(ma3( 1,-1, 1)) = 0
                   xCoeff(ma3(-1, 0, 1)) = 0
                   xCoeff(ma3( 0, 0, 1)) = 0
                   xCoeff(ma3( 1, 0, 1)) = 0
                   xCoeff(ma3(-1, 1, 1)) = 0
                   xCoeff(ma3( 0, 1, 1)) = 0
                   xCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator y = uy
                   yCoeff(ma3(-1,-1,-1)) = 0
                   yCoeff(ma3( 0,-1,-1)) = 0
                   yCoeff(ma3( 1,-1,-1)) = 0
                   yCoeff(ma3(-1, 0,-1)) = 0
                   yCoeff(ma3( 0, 0,-1)) = 0
                   yCoeff(ma3( 1, 0,-1)) = 0
                   yCoeff(ma3(-1, 1,-1)) = 0
                   yCoeff(ma3( 0, 1,-1)) = 0
                   yCoeff(ma3( 1, 1,-1)) = 0
                   yCoeff(ma3(-1,-1, 0)) = 0
                   yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                   yCoeff(ma3( 1,-1, 0)) = 0
                   yCoeff(ma3(-1, 0, 0)) = 0
                   yCoeff(ma3( 0, 0, 0)) = 0
                   yCoeff(ma3( 1, 0, 0)) = 0
                   yCoeff(ma3(-1, 1, 0)) = 0
                   yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                   yCoeff(ma3( 1, 1, 0)) = 0
                   yCoeff(ma3(-1,-1, 1)) = 0
                   yCoeff(ma3( 0,-1, 1)) = 0
                   yCoeff(ma3( 1,-1, 1)) = 0
                   yCoeff(ma3(-1, 0, 1)) = 0
                   yCoeff(ma3( 0, 0, 1)) = 0
                   yCoeff(ma3( 1, 0, 1)) = 0
                   yCoeff(ma3(-1, 1, 1)) = 0
                   yCoeff(ma3( 0, 1, 1)) = 0
                   yCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator identity 
                   iCoeff(ma3(-1,-1,-1)) = 0
                   iCoeff(ma3( 0,-1,-1)) = 0
                   iCoeff(ma3( 1,-1,-1)) = 0
                   iCoeff(ma3(-1, 0,-1)) = 0
                   iCoeff(ma3( 0, 0,-1)) = 0
                   iCoeff(ma3( 1, 0,-1)) = 0
                   iCoeff(ma3(-1, 1,-1)) = 0
                   iCoeff(ma3( 0, 1,-1)) = 0
                   iCoeff(ma3( 1, 1,-1)) = 0
                   iCoeff(ma3(-1,-1, 0)) = 0
                   iCoeff(ma3( 0,-1, 0)) = 0
                   iCoeff(ma3( 1,-1, 0)) = 0
                   iCoeff(ma3(-1, 0, 0)) = 0
                   iCoeff(ma3( 0, 0, 0)) = 1.
                   iCoeff(ma3( 1, 0, 0)) = 0
                   iCoeff(ma3(-1, 1, 0)) = 0
                   iCoeff(ma3( 0, 1, 0)) = 0
                   iCoeff(ma3( 1, 1, 0)) = 0
                   iCoeff(ma3(-1,-1, 1)) = 0
                   iCoeff(ma3( 0,-1, 1)) = 0
                   iCoeff(ma3( 1,-1, 1)) = 0
                   iCoeff(ma3(-1, 0, 1)) = 0
                   iCoeff(ma3( 0, 0, 1)) = 0
                   iCoeff(ma3( 1, 0, 1)) = 0
                   iCoeff(ma3(-1, 1, 1)) = 0
                   iCoeff(ma3( 0, 1, 1)) = 0
                   iCoeff(ma3( 1, 1, 1)) = 0
                   ! Operator z = uz
                    zCoeff(ma3(-1,-1,-1)) = 0
                    zCoeff(ma3( 0,-1,-1)) = 0
                    zCoeff(ma3( 1,-1,-1)) = 0
                    zCoeff(ma3(-1, 0,-1)) = 0
                    zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                    zCoeff(ma3( 1, 0,-1)) = 0
                    zCoeff(ma3(-1, 1,-1)) = 0
                    zCoeff(ma3( 0, 1,-1)) = 0
                    zCoeff(ma3( 1, 1,-1)) = 0
                    zCoeff(ma3(-1,-1, 0)) = 0
                    zCoeff(ma3( 0,-1, 0)) = 0
                    zCoeff(ma3( 1,-1, 0)) = 0
                    zCoeff(ma3(-1, 0, 0)) = 0
                    zCoeff(ma3( 0, 0, 0)) = 0
                    zCoeff(ma3( 1, 0, 0)) = 0
                    zCoeff(ma3(-1, 1, 0)) = 0
                    zCoeff(ma3( 0, 1, 0)) = 0
                    zCoeff(ma3( 1, 1, 0)) = 0
                    zCoeff(ma3(-1,-1, 1)) = 0
                    zCoeff(ma3( 0,-1, 1)) = 0
                    zCoeff(ma3( 1,-1, 1)) = 0
                    zCoeff(ma3(-1, 0, 1)) = 0
                    zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                    zCoeff(ma3( 1, 0, 1)) = 0
                    zCoeff(ma3(-1, 1, 1)) = 0
                    zCoeff(ma3( 0, 1, 1)) = 0
                    zCoeff(ma3( 1, 1, 1)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma3(m1,m2,m3)
                 mm=mce3(m1,m2,m3,cmpu,eqnu)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnu)=ghost1
              else
               ! boundary face is y=constant, or z=constant : give u=0 
               do m=ce(0,eqnu),ce(0,eqnu+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpu,eqnu)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnu)=extrapolation
              end if
            !  --- equations for v ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
              if( normalAxis.eq.1 )then
               ! boundary face is y=constant:
               !  Give v.n = 0 
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = ux
                   xCoeff(ma3(-1,-1,-1)) = 0
                   xCoeff(ma3( 0,-1,-1)) = 0
                   xCoeff(ma3( 1,-1,-1)) = 0
                   xCoeff(ma3(-1, 0,-1)) = 0
                   xCoeff(ma3( 0, 0,-1)) = 0
                   xCoeff(ma3( 1, 0,-1)) = 0
                   xCoeff(ma3(-1, 1,-1)) = 0
                   xCoeff(ma3( 0, 1,-1)) = 0
                   xCoeff(ma3( 1, 1,-1)) = 0
                   xCoeff(ma3(-1,-1, 0)) = 0
                   xCoeff(ma3( 0,-1, 0)) = 0
                   xCoeff(ma3( 1,-1, 0)) = 0
                   xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                   xCoeff(ma3( 0, 0, 0)) = 0
                   xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                   xCoeff(ma3(-1, 1, 0)) = 0
                   xCoeff(ma3( 0, 1, 0)) = 0
                   xCoeff(ma3( 1, 1, 0)) = 0
                   xCoeff(ma3(-1,-1, 1)) = 0
                   xCoeff(ma3( 0,-1, 1)) = 0
                   xCoeff(ma3( 1,-1, 1)) = 0
                   xCoeff(ma3(-1, 0, 1)) = 0
                   xCoeff(ma3( 0, 0, 1)) = 0
                   xCoeff(ma3( 1, 0, 1)) = 0
                   xCoeff(ma3(-1, 1, 1)) = 0
                   xCoeff(ma3( 0, 1, 1)) = 0
                   xCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator y = uy
                   yCoeff(ma3(-1,-1,-1)) = 0
                   yCoeff(ma3( 0,-1,-1)) = 0
                   yCoeff(ma3( 1,-1,-1)) = 0
                   yCoeff(ma3(-1, 0,-1)) = 0
                   yCoeff(ma3( 0, 0,-1)) = 0
                   yCoeff(ma3( 1, 0,-1)) = 0
                   yCoeff(ma3(-1, 1,-1)) = 0
                   yCoeff(ma3( 0, 1,-1)) = 0
                   yCoeff(ma3( 1, 1,-1)) = 0
                   yCoeff(ma3(-1,-1, 0)) = 0
                   yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                   yCoeff(ma3( 1,-1, 0)) = 0
                   yCoeff(ma3(-1, 0, 0)) = 0
                   yCoeff(ma3( 0, 0, 0)) = 0
                   yCoeff(ma3( 1, 0, 0)) = 0
                   yCoeff(ma3(-1, 1, 0)) = 0
                   yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                   yCoeff(ma3( 1, 1, 0)) = 0
                   yCoeff(ma3(-1,-1, 1)) = 0
                   yCoeff(ma3( 0,-1, 1)) = 0
                   yCoeff(ma3( 1,-1, 1)) = 0
                   yCoeff(ma3(-1, 0, 1)) = 0
                   yCoeff(ma3( 0, 0, 1)) = 0
                   yCoeff(ma3( 1, 0, 1)) = 0
                   yCoeff(ma3(-1, 1, 1)) = 0
                   yCoeff(ma3( 0, 1, 1)) = 0
                   yCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator identity 
                   iCoeff(ma3(-1,-1,-1)) = 0
                   iCoeff(ma3( 0,-1,-1)) = 0
                   iCoeff(ma3( 1,-1,-1)) = 0
                   iCoeff(ma3(-1, 0,-1)) = 0
                   iCoeff(ma3( 0, 0,-1)) = 0
                   iCoeff(ma3( 1, 0,-1)) = 0
                   iCoeff(ma3(-1, 1,-1)) = 0
                   iCoeff(ma3( 0, 1,-1)) = 0
                   iCoeff(ma3( 1, 1,-1)) = 0
                   iCoeff(ma3(-1,-1, 0)) = 0
                   iCoeff(ma3( 0,-1, 0)) = 0
                   iCoeff(ma3( 1,-1, 0)) = 0
                   iCoeff(ma3(-1, 0, 0)) = 0
                   iCoeff(ma3( 0, 0, 0)) = 1.
                   iCoeff(ma3( 1, 0, 0)) = 0
                   iCoeff(ma3(-1, 1, 0)) = 0
                   iCoeff(ma3( 0, 1, 0)) = 0
                   iCoeff(ma3( 1, 1, 0)) = 0
                   iCoeff(ma3(-1,-1, 1)) = 0
                   iCoeff(ma3( 0,-1, 1)) = 0
                   iCoeff(ma3( 1,-1, 1)) = 0
                   iCoeff(ma3(-1, 0, 1)) = 0
                   iCoeff(ma3( 0, 0, 1)) = 0
                   iCoeff(ma3( 1, 0, 1)) = 0
                   iCoeff(ma3(-1, 1, 1)) = 0
                   iCoeff(ma3( 0, 1, 1)) = 0
                   iCoeff(ma3( 1, 1, 1)) = 0
                   ! Operator z = uz
                    zCoeff(ma3(-1,-1,-1)) = 0
                    zCoeff(ma3( 0,-1,-1)) = 0
                    zCoeff(ma3( 1,-1,-1)) = 0
                    zCoeff(ma3(-1, 0,-1)) = 0
                    zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                    zCoeff(ma3( 1, 0,-1)) = 0
                    zCoeff(ma3(-1, 1,-1)) = 0
                    zCoeff(ma3( 0, 1,-1)) = 0
                    zCoeff(ma3( 1, 1,-1)) = 0
                    zCoeff(ma3(-1,-1, 0)) = 0
                    zCoeff(ma3( 0,-1, 0)) = 0
                    zCoeff(ma3( 1,-1, 0)) = 0
                    zCoeff(ma3(-1, 0, 0)) = 0
                    zCoeff(ma3( 0, 0, 0)) = 0
                    zCoeff(ma3( 1, 0, 0)) = 0
                    zCoeff(ma3(-1, 1, 0)) = 0
                    zCoeff(ma3( 0, 1, 0)) = 0
                    zCoeff(ma3( 1, 1, 0)) = 0
                    zCoeff(ma3(-1,-1, 1)) = 0
                    zCoeff(ma3( 0,-1, 1)) = 0
                    zCoeff(ma3( 1,-1, 1)) = 0
                    zCoeff(ma3(-1, 0, 1)) = 0
                    zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                    zCoeff(ma3( 1, 0, 1)) = 0
                    zCoeff(ma3(-1, 1, 1)) = 0
                    zCoeff(ma3( 0, 1, 1)) = 0
                    zCoeff(ma3( 1, 1, 1)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma3(m1,m2,m3)
                 mm=mce3(m1,m2,m3,cmpv,eqnv)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnv,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnv)=ghost1
              else
               ! boundary face is x=constant, or z=constant : give v=0 
               do m=ce(0,eqnv),ce(0,eqnv+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpv,eqnv)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnv)=extrapolation
              end if
            !  --- equations for w ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffW )then
              if( normalAxis.eq.2 )then
               ! boundary face is z=constant:
               !  Give w.n = 0 
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = ux
                   xCoeff(ma3(-1,-1,-1)) = 0
                   xCoeff(ma3( 0,-1,-1)) = 0
                   xCoeff(ma3( 1,-1,-1)) = 0
                   xCoeff(ma3(-1, 0,-1)) = 0
                   xCoeff(ma3( 0, 0,-1)) = 0
                   xCoeff(ma3( 1, 0,-1)) = 0
                   xCoeff(ma3(-1, 1,-1)) = 0
                   xCoeff(ma3( 0, 1,-1)) = 0
                   xCoeff(ma3( 1, 1,-1)) = 0
                   xCoeff(ma3(-1,-1, 0)) = 0
                   xCoeff(ma3( 0,-1, 0)) = 0
                   xCoeff(ma3( 1,-1, 0)) = 0
                   xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                   xCoeff(ma3( 0, 0, 0)) = 0
                   xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                   xCoeff(ma3(-1, 1, 0)) = 0
                   xCoeff(ma3( 0, 1, 0)) = 0
                   xCoeff(ma3( 1, 1, 0)) = 0
                   xCoeff(ma3(-1,-1, 1)) = 0
                   xCoeff(ma3( 0,-1, 1)) = 0
                   xCoeff(ma3( 1,-1, 1)) = 0
                   xCoeff(ma3(-1, 0, 1)) = 0
                   xCoeff(ma3( 0, 0, 1)) = 0
                   xCoeff(ma3( 1, 0, 1)) = 0
                   xCoeff(ma3(-1, 1, 1)) = 0
                   xCoeff(ma3( 0, 1, 1)) = 0
                   xCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator y = uy
                   yCoeff(ma3(-1,-1,-1)) = 0
                   yCoeff(ma3( 0,-1,-1)) = 0
                   yCoeff(ma3( 1,-1,-1)) = 0
                   yCoeff(ma3(-1, 0,-1)) = 0
                   yCoeff(ma3( 0, 0,-1)) = 0
                   yCoeff(ma3( 1, 0,-1)) = 0
                   yCoeff(ma3(-1, 1,-1)) = 0
                   yCoeff(ma3( 0, 1,-1)) = 0
                   yCoeff(ma3( 1, 1,-1)) = 0
                   yCoeff(ma3(-1,-1, 0)) = 0
                   yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                   yCoeff(ma3( 1,-1, 0)) = 0
                   yCoeff(ma3(-1, 0, 0)) = 0
                   yCoeff(ma3( 0, 0, 0)) = 0
                   yCoeff(ma3( 1, 0, 0)) = 0
                   yCoeff(ma3(-1, 1, 0)) = 0
                   yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                   yCoeff(ma3( 1, 1, 0)) = 0
                   yCoeff(ma3(-1,-1, 1)) = 0
                   yCoeff(ma3( 0,-1, 1)) = 0
                   yCoeff(ma3( 1,-1, 1)) = 0
                   yCoeff(ma3(-1, 0, 1)) = 0
                   yCoeff(ma3( 0, 0, 1)) = 0
                   yCoeff(ma3( 1, 0, 1)) = 0
                   yCoeff(ma3(-1, 1, 1)) = 0
                   yCoeff(ma3( 0, 1, 1)) = 0
                   yCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator identity 
                   iCoeff(ma3(-1,-1,-1)) = 0
                   iCoeff(ma3( 0,-1,-1)) = 0
                   iCoeff(ma3( 1,-1,-1)) = 0
                   iCoeff(ma3(-1, 0,-1)) = 0
                   iCoeff(ma3( 0, 0,-1)) = 0
                   iCoeff(ma3( 1, 0,-1)) = 0
                   iCoeff(ma3(-1, 1,-1)) = 0
                   iCoeff(ma3( 0, 1,-1)) = 0
                   iCoeff(ma3( 1, 1,-1)) = 0
                   iCoeff(ma3(-1,-1, 0)) = 0
                   iCoeff(ma3( 0,-1, 0)) = 0
                   iCoeff(ma3( 1,-1, 0)) = 0
                   iCoeff(ma3(-1, 0, 0)) = 0
                   iCoeff(ma3( 0, 0, 0)) = 1.
                   iCoeff(ma3( 1, 0, 0)) = 0
                   iCoeff(ma3(-1, 1, 0)) = 0
                   iCoeff(ma3( 0, 1, 0)) = 0
                   iCoeff(ma3( 1, 1, 0)) = 0
                   iCoeff(ma3(-1,-1, 1)) = 0
                   iCoeff(ma3( 0,-1, 1)) = 0
                   iCoeff(ma3( 1,-1, 1)) = 0
                   iCoeff(ma3(-1, 0, 1)) = 0
                   iCoeff(ma3( 0, 0, 1)) = 0
                   iCoeff(ma3( 1, 0, 1)) = 0
                   iCoeff(ma3(-1, 1, 1)) = 0
                   iCoeff(ma3( 0, 1, 1)) = 0
                   iCoeff(ma3( 1, 1, 1)) = 0
                   ! Operator z = uz
                    zCoeff(ma3(-1,-1,-1)) = 0
                    zCoeff(ma3( 0,-1,-1)) = 0
                    zCoeff(ma3( 1,-1,-1)) = 0
                    zCoeff(ma3(-1, 0,-1)) = 0
                    zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                    zCoeff(ma3( 1, 0,-1)) = 0
                    zCoeff(ma3(-1, 1,-1)) = 0
                    zCoeff(ma3( 0, 1,-1)) = 0
                    zCoeff(ma3( 1, 1,-1)) = 0
                    zCoeff(ma3(-1,-1, 0)) = 0
                    zCoeff(ma3( 0,-1, 0)) = 0
                    zCoeff(ma3( 1,-1, 0)) = 0
                    zCoeff(ma3(-1, 0, 0)) = 0
                    zCoeff(ma3( 0, 0, 0)) = 0
                    zCoeff(ma3( 1, 0, 0)) = 0
                    zCoeff(ma3(-1, 1, 0)) = 0
                    zCoeff(ma3( 0, 1, 0)) = 0
                    zCoeff(ma3( 1, 1, 0)) = 0
                    zCoeff(ma3(-1,-1, 1)) = 0
                    zCoeff(ma3( 0,-1, 1)) = 0
                    zCoeff(ma3( 1,-1, 1)) = 0
                    zCoeff(ma3(-1, 0, 1)) = 0
                    zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                    zCoeff(ma3( 1, 0, 1)) = 0
                    zCoeff(ma3(-1, 1, 1)) = 0
                    zCoeff(ma3( 0, 1, 1)) = 0
                    zCoeff(ma3( 1, 1, 1)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma3(m1,m2,m3)
                 mm=mce3(m1,m2,m3,cmpw,eqnw)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnw,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnw)=ghost1
              else
               ! boundary face is x=constant, or y=constant : give w=0 
               do m=ce(0,eqnw),ce(0,eqnw+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpw,eqnw)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnw)=extrapolation
              end if
            else
              write(*,'(" insImpINS: bc0.eq.inflowWithPandTV -- 
     & unknown option")')
              stop 8141
            end if
             end if
            end do
            end do
            end do
         else
           ! ****** inflowWithPandTV: vector system *********
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.Lu"
            nDotL(0)=an(0)*coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpu,eqnw),i1,i2,i3)
            nDotL(1)=an(0)*coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpv,eqnw),i1,i2,i3)
            nDotL(2)=an(0)*coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpw,eqnw),i1,i2,i3)
            ! form the matrix for  Iu + [ (n.(Lu)) - (n.u) ] n 
            !  eqnu:     u1 + nDotL*n1 - (n1*u1+n2*u2+n3*u3)*n1 
            !  eqnv:     u2 + nDotL*n2 - (n1*u1+n2*u2+n3*u3)*n2
            !  eqnw:     u3 + nDotL*n3 - (n1*u1+n2*u2+n3*u3)*n3
            !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
            do e=eqnu,eqnu+nd-1
            do c=cmpu,cmpu+nd-1
             ! *** check this ***
             coeff(mce3(m1,m2,m3,c,e),i1,i2,i3)= iCoeff(ma3(m1,m2,m3))*
     & delta(c-cmpu,e-eqnu) + an(e-eqnu)*( nDotL(c-cmpu) - iCoeff(ma3(
     & m1,m2,m3))*an(c-cmpu) )
            end do
            end do
            end do
            end do
            end do
           ! Neumann condition for ghost: **** is this right? or extrapolate ?? ****
           do n=0,ndu-1
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = ux
                 xCoeff(ma3(-1,-1,-1)) = 0
                 xCoeff(ma3( 0,-1,-1)) = 0
                 xCoeff(ma3( 1,-1,-1)) = 0
                 xCoeff(ma3(-1, 0,-1)) = 0
                 xCoeff(ma3( 0, 0,-1)) = 0
                 xCoeff(ma3( 1, 0,-1)) = 0
                 xCoeff(ma3(-1, 1,-1)) = 0
                 xCoeff(ma3( 0, 1,-1)) = 0
                 xCoeff(ma3( 1, 1,-1)) = 0
                 xCoeff(ma3(-1,-1, 0)) = 0
                 xCoeff(ma3( 0,-1, 0)) = 0
                 xCoeff(ma3( 1,-1, 0)) = 0
                 xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                 xCoeff(ma3( 0, 0, 0)) = 0
                 xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                 xCoeff(ma3(-1, 1, 0)) = 0
                 xCoeff(ma3( 0, 1, 0)) = 0
                 xCoeff(ma3( 1, 1, 0)) = 0
                 xCoeff(ma3(-1,-1, 1)) = 0
                 xCoeff(ma3( 0,-1, 1)) = 0
                 xCoeff(ma3( 1,-1, 1)) = 0
                 xCoeff(ma3(-1, 0, 1)) = 0
                 xCoeff(ma3( 0, 0, 1)) = 0
                 xCoeff(ma3( 1, 0, 1)) = 0
                 xCoeff(ma3(-1, 1, 1)) = 0
                 xCoeff(ma3( 0, 1, 1)) = 0
                 xCoeff(ma3( 1, 1, 1)) = 0
                ! Operator y = uy
                 yCoeff(ma3(-1,-1,-1)) = 0
                 yCoeff(ma3( 0,-1,-1)) = 0
                 yCoeff(ma3( 1,-1,-1)) = 0
                 yCoeff(ma3(-1, 0,-1)) = 0
                 yCoeff(ma3( 0, 0,-1)) = 0
                 yCoeff(ma3( 1, 0,-1)) = 0
                 yCoeff(ma3(-1, 1,-1)) = 0
                 yCoeff(ma3( 0, 1,-1)) = 0
                 yCoeff(ma3( 1, 1,-1)) = 0
                 yCoeff(ma3(-1,-1, 0)) = 0
                 yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                 yCoeff(ma3( 1,-1, 0)) = 0
                 yCoeff(ma3(-1, 0, 0)) = 0
                 yCoeff(ma3( 0, 0, 0)) = 0
                 yCoeff(ma3( 1, 0, 0)) = 0
                 yCoeff(ma3(-1, 1, 0)) = 0
                 yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                 yCoeff(ma3( 1, 1, 0)) = 0
                 yCoeff(ma3(-1,-1, 1)) = 0
                 yCoeff(ma3( 0,-1, 1)) = 0
                 yCoeff(ma3( 1,-1, 1)) = 0
                 yCoeff(ma3(-1, 0, 1)) = 0
                 yCoeff(ma3( 0, 0, 1)) = 0
                 yCoeff(ma3( 1, 0, 1)) = 0
                 yCoeff(ma3(-1, 1, 1)) = 0
                 yCoeff(ma3( 0, 1, 1)) = 0
                 yCoeff(ma3( 1, 1, 1)) = 0
                ! Operator identity 
                 iCoeff(ma3(-1,-1,-1)) = 0
                 iCoeff(ma3( 0,-1,-1)) = 0
                 iCoeff(ma3( 1,-1,-1)) = 0
                 iCoeff(ma3(-1, 0,-1)) = 0
                 iCoeff(ma3( 0, 0,-1)) = 0
                 iCoeff(ma3( 1, 0,-1)) = 0
                 iCoeff(ma3(-1, 1,-1)) = 0
                 iCoeff(ma3( 0, 1,-1)) = 0
                 iCoeff(ma3( 1, 1,-1)) = 0
                 iCoeff(ma3(-1,-1, 0)) = 0
                 iCoeff(ma3( 0,-1, 0)) = 0
                 iCoeff(ma3( 1,-1, 0)) = 0
                 iCoeff(ma3(-1, 0, 0)) = 0
                 iCoeff(ma3( 0, 0, 0)) = 1.
                 iCoeff(ma3( 1, 0, 0)) = 0
                 iCoeff(ma3(-1, 1, 0)) = 0
                 iCoeff(ma3( 0, 1, 0)) = 0
                 iCoeff(ma3( 1, 1, 0)) = 0
                 iCoeff(ma3(-1,-1, 1)) = 0
                 iCoeff(ma3( 0,-1, 1)) = 0
                 iCoeff(ma3( 1,-1, 1)) = 0
                 iCoeff(ma3(-1, 0, 1)) = 0
                 iCoeff(ma3( 0, 0, 1)) = 0
                 iCoeff(ma3( 1, 0, 1)) = 0
                 iCoeff(ma3(-1, 1, 1)) = 0
                 iCoeff(ma3( 0, 1, 1)) = 0
                 iCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator z = uz
                  zCoeff(ma3(-1,-1,-1)) = 0
                  zCoeff(ma3( 0,-1,-1)) = 0
                  zCoeff(ma3( 1,-1,-1)) = 0
                  zCoeff(ma3(-1, 0,-1)) = 0
                  zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                  zCoeff(ma3( 1, 0,-1)) = 0
                  zCoeff(ma3(-1, 1,-1)) = 0
                  zCoeff(ma3( 0, 1,-1)) = 0
                  zCoeff(ma3( 1, 1,-1)) = 0
                  zCoeff(ma3(-1,-1, 0)) = 0
                  zCoeff(ma3( 0,-1, 0)) = 0
                  zCoeff(ma3( 1,-1, 0)) = 0
                  zCoeff(ma3(-1, 0, 0)) = 0
                  zCoeff(ma3( 0, 0, 0)) = 0
                  zCoeff(ma3( 1, 0, 0)) = 0
                  zCoeff(ma3(-1, 1, 0)) = 0
                  zCoeff(ma3( 0, 1, 0)) = 0
                  zCoeff(ma3( 1, 1, 0)) = 0
                  zCoeff(ma3(-1,-1, 1)) = 0
                  zCoeff(ma3( 0,-1, 1)) = 0
                  zCoeff(ma3( 1,-1, 1)) = 0
                  zCoeff(ma3(-1, 0, 1)) = 0
                  zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                  zCoeff(ma3( 1, 0, 1)) = 0
                  zCoeff(ma3(-1, 1, 1)) = 0
                  zCoeff(ma3( 0, 1, 1)) = 0
                  zCoeff(ma3( 1, 1, 1)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma3(m1,m2,m3)
               mm=mce3(m1,m2,m3,cmpu+n,eqnu+n)
                coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+0.*iCoeff(m)
               ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnu+n)=ghost1
           end do
            end if
           end do
           end do
           end do
         end if  ! end vector system
         else if( bc0.eq.axisymmetric )then
          if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
           ! BC on an axisymmetric side : scalar matrix for U 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
            ! getCoeff(identity, iCoeff,aj)
            !zeroMatrixCoefficients( coeff,eqnv,eqnv, i1,i2,i3 )  ! set v eqn coeffs to zero
            !setCoeff1(cmpv,eqnv,coeff,iCoeff)                ! dirichlet: V= 
            !fillMatrixExtrapolation(coe<ff,cmpv,eqnv,i1,i2,i3,orderOfExtrapolation,1)  ! extrap ghost for V 
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = ux
                xCoeff(ma3(-1,-1,-1)) = 0
                xCoeff(ma3( 0,-1,-1)) = 0
                xCoeff(ma3( 1,-1,-1)) = 0
                xCoeff(ma3(-1, 0,-1)) = 0
                xCoeff(ma3( 0, 0,-1)) = 0
                xCoeff(ma3( 1, 0,-1)) = 0
                xCoeff(ma3(-1, 1,-1)) = 0
                xCoeff(ma3( 0, 1,-1)) = 0
                xCoeff(ma3( 1, 1,-1)) = 0
                xCoeff(ma3(-1,-1, 0)) = 0
                xCoeff(ma3( 0,-1, 0)) = 0
                xCoeff(ma3( 1,-1, 0)) = 0
                xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                xCoeff(ma3( 0, 0, 0)) = 0
                xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                xCoeff(ma3(-1, 1, 0)) = 0
                xCoeff(ma3( 0, 1, 0)) = 0
                xCoeff(ma3( 1, 1, 0)) = 0
                xCoeff(ma3(-1,-1, 1)) = 0
                xCoeff(ma3( 0,-1, 1)) = 0
                xCoeff(ma3( 1,-1, 1)) = 0
                xCoeff(ma3(-1, 0, 1)) = 0
                xCoeff(ma3( 0, 0, 1)) = 0
                xCoeff(ma3( 1, 0, 1)) = 0
                xCoeff(ma3(-1, 1, 1)) = 0
                xCoeff(ma3( 0, 1, 1)) = 0
                xCoeff(ma3( 1, 1, 1)) = 0
               ! Operator y = uy
                yCoeff(ma3(-1,-1,-1)) = 0
                yCoeff(ma3( 0,-1,-1)) = 0
                yCoeff(ma3( 1,-1,-1)) = 0
                yCoeff(ma3(-1, 0,-1)) = 0
                yCoeff(ma3( 0, 0,-1)) = 0
                yCoeff(ma3( 1, 0,-1)) = 0
                yCoeff(ma3(-1, 1,-1)) = 0
                yCoeff(ma3( 0, 1,-1)) = 0
                yCoeff(ma3( 1, 1,-1)) = 0
                yCoeff(ma3(-1,-1, 0)) = 0
                yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma3( 1,-1, 0)) = 0
                yCoeff(ma3(-1, 0, 0)) = 0
                yCoeff(ma3( 0, 0, 0)) = 0
                yCoeff(ma3( 1, 0, 0)) = 0
                yCoeff(ma3(-1, 1, 0)) = 0
                yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma3( 1, 1, 0)) = 0
                yCoeff(ma3(-1,-1, 1)) = 0
                yCoeff(ma3( 0,-1, 1)) = 0
                yCoeff(ma3( 1,-1, 1)) = 0
                yCoeff(ma3(-1, 0, 1)) = 0
                yCoeff(ma3( 0, 0, 1)) = 0
                yCoeff(ma3( 1, 0, 1)) = 0
                yCoeff(ma3(-1, 1, 1)) = 0
                yCoeff(ma3( 0, 1, 1)) = 0
                yCoeff(ma3( 1, 1, 1)) = 0
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
                ! Operator z = uz
                 zCoeff(ma3(-1,-1,-1)) = 0
                 zCoeff(ma3( 0,-1,-1)) = 0
                 zCoeff(ma3( 1,-1,-1)) = 0
                 zCoeff(ma3(-1, 0,-1)) = 0
                 zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                 zCoeff(ma3( 1, 0,-1)) = 0
                 zCoeff(ma3(-1, 1,-1)) = 0
                 zCoeff(ma3( 0, 1,-1)) = 0
                 zCoeff(ma3( 1, 1,-1)) = 0
                 zCoeff(ma3(-1,-1, 0)) = 0
                 zCoeff(ma3( 0,-1, 0)) = 0
                 zCoeff(ma3( 1,-1, 0)) = 0
                 zCoeff(ma3(-1, 0, 0)) = 0
                 zCoeff(ma3( 0, 0, 0)) = 0
                 zCoeff(ma3( 1, 0, 0)) = 0
                 zCoeff(ma3(-1, 1, 0)) = 0
                 zCoeff(ma3( 0, 1, 0)) = 0
                 zCoeff(ma3( 1, 1, 0)) = 0
                 zCoeff(ma3(-1,-1, 1)) = 0
                 zCoeff(ma3( 0,-1, 1)) = 0
                 zCoeff(ma3( 1,-1, 1)) = 0
                 zCoeff(ma3(-1, 0, 1)) = 0
                 zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                 zCoeff(ma3( 1, 0, 1)) = 0
                 zCoeff(ma3(-1, 1, 1)) = 0
                 zCoeff(ma3( 0, 1, 1)) = 0
                 zCoeff(ma3( 1, 1, 1)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma3(m1,m2,m3)
              mm=mce3(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
           ! BC on an axisymmetric side : scalar matrix for V 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
            !getNormalForCurvilinearGrid(side,axis,i1,i2,i3)
            !fillMatrixNeumann(coeff, cmpu,eqnu, i1,i2,i3, an,0.,1. )  ! Neuman: U_r = 
             end if
            end do
            end do
            end do
          else
           ! BC on an axisymmetric side  
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = ux
                xCoeff(ma3(-1,-1,-1)) = 0
                xCoeff(ma3( 0,-1,-1)) = 0
                xCoeff(ma3( 1,-1,-1)) = 0
                xCoeff(ma3(-1, 0,-1)) = 0
                xCoeff(ma3( 0, 0,-1)) = 0
                xCoeff(ma3( 1, 0,-1)) = 0
                xCoeff(ma3(-1, 1,-1)) = 0
                xCoeff(ma3( 0, 1,-1)) = 0
                xCoeff(ma3( 1, 1,-1)) = 0
                xCoeff(ma3(-1,-1, 0)) = 0
                xCoeff(ma3( 0,-1, 0)) = 0
                xCoeff(ma3( 1,-1, 0)) = 0
                xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                xCoeff(ma3( 0, 0, 0)) = 0
                xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                xCoeff(ma3(-1, 1, 0)) = 0
                xCoeff(ma3( 0, 1, 0)) = 0
                xCoeff(ma3( 1, 1, 0)) = 0
                xCoeff(ma3(-1,-1, 1)) = 0
                xCoeff(ma3( 0,-1, 1)) = 0
                xCoeff(ma3( 1,-1, 1)) = 0
                xCoeff(ma3(-1, 0, 1)) = 0
                xCoeff(ma3( 0, 0, 1)) = 0
                xCoeff(ma3( 1, 0, 1)) = 0
                xCoeff(ma3(-1, 1, 1)) = 0
                xCoeff(ma3( 0, 1, 1)) = 0
                xCoeff(ma3( 1, 1, 1)) = 0
               ! Operator y = uy
                yCoeff(ma3(-1,-1,-1)) = 0
                yCoeff(ma3( 0,-1,-1)) = 0
                yCoeff(ma3( 1,-1,-1)) = 0
                yCoeff(ma3(-1, 0,-1)) = 0
                yCoeff(ma3( 0, 0,-1)) = 0
                yCoeff(ma3( 1, 0,-1)) = 0
                yCoeff(ma3(-1, 1,-1)) = 0
                yCoeff(ma3( 0, 1,-1)) = 0
                yCoeff(ma3( 1, 1,-1)) = 0
                yCoeff(ma3(-1,-1, 0)) = 0
                yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                yCoeff(ma3( 1,-1, 0)) = 0
                yCoeff(ma3(-1, 0, 0)) = 0
                yCoeff(ma3( 0, 0, 0)) = 0
                yCoeff(ma3( 1, 0, 0)) = 0
                yCoeff(ma3(-1, 1, 0)) = 0
                yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                yCoeff(ma3( 1, 1, 0)) = 0
                yCoeff(ma3(-1,-1, 1)) = 0
                yCoeff(ma3( 0,-1, 1)) = 0
                yCoeff(ma3( 1,-1, 1)) = 0
                yCoeff(ma3(-1, 0, 1)) = 0
                yCoeff(ma3( 0, 0, 1)) = 0
                yCoeff(ma3( 1, 0, 1)) = 0
                yCoeff(ma3(-1, 1, 1)) = 0
                yCoeff(ma3( 0, 1, 1)) = 0
                yCoeff(ma3( 1, 1, 1)) = 0
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
                ! Operator z = uz
                 zCoeff(ma3(-1,-1,-1)) = 0
                 zCoeff(ma3( 0,-1,-1)) = 0
                 zCoeff(ma3( 1,-1,-1)) = 0
                 zCoeff(ma3(-1, 0,-1)) = 0
                 zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                 zCoeff(ma3( 1, 0,-1)) = 0
                 zCoeff(ma3(-1, 1,-1)) = 0
                 zCoeff(ma3( 0, 1,-1)) = 0
                 zCoeff(ma3( 1, 1,-1)) = 0
                 zCoeff(ma3(-1,-1, 0)) = 0
                 zCoeff(ma3( 0,-1, 0)) = 0
                 zCoeff(ma3( 1,-1, 0)) = 0
                 zCoeff(ma3(-1, 0, 0)) = 0
                 zCoeff(ma3( 0, 0, 0)) = 0
                 zCoeff(ma3( 1, 0, 0)) = 0
                 zCoeff(ma3(-1, 1, 0)) = 0
                 zCoeff(ma3( 0, 1, 0)) = 0
                 zCoeff(ma3( 1, 1, 0)) = 0
                 zCoeff(ma3(-1,-1, 1)) = 0
                 zCoeff(ma3( 0,-1, 1)) = 0
                 zCoeff(ma3( 1,-1, 1)) = 0
                 zCoeff(ma3(-1, 0, 1)) = 0
                 zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                 zCoeff(ma3( 1, 0, 1)) = 0
                 zCoeff(ma3(-1, 1, 1)) = 0
                 zCoeff(ma3( 0, 1, 1)) = 0
                 zCoeff(ma3( 1, 1, 1)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma3(m1,m2,m3)
              mm=mce3(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          end if
         else if( bc0.gt.0 )then
           write(*,'("insimp:BC: ERROR unknown bc=",i4)') bc0
           stop 5501
         end if
         if( extrapolateGhostByDefault.eq.1 .and. (
     & bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall.or.bc0.eq.inflowWithVelocityGiven .or.(
     & bc0.eq.outflow .and. outflowOption.eq.0) 
     & .or.bc0.eq.interfaceBoundaryCondition) )then
          ! === extrapolation ===
          orderOfExtrap=orderOfExtrapolation
          if( bc0.eq.outflow .and. orderOfExtrapolationForOutflow.gt.0 
     & )then
            orderOfExtrap=orderOfExtrapolationForOutflow
          end if
          if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
           write(*,'("insimp:BC:ERROR: requesting orderOfExtrap=",i6)')
     &  orderOfExtrap
           stop 5502
          end if
          if( .false. .and. bc0.eq.outflow )then
           write(*,'("insimp:BC: fill extrap outflow BC into matrix, 
     & orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') 
     & orderOfExtrap,orderOfExtrapolationForOutflow
          end if
          ! write(*,'("insimp:BC: orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') orderOfExtrap,orderOfExtrapolationForOutflow
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! i1m=i1-is1  ! ghost point
           ! i2m=i2-is2
           ! i3m=i3-is3
           ! zeroMatrixCoefficients( coeff,eqnu,eqnu+ndu-1, i1,i2,i3 )
           do n=0,ndu-1
            c=cmpu+n
            e=eqnu+n
             if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrap
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(c,e)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrap) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,e)=extrapolation
           end do
            end if
           end do
           end do
           end do
         end if
         end if
         if( pdeModel.eq.BoussinesqModel .and. (
     & fillCoefficientsScalarSystem.eq.0 .or. 
     & fillCoefficientsScalarSystem.eq.fillCoeffT) )then
          ! ----------------------------
          ! --- Assign the BCs for T --- (this is duplicated from insImpVP.bf : we could share 
          ! ----------------------------
          bc0 = bc(side,axis)
          a0 = mixedCoeff(tc,side,axis,grid)
          a1 = mixedNormalCoeff(tc,side,axis,grid)
          if( debug.gt.3 )then
            write(*,'(" insImpINS: T BC: bc=",i3," (a0,a1)=(",f5.1,",",
     & f5.1,") for side,axis,grid=",3i3)') bc0,a0,a1,side,axis,grid
            write(*,'(" cmpu,eqnu=",2i2," cmpq,eqnq=",2i2," 
     & orderOfExtrap=",i2)') cmpu,eqnu, cmpq,eqnq,orderOfExtrap
          endif
          ! '
          if( bc0.eq.dirichletBoundaryCondition .or.bc0.eq.noSlipWall 
     & .or.bc0.eq.slipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.outflow .or.bc0.eq.axisymmetric 
     & .or.bc0.eq.interfaceBoundaryCondition .or. 
     & bc0.eq.freeSurfaceBoundaryCondition )then
            if( bc0.eq.outflow .or. bc0.eq.axisymmetric )then
             ! outflow is Neumann
             a0=0.
             a1=1.
            end if
           if( a1.ne.0. )then
            ! Mixed BC 
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = ux
                 xCoeff(ma3(-1,-1,-1)) = 0
                 xCoeff(ma3( 0,-1,-1)) = 0
                 xCoeff(ma3( 1,-1,-1)) = 0
                 xCoeff(ma3(-1, 0,-1)) = 0
                 xCoeff(ma3( 0, 0,-1)) = 0
                 xCoeff(ma3( 1, 0,-1)) = 0
                 xCoeff(ma3(-1, 1,-1)) = 0
                 xCoeff(ma3( 0, 1,-1)) = 0
                 xCoeff(ma3( 1, 1,-1)) = 0
                 xCoeff(ma3(-1,-1, 0)) = 0
                 xCoeff(ma3( 0,-1, 0)) = 0
                 xCoeff(ma3( 1,-1, 0)) = 0
                 xCoeff(ma3(-1, 0, 0)) = -1./2./dx(0)
                 xCoeff(ma3( 0, 0, 0)) = 0
                 xCoeff(ma3( 1, 0, 0)) = 1./2./dx(0)
                 xCoeff(ma3(-1, 1, 0)) = 0
                 xCoeff(ma3( 0, 1, 0)) = 0
                 xCoeff(ma3( 1, 1, 0)) = 0
                 xCoeff(ma3(-1,-1, 1)) = 0
                 xCoeff(ma3( 0,-1, 1)) = 0
                 xCoeff(ma3( 1,-1, 1)) = 0
                 xCoeff(ma3(-1, 0, 1)) = 0
                 xCoeff(ma3( 0, 0, 1)) = 0
                 xCoeff(ma3( 1, 0, 1)) = 0
                 xCoeff(ma3(-1, 1, 1)) = 0
                 xCoeff(ma3( 0, 1, 1)) = 0
                 xCoeff(ma3( 1, 1, 1)) = 0
                ! Operator y = uy
                 yCoeff(ma3(-1,-1,-1)) = 0
                 yCoeff(ma3( 0,-1,-1)) = 0
                 yCoeff(ma3( 1,-1,-1)) = 0
                 yCoeff(ma3(-1, 0,-1)) = 0
                 yCoeff(ma3( 0, 0,-1)) = 0
                 yCoeff(ma3( 1, 0,-1)) = 0
                 yCoeff(ma3(-1, 1,-1)) = 0
                 yCoeff(ma3( 0, 1,-1)) = 0
                 yCoeff(ma3( 1, 1,-1)) = 0
                 yCoeff(ma3(-1,-1, 0)) = 0
                 yCoeff(ma3( 0,-1, 0)) = -1./2./dx(1)
                 yCoeff(ma3( 1,-1, 0)) = 0
                 yCoeff(ma3(-1, 0, 0)) = 0
                 yCoeff(ma3( 0, 0, 0)) = 0
                 yCoeff(ma3( 1, 0, 0)) = 0
                 yCoeff(ma3(-1, 1, 0)) = 0
                 yCoeff(ma3( 0, 1, 0)) = 1./2./dx(1)
                 yCoeff(ma3( 1, 1, 0)) = 0
                 yCoeff(ma3(-1,-1, 1)) = 0
                 yCoeff(ma3( 0,-1, 1)) = 0
                 yCoeff(ma3( 1,-1, 1)) = 0
                 yCoeff(ma3(-1, 0, 1)) = 0
                 yCoeff(ma3( 0, 0, 1)) = 0
                 yCoeff(ma3( 1, 0, 1)) = 0
                 yCoeff(ma3(-1, 1, 1)) = 0
                 yCoeff(ma3( 0, 1, 1)) = 0
                 yCoeff(ma3( 1, 1, 1)) = 0
                ! Operator identity 
                 iCoeff(ma3(-1,-1,-1)) = 0
                 iCoeff(ma3( 0,-1,-1)) = 0
                 iCoeff(ma3( 1,-1,-1)) = 0
                 iCoeff(ma3(-1, 0,-1)) = 0
                 iCoeff(ma3( 0, 0,-1)) = 0
                 iCoeff(ma3( 1, 0,-1)) = 0
                 iCoeff(ma3(-1, 1,-1)) = 0
                 iCoeff(ma3( 0, 1,-1)) = 0
                 iCoeff(ma3( 1, 1,-1)) = 0
                 iCoeff(ma3(-1,-1, 0)) = 0
                 iCoeff(ma3( 0,-1, 0)) = 0
                 iCoeff(ma3( 1,-1, 0)) = 0
                 iCoeff(ma3(-1, 0, 0)) = 0
                 iCoeff(ma3( 0, 0, 0)) = 1.
                 iCoeff(ma3( 1, 0, 0)) = 0
                 iCoeff(ma3(-1, 1, 0)) = 0
                 iCoeff(ma3( 0, 1, 0)) = 0
                 iCoeff(ma3( 1, 1, 0)) = 0
                 iCoeff(ma3(-1,-1, 1)) = 0
                 iCoeff(ma3( 0,-1, 1)) = 0
                 iCoeff(ma3( 1,-1, 1)) = 0
                 iCoeff(ma3(-1, 0, 1)) = 0
                 iCoeff(ma3( 0, 0, 1)) = 0
                 iCoeff(ma3( 1, 0, 1)) = 0
                 iCoeff(ma3(-1, 1, 1)) = 0
                 iCoeff(ma3( 0, 1, 1)) = 0
                 iCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator z = uz
                  zCoeff(ma3(-1,-1,-1)) = 0
                  zCoeff(ma3( 0,-1,-1)) = 0
                  zCoeff(ma3( 1,-1,-1)) = 0
                  zCoeff(ma3(-1, 0,-1)) = 0
                  zCoeff(ma3( 0, 0,-1)) = -1./2./dx(2)
                  zCoeff(ma3( 1, 0,-1)) = 0
                  zCoeff(ma3(-1, 1,-1)) = 0
                  zCoeff(ma3( 0, 1,-1)) = 0
                  zCoeff(ma3( 1, 1,-1)) = 0
                  zCoeff(ma3(-1,-1, 0)) = 0
                  zCoeff(ma3( 0,-1, 0)) = 0
                  zCoeff(ma3( 1,-1, 0)) = 0
                  zCoeff(ma3(-1, 0, 0)) = 0
                  zCoeff(ma3( 0, 0, 0)) = 0
                  zCoeff(ma3( 1, 0, 0)) = 0
                  zCoeff(ma3(-1, 1, 0)) = 0
                  zCoeff(ma3( 0, 1, 0)) = 0
                  zCoeff(ma3( 1, 1, 0)) = 0
                  zCoeff(ma3(-1,-1, 1)) = 0
                  zCoeff(ma3( 0,-1, 1)) = 0
                  zCoeff(ma3( 1,-1, 1)) = 0
                  zCoeff(ma3(-1, 0, 1)) = 0
                  zCoeff(ma3( 0, 0, 1)) = 1./2./dx(2)
                  zCoeff(ma3( 1, 0, 1)) = 0
                  zCoeff(ma3(-1, 1, 1)) = 0
                  zCoeff(ma3( 0, 1, 1)) = 0
                  zCoeff(ma3( 1, 1, 1)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma3(m1,m2,m3)
               mm=mce3(m1,m2,m3,cmpq,eqnq)
                coeff(mm,i1m,i2m,i3m)=a1*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+a0*iCoeff(m)
               ! The equation for pt (eqnq,i1m,i2m,i3m) is centered on (cmpq,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnq)=ghost1
              end if
             end do
             end do
             end do
           else
            ! Dirichlet + extrap ghost line values
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             do m=ce(0,eqnq),ce(0,eqnq+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce3(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(a0*iCoeff(
     & ma3(m1,m2,m3)))
              end do
              end do
              end do
              if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                stop 7734
              end if
              i1m=i1-is1*(1)  ! 1 point
              i2m=i2-is2*(1)
              i3m=i3-is3*(1)
              do m=0,orderOfExtrapolation
               j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
               j2=i2m+is2*m
               j3=i3m+is3*m
               mm = ce(cmpq,eqnq)+m
               coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
              end do
               classify(i1m,i2m,i3m,eqnq)=extrapolation
              end if
             end do
             end do
             end do
           end if
         !  else if( bc0.eq.outflow )then
         !    ! === extrapolation ===
         !   beginLoopsMixedBoundary()
         !    fillMatrixExtrapolation(coeff,cmpq,eqnq,i1,i2,i3,orderOfExtrap,1)
         !   endLoops()
          else if( bc0.gt.0 )then
           write(*,'("insImpINS:T: ERROR unknown bc=",i4)') bc0
           stop 9167
          end if
         endif
         end if ! end if( fillCoefficients.eq.1 )
         if( evalResidualForBoundaryConditions.eq.1 )then
         if( bc(side,axis).eq.dirichletBoundaryCondition .or.bc(side,
     & axis).eq.noSlipWall.or.bc(side,axis)
     & .eq.inflowWithVelocityGiven.or.bc(side,axis)
     & .eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           ! do n=0,ntdc-1             ! ntdc = number of time depenedent components
           do n=0,nd-1  ! ntdc = number of time depenedent components
            ! fe(i1,i2,i3,uc+n)=0.  
            fe(i1,i2,i3,uc+n)=fi(i1,i2,i3,uc+n)-u(i1,i2,i3,uc+n)
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.outflow )then
         else if( bc(side,axis).eq.axisymmetric )then
         ! do nothing for now
         else if( bc(side,axis).eq.freeSurfaceBoundaryCondition )then
         ! do nothing for now
         else if( bc(side,axis).eq.slipWall )then
           ! SLIP-WALL
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.inflowWithPandTV )then
          ! pressure and tangential velocity given
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).gt.0 )then
           write(*,'("insimp:residual:BC: ERROR unknown bc=",i4)') bc(
     & side,axis)
           stop 9099
         end if
         end if ! end if( evalResidualForBoundaryConditions.eq.1 )
       !*   if( side.eq.0 .and. axis.eq.0 )then
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal00)
       !*    getBoundaryResidualINS(normal00)
       !*   else if( side.eq.1 .and. axis.eq.0 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal10)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.0 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal01)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.1 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal11)
       !*    getBoundaryResidualINS(normal11)
       !*   else if( side.eq.0 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal02)
       !*    getBoundaryResidualINS(normal02)
       !*   else if( side.eq.1 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal12)
       !*    getBoundaryResidualINS(normal12)
       !*  else
       !* !    stop 2077
       !*  end if
         ! reset values
         if( axis.eq.0 )then
           n1a=indexRange(0,axis)
           n1b=indexRange(1,axis)
         else if( axis.eq.1 )then
           n2a=indexRange(0,axis)
           n2b=indexRange(1,axis)
         else
           n3a=indexRange(0,axis)
           n3b=indexRange(1,axis)
         end if
        end do ! side
        end do ! axis
       end if
       ! assign the RHS:
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( evalRightHandSide.eq.1 .or. evalResidual.eq.1 )then
         ! **** to do : optimize this for backward-Euler : fe=0, fi=0 !!
         ! NOTE: For moving grid problems we must eval the RHS as some mask==0 (exposed) points
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! evaluate forward derivatives of the current solution: 
           ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
           ! MAXDER = max number of parametric derivatives to precompute.
            uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
           ! Evaluate the spatial derivatives of u:
             u0x = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dx(0))
             u0y = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dx(1))
             u0xx = (u(i1-1,i2,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1+1,i2,i3,
     & uc))/(dx(0)**2)
             u0yy = (u(i1,i2-1,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1,i2+1,i3,
     & uc))/(dx(1)**2)
           ! Evaluate the spatial derivatives of v:
            vv=u(i1,i2,i3,vc) ! in the rectangular case just eval the solution
             v0x = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dx(0))
             v0y = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dx(1))
             v0xx = (u(i1-1,i2,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1+1,i2,i3,
     & vc))/(dx(0)**2)
             v0yy = (u(i1,i2-1,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1,i2+1,i3,
     & vc))/(dx(1)**2)
           ! Evaluate the spatial derivatives of p:
            pp=u(i1,i2,i3,pc) ! in the rectangular case just eval the solution
             p0x = (-u(i1-1,i2,i3,pc)+u(i1+1,i2,i3,pc))/(2.*dx(0))
             p0y = (-u(i1,i2-1,i3,pc)+u(i1,i2+1,i3,pc))/(2.*dx(1))
             u0z = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dx(2))
             v0z = (-u(i1,i2,i3-1,vc)+u(i1,i2,i3+1,vc))/(2.*dx(2))
             p0z = (-u(i1,i2,i3-1,pc)+u(i1,i2,i3+1,pc))/(2.*dx(2))
             u0zz = (u(i1,i2,i3-1,uc)-2.*u(i1,i2,i3,uc)+u(i1,i2,i3+1,
     & uc))/(dx(2)**2)
             v0zz = (u(i1,i2,i3-1,vc)-2.*u(i1,i2,i3,vc)+u(i1,i2,i3+1,
     & vc))/(dx(2)**2)
            ww=u(i1,i2,i3,wc) ! in the rectangular case just eval the solution
             w0x = (-u(i1-1,i2,i3,wc)+u(i1+1,i2,i3,wc))/(2.*dx(0))
             w0y = (-u(i1,i2-1,i3,wc)+u(i1,i2+1,i3,wc))/(2.*dx(1))
             w0z = (-u(i1,i2,i3-1,wc)+u(i1,i2,i3+1,wc))/(2.*dx(2))
             w0xx = (u(i1-1,i2,i3,wc)-2.*u(i1,i2,i3,wc)+u(i1+1,i2,i3,
     & wc))/(dx(0)**2)
             w0yy = (u(i1,i2-1,i3,wc)-2.*u(i1,i2,i3,wc)+u(i1,i2+1,i3,
     & wc))/(dx(1)**2)
             w0zz = (u(i1,i2,i3-1,wc)-2.*u(i1,i2,i3,wc)+u(i1,i2,i3+1,
     & wc))/(dx(2)**2)
          if( evalLinearizedDerivatives.eq.1 )then
             uul=ul(i1,i2,i3,uc) ! in the rectangular case just eval the solution
              ulx = (-ul(i1-1,i2,i3,uc)+ul(i1+1,i2,i3,uc))/(2.*dx(0))
              uly = (-ul(i1,i2-1,i3,uc)+ul(i1,i2+1,i3,uc))/(2.*dx(1))
              ulz = (-ul(i1,i2,i3-1,uc)+ul(i1,i2,i3+1,uc))/(2.*dx(2))
             vvl=ul(i1,i2,i3,vc) ! in the rectangular case just eval the solution
              vlx = (-ul(i1-1,i2,i3,vc)+ul(i1+1,i2,i3,vc))/(2.*dx(0))
              vly = (-ul(i1,i2-1,i3,vc)+ul(i1,i2+1,i3,vc))/(2.*dx(1))
              vlz = (-ul(i1,i2,i3-1,vc)+ul(i1,i2,i3+1,vc))/(2.*dx(2))
             wwl=ul(i1,i2,i3,wc) ! in the rectangular case just eval the solution
              wlx = (-ul(i1-1,i2,i3,wc)+ul(i1+1,i2,i3,wc))/(2.*dx(0))
              wly = (-ul(i1,i2-1,i3,wc)+ul(i1,i2+1,i3,wc))/(2.*dx(1))
              wlz = (-ul(i1,i2,i3-1,wc)+ul(i1,i2,i3+1,wc))/(2.*dx(2))
          end if
          if( pdeModel.eq.BoussinesqModel )then
           ! Evaluate the spatial derivatives of q:
            qq=u(i1,i2,i3,qc) ! in the rectangular case just eval the solution
             q0x = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dx(0))
             q0y = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dx(1))
             q0xx = (u(i1-1,i2,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1+1,i2,i3,
     & qc))/(dx(0)**2)
             q0yy = (u(i1,i2-1,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1,i2+1,i3,
     & qc))/(dx(1)**2)
              q0z = (-u(i1,i2,i3-1,qc)+u(i1,i2,i3+1,qc))/(2.*dx(2))
              q0zz = (u(i1,i2,i3-1,qc)-2.*u(i1,i2,i3,qc)+u(i1,i2,i3+1,
     & qc))/(dx(2)**2)
          end if
          if( gridIsMoving.ne.0 )then
            ugv = uu - gv(i1,i2,i3,0)
            vgv = vv - gv(i1,i2,i3,1)
            wgv = ww - gv(i1,i3,i3,2)
          else
            ugv = uu
            vgv = vv
            wgv = ww
          end if
          ! eval the nonlinear coeff. of artificial dissipation: 
            adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y)+abs(u0z) + abs(
     & v0x)+abs(v0y)+abs(v0z) + abs(w0x)+abs(w0y)+abs(w0z) )
           ! ---- 3D -----
          if( evalRightHandSide.eq.1 )then
           if( gridIsImplicit.eq.0 )then
             ! explicit
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y -wgv*u0z - p0x+ nu*(
     & u0xx+u0yy+u0zz) + adCoeff*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(
     & i1,i2,i3-1,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)+u(i1,i2,i3+1,
     & uc)-6.*u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y -wgv*v0z - p0y+ nu*(
     & v0xx+v0yy+v0zz) + adCoeff*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(
     & i1,i2,i3-1,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)+u(i1,i2,i3+1,
     & vc)-6.*u(i1,i2,i3,vc))
             fe(i1,i2,i3,wc) = -ugv*w0x -vgv*w0y -wgv*w0z - p0z+ nu*(
     & w0xx+w0yy+w0zz) + adCoeff*(u(i1-1,i2,i3,wc)+u(i1,i2-1,i3,wc)+u(
     & i1,i2,i3-1,wc)+u(i1+1,i2,i3,wc)+u(i1,i2+1,i3,wc)+u(i1,i2,i3+1,
     & wc)-6.*u(i1,i2,i3,wc))
             if( pdeModel.eq.BoussinesqModel )then
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
              fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) -thermalExpansivity*
     & gravity(2)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y -wgv*q0z + 
     & adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1,i2,i3-1,
     & qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)+u(i1,i2,i3+1,qc)-6.*u(i1,
     & i2,i3,qc))
              if( materialFormat.eq.constantMaterialProperties )then
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*(q0xx+
     & q0yy+q0zz)
              else
               ! -- variable material properties : 
               ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                ! ---------- 3D -----------
                ! Get coefficients at nearby points: 
                if( materialFormat.eq.constantMaterialProperties )then
                  ! const material properties 
                  stop 11199
                else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                  ! piecewise constant material properties
                  scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                  Kzzm=thermalKpc(i1  ,i2  ,i3-1)
                  Kzmz=thermalKpc(i1  ,i2-1,i3  )
                  Kmzz=thermalKpc(i1-1,i2  ,i3  )
                  Kzzz=thermalKpc(i1  ,i2  ,i3  )
                  Kpzz=thermalKpc(i1+1,i2  ,i3  )
                  Kzpz=thermalKpc(i1  ,i2+1,i3  )
                  Kzzp=thermalKpc(i1  ,i2  ,i3+1)
                else if( materialFormat.eq.variableMaterialProperties )
     & then
                  ! variable material properties
                  scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                  Kzzm=thermalKv(i1  ,i2  ,i3-1)
                  Kzmz=thermalKv(i1  ,i2-1,i3  )
                  Kmzz=thermalKv(i1-1,i2  ,i3  )
                  Kzzz=thermalKv(i1  ,i2  ,i3  )
                  Kpzz=thermalKv(i1+1,i2  ,i3  )
                  Kzpz=thermalKv(i1  ,i2+1,i3  )
                  Kzzp=thermalKv(i1  ,i2  ,i3+1)
                end if
                !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
                  K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
                  K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
                  K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
                  K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
                  K2ph = .5*( Kzzp+Kzzz )  ! K(i1,i2,i3+1/2)
                  K2mh = .5*( Kzzz+Kzzm )  ! K(i1,i2,i3-1/2)
                  ! equation for T
                  !    Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z )  
                  au11ph = K0ph*dxvsqi(0)*(scale)
                  au11mh = K0mh*dxvsqi(0)*(scale)
                  au22ph = K1ph*dxvsqi(1)*(scale)
                  au22mh = K1mh*dxvsqi(1)*(scale)
                  au33ph = K2ph*dxvsqi(2)*(scale)
                  au33mh = K2mh*dxvsqi(2)*(scale)
                  au12pzz=0.
                  au12mzz=0.
                  au13pzz=0.
                  au13mzz=0.
                  au21zpz=0.
                  au21zmz=0.
                  au23zpz=0.
                  au23zmz=0.
                  au31zzp=0.
                  au31zzm=0.
                  au32zzp=0.
                  au32zzm=0.
                 ! 3D, order 2:
                 dsgT = ( ( au23zmz+au32zzm)*u(i1  ,i2-1,i3-1,qc) +( 
     & au13mzz+au31zzm)*u(i1-1,i2  ,i3-1,qc) +( au33mh            )*u(
     & i1  ,i2  ,i3-1,qc) +(-au13pzz-au31zzm)*u(i1+1,i2  ,i3-1,qc) +(-
     & au23zpz-au32zzm)*u(i1  ,i2+1,i3-1,qc) +( au12mzz+au21zmz)*u(i1-
     & 1,i2-1,i3  ,qc) +( au22mh            )*u(i1  ,i2-1,i3  ,qc) +(-
     & au12pzz-au21zmz)*u(i1+1,i2-1,i3  ,qc) +( au11mh            )*u(
     & i1-1,i2  ,i3  ,qc) +(-au11ph-au11mh -au22ph -au22mh -au33ph -
     & au33mh)*u(i1  ,i2  ,i3  ,qc) +( au11ph            )*u(i1+1,i2  
     & ,i3  ,qc) +(-au12mzz-au21zpz)*u(i1-1,i2+1,i3  ,qc) +( au22ph   
     &          )*u(i1  ,i2+1,i3  ,qc) +( au12pzz+au21zpz)*u(i1+1,i2+
     & 1,i3  ,qc) +(-au23zmz-au32zzp)*u(i1  ,i2-1,i3+1,qc) +(-au13mzz-
     & au31zzp)*u(i1-1,i2  ,i3+1,qc) +( au33ph            )*u(i1  ,i2 
     &  ,i3+1,qc) +( au13pzz+au31zzp)*u(i1+1,i2  ,i3+1,qc) +( au23zpz+
     & au32zzp)*u(i1  ,i2+1,i3+1,qc) )
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
              endif
             end if
           else
             ! eval the nonlinear coeff. of artificial dissipation for the linearized solution:
               adCoeffl = ad21 + cd22*( abs(ulx)+abs(uly)+abs(ulz) + 
     & abs(vlx)+abs(vly)+abs(vlz) + abs(wlx)+abs(wly)+abs(wlz) )
             ! implicit method -- compute explicit part
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y -wgv*u0z - p0x + (
     & adCoeff-adCoeffl)*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1,i2,
     & i3-1,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)+u(i1,i2,i3+1,uc)-6.*
     & u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y -wgv*v0z - p0y + (
     & adCoeff-adCoeffl)*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1,i2,
     & i3-1,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)+u(i1,i2,i3+1,vc)-6.*
     & u(i1,i2,i3,vc))
             fe(i1,i2,i3,wc) = -ugv*w0x -vgv*w0y -wgv*w0z - p0z + (
     & adCoeff-adCoeffl)*(u(i1-1,i2,i3,wc)+u(i1,i2-1,i3,wc)+u(i1,i2,
     & i3-1,wc)+u(i1+1,i2,i3,wc)+u(i1,i2+1,i3,wc)+u(i1,i2,i3+1,wc)-6.*
     & u(i1,i2,i3,wc))
             if( nonlinearTermsAreImplicit.eq.1 )then
               ! include linearized terms u0*ulx + ul*u0x + ...
               if( gridIsMoving.ne.0 )then
                ugvl = uul - gvl(i1,i2,i3,0)
                vgvl = vvl - gvl(i1,i2,i3,1)
                wgvl = wwl - gvl(i1,i3,i3,2)
               else
                ugvl = uul
                vgvl = vvl
                wgvl = wwl
               end if
               ! ulterm = uul*u0x + vvl*u0y + bImp*(uu*ulx +  vv*uly)
               ulterm = ugvl*u0x + vgvl*u0y + wgvl*u0z + bImp*(uu*ulx +
     &  vv*uly + ww*ulz)
               vlterm = ugvl*v0x + vgvl*v0y + wgvl*v0z + bImp*(uu*vlx +
     &  vv*vly + ww*vlz)
               wlterm = ugvl*w0x + vgvl*w0y + wgvl*w0z + bImp*(uu*wlx +
     &  vv*wly + ww*wlz)
               fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + ulterm
               fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + vlterm
               fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) + wlterm
             end if
             if( implicitOption.eq.computeImplicitTermsSeparately )then
               ! implicit method -- compute implicit part 
               fi(i1,i2,i3,uc) = nuImp*(u0xx+u0yy+u0zz) + adCoeffl*(u(
     & i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1,i2,i3-1,uc)+u(i1+1,i2,i3,
     & uc)+u(i1,i2+1,i3,uc)+u(i1,i2,i3+1,uc)-6.*u(i1,i2,i3,uc))
               fi(i1,i2,i3,vc) = nuImp*(v0xx+v0yy+v0zz) + adCoeffl*(u(
     & i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1,i2,i3-1,vc)+u(i1+1,i2,i3,
     & vc)+u(i1,i2+1,i3,vc)+u(i1,i2,i3+1,vc)-6.*u(i1,i2,i3,vc))
               fi(i1,i2,i3,wc) = nuImp*(w0xx+w0yy+w0zz) + adCoeffl*(u(
     & i1-1,i2,i3,wc)+u(i1,i2-1,i3,wc)+u(i1,i2,i3-1,wc)+u(i1+1,i2,i3,
     & wc)+u(i1,i2+1,i3,wc)+u(i1,i2,i3+1,wc)-6.*u(i1,i2,i3,wc))
               if( nonlinearTermsAreImplicit.eq.1 )then
                 ! include linearized terms u0*ulx + ul*u0x 
                 fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) - aImp*( ulterm )
                 fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) - aImp*( vlterm )
                 fi(i1,i2,i3,wc) = fi(i1,i2,i3,wc) - aImp*( wlterm )
               end if
             end if
             ! add Boussinesq terms 
             if( pdeModel.eq.BoussinesqModel )then
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -(1.-tImp)*
     & thermalExpansivity*gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -(1.-tImp)*
     & thermalExpansivity*gravity(1)*qq
              fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) -(1.-tImp)*
     & thermalExpansivity*gravity(2)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y -wgv*q0z
              if( nonlinearTermsAreImplicit.eq.1 )then
                 qql=ul(i1,i2,i3,qc) ! in the rectangular case just eval the solution
                  qlx = (-ul(i1-1,i2,i3,qc)+ul(i1+1,i2,i3,qc))/(2.*dx(
     & 0))
                  qly = (-ul(i1,i2-1,i3,qc)+ul(i1,i2+1,i3,qc))/(2.*dx(
     & 1))
                  qlz = (-ul(i1,i2,i3-1,qc)+ul(i1,i2,i3+1,qc))/(2.*dx(
     & 2))
                qlterm = ugvl*q0x + vgvl*q0y + wgvl*q0z + bImp*(uu*qlx 
     & + vv*qly+ ww*qlz)
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + qlterm
              end if
              if( implicitOption.eq.computeImplicitTermsSeparately )
     & then
               ! implicit method -- compute implicit part 
               fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) -tImp*
     & thermalExpansivity*gravity(0)*qq
               fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) -tImp*
     & thermalExpansivity*gravity(1)*qq
               fi(i1,i2,i3,wc) = fi(i1,i2,i3,wc) -tImp*
     & thermalExpansivity*gravity(2)*qq
               if( materialFormat.eq.constantMaterialProperties )then
                 fi(i1,i2,i3,qc) = kThermal*(q0xx+q0yy+q0zz) + 
     & adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1,i2,i3-1,
     & qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)+u(i1,i2,i3+1,qc)-6.*u(i1,
     & i2,i3,qc))
               else
                ! -- variable material properties : 
                ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                 ! ---------- 3D -----------
                 ! Get coefficients at nearby points: 
                 if( materialFormat.eq.constantMaterialProperties )then
                   ! const material properties 
                   stop 11199
                 else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                   ! piecewise constant material properties
                   scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                   Kzzm=thermalKpc(i1  ,i2  ,i3-1)
                   Kzmz=thermalKpc(i1  ,i2-1,i3  )
                   Kmzz=thermalKpc(i1-1,i2  ,i3  )
                   Kzzz=thermalKpc(i1  ,i2  ,i3  )
                   Kpzz=thermalKpc(i1+1,i2  ,i3  )
                   Kzpz=thermalKpc(i1  ,i2+1,i3  )
                   Kzzp=thermalKpc(i1  ,i2  ,i3+1)
                 else if( materialFormat.eq.variableMaterialProperties 
     & )then
                   ! variable material properties
                   scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                   Kzzm=thermalKv(i1  ,i2  ,i3-1)
                   Kzmz=thermalKv(i1  ,i2-1,i3  )
                   Kmzz=thermalKv(i1-1,i2  ,i3  )
                   Kzzz=thermalKv(i1  ,i2  ,i3  )
                   Kpzz=thermalKv(i1+1,i2  ,i3  )
                   Kzpz=thermalKv(i1  ,i2+1,i3  )
                   Kzzp=thermalKv(i1  ,i2  ,i3+1)
                 end if
                 !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
                   K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
                   K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
                   K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
                   K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
                   K2ph = .5*( Kzzp+Kzzz )  ! K(i1,i2,i3+1/2)
                   K2mh = .5*( Kzzz+Kzzm )  ! K(i1,i2,i3-1/2)
                   ! equation for T
                   !    Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z )  
                   au11ph = K0ph*dxvsqi(0)*(scale)
                   au11mh = K0mh*dxvsqi(0)*(scale)
                   au22ph = K1ph*dxvsqi(1)*(scale)
                   au22mh = K1mh*dxvsqi(1)*(scale)
                   au33ph = K2ph*dxvsqi(2)*(scale)
                   au33mh = K2mh*dxvsqi(2)*(scale)
                   au12pzz=0.
                   au12mzz=0.
                   au13pzz=0.
                   au13mzz=0.
                   au21zpz=0.
                   au21zmz=0.
                   au23zpz=0.
                   au23zmz=0.
                   au31zzp=0.
                   au31zzm=0.
                   au32zzp=0.
                   au32zzm=0.
                  ! 3D, order 2:
                  dsgT = ( ( au23zmz+au32zzm)*u(i1  ,i2-1,i3-1,qc) +( 
     & au13mzz+au31zzm)*u(i1-1,i2  ,i3-1,qc) +( au33mh            )*u(
     & i1  ,i2  ,i3-1,qc) +(-au13pzz-au31zzm)*u(i1+1,i2  ,i3-1,qc) +(-
     & au23zpz-au32zzm)*u(i1  ,i2+1,i3-1,qc) +( au12mzz+au21zmz)*u(i1-
     & 1,i2-1,i3  ,qc) +( au22mh            )*u(i1  ,i2-1,i3  ,qc) +(-
     & au12pzz-au21zmz)*u(i1+1,i2-1,i3  ,qc) +( au11mh            )*u(
     & i1-1,i2  ,i3  ,qc) +(-au11ph-au11mh -au22ph -au22mh -au33ph -
     & au33mh)*u(i1  ,i2  ,i3  ,qc) +( au11ph            )*u(i1+1,i2  
     & ,i3  ,qc) +(-au12mzz-au21zpz)*u(i1-1,i2+1,i3  ,qc) +( au22ph   
     &          )*u(i1  ,i2+1,i3  ,qc) +( au12pzz+au21zpz)*u(i1+1,i2+
     & 1,i3  ,qc) +(-au23zmz-au32zzp)*u(i1  ,i2-1,i3+1,qc) +(-au13mzz-
     & au31zzp)*u(i1-1,i2  ,i3+1,qc) +( au33ph            )*u(i1  ,i2 
     &  ,i3+1,qc) +( au13pzz+au31zzp)*u(i1+1,i2  ,i3+1,qc) +( au23zpz+
     & au32zzp)*u(i1  ,i2+1,i3+1,qc) )
                fi(i1,i2,i3,qc) = dsgT + adcBoussinesq*(u(i1-1,i2,i3,
     & qc)+u(i1,i2-1,i3,qc)+u(i1,i2,i3-1,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+
     & 1,i3,qc)+u(i1,i2,i3+1,qc)-6.*u(i1,i2,i3,qc))
               endif
               if( nonlinearTermsAreImplicit.eq.1 )then
                 fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) - aImp*( qlterm )
               end if
              end if
             end if
           end if
          end if
          if( evalResidual.eq.1 )then
            ! residual in 3D: (NOTE: currently ul is not available when evaluating the residual)
            fe(i1,i2,i3,uc) = fi(i1,i2,i3,uc) -ugv*u0x -vgv*u0y -wgv*
     & u0z - p0x + nu*(u0xx+u0yy+u0zz) + adCoeff*(u(i1-1,i2,i3,uc)+u(
     & i1,i2-1,i3,uc)+u(i1,i2,i3-1,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,
     & uc)+u(i1,i2,i3+1,uc)-6.*u(i1,i2,i3,uc))
            fe(i1,i2,i3,vc) = fi(i1,i2,i3,vc) -ugv*v0x -vgv*v0y -wgv*
     & v0z - p0y + nu*(v0xx+v0yy+v0zz) + adCoeff*(u(i1-1,i2,i3,vc)+u(
     & i1,i2-1,i3,vc)+u(i1,i2,i3-1,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,
     & vc)+u(i1,i2,i3+1,vc)-6.*u(i1,i2,i3,vc))
            fe(i1,i2,i3,wc) = fi(i1,i2,i3,wc) -ugv*w0x -vgv*w0y -wgv*
     & w0z - p0z + nu*(w0xx+w0yy+w0zz) + adCoeff*(u(i1-1,i2,i3,wc)+u(
     & i1,i2-1,i3,wc)+u(i1,i2,i3-1,wc)+u(i1+1,i2,i3,wc)+u(i1,i2+1,i3,
     & wc)+u(i1,i2,i3+1,wc)-6.*u(i1,i2,i3,wc))
            if( pdeModel.eq.BoussinesqModel )then
             fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
             fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
             fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) -thermalExpansivity*
     & gravity(2)*qq
             fe(i1,i2,i3,qc) = fi(i1,i2,i3,qc) -ugv*q0x -vgv*q0y -wgv*
     & q0z + adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1,i2,
     & i3-1,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)+u(i1,i2,i3+1,qc)-6.*
     & u(i1,i2,i3,qc))
             if( materialFormat.eq.constantMaterialProperties )then
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) +kThermal*(q0xx+q0yy+
     & q0zz)
             else
              ! -- variable material properties : 
              ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
               ! ---------- 3D -----------
               ! Get coefficients at nearby points: 
               if( materialFormat.eq.constantMaterialProperties )then
                 ! const material properties 
                 stop 11199
               else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                 ! piecewise constant material properties
                 scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                 Kzzm=thermalKpc(i1  ,i2  ,i3-1)
                 Kzmz=thermalKpc(i1  ,i2-1,i3  )
                 Kmzz=thermalKpc(i1-1,i2  ,i3  )
                 Kzzz=thermalKpc(i1  ,i2  ,i3  )
                 Kpzz=thermalKpc(i1+1,i2  ,i3  )
                 Kzpz=thermalKpc(i1  ,i2+1,i3  )
                 Kzzp=thermalKpc(i1  ,i2  ,i3+1)
               else if( materialFormat.eq.variableMaterialProperties )
     & then
                 ! variable material properties
                 scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                 Kzzm=thermalKv(i1  ,i2  ,i3-1)
                 Kzmz=thermalKv(i1  ,i2-1,i3  )
                 Kmzz=thermalKv(i1-1,i2  ,i3  )
                 Kzzz=thermalKv(i1  ,i2  ,i3  )
                 Kpzz=thermalKv(i1+1,i2  ,i3  )
                 Kzpz=thermalKv(i1  ,i2+1,i3  )
                 Kzzp=thermalKv(i1  ,i2  ,i3+1)
               end if
               !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
                 K0ph = .5*( Kpzz+Kzzz )  ! K(i1+1/2,i2,i3)
                 K0mh = .5*( Kzzz+Kmzz )  ! K(i1-1/2,i2,i3)
                 K1ph = .5*( Kzpz+Kzzz )  ! K(i1,i2+1/2,i3)
                 K1mh = .5*( Kzzz+Kzmz )  ! K(i1,i2-1/2,i3)
                 K2ph = .5*( Kzzp+Kzzz )  ! K(i1,i2,i3+1/2)
                 K2mh = .5*( Kzzz+Kzzm )  ! K(i1,i2,i3-1/2)
                 ! equation for T
                 !    Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z )  
                 au11ph = K0ph*dxvsqi(0)*(scale)
                 au11mh = K0mh*dxvsqi(0)*(scale)
                 au22ph = K1ph*dxvsqi(1)*(scale)
                 au22mh = K1mh*dxvsqi(1)*(scale)
                 au33ph = K2ph*dxvsqi(2)*(scale)
                 au33mh = K2mh*dxvsqi(2)*(scale)
                 au12pzz=0.
                 au12mzz=0.
                 au13pzz=0.
                 au13mzz=0.
                 au21zpz=0.
                 au21zmz=0.
                 au23zpz=0.
                 au23zmz=0.
                 au31zzp=0.
                 au31zzm=0.
                 au32zzp=0.
                 au32zzm=0.
                ! 3D, order 2:
                dsgT = ( ( au23zmz+au32zzm)*u(i1  ,i2-1,i3-1,qc) +( 
     & au13mzz+au31zzm)*u(i1-1,i2  ,i3-1,qc) +( au33mh            )*u(
     & i1  ,i2  ,i3-1,qc) +(-au13pzz-au31zzm)*u(i1+1,i2  ,i3-1,qc) +(-
     & au23zpz-au32zzm)*u(i1  ,i2+1,i3-1,qc) +( au12mzz+au21zmz)*u(i1-
     & 1,i2-1,i3  ,qc) +( au22mh            )*u(i1  ,i2-1,i3  ,qc) +(-
     & au12pzz-au21zmz)*u(i1+1,i2-1,i3  ,qc) +( au11mh            )*u(
     & i1-1,i2  ,i3  ,qc) +(-au11ph-au11mh -au22ph -au22mh -au33ph -
     & au33mh)*u(i1  ,i2  ,i3  ,qc) +( au11ph            )*u(i1+1,i2  
     & ,i3  ,qc) +(-au12mzz-au21zpz)*u(i1-1,i2+1,i3  ,qc) +( au22ph   
     &          )*u(i1  ,i2+1,i3  ,qc) +( au12pzz+au21zpz)*u(i1+1,i2+
     & 1,i3  ,qc) +(-au23zmz-au32zzp)*u(i1  ,i2-1,i3+1,qc) +(-au13mzz-
     & au31zzp)*u(i1-1,i2  ,i3+1,qc) +( au33ph            )*u(i1  ,i2 
     &  ,i3+1,qc) +( au13pzz+au31zzp)*u(i1+1,i2  ,i3+1,qc) +( au23zpz+
     & au32zzp)*u(i1  ,i2+1,i3+1,qc) )
              fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
             endif
            end if
          end if
          end do
          end do
          end do
         end if
      else if( nd.eq.3 .and. gridType.eq.curvilinear .and. 
     & orderOfAccuracy.eq.2 )then
       ! fill the coefficients:
        ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
        if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           ! --- fill coefficients for a scalar system for a velocity component: I - nu*Delta - A.D. 
           ! write(*,'("@@@@ insImpINS: (u,v,w) fillCoefficientsScalarSystem=",i4)') fillCoefficientsScalarSystem
           ! '
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! this next call will define the jacobian and its derivatives (parameteric and spatial)
           ajrx = rsxy(i1,i2,i3,0,0)
           ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*dr(
     & 0))
           ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*dr(
     & 1))
           ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*dr(
     & 2))
           ajsx = rsxy(i1,i2,i3,1,0)
           ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*dr(
     & 0))
           ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*dr(
     & 1))
           ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*dr(
     & 2))
           ajtx = rsxy(i1,i2,i3,2,0)
           ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*dr(
     & 0))
           ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*dr(
     & 1))
           ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*dr(
     & 2))
           ajry = rsxy(i1,i2,i3,0,1)
           ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*dr(
     & 0))
           ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*dr(
     & 1))
           ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*dr(
     & 2))
           ajsy = rsxy(i1,i2,i3,1,1)
           ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*dr(
     & 0))
           ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*dr(
     & 1))
           ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*dr(
     & 2))
           ajty = rsxy(i1,i2,i3,2,1)
           ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*dr(
     & 0))
           ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*dr(
     & 1))
           ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*dr(
     & 2))
           ajrz = rsxy(i1,i2,i3,0,2)
           ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*dr(
     & 0))
           ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*dr(
     & 1))
           ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*dr(
     & 2))
           ajsz = rsxy(i1,i2,i3,1,2)
           ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*dr(
     & 0))
           ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*dr(
     & 1))
           ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*dr(
     & 2))
           ajtz = rsxy(i1,i2,i3,2,2)
           ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*dr(
     & 0))
           ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*dr(
     & 1))
           ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*dr(
     & 2))
           ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
           ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
           ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
           ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
           ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
           ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
           ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
           ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
           ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
           ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
           ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
           ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
           ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
           ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
           ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
           ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
           ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
           ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
           ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
           ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
           ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
           ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
           ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
           ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
           ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
           ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
           ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
            ! Operator laplacian = 2*rz*tz*urt+rx^2*urr+rxx*ur+sx^2*uss+sxx*us+ry^2*urr+ryy*ur+sy^2*uss+syy*us+2*rx*sx*urs+2*ry*sy*urs+2*rx*tx*urt+2*sx*tx*ust+2*ry*ty*urt+2*sy*ty*ust+2*rz*sz*urs+2*sz*tz*ust+tx^2*utt+txx*ut+ty^2*utt+tyy*ut+rz^2*urr+tz^2*utt+sz^2*uss+rzz*ur+szz*us+tzz*ut
             cur = ajrxx+ajryy+ajrzz
             curr = ajrx**2+ajry**2+ajrz**2
             cus = ajsxx+ajsyy+ajszz
             curs = 2.*ajrx*ajsx+2.*ajry*ajsy+2.*ajrz*ajsz
             cuss = ajsx**2+ajsy**2+ajsz**2
             cut = ajtxx+ajtyy+ajtzz
             curt = 2.*ajrz*ajtz+2.*ajrx*ajtx+2.*ajry*ajty
             cust = 2.*ajsx*ajtx+2.*ajsy*ajty+2.*ajsz*ajtz
             cutt = ajtx**2+ajty**2+ajtz**2
             lapCoeff(ma3(-1,-1,-1)) = 0
             lapCoeff(ma3( 0,-1,-1)) = 1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1,-1,-1)) = 0
             lapCoeff(ma3(-1, 0,-1)) = 1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)+cutt/dr(2)**2
             lapCoeff(ma3( 1, 0,-1)) = -1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3(-1, 1,-1)) = 0
             lapCoeff(ma3( 0, 1,-1)) = -1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1, 1,-1)) = 0
             lapCoeff(ma3(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma3( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma3( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(1)*
     & *2-2.*cutt/dr(2)**2
             lapCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma3(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma3( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3(-1,-1, 1)) = 0
             lapCoeff(ma3( 0,-1, 1)) = -1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1,-1, 1)) = 0
             lapCoeff(ma3(-1, 0, 1)) = -1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)+cutt/dr(2)**2
             lapCoeff(ma3( 1, 0, 1)) = 1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3(-1, 1, 1)) = 0
             lapCoeff(ma3( 0, 1, 1)) = 1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1, 1, 1)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss+utt
             dissCoeff(ma3(-1,-1,-1)) = 0
             dissCoeff(ma3( 0,-1,-1)) = 0
             dissCoeff(ma3( 1,-1,-1)) = 0
             dissCoeff(ma3(-1, 0,-1)) = 0
             dissCoeff(ma3( 0, 0,-1)) = 1
             dissCoeff(ma3( 1, 0,-1)) = 0
             dissCoeff(ma3(-1, 1,-1)) = 0
             dissCoeff(ma3( 0, 1,-1)) = 0
             dissCoeff(ma3( 1, 1,-1)) = 0
             dissCoeff(ma3(-1,-1, 0)) = 0
             dissCoeff(ma3( 0,-1, 0)) = 1
             dissCoeff(ma3( 1,-1, 0)) = 0
             dissCoeff(ma3(-1, 0, 0)) = 1
             dissCoeff(ma3( 0, 0, 0)) = -6
             dissCoeff(ma3( 1, 0, 0)) = 1
             dissCoeff(ma3(-1, 1, 0)) = 0
             dissCoeff(ma3( 0, 1, 0)) = 1
             dissCoeff(ma3( 1, 1, 0)) = 0
             dissCoeff(ma3(-1,-1, 1)) = 0
             dissCoeff(ma3( 0,-1, 1)) = 0
             dissCoeff(ma3( 1,-1, 1)) = 0
             dissCoeff(ma3(-1, 0, 1)) = 0
             dissCoeff(ma3( 0, 0, 1)) = 1
             dissCoeff(ma3( 1, 0, 1)) = 0
             dissCoeff(ma3(-1, 1, 1)) = 0
             dissCoeff(ma3( 0, 1, 1)) = 0
             dissCoeff(ma3( 1, 1, 1)) = 0
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu = u(i1,i2,i3,uc)
           uur = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
           uus = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
           uut = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = ajrx*uur+ajsx*uus+ajtx*uut
            u0y = ajry*uur+ajsy*uus+ajty*uut
             u0z = ajrz*uur+ajsz*uus+ajtz*uut
          ! parametric derivatives of v: 
           vv = u(i1,i2,i3,vc)
           vvr = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dr(0))
           vvs = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dr(1))
           vvt = (-u(i1,i2,i3-1,vc)+u(i1,i2,i3+1,vc))/(2.*dr(2))
            v0x = ajrx*vvr+ajsx*vvs+ajtx*vvt
            v0y = ajry*vvr+ajsy*vvs+ajty*vvt
             v0z = ajrz*vvr+ajsz*vvs+ajtz*vvt
            ww = u(i1,i2,i3,wc)
            wwr = (-u(i1-1,i2,i3,wc)+u(i1+1,i2,i3,wc))/(2.*dr(0))
            wws = (-u(i1,i2-1,i3,wc)+u(i1,i2+1,i3,wc))/(2.*dr(1))
            wwt = (-u(i1,i2,i3-1,wc)+u(i1,i2,i3+1,wc))/(2.*dr(2))
             w0x = ajrx*wwr+ajsx*wws+ajtx*wwt
             w0y = ajry*wwr+ajsy*wws+ajty*wwt
             w0z = ajrz*wwr+ajsz*wws+ajtz*wwt
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y)+abs(u0z) + abs(
     & v0x)+abs(v0y)+abs(v0z) + abs(w0x)+abs(w0y)+abs(w0z) )
         ! Form : I - nuDt*Delta -adCoeff*dt*( urr + uss + .. )
          do m3=-halfWidth3,halfWidth3
          do m2=-halfWidth,halfWidth
          do m1=-halfWidth,halfWidth
            coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(m1,m2,
     & m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*dissCoeff(
     & ma3(m1,m2,m3)))
          end do
          end do
          end do
           end if
          end do
          end do
          end do
         else if( fillCoefficientsScalarSystem.eq.fillCoeffT )then
           ! --- fill coefficients for a scalar system for the Temperature: I - kappa*Delta - A.D. 
          write(*,'("@@@@ insImpINS: T: fillCoefficientsScalarSystem=",
     & i4)') fillCoefficientsScalarSystem
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! this next call will define the jacobian and its derivatives (parameteric and spatial)
           ajrx = rsxy(i1,i2,i3,0,0)
           ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*dr(
     & 0))
           ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*dr(
     & 1))
           ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*dr(
     & 2))
           ajsx = rsxy(i1,i2,i3,1,0)
           ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*dr(
     & 0))
           ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*dr(
     & 1))
           ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*dr(
     & 2))
           ajtx = rsxy(i1,i2,i3,2,0)
           ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*dr(
     & 0))
           ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*dr(
     & 1))
           ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*dr(
     & 2))
           ajry = rsxy(i1,i2,i3,0,1)
           ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*dr(
     & 0))
           ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*dr(
     & 1))
           ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*dr(
     & 2))
           ajsy = rsxy(i1,i2,i3,1,1)
           ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*dr(
     & 0))
           ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*dr(
     & 1))
           ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*dr(
     & 2))
           ajty = rsxy(i1,i2,i3,2,1)
           ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*dr(
     & 0))
           ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*dr(
     & 1))
           ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*dr(
     & 2))
           ajrz = rsxy(i1,i2,i3,0,2)
           ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*dr(
     & 0))
           ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*dr(
     & 1))
           ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*dr(
     & 2))
           ajsz = rsxy(i1,i2,i3,1,2)
           ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*dr(
     & 0))
           ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*dr(
     & 1))
           ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*dr(
     & 2))
           ajtz = rsxy(i1,i2,i3,2,2)
           ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*dr(
     & 0))
           ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*dr(
     & 1))
           ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*dr(
     & 2))
           ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
           ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
           ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
           ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
           ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
           ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
           ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
           ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
           ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
           ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
           ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
           ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
           ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
           ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
           ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
           ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
           ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
           ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
           ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
           ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
           ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
           ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
           ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
           ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
           ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
           ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
           ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
            ! Operator laplacian = 2*rz*tz*urt+rx^2*urr+rxx*ur+sx^2*uss+sxx*us+ry^2*urr+ryy*ur+sy^2*uss+syy*us+2*rx*sx*urs+2*ry*sy*urs+2*rx*tx*urt+2*sx*tx*ust+2*ry*ty*urt+2*sy*ty*ust+2*rz*sz*urs+2*sz*tz*ust+tx^2*utt+txx*ut+ty^2*utt+tyy*ut+rz^2*urr+tz^2*utt+sz^2*uss+rzz*ur+szz*us+tzz*ut
             cur = ajrxx+ajryy+ajrzz
             curr = ajrx**2+ajry**2+ajrz**2
             cus = ajsxx+ajsyy+ajszz
             curs = 2.*ajrx*ajsx+2.*ajry*ajsy+2.*ajrz*ajsz
             cuss = ajsx**2+ajsy**2+ajsz**2
             cut = ajtxx+ajtyy+ajtzz
             curt = 2.*ajrz*ajtz+2.*ajrx*ajtx+2.*ajry*ajty
             cust = 2.*ajsx*ajtx+2.*ajsy*ajty+2.*ajsz*ajtz
             cutt = ajtx**2+ajty**2+ajtz**2
             lapCoeff(ma3(-1,-1,-1)) = 0
             lapCoeff(ma3( 0,-1,-1)) = 1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1,-1,-1)) = 0
             lapCoeff(ma3(-1, 0,-1)) = 1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)+cutt/dr(2)**2
             lapCoeff(ma3( 1, 0,-1)) = -1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3(-1, 1,-1)) = 0
             lapCoeff(ma3( 0, 1,-1)) = -1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1, 1,-1)) = 0
             lapCoeff(ma3(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma3( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma3( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(1)*
     & *2-2.*cutt/dr(2)**2
             lapCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma3(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma3( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3(-1,-1, 1)) = 0
             lapCoeff(ma3( 0,-1, 1)) = -1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1,-1, 1)) = 0
             lapCoeff(ma3(-1, 0, 1)) = -1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)+cutt/dr(2)**2
             lapCoeff(ma3( 1, 0, 1)) = 1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3(-1, 1, 1)) = 0
             lapCoeff(ma3( 0, 1, 1)) = 1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1, 1, 1)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss+utt
             dissCoeff(ma3(-1,-1,-1)) = 0
             dissCoeff(ma3( 0,-1,-1)) = 0
             dissCoeff(ma3( 1,-1,-1)) = 0
             dissCoeff(ma3(-1, 0,-1)) = 0
             dissCoeff(ma3( 0, 0,-1)) = 1
             dissCoeff(ma3( 1, 0,-1)) = 0
             dissCoeff(ma3(-1, 1,-1)) = 0
             dissCoeff(ma3( 0, 1,-1)) = 0
             dissCoeff(ma3( 1, 1,-1)) = 0
             dissCoeff(ma3(-1,-1, 0)) = 0
             dissCoeff(ma3( 0,-1, 0)) = 1
             dissCoeff(ma3( 1,-1, 0)) = 0
             dissCoeff(ma3(-1, 0, 0)) = 1
             dissCoeff(ma3( 0, 0, 0)) = -6
             dissCoeff(ma3( 1, 0, 0)) = 1
             dissCoeff(ma3(-1, 1, 0)) = 0
             dissCoeff(ma3( 0, 1, 0)) = 1
             dissCoeff(ma3( 1, 1, 0)) = 0
             dissCoeff(ma3(-1,-1, 1)) = 0
             dissCoeff(ma3( 0,-1, 1)) = 0
             dissCoeff(ma3( 1,-1, 1)) = 0
             dissCoeff(ma3(-1, 0, 1)) = 0
             dissCoeff(ma3( 0, 0, 1)) = 1
             dissCoeff(ma3( 1, 0, 1)) = 0
             dissCoeff(ma3(-1, 1, 1)) = 0
             dissCoeff(ma3( 0, 1, 1)) = 0
             dissCoeff(ma3( 1, 1, 1)) = 0
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma3(m1,m2,m3)))+(-adcBoussinesq*dt*
     & dissCoeff(ma3(m1,m2,m3)))
             end do
             end do
             end do
          else
           ! -- variable material properties : 
           ! get coefficients scaled by -dt*implicitFactor: 
            ! ---------- 3D -----------
            ! Get coefficients at nearby points: 
            if( materialFormat.eq.constantMaterialProperties )then
              ! const material properties 
              stop 11199
            else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
              ! piecewise constant material properties
              scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
              Kzzm=thermalKpc(i1  ,i2  ,i3-1)
              Kzmz=thermalKpc(i1  ,i2-1,i3  )
              Kmzz=thermalKpc(i1-1,i2  ,i3  )
              Kzzz=thermalKpc(i1  ,i2  ,i3  )
              Kpzz=thermalKpc(i1+1,i2  ,i3  )
              Kzpz=thermalKpc(i1  ,i2+1,i3  )
              Kzzp=thermalKpc(i1  ,i2  ,i3+1)
            else if( materialFormat.eq.variableMaterialProperties )then
              ! variable material properties
              scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
              Kzzm=thermalKv(i1  ,i2  ,i3-1)
              Kzmz=thermalKv(i1  ,i2-1,i3  )
              Kmzz=thermalKv(i1-1,i2  ,i3  )
              Kzzz=thermalKv(i1  ,i2  ,i3  )
              Kpzz=thermalKv(i1+1,i2  ,i3  )
              Kzpz=thermalKv(i1  ,i2+1,i3  )
              Kzzp=thermalKv(i1  ,i2  ,i3+1)
            end if
            !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
             ! evaluate the jacobian at nearby points:
             ajzzm = (1./((rx(i1,i2,i3-1)*sy(i1,i2,i3-1)-ry(i1,i2,i3-1)
     & *sx(i1,i2,i3-1))*tz(i1,i2,i3-1)+(ry(i1,i2,i3-1)*sz(i1,i2,i3-1)-
     & rz(i1,i2,i3-1)*sy(i1,i2,i3-1))*tx(i1,i2,i3-1)+(rz(i1,i2,i3-1)*
     & sx(i1,i2,i3-1)-rx(i1,i2,i3-1)*sz(i1,i2,i3-1))*ty(i1,i2,i3-1)))
             ajzmz = (1./((rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,i3)
     & *sx(i1,i2-1,i3))*tz(i1,i2-1,i3)+(ry(i1,i2-1,i3)*sz(i1,i2-1,i3)-
     & rz(i1,i2-1,i3)*sy(i1,i2-1,i3))*tx(i1,i2-1,i3)+(rz(i1,i2-1,i3)*
     & sx(i1,i2-1,i3)-rx(i1,i2-1,i3)*sz(i1,i2-1,i3))*ty(i1,i2-1,i3)))
             ajmzz = (1./((rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,i3)
     & *sx(i1-1,i2,i3))*tz(i1-1,i2,i3)+(ry(i1-1,i2,i3)*sz(i1-1,i2,i3)-
     & rz(i1-1,i2,i3)*sy(i1-1,i2,i3))*tx(i1-1,i2,i3)+(rz(i1-1,i2,i3)*
     & sx(i1-1,i2,i3)-rx(i1-1,i2,i3)*sz(i1-1,i2,i3))*ty(i1-1,i2,i3)))
             ajzzz = (1./((rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*sx(
     & i1,i2,i3))*tz(i1,i2,i3)+(ry(i1,i2,i3)*sz(i1,i2,i3)-rz(i1,i2,i3)
     & *sy(i1,i2,i3))*tx(i1,i2,i3)+(rz(i1,i2,i3)*sx(i1,i2,i3)-rx(i1,
     & i2,i3)*sz(i1,i2,i3))*ty(i1,i2,i3)))
             ajpzz = (1./((rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,i3)
     & *sx(i1+1,i2,i3))*tz(i1+1,i2,i3)+(ry(i1+1,i2,i3)*sz(i1+1,i2,i3)-
     & rz(i1+1,i2,i3)*sy(i1+1,i2,i3))*tx(i1+1,i2,i3)+(rz(i1+1,i2,i3)*
     & sx(i1+1,i2,i3)-rx(i1+1,i2,i3)*sz(i1+1,i2,i3))*ty(i1+1,i2,i3)))
             ajzpz = (1./((rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,i3)
     & *sx(i1,i2+1,i3))*tz(i1,i2+1,i3)+(ry(i1,i2+1,i3)*sz(i1,i2+1,i3)-
     & rz(i1,i2+1,i3)*sy(i1,i2+1,i3))*tx(i1,i2+1,i3)+(rz(i1,i2+1,i3)*
     & sx(i1,i2+1,i3)-rx(i1,i2+1,i3)*sz(i1,i2+1,i3))*ty(i1,i2+1,i3)))
             ajzzp = (1./((rx(i1,i2,i3+1)*sy(i1,i2,i3+1)-ry(i1,i2,i3+1)
     & *sx(i1,i2,i3+1))*tz(i1,i2,i3+1)+(ry(i1,i2,i3+1)*sz(i1,i2,i3+1)-
     & rz(i1,i2,i3+1)*sy(i1,i2,i3+1))*tx(i1,i2,i3+1)+(rz(i1,i2,i3+1)*
     & sx(i1,i2,i3+1)-rx(i1,i2,i3+1)*sz(i1,i2,i3+1))*ty(i1,i2,i3+1)))
             ! ------------------------------------------------------------------------------------------------------------
             ! au. Get coefficients au11ph, au11mh, au22ph, etc. for 
             !          Dx( K*u.x ) + Dy( K*u.y ) + Dz( K*u.z )  
              au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)*
     & rz(i1-1,i2,i3) )
              au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)*
     & rz(i1  ,i2,i3) )
              au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)*
     & rz(i1+1,i2,i3) )
              au11ph = .5*( au11zzz+au11pzz )
              au11mh = .5*( au11zzz+au11mzz )
              au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)*
     & sz(i1,i2-1,i3) )
              au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)*
     & sz(i1,i2  ,i3) )
              au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)*
     & sz(i1,i2+1,i3) )
              au22ph = .5*( au22zzz+au22zpz )
              au22mh = .5*( au22zzz+au22zmz )
              au33zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*tx(i1,i2,i3-1) + 
     & (Kzzm)*ty(i1,i2,i3-1)*ty(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)*
     & tz(i1,i2,i3-1) )
              au33zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*tx(i1,i2,i3  ) + 
     & (Kzzz)*ty(i1,i2,i3  )*ty(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )*
     & tz(i1,i2,i3  ) )
              au33zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*tx(i1,i2,i3+1) + 
     & (Kzzp)*ty(i1,i2,i3+1)*ty(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)*
     & tz(i1,i2,i3+1) )
              au33ph = .5*( au33zzz+au33zzp )
              au33mh = .5*( au33zzz+au33zzm )
              au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)*
     & sz(i1-1,i2,i3) )
              au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)*
     & sz(i1  ,i2,i3) )
              au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)*
     & sz(i1+1,i2,i3) )
              au13mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*tx(i1-1,i2,i3) + 
     & (Kmzz)*ry(i1-1,i2,i3)*ty(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)*
     & tz(i1-1,i2,i3) )
              au13zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*tx(i1  ,i2,i3) + 
     & (Kzzz)*ry(i1  ,i2,i3)*ty(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)*
     & tz(i1  ,i2,i3) )
              au13pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*tx(i1+1,i2,i3) + 
     & (Kpzz)*ry(i1+1,i2,i3)*ty(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)*
     & tz(i1+1,i2,i3) )
              au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)*
     & rz(i1,i2-1,i3) )
              au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)*
     & rz(i1,i2  ,i3) )
              au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)*
     & rz(i1,i2+1,i3) )
              au23zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*tx(i1,i2-1,i3) + 
     & (Kzmz)*sy(i1,i2-1,i3)*ty(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)*
     & tz(i1,i2-1,i3) )
              au23zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*tx(i1,i2  ,i3) + 
     & (Kzzz)*sy(i1,i2  ,i3)*ty(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)*
     & tz(i1,i2  ,i3) )
              au23zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*tx(i1,i2+1,i3) + 
     & (Kzpz)*sy(i1,i2+1,i3)*ty(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)*
     & tz(i1,i2+1,i3) )
              au31zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*rx(i1,i2,i3-1) + 
     & (Kzzm)*ty(i1,i2,i3-1)*ry(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)*
     & rz(i1,i2,i3-1) )
              au31zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*rx(i1,i2,i3  ) + 
     & (Kzzz)*ty(i1,i2,i3  )*ry(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )*
     & rz(i1,i2,i3  ) )
              au31zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*rx(i1,i2,i3+1) + 
     & (Kzzp)*ty(i1,i2,i3+1)*ry(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)*
     & rz(i1,i2,i3+1) )
              au32zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*sx(i1,i2,i3-1) + 
     & (Kzzm)*ty(i1,i2,i3-1)*sy(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)*
     & sz(i1,i2,i3-1) )
              au32zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*sx(i1,i2,i3  ) + 
     & (Kzzz)*ty(i1,i2,i3  )*sy(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )*
     & sz(i1,i2,i3  ) )
              au32zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*sx(i1,i2,i3+1) + 
     & (Kzzp)*ty(i1,i2,i3+1)*sy(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)*
     & sz(i1,i2,i3+1) )
             ! scaling factors: 
             dr0i = (scale)/(ajzzz*dr(0)**2)
             dr1i = (scale)/(ajzzz*dr(1)**2)
             dr2i = (scale)/(ajzzz*dr(2)**2)
             dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
             dr0dr2 = (scale)/(ajzzz*4.*dr(0)*dr(2))
             dr1dr2 = (scale)/(ajzzz*4.*dr(1)*dr(2))
              au11ph=au11ph*dr0i
              au11mh=au11mh*dr0i
              au22ph=au22ph*dr1i
              au22mh=au22mh*dr1i
              au33ph=au33ph*dr2i
              au33mh=au33mh*dr2i
              au12pzz=au12pzz*dr0dr1
              au12mzz=au12mzz*dr0dr1
              au13pzz=au13pzz*dr0dr2
              au13mzz=au13mzz*dr0dr2
              au21zpz=au21zpz*dr0dr1
              au21zmz=au21zmz*dr0dr1
              au23zpz=au23zpz*dr1dr2
              au23zmz=au23zmz*dr1dr2
              au31zzp=au31zzp*dr0dr2
              au31zzm=au31zzm*dr0dr2
              au32zzp=au32zzp*dr1dr2
              au32zzm=au32zzm*dr1dr2
           ! Set coeff = - dtImp*div( K grad)
               coeff(mce3(-1,-1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,-1,-1,cmpu,eqnu),i1,i2,i3)=         
     & au23zmz+au32zzm
               coeff(mce3(1,-1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(-1,0,-1,cmpu,eqnu),i1,i2,i3)=  au13mzz+
     & au31zzm
               coeff(mce3(0,0,-1,cmpu,eqnu),i1,i2,i3)=                 
     &                    au33mh
               coeff(mce3(1,0,-1,cmpu,eqnu),i1,i2,i3)= -au13pzz-au31zzm
               coeff(mce3(-1,1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,1,-1,cmpu,eqnu),i1,i2,i3)=        -au23zpz-
     & au32zzm
               coeff(mce3(1,1,-1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(-1,-1,0,cmpu,eqnu),i1,i2,i3)=  au12mzz+
     & au21zmz
               coeff(mce3(0,-1,0,cmpu,eqnu),i1,i2,i3)=                 
     &      au22mh
               coeff(mce3(1,-1,0,cmpu,eqnu),i1,i2,i3)= -au12pzz-au21zmz
               coeff(mce3(-1,0,0,cmpu,eqnu),i1,i2,i3)=         au11mh
               coeff(mce3(0,0,0,cmpu,eqnu),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh -au33ph -au33mh
               coeff(mce3(1,0,0,cmpu,eqnu),i1,i2,i3)=  au11ph
               coeff(mce3(-1,1,0,cmpu,eqnu),i1,i2,i3)= -au12mzz-au21zpz
               coeff(mce3(0,1,0,cmpu,eqnu),i1,i2,i3)=               
     & au22ph
               coeff(mce3(1,1,0,cmpu,eqnu),i1,i2,i3)=  au12pzz+au21zpz
               coeff(mce3(-1,-1,1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,-1,1,cmpu,eqnu),i1,i2,i3)=       -au23zmz-
     & au32zzp
               coeff(mce3(1,-1,1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(-1,0,1,cmpu,eqnu),i1,i2,i3)= -au13mzz-au31zzp
               coeff(mce3(0,0,1,cmpu,eqnu),i1,i2,i3)=                  
     &           au33ph
               coeff(mce3(1,0,1,cmpu,eqnu),i1,i2,i3)=  au13pzz+au31zzp
               coeff(mce3(-1,1,1,cmpu,eqnu),i1,i2,i3)= 0.
               coeff(mce3(0,1,1,cmpu,eqnu),i1,i2,i3)=        au23zpz+
     & au32zzp
               coeff(mce3(1,1,1,cmpu,eqnu),i1,i2,i3)= 0.
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
              coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=coeff(mce3(m1,
     & m2,m3,cmpu,eqnu),i1,i2,i3)+(iCoeff(ma3(m1,m2,m3)))+(-
     & adcBoussinesq*dt*dissCoeff(ma3(m1,m2,m3)))
            end do
            end do
            end do
          endif
           end if
          end do
          end do
          end do
         else
           ! --- fill coefficients for the full system ---
         ! write(*,'("&&&&& insImpINS: fill coefficients for a full system, pdeModel=",i3)') pdeModel
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           if( mask(i1,i2,i3).gt.0 )then
          ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
          ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           ! this next call will define the jacobian and its derivatives (parameteric and spatial)
           ajrx = rsxy(i1,i2,i3,0,0)
           ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*dr(
     & 0))
           ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*dr(
     & 1))
           ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*dr(
     & 2))
           ajsx = rsxy(i1,i2,i3,1,0)
           ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*dr(
     & 0))
           ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*dr(
     & 1))
           ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*dr(
     & 2))
           ajtx = rsxy(i1,i2,i3,2,0)
           ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*dr(
     & 0))
           ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*dr(
     & 1))
           ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*dr(
     & 2))
           ajry = rsxy(i1,i2,i3,0,1)
           ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*dr(
     & 0))
           ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*dr(
     & 1))
           ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*dr(
     & 2))
           ajsy = rsxy(i1,i2,i3,1,1)
           ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*dr(
     & 0))
           ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*dr(
     & 1))
           ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*dr(
     & 2))
           ajty = rsxy(i1,i2,i3,2,1)
           ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*dr(
     & 0))
           ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*dr(
     & 1))
           ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*dr(
     & 2))
           ajrz = rsxy(i1,i2,i3,0,2)
           ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*dr(
     & 0))
           ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*dr(
     & 1))
           ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*dr(
     & 2))
           ajsz = rsxy(i1,i2,i3,1,2)
           ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*dr(
     & 0))
           ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*dr(
     & 1))
           ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*dr(
     & 2))
           ajtz = rsxy(i1,i2,i3,2,2)
           ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*dr(
     & 0))
           ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*dr(
     & 1))
           ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*dr(
     & 2))
           ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
           ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
           ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
           ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
           ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
           ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
           ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
           ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
           ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
           ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
           ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
           ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
           ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
           ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
           ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
           ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
           ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
           ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
           ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
           ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
           ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
           ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
           ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
           ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
           ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
           ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
           ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
          ! evaluate the coeff operators 
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
            ! Operator laplacian = 2*rz*tz*urt+rx^2*urr+rxx*ur+sx^2*uss+sxx*us+ry^2*urr+ryy*ur+sy^2*uss+syy*us+2*rx*sx*urs+2*ry*sy*urs+2*rx*tx*urt+2*sx*tx*ust+2*ry*ty*urt+2*sy*ty*ust+2*rz*sz*urs+2*sz*tz*ust+tx^2*utt+txx*ut+ty^2*utt+tyy*ut+rz^2*urr+tz^2*utt+sz^2*uss+rzz*ur+szz*us+tzz*ut
             cur = ajrxx+ajryy+ajrzz
             curr = ajrx**2+ajry**2+ajrz**2
             cus = ajsxx+ajsyy+ajszz
             curs = 2.*ajrx*ajsx+2.*ajry*ajsy+2.*ajrz*ajsz
             cuss = ajsx**2+ajsy**2+ajsz**2
             cut = ajtxx+ajtyy+ajtzz
             curt = 2.*ajrz*ajtz+2.*ajrx*ajtx+2.*ajry*ajty
             cust = 2.*ajsx*ajtx+2.*ajsy*ajty+2.*ajsz*ajtz
             cutt = ajtx**2+ajty**2+ajtz**2
             lapCoeff(ma3(-1,-1,-1)) = 0
             lapCoeff(ma3( 0,-1,-1)) = 1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1,-1,-1)) = 0
             lapCoeff(ma3(-1, 0,-1)) = 1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)+cutt/dr(2)**2
             lapCoeff(ma3( 1, 0,-1)) = -1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3(-1, 1,-1)) = 0
             lapCoeff(ma3( 0, 1,-1)) = -1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1, 1,-1)) = 0
             lapCoeff(ma3(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma3( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma3( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(1)*
     & *2-2.*cutt/dr(2)**2
             lapCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
             lapCoeff(ma3(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
             lapCoeff(ma3( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
             lapCoeff(ma3(-1,-1, 1)) = 0
             lapCoeff(ma3( 0,-1, 1)) = -1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1,-1, 1)) = 0
             lapCoeff(ma3(-1, 0, 1)) = -1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)+cutt/dr(2)**2
             lapCoeff(ma3( 1, 0, 1)) = 1./4.*curt/(dr(0)*dr(2))
             lapCoeff(ma3(-1, 1, 1)) = 0
             lapCoeff(ma3( 0, 1, 1)) = 1./4.*cust/(dr(1)*dr(2))
             lapCoeff(ma3( 1, 1, 1)) = 0
            ! Operator x = rx*ur+sx*us+tx*ut
             cur = ajrx
             cus = ajsx
             cut = ajtx
             xCoeff(ma3(-1,-1,-1)) = 0
             xCoeff(ma3( 0,-1,-1)) = 0
             xCoeff(ma3( 1,-1,-1)) = 0
             xCoeff(ma3(-1, 0,-1)) = 0
             xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
             xCoeff(ma3( 1, 0,-1)) = 0
             xCoeff(ma3(-1, 1,-1)) = 0
             xCoeff(ma3( 0, 1,-1)) = 0
             xCoeff(ma3( 1, 1,-1)) = 0
             xCoeff(ma3(-1,-1, 0)) = 0
             xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
             xCoeff(ma3( 1,-1, 0)) = 0
             xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
             xCoeff(ma3( 0, 0, 0)) = 0
             xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
             xCoeff(ma3(-1, 1, 0)) = 0
             xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
             xCoeff(ma3( 1, 1, 0)) = 0
             xCoeff(ma3(-1,-1, 1)) = 0
             xCoeff(ma3( 0,-1, 1)) = 0
             xCoeff(ma3( 1,-1, 1)) = 0
             xCoeff(ma3(-1, 0, 1)) = 0
             xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
             xCoeff(ma3( 1, 0, 1)) = 0
             xCoeff(ma3(-1, 1, 1)) = 0
             xCoeff(ma3( 0, 1, 1)) = 0
             xCoeff(ma3( 1, 1, 1)) = 0
            ! Operator y = ry*ur+sy*us+ty*ut
             cur = ajry
             cus = ajsy
             cut = ajty
             yCoeff(ma3(-1,-1,-1)) = 0
             yCoeff(ma3( 0,-1,-1)) = 0
             yCoeff(ma3( 1,-1,-1)) = 0
             yCoeff(ma3(-1, 0,-1)) = 0
             yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
             yCoeff(ma3( 1, 0,-1)) = 0
             yCoeff(ma3(-1, 1,-1)) = 0
             yCoeff(ma3( 0, 1,-1)) = 0
             yCoeff(ma3( 1, 1,-1)) = 0
             yCoeff(ma3(-1,-1, 0)) = 0
             yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
             yCoeff(ma3( 1,-1, 0)) = 0
             yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
             yCoeff(ma3( 0, 0, 0)) = 0
             yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
             yCoeff(ma3(-1, 1, 0)) = 0
             yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
             yCoeff(ma3( 1, 1, 0)) = 0
             yCoeff(ma3(-1,-1, 1)) = 0
             yCoeff(ma3( 0,-1, 1)) = 0
             yCoeff(ma3( 1,-1, 1)) = 0
             yCoeff(ma3(-1, 0, 1)) = 0
             yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
             yCoeff(ma3( 1, 0, 1)) = 0
             yCoeff(ma3(-1, 1, 1)) = 0
             yCoeff(ma3( 0, 1, 1)) = 0
             yCoeff(ma3( 1, 1, 1)) = 0
             ! Operator z = rz*ur+sz*us+tz*ut
              cur = ajrz
              cus = ajsz
              cut = ajtz
              zCoeff(ma3(-1,-1,-1)) = 0
              zCoeff(ma3( 0,-1,-1)) = 0
              zCoeff(ma3( 1,-1,-1)) = 0
              zCoeff(ma3(-1, 0,-1)) = 0
              zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
              zCoeff(ma3( 1, 0,-1)) = 0
              zCoeff(ma3(-1, 1,-1)) = 0
              zCoeff(ma3( 0, 1,-1)) = 0
              zCoeff(ma3( 1, 1,-1)) = 0
              zCoeff(ma3(-1,-1, 0)) = 0
              zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
              zCoeff(ma3( 1,-1, 0)) = 0
              zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
              zCoeff(ma3( 0, 0, 0)) = 0
              zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
              zCoeff(ma3(-1, 1, 0)) = 0
              zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
              zCoeff(ma3( 1, 1, 0)) = 0
              zCoeff(ma3(-1,-1, 1)) = 0
              zCoeff(ma3( 0,-1, 1)) = 0
              zCoeff(ma3( 1,-1, 1)) = 0
              zCoeff(ma3(-1, 0, 1)) = 0
              zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
              zCoeff(ma3( 1, 0, 1)) = 0
              zCoeff(ma3(-1, 1, 1)) = 0
              zCoeff(ma3( 0, 1, 1)) = 0
              zCoeff(ma3( 1, 1, 1)) = 0
          ! dissCoeff = dr^2*D_rr + ds^2*D_ss [ + dt^2*D_tt ] 
            ! Operator r2Dissipation = urr+uss+utt
             dissCoeff(ma3(-1,-1,-1)) = 0
             dissCoeff(ma3( 0,-1,-1)) = 0
             dissCoeff(ma3( 1,-1,-1)) = 0
             dissCoeff(ma3(-1, 0,-1)) = 0
             dissCoeff(ma3( 0, 0,-1)) = 1
             dissCoeff(ma3( 1, 0,-1)) = 0
             dissCoeff(ma3(-1, 1,-1)) = 0
             dissCoeff(ma3( 0, 1,-1)) = 0
             dissCoeff(ma3( 1, 1,-1)) = 0
             dissCoeff(ma3(-1,-1, 0)) = 0
             dissCoeff(ma3( 0,-1, 0)) = 1
             dissCoeff(ma3( 1,-1, 0)) = 0
             dissCoeff(ma3(-1, 0, 0)) = 1
             dissCoeff(ma3( 0, 0, 0)) = -6
             dissCoeff(ma3( 1, 0, 0)) = 1
             dissCoeff(ma3(-1, 1, 0)) = 0
             dissCoeff(ma3( 0, 1, 0)) = 1
             dissCoeff(ma3( 1, 1, 0)) = 0
             dissCoeff(ma3(-1,-1, 1)) = 0
             dissCoeff(ma3( 0,-1, 1)) = 0
             dissCoeff(ma3( 1,-1, 1)) = 0
             dissCoeff(ma3(-1, 0, 1)) = 0
             dissCoeff(ma3( 0, 0, 1)) = 1
             dissCoeff(ma3( 1, 0, 1)) = 0
             dissCoeff(ma3(-1, 1, 1)) = 0
             dissCoeff(ma3( 0, 1, 1)) = 0
             dissCoeff(ma3( 1, 1, 1)) = 0
          ! for testing, get coeff for div( s grad )
          ! getOpCoeffDivScalarGrad(s(i1,i2,i3,0))
          ! **** get a fourth order dissipation u.rrrr + u.ssss 
          ! evaluate forward derivatives of the current solution: 
          ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
          ! MAXDER = max number of parametric derivatives to precompute.
           uu = u(i1,i2,i3,uc)
           uur = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
           uus = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
           uut = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
          ! Evaluate the spatial derivatives of u (uses uur, uus):
            u0x = ajrx*uur+ajsx*uus+ajtx*uut
            u0y = ajry*uur+ajsy*uus+ajty*uut
             u0z = ajrz*uur+ajsz*uus+ajtz*uut
          ! parametric derivatives of v: 
           vv = u(i1,i2,i3,vc)
           vvr = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dr(0))
           vvs = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dr(1))
           vvt = (-u(i1,i2,i3-1,vc)+u(i1,i2,i3+1,vc))/(2.*dr(2))
            v0x = ajrx*vvr+ajsx*vvs+ajtx*vvt
            v0y = ajry*vvr+ajsy*vvs+ajty*vvt
             v0z = ajrz*vvr+ajsz*vvs+ajtz*vvt
            ww = u(i1,i2,i3,wc)
            wwr = (-u(i1-1,i2,i3,wc)+u(i1+1,i2,i3,wc))/(2.*dr(0))
            wws = (-u(i1,i2-1,i3,wc)+u(i1,i2+1,i3,wc))/(2.*dr(1))
            wwt = (-u(i1,i2,i3-1,wc)+u(i1,i2,i3+1,wc))/(2.*dr(2))
             w0x = ajrx*wwr+ajsx*wws+ajtx*wwt
             w0y = ajry*wwr+ajsy*wws+ajty*wwt
             w0z = ajrz*wwr+ajsz*wws+ajtz*wwt
           adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y)+abs(u0z) + abs(
     & v0x)+abs(v0y)+abs(v0z) + abs(w0x)+abs(w0y)+abs(w0z) )
         if( gridIsMoving.ne.0 )then
           ugv = uu - gv(i1,i2,i3,0)
           vgv = vv - gv(i1,i2,i3,1)
           wgv = ww - gv(i1,i3,i3,2)
         else
           ugv = uu
           vgv = vv
           wgv = ww
         end if
          ! Form : I - nuDt*Delta + aDt*u*Dx + aDt*v*Dy + aDt*w*dz
          !    u0*ux + v0*uy + w0*uz + u*u0x + v*u0y + w*u0z 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(
     & ma3(m1,m2,m3)))+(bDt*u0x*iCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*
     & dissCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpv,eqnu),i1,i2,i3)+(bDt*u0y*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpw,eqnu),i1,i2,i3)+(bDt*u0z*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
          !    u0*vx + v0*vy + w0*vz + u*v0x + v*v0y + w*v0z 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(
     & ma3(m1,m2,m3)))+(bDt*v0y*iCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*
     & dissCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpu,eqnv),i1,i2,i3)+(bDt*v0x*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpw,eqnv),i1,i2,i3)+(bDt*v0z*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
          !    u0*wx + v0*wy + w0*wz + u*w0x + v*w0y + w*w0z 
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-nuDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(
     & m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(
     & ma3(m1,m2,m3)))+(bDt*w0z*iCoeff(ma3(m1,m2,m3)))+(-adCoeff*dt*
     & dissCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnw),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpu,eqnw),i1,i2,i3)+(bDt*w0x*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnw),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpv,eqnw),i1,i2,i3)+(bDt*w0y*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
         if( pdeModel.eq.BoussinesqModel )then
          ! ----------------------------------------------------------------------------
          ! ---------- add the temperature equation to the full system -----------------
          ! ----------------------------------------------------------------------------
           qq = u(i1,i2,i3,qc)
           qqr = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dr(0))
           qqs = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dr(1))
           qqt = (-u(i1,i2,i3-1,qc)+u(i1,i2,i3+1,qc))/(2.*dr(2))
            q0x = ajrx*qqr+ajsx*qqs+ajtx*qqt
            q0y = ajry*qqr+ajsy*qqs+ajty*qqt
             q0z = ajrz*qqr+ajsz*qqs+ajtz*qqt
          if( materialFormat.eq.constantMaterialProperties )then
            ! constant material properties:
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))+(-kDt*lapCoeff(ma3(m1,m2,m3)))+(adt*ugv*xCoeff(ma3(m1,
     & m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*wgv*zCoeff(ma3(
     & m1,m2,m3)))+(-adcBoussinesq*dt*dissCoeff(ma3(m1,m2,m3)))
             end do
             end do
             end do
          else
            ! get coefficients scaled by -dt*implicitFactor: 
             ! ---------- 3D -----------
             ! Get coefficients at nearby points: 
             if( materialFormat.eq.constantMaterialProperties )then
               ! const material properties 
               stop 11199
             else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
               ! piecewise constant material properties
               scale = (-dtImp)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
               Kzzm=thermalKpc(i1  ,i2  ,i3-1)
               Kzmz=thermalKpc(i1  ,i2-1,i3  )
               Kmzz=thermalKpc(i1-1,i2  ,i3  )
               Kzzz=thermalKpc(i1  ,i2  ,i3  )
               Kpzz=thermalKpc(i1+1,i2  ,i3  )
               Kzpz=thermalKpc(i1  ,i2+1,i3  )
               Kzzp=thermalKpc(i1  ,i2  ,i3+1)
             else if( materialFormat.eq.variableMaterialProperties )
     & then
               ! variable material properties
               scale = (-dtImp)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
               Kzzm=thermalKv(i1  ,i2  ,i3-1)
               Kzmz=thermalKv(i1  ,i2-1,i3  )
               Kmzz=thermalKv(i1-1,i2  ,i3  )
               Kzzz=thermalKv(i1  ,i2  ,i3  )
               Kpzz=thermalKv(i1+1,i2  ,i3  )
               Kzpz=thermalKv(i1  ,i2+1,i3  )
               Kzzp=thermalKv(i1  ,i2  ,i3+1)
             end if
             !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
              ! evaluate the jacobian at nearby points:
              ajzzm = (1./((rx(i1,i2,i3-1)*sy(i1,i2,i3-1)-ry(i1,i2,i3-
     & 1)*sx(i1,i2,i3-1))*tz(i1,i2,i3-1)+(ry(i1,i2,i3-1)*sz(i1,i2,i3-
     & 1)-rz(i1,i2,i3-1)*sy(i1,i2,i3-1))*tx(i1,i2,i3-1)+(rz(i1,i2,i3-
     & 1)*sx(i1,i2,i3-1)-rx(i1,i2,i3-1)*sz(i1,i2,i3-1))*ty(i1,i2,i3-1)
     & ))
              ajzmz = (1./((rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,
     & i3)*sx(i1,i2-1,i3))*tz(i1,i2-1,i3)+(ry(i1,i2-1,i3)*sz(i1,i2-1,
     & i3)-rz(i1,i2-1,i3)*sy(i1,i2-1,i3))*tx(i1,i2-1,i3)+(rz(i1,i2-1,
     & i3)*sx(i1,i2-1,i3)-rx(i1,i2-1,i3)*sz(i1,i2-1,i3))*ty(i1,i2-1,
     & i3)))
              ajmzz = (1./((rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,
     & i3)*sx(i1-1,i2,i3))*tz(i1-1,i2,i3)+(ry(i1-1,i2,i3)*sz(i1-1,i2,
     & i3)-rz(i1-1,i2,i3)*sy(i1-1,i2,i3))*tx(i1-1,i2,i3)+(rz(i1-1,i2,
     & i3)*sx(i1-1,i2,i3)-rx(i1-1,i2,i3)*sz(i1-1,i2,i3))*ty(i1-1,i2,
     & i3)))
              ajzzz = (1./((rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*sx(
     & i1,i2,i3))*tz(i1,i2,i3)+(ry(i1,i2,i3)*sz(i1,i2,i3)-rz(i1,i2,i3)
     & *sy(i1,i2,i3))*tx(i1,i2,i3)+(rz(i1,i2,i3)*sx(i1,i2,i3)-rx(i1,
     & i2,i3)*sz(i1,i2,i3))*ty(i1,i2,i3)))
              ajpzz = (1./((rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,
     & i3)*sx(i1+1,i2,i3))*tz(i1+1,i2,i3)+(ry(i1+1,i2,i3)*sz(i1+1,i2,
     & i3)-rz(i1+1,i2,i3)*sy(i1+1,i2,i3))*tx(i1+1,i2,i3)+(rz(i1+1,i2,
     & i3)*sx(i1+1,i2,i3)-rx(i1+1,i2,i3)*sz(i1+1,i2,i3))*ty(i1+1,i2,
     & i3)))
              ajzpz = (1./((rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,
     & i3)*sx(i1,i2+1,i3))*tz(i1,i2+1,i3)+(ry(i1,i2+1,i3)*sz(i1,i2+1,
     & i3)-rz(i1,i2+1,i3)*sy(i1,i2+1,i3))*tx(i1,i2+1,i3)+(rz(i1,i2+1,
     & i3)*sx(i1,i2+1,i3)-rx(i1,i2+1,i3)*sz(i1,i2+1,i3))*ty(i1,i2+1,
     & i3)))
              ajzzp = (1./((rx(i1,i2,i3+1)*sy(i1,i2,i3+1)-ry(i1,i2,i3+
     & 1)*sx(i1,i2,i3+1))*tz(i1,i2,i3+1)+(ry(i1,i2,i3+1)*sz(i1,i2,i3+
     & 1)-rz(i1,i2,i3+1)*sy(i1,i2,i3+1))*tx(i1,i2,i3+1)+(rz(i1,i2,i3+
     & 1)*sx(i1,i2,i3+1)-rx(i1,i2,i3+1)*sz(i1,i2,i3+1))*ty(i1,i2,i3+1)
     & ))
              ! ------------------------------------------------------------------------------------------------------------
              ! au. Get coefficients au11ph, au11mh, au22ph, etc. for 
              !          Dx( K*u.x ) + Dy( K*u.y ) + Dz( K*u.z )  
               au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,i3) +
     &  (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)*
     & rz(i1-1,i2,i3) )
               au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,i3) +
     &  (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)*
     & rz(i1  ,i2,i3) )
               au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,i3) +
     &  (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)*
     & rz(i1+1,i2,i3) )
               au11ph = .5*( au11zzz+au11pzz )
               au11mh = .5*( au11zzz+au11mzz )
               au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,i3) +
     &  (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)*
     & sz(i1,i2-1,i3) )
               au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,i3) +
     &  (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)*
     & sz(i1,i2  ,i3) )
               au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,i3) +
     &  (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)*
     & sz(i1,i2+1,i3) )
               au22ph = .5*( au22zzz+au22zpz )
               au22mh = .5*( au22zzz+au22zmz )
               au33zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*tx(i1,i2,i3-1) +
     &  (Kzzm)*ty(i1,i2,i3-1)*ty(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)*
     & tz(i1,i2,i3-1) )
               au33zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*tx(i1,i2,i3  ) +
     &  (Kzzz)*ty(i1,i2,i3  )*ty(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )*
     & tz(i1,i2,i3  ) )
               au33zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*tx(i1,i2,i3+1) +
     &  (Kzzp)*ty(i1,i2,i3+1)*ty(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)*
     & tz(i1,i2,i3+1) )
               au33ph = .5*( au33zzz+au33zzp )
               au33mh = .5*( au33zzz+au33zzm )
               au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,i3) +
     &  (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)*
     & sz(i1-1,i2,i3) )
               au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,i3) +
     &  (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)*
     & sz(i1  ,i2,i3) )
               au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,i3) +
     &  (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)*
     & sz(i1+1,i2,i3) )
               au13mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*tx(i1-1,i2,i3) +
     &  (Kmzz)*ry(i1-1,i2,i3)*ty(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)*
     & tz(i1-1,i2,i3) )
               au13zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*tx(i1  ,i2,i3) +
     &  (Kzzz)*ry(i1  ,i2,i3)*ty(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)*
     & tz(i1  ,i2,i3) )
               au13pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*tx(i1+1,i2,i3) +
     &  (Kpzz)*ry(i1+1,i2,i3)*ty(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)*
     & tz(i1+1,i2,i3) )
               au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,i3) +
     &  (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)*
     & rz(i1,i2-1,i3) )
               au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,i3) +
     &  (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)*
     & rz(i1,i2  ,i3) )
               au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,i3) +
     &  (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)*
     & rz(i1,i2+1,i3) )
               au23zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*tx(i1,i2-1,i3) +
     &  (Kzmz)*sy(i1,i2-1,i3)*ty(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)*
     & tz(i1,i2-1,i3) )
               au23zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*tx(i1,i2  ,i3) +
     &  (Kzzz)*sy(i1,i2  ,i3)*ty(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)*
     & tz(i1,i2  ,i3) )
               au23zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*tx(i1,i2+1,i3) +
     &  (Kzpz)*sy(i1,i2+1,i3)*ty(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)*
     & tz(i1,i2+1,i3) )
               au31zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*rx(i1,i2,i3-1) +
     &  (Kzzm)*ty(i1,i2,i3-1)*ry(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)*
     & rz(i1,i2,i3-1) )
               au31zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*rx(i1,i2,i3  ) +
     &  (Kzzz)*ty(i1,i2,i3  )*ry(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )*
     & rz(i1,i2,i3  ) )
               au31zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*rx(i1,i2,i3+1) +
     &  (Kzzp)*ty(i1,i2,i3+1)*ry(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)*
     & rz(i1,i2,i3+1) )
               au32zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*sx(i1,i2,i3-1) +
     &  (Kzzm)*ty(i1,i2,i3-1)*sy(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)*
     & sz(i1,i2,i3-1) )
               au32zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*sx(i1,i2,i3  ) +
     &  (Kzzz)*ty(i1,i2,i3  )*sy(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )*
     & sz(i1,i2,i3  ) )
               au32zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*sx(i1,i2,i3+1) +
     &  (Kzzp)*ty(i1,i2,i3+1)*sy(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)*
     & sz(i1,i2,i3+1) )
              ! scaling factors: 
              dr0i = (scale)/(ajzzz*dr(0)**2)
              dr1i = (scale)/(ajzzz*dr(1)**2)
              dr2i = (scale)/(ajzzz*dr(2)**2)
              dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
              dr0dr2 = (scale)/(ajzzz*4.*dr(0)*dr(2))
              dr1dr2 = (scale)/(ajzzz*4.*dr(1)*dr(2))
               au11ph=au11ph*dr0i
               au11mh=au11mh*dr0i
               au22ph=au22ph*dr1i
               au22mh=au22mh*dr1i
               au33ph=au33ph*dr2i
               au33mh=au33mh*dr2i
               au12pzz=au12pzz*dr0dr1
               au12mzz=au12mzz*dr0dr1
               au13pzz=au13pzz*dr0dr2
               au13mzz=au13mzz*dr0dr2
               au21zpz=au21zpz*dr0dr1
               au21zmz=au21zmz*dr0dr1
               au23zpz=au23zpz*dr1dr2
               au23zmz=au23zmz*dr1dr2
               au31zzp=au31zzp*dr0dr2
               au31zzm=au31zzm*dr0dr2
               au32zzp=au32zzp*dr1dr2
               au32zzm=au32zzm*dr1dr2
              coeff(mce3(-1,-1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,-1,-1,cmpq,eqnq),i1,i2,i3)=         au23zmz+
     & au32zzm
              coeff(mce3(1,-1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(-1,0,-1,cmpq,eqnq),i1,i2,i3)=  au13mzz+au31zzm
              coeff(mce3(0,0,-1,cmpq,eqnq),i1,i2,i3)=                  
     &                   au33mh
              coeff(mce3(1,0,-1,cmpq,eqnq),i1,i2,i3)= -au13pzz-au31zzm
              coeff(mce3(-1,1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,1,-1,cmpq,eqnq),i1,i2,i3)=        -au23zpz-
     & au32zzm
              coeff(mce3(1,1,-1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(-1,-1,0,cmpq,eqnq),i1,i2,i3)=  au12mzz+au21zmz
              coeff(mce3(0,-1,0,cmpq,eqnq),i1,i2,i3)=                  
     &     au22mh
              coeff(mce3(1,-1,0,cmpq,eqnq),i1,i2,i3)= -au12pzz-au21zmz
              coeff(mce3(-1,0,0,cmpq,eqnq),i1,i2,i3)=         au11mh
              coeff(mce3(0,0,0,cmpq,eqnq),i1,i2,i3)= -au11ph-au11mh -
     & au22ph -au22mh -au33ph -au33mh
              coeff(mce3(1,0,0,cmpq,eqnq),i1,i2,i3)=  au11ph
              coeff(mce3(-1,1,0,cmpq,eqnq),i1,i2,i3)= -au12mzz-au21zpz
              coeff(mce3(0,1,0,cmpq,eqnq),i1,i2,i3)=               
     & au22ph
              coeff(mce3(1,1,0,cmpq,eqnq),i1,i2,i3)=  au12pzz+au21zpz
              coeff(mce3(-1,-1,1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,-1,1,cmpq,eqnq),i1,i2,i3)=       -au23zmz-
     & au32zzp
              coeff(mce3(1,-1,1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(-1,0,1,cmpq,eqnq),i1,i2,i3)= -au13mzz-au31zzp
              coeff(mce3(0,0,1,cmpq,eqnq),i1,i2,i3)=                   
     &          au33ph
              coeff(mce3(1,0,1,cmpq,eqnq),i1,i2,i3)=  au13pzz+au31zzp
              coeff(mce3(-1,1,1,cmpq,eqnq),i1,i2,i3)= 0.
              coeff(mce3(0,1,1,cmpq,eqnq),i1,i2,i3)=        au23zpz+
     & au32zzp
              coeff(mce3(1,1,1,cmpq,eqnq),i1,i2,i3)= 0.
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=coeff(mce3(m1,
     & m2,m3,cmpq,eqnq),i1,i2,i3)+(iCoeff(ma3(m1,m2,m3)))+(adt*ugv*
     & xCoeff(ma3(m1,m2,m3)))+(adt*vgv*yCoeff(ma3(m1,m2,m3)))+(adt*
     & wgv*zCoeff(ma3(m1,m2,m3)))+(-adcBoussinesq*dt*dissCoeff(ma3(m1,
     & m2,m3)))
             end do
             end do
             end do
          endif
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpu,eqnq),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpu,eqnq),i1,i2,i3)+(bDt*q0x*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpv,eqnq),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpv,eqnq),i1,i2,i3)+(bDt*q0y*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpw,eqnq),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpw,eqnq),i1,i2,i3)+(bDt*q0z*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpq,eqnu),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpq,eqnu),i1,i2,i3)+(teDt*gravity(0)*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpq,eqnv),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpq,eqnv),i1,i2,i3)+(teDt*gravity(1)*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
           do m3=-halfWidth3,halfWidth3
           do m2=-halfWidth,halfWidth
           do m1=-halfWidth,halfWidth
             coeff(mce3(m1,m2,m3,cmpq,eqnw),i1,i2,i3)=coeff(mce3(m1,m2,
     & m3,cmpq,eqnw),i1,i2,i3)+(teDt*gravity(2)*iCoeff(ma3(m1,m2,m3)))
           end do
           end do
           end do
         endif  ! pdeModel.eq.BoussinesqModel
           end if
          end do
          end do
          end do
        end if
        end if
       ! fill matrix BCs
       if( fillCoefficients.eq.1 .or. 
     & evalResidualForBoundaryConditions.eq.1 )then
        indexRange(0,0)=n1a
        indexRange(1,0)=n1b
        indexRange(0,1)=n2a
        indexRange(1,1)=n2b
        indexRange(0,2)=n3a
        indexRange(1,2)=n3b
        do axis=0,nd-1
        do side=0,1
         is1=0
         is2=0
         is3=0
         if( axis.eq.0 )then
           is1=1-2*side
           n1a=indexRange(side,axis)
           n1b=n1a
         else if( axis.eq.1 )then
           is2=1-2*side
           n2a=indexRange(side,axis)
           n2b=n2a
         else
           is3=1-2*side
           n3a=indexRange(side,axis)
           n3b=n3a
         end if
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( bc0.eq.noSlipWall )then
            write(*,'(" ")')
            write(*,'(">>> insImpINS: fill Matrix Boundary Conditions: 
     & useImplicitAmpBCs=",i4," isBulkSolid=",i2)') useImplicitAmpBCs,
     & isBulkSolid
            write(*,'(">>> insImpINS: fill useAddedMassAlgorithm=",i4,
     & " projectAddedMassVelocity=",i4)') useAddedMassAlgorithm,
     & projectAddedMassVelocity
            write(*,'(">>> insImpINS: nu,dt,alpha,beta=",4e10.2)') nu,
     & dt,alpha,beta
         end if
         ! Some Bc's like no-slip wall use extrapolation for ghost, sometimes we turn this off, for example,
         ! for the AMP "no-slip wall" BCs
         extrapolateGhostByDefault=1
         if( fillCoefficients.eq.1 )then
         if( fillCoefficientsScalarSystem.ne.fillCoeffT )then
           ! ---- fill BC coeffs for (u,v,w) ---
           bc0 = bc(side,axis)
           if( bc0.eq.slipWall .and. fillCoefficientsScalarSystem.gt.0 
     & )then
             if( fillCoefficientsScalarSystem.eq.(axis+1) )then
               bc0=dirichletBoundaryCondition
             else
               bc0=neumannBoundaryCondition
             end if
           end if
         if( bc0.eq.noSlipWall .and. useAddedMassAlgorithm.eq.1 .and. 
     & projectAddedMassVelocity.eq.1 .and. isBulkSolid.eq.1 )then
           ! ** AMP NO-SLIP WALL BCs FOR A BULK SOLID INTERFACE *** 
           !  The AMP conditions (see fib and fibr papers) have a limit of
           !  a no-slip wall for a heavy solid and a free surface for a light solid
          write(*,'(" insImpINS: FILL IMPLICIT AMP velocity BCs: 
     & fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
          if( mu.eq.0. )then
            write(*,'(" insImpINS:ERROR: mu=0 : nu,fluidDensity=",
     & 2e10.2)') nu,fluidDensity
            stop 0099
          end if
          extrapolateGhostByDefault=0 ! do NOT extrapolate ghost points (below)
          if( useImplicitAmpBCs.eq.0 )then
            write(*,'(" --- USE OLD WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=0 --- ")')
            ! *** DO THIS FOR NOW ***
            ! Dirichlet BC
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
             do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
           !   opEvalJacobianDerivatives(aj,1)
             ! evaluate the coeff operators 
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
           !   getCoeff(x, xCoeff,aj)
           !   getCoeff(y, yCoeff,aj)
           !    getCoeff(z, zCoeff,aj)
             do n=0,ndu-1
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
                 coeff(mce3(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma3(m1,m2,m3)))
               end do
               end do
               end do
             end do
              end if
             end do
             end do
             end do
          else
           write(*,'("  ")')
           write(*,'(" --- USE NEW WAY FOR IMPLICIT AMP BCS since 
     & useImplicitAmpBCs=1 --- ")')
           ! ********* NEW ADDED MASS BULK SOLID VELOCITY BCS ********
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
                 ! get the outward normal for curvilinear grids
                 an(0)=rsxy(i1,i2,i3,axis,0)
                 an(1)=rsxy(i1,i2,i3,axis,1)
                   an(2)=rsxy(i1,i2,i3,axis,2)
                   anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(
     & 1)**2 + an(2)**2 ) )
                   an(0)=an(0)*anNorm
                   an(1)=an(1)*anNorm
                   an(2)=an(2)*anNorm
             write(*,'(" IMP: AMP BC i1,i2=",2i2," ndu=",i4," normal=",
     & 2e10.2)') i1,i2,ndu,an(0),an(1)
             ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
             ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') AMG(0,0,0),AMG(0,0,1),AMG(0,1,0),AMG(0,1,1)
             ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') AMG(1,0,0),AMG(1,0,1),AMG(1,1,0),AMG(1,1,1)
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! this next call will define the jacobian and its derivatives (parameteric and spatial)
              ajrx = rsxy(i1,i2,i3,0,0)
              ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
              ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
              ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*
     & dr(2))
              ajsx = rsxy(i1,i2,i3,1,0)
              ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
              ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
              ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*
     & dr(2))
              ajtx = rsxy(i1,i2,i3,2,0)
              ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*
     & dr(0))
              ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*
     & dr(1))
              ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*
     & dr(2))
              ajry = rsxy(i1,i2,i3,0,1)
              ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
              ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
              ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*
     & dr(2))
              ajsy = rsxy(i1,i2,i3,1,1)
              ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
              ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
              ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*
     & dr(2))
              ajty = rsxy(i1,i2,i3,2,1)
              ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*
     & dr(0))
              ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*
     & dr(1))
              ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*
     & dr(2))
              ajrz = rsxy(i1,i2,i3,0,2)
              ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*
     & dr(0))
              ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*
     & dr(1))
              ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*
     & dr(2))
              ajsz = rsxy(i1,i2,i3,1,2)
              ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*
     & dr(0))
              ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*
     & dr(1))
              ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*
     & dr(2))
              ajtz = rsxy(i1,i2,i3,2,2)
              ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*
     & dr(0))
              ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*
     & dr(1))
              ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*
     & dr(2))
              ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
              ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
              ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
              ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
              ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
              ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
              ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
              ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
              ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
              ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
              ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
              ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
              ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
              ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
              ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
              ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
              ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
              ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
              ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
              ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
              ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
              ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
              ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
              ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
              ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
              ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
              ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = rx*ur+sx*us+tx*ut
                cur = ajrx
                cus = ajsx
                cut = ajtx
                xCoeff(ma3(-1,-1,-1)) = 0
                xCoeff(ma3( 0,-1,-1)) = 0
                xCoeff(ma3( 1,-1,-1)) = 0
                xCoeff(ma3(-1, 0,-1)) = 0
                xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                xCoeff(ma3( 1, 0,-1)) = 0
                xCoeff(ma3(-1, 1,-1)) = 0
                xCoeff(ma3( 0, 1,-1)) = 0
                xCoeff(ma3( 1, 1,-1)) = 0
                xCoeff(ma3(-1,-1, 0)) = 0
                xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                xCoeff(ma3( 1,-1, 0)) = 0
                xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                xCoeff(ma3( 0, 0, 0)) = 0
                xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                xCoeff(ma3(-1, 1, 0)) = 0
                xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                xCoeff(ma3( 1, 1, 0)) = 0
                xCoeff(ma3(-1,-1, 1)) = 0
                xCoeff(ma3( 0,-1, 1)) = 0
                xCoeff(ma3( 1,-1, 1)) = 0
                xCoeff(ma3(-1, 0, 1)) = 0
                xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                xCoeff(ma3( 1, 0, 1)) = 0
                xCoeff(ma3(-1, 1, 1)) = 0
                xCoeff(ma3( 0, 1, 1)) = 0
                xCoeff(ma3( 1, 1, 1)) = 0
               ! Operator y = ry*ur+sy*us+ty*ut
                cur = ajry
                cus = ajsy
                cut = ajty
                yCoeff(ma3(-1,-1,-1)) = 0
                yCoeff(ma3( 0,-1,-1)) = 0
                yCoeff(ma3( 1,-1,-1)) = 0
                yCoeff(ma3(-1, 0,-1)) = 0
                yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                yCoeff(ma3( 1, 0,-1)) = 0
                yCoeff(ma3(-1, 1,-1)) = 0
                yCoeff(ma3( 0, 1,-1)) = 0
                yCoeff(ma3( 1, 1,-1)) = 0
                yCoeff(ma3(-1,-1, 0)) = 0
                yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma3( 1,-1, 0)) = 0
                yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma3( 0, 0, 0)) = 0
                yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma3(-1, 1, 0)) = 0
                yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma3( 1, 1, 0)) = 0
                yCoeff(ma3(-1,-1, 1)) = 0
                yCoeff(ma3( 0,-1, 1)) = 0
                yCoeff(ma3( 1,-1, 1)) = 0
                yCoeff(ma3(-1, 0, 1)) = 0
                yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                yCoeff(ma3( 1, 0, 1)) = 0
                yCoeff(ma3(-1, 1, 1)) = 0
                yCoeff(ma3( 0, 1, 1)) = 0
                yCoeff(ma3( 1, 1, 1)) = 0
                ! Operator z = rz*ur+sz*us+tz*ut
                 cur = ajrz
                 cus = ajsz
                 cut = ajtz
                 zCoeff(ma3(-1,-1,-1)) = 0
                 zCoeff(ma3( 0,-1,-1)) = 0
                 zCoeff(ma3( 1,-1,-1)) = 0
                 zCoeff(ma3(-1, 0,-1)) = 0
                 zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 zCoeff(ma3( 1, 0,-1)) = 0
                 zCoeff(ma3(-1, 1,-1)) = 0
                 zCoeff(ma3( 0, 1,-1)) = 0
                 zCoeff(ma3( 1, 1,-1)) = 0
                 zCoeff(ma3(-1,-1, 0)) = 0
                 zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 zCoeff(ma3( 1,-1, 0)) = 0
                 zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 zCoeff(ma3( 0, 0, 0)) = 0
                 zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 zCoeff(ma3(-1, 1, 0)) = 0
                 zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 zCoeff(ma3( 1, 1, 0)) = 0
                 zCoeff(ma3(-1,-1, 1)) = 0
                 zCoeff(ma3( 0,-1, 1)) = 0
                 zCoeff(ma3( 1,-1, 1)) = 0
                 zCoeff(ma3(-1, 0, 1)) = 0
                 zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 zCoeff(ma3( 1, 0, 1)) = 0
                 zCoeff(ma3(-1, 1, 1)) = 0
                 zCoeff(ma3( 0, 1, 1)) = 0
                 zCoeff(ma3( 1, 1, 1)) = 0
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
               ! Operator laplacian = 2*rz*tz*urt+rx^2*urr+rxx*ur+sx^2*uss+sxx*us+ry^2*urr+ryy*ur+sy^2*uss+syy*us+2*rx*sx*urs+2*ry*sy*urs+2*rx*tx*urt+2*sx*tx*ust+2*ry*ty*urt+2*sy*ty*ust+2*rz*sz*urs+2*sz*tz*ust+tx^2*utt+txx*ut+ty^2*utt+tyy*ut+rz^2*urr+tz^2*utt+sz^2*uss+rzz*ur+szz*us+tzz*ut
                cur = ajrxx+ajryy+ajrzz
                curr = ajrx**2+ajry**2+ajrz**2
                cus = ajsxx+ajsyy+ajszz
                curs = 2.*ajrx*ajsx+2.*ajry*ajsy+2.*ajrz*ajsz
                cuss = ajsx**2+ajsy**2+ajsz**2
                cut = ajtxx+ajtyy+ajtzz
                curt = 2.*ajrz*ajtz+2.*ajrx*ajtx+2.*ajry*ajty
                cust = 2.*ajsx*ajtx+2.*ajsy*ajty+2.*ajsz*ajtz
                cutt = ajtx**2+ajty**2+ajtz**2
                lapCoeff(ma3(-1,-1,-1)) = 0
                lapCoeff(ma3( 0,-1,-1)) = 1./4.*cust/(dr(1)*dr(2))
                lapCoeff(ma3( 1,-1,-1)) = 0
                lapCoeff(ma3(-1, 0,-1)) = 1./4.*curt/(dr(0)*dr(2))
                lapCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)+cutt/dr(2)**
     & 2
                lapCoeff(ma3( 1, 0,-1)) = -1./4.*curt/(dr(0)*dr(2))
                lapCoeff(ma3(-1, 1,-1)) = 0
                lapCoeff(ma3( 0, 1,-1)) = -1./4.*cust/(dr(1)*dr(2))
                lapCoeff(ma3( 1, 1,-1)) = 0
                lapCoeff(ma3(-1,-1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)+cuss/dr(1)**
     & 2
                lapCoeff(ma3( 1,-1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)+curr/dr(0)**
     & 2
                lapCoeff(ma3( 0, 0, 0)) = -2.*curr/dr(0)**2-2.*cuss/dr(
     & 1)**2-2.*cutt/dr(2)**2
                lapCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)+curr/dr(0)**2
                lapCoeff(ma3(-1, 1, 0)) = -1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)+cuss/dr(1)**2
                lapCoeff(ma3( 1, 1, 0)) = 1./4.*curs/(dr(0)*dr(1))
                lapCoeff(ma3(-1,-1, 1)) = 0
                lapCoeff(ma3( 0,-1, 1)) = -1./4.*cust/(dr(1)*dr(2))
                lapCoeff(ma3( 1,-1, 1)) = 0
                lapCoeff(ma3(-1, 0, 1)) = -1./4.*curt/(dr(0)*dr(2))
                lapCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)+cutt/dr(2)**2
                lapCoeff(ma3( 1, 0, 1)) = 1./4.*curt/(dr(0)*dr(2))
                lapCoeff(ma3(-1, 1, 1)) = 0
                lapCoeff(ma3( 0, 1, 1)) = 1./4.*cust/(dr(1)*dr(2))
                lapCoeff(ma3( 1, 1, 1)) = 0
             ! Equations on the ghost point:
             do m=0,ndc-1
              coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
             end do
             ! Equations on the boundary:
             do m=0,ndc-1
              coeff(m,i1,i2,i3)=0.  ! init all elements to zero
             end do
             beta = implicitFactor*nu*dt
             !! beta = 0. ! TEST
              ! ************************ THREE DIMENSIONS ****************************
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled BC equations for u and v and w 
               ! -------------Coefficients in the the ghost point equation ----------
               do n=0,nd-1
                 ! equation n:  (equation numbers and classify  are set in these calls)
                   classify(i1m,i2m,i3m,eqnu+n)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,0)-an(n)*
     & an(0))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(1,2)*an(n)+delta(n,1)*an(2)+delta(n,2)*an(1)-2.*an(n)*
     & an(1)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,1)-an(n)*an(1))
     & *(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)+((delta(2,0)*an(
     & n)+delta(n,2)*an(0)+delta(n,0)*an(2)-2.*an(n)*an(2)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(2,1)*an(n)+delta(n,2)*an(1)+
     & delta(n,1)*an(2)-2.*an(n)*an(2)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(2,2)*an(n)+delta(n,2)*an(2)+delta(n,2)*an(2)-2.*an(n)*
     & an(2)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,2)-an(n)*an(2))
     & *(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,
     & i3m)=(cmpw+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
                ! We decouple the coupled velocity components: Only add coefficients of u 
                n=0
                  classify(i1m,i2m,i3m,eqnu+n)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,0)-an(n)*
     & an(0))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                  ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                   equationNumber(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
                ! We decouple the coupled velocity components: Only add components of v 
                n=1
                  classify(i1m,i2m,i3m,eqnu+n)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)=((
     & delta(1,0)*an(n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(
     & 1)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*
     & an(1)+delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(1,2)*an(n)+delta(n,1)*an(2)+delta(n,2)*an(1)-2.*
     & an(n)*an(1)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,1)-an(n)*
     & an(1))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                  ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                   equationNumber(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffw )then
                ! We decouple the coupled velocity components: Only add components of w
                n=2
                  classify(i1m,i2m,i3m,eqnu+n)=ghost1
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                   coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)=((
     & delta(2,0)*an(n)+delta(n,2)*an(0)+delta(n,0)*an(2)-2.*an(n)*an(
     & 2)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(2,1)*an(n)+delta(n,2)*
     & an(1)+delta(n,1)*an(2)-2.*an(n)*an(2)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(2,2)*an(n)+delta(n,2)*an(2)+delta(n,2)*an(2)-2.*
     & an(n)*an(2)*an(2))*zCoeff(ma3(m1,m2,m3)))+((+(delta(n,2)-an(n)*
     & an(2))*(zs/mu))*iCoeff(ma3(m1,m2,m3)))
                  ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                   equationNumber(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,
     & i3m)=(cmpw+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                 end do
                 end do
                 end do
              end if
              ! ------------- Coefficients on the boundary ----------------
              ! evaluate the coeff operators 
              if( fillCoefficientsScalarSystem.eq.0 )then
               ! Fill in the coupled equations for u and v  
               ! u equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpv,eqnu),i1,i2,i3)+((-beta*(delta(0,1)-(1.-alpha)*
     & an(0)*an(1)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpw,eqnu),i1,i2,i3)+((-beta*(delta(0,2)-(1.-alpha)*
     & an(0)*an(2)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
               ! v equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpu,eqnv),i1,i2,i3)+((-beta*(delta(1,0)-(1.-alpha)*
     & an(1)*an(0)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpw,eqnv),i1,i2,i3)+((-beta*(delta(1,2)-(1.-alpha)*
     & an(1)*an(2)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
               ! w equation:
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(2,2)-(1.-alpha)*an(2)*an(2)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnw),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpu,eqnw),i1,i2,i3)+((-beta*(delta(2,0)-(1.-alpha)*
     & an(2)*an(0)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=coeff(mce3(
     & m1,m2,m3,cmpw,eqnw),i1,i2,i3)+((-beta*(delta(2,1)-(1.-alpha)*
     & an(2)*an(1)))*lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
               ! We decouple the coupled velocity components: Only add coefficients of u 
               n=0
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(0,0)-(1.-alpha)*an(0)*an(0)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffv )then
               ! We decouple the coupled velocity components: Only add components of v 
               n=1
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(1,1)-(1.-alpha)*an(1)*an(1)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              else if( fillCoefficientsScalarSystem.eq.fillCoeffw )then
               ! We decouple the coupled velocity components: Only add components of w
               n=2
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))+((-beta*(delta(2,2)-(1.-alpha)*an(2)*an(2)))*
     & lapCoeff(ma3(m1,m2,m3)))
                end do
                end do
                end do
              end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent AMP NO-SLIP WALLS  -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.noSlipWall .or. bc(1,axisp1)
     & .eq.noSlipWall .or. bc(0,axisp2).eq.noSlipWall .or. bc(1,
     & axisp2).eq.noSlipWall )then
             write(*,'("insImpINS: ERROR: two AMP no-slip walls meet 
     & at a corner -- not implemented -- fix me")')
             stop 9099
           end if
           ! write(*,'(" Finished filling in implicit AMP velocity BCs -- stop for now")')
           ! stop 1004
          end if
         else if( bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! zero out equations for u,v, [w]    ** but not the T eqn since these may be a Neumann BC ! **
           do m=ce(0,eqnu),ce(0,eqnu+ndu-1+1)-1
            coeff(m,i1,i2,i3)=0.
           end do
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
         !   opEvalJacobianDerivatives(aj,1)
           ! evaluate the coeff operators 
             ! Operator identity 
              iCoeff(ma3(-1,-1,-1)) = 0
              iCoeff(ma3( 0,-1,-1)) = 0
              iCoeff(ma3( 1,-1,-1)) = 0
              iCoeff(ma3(-1, 0,-1)) = 0
              iCoeff(ma3( 0, 0,-1)) = 0
              iCoeff(ma3( 1, 0,-1)) = 0
              iCoeff(ma3(-1, 1,-1)) = 0
              iCoeff(ma3( 0, 1,-1)) = 0
              iCoeff(ma3( 1, 1,-1)) = 0
              iCoeff(ma3(-1,-1, 0)) = 0
              iCoeff(ma3( 0,-1, 0)) = 0
              iCoeff(ma3( 1,-1, 0)) = 0
              iCoeff(ma3(-1, 0, 0)) = 0
              iCoeff(ma3( 0, 0, 0)) = 1.
              iCoeff(ma3( 1, 0, 0)) = 0
              iCoeff(ma3(-1, 1, 0)) = 0
              iCoeff(ma3( 0, 1, 0)) = 0
              iCoeff(ma3( 1, 1, 0)) = 0
              iCoeff(ma3(-1,-1, 1)) = 0
              iCoeff(ma3( 0,-1, 1)) = 0
              iCoeff(ma3( 1,-1, 1)) = 0
              iCoeff(ma3(-1, 0, 1)) = 0
              iCoeff(ma3( 0, 0, 1)) = 0
              iCoeff(ma3( 1, 0, 1)) = 0
              iCoeff(ma3(-1, 1, 1)) = 0
              iCoeff(ma3( 0, 1, 1)) = 0
              iCoeff(ma3( 1, 1, 1)) = 0
         !   getCoeff(x, xCoeff,aj)
         !   getCoeff(y, yCoeff,aj)
         !    getCoeff(z, zCoeff,aj)
           do n=0,ndu-1
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpu+n,eqnu+n),i1,i2,i3)=(iCoeff(
     & ma3(m1,m2,m3)))
             end do
             end do
             end do
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.outflow )then
          ! NOTE: outflowOption==0 is done below (extrapolation)
          if( outflowOption.eq.1 )then
           ! Neumann BC at outflow if outflowOption==1
            ! write(*,'("insImpINS: fill outflow BC into matrix: Neumann BC")')
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  an(2)=rsxy(i1,i2,i3,axis,2)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 + an(2)**2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
                  an(2)=an(2)*anNorm
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                ajrx = rsxy(i1,i2,i3,0,0)
                ajsx = rsxy(i1,i2,i3,1,0)
                ajtx = rsxy(i1,i2,i3,2,0)
                ajry = rsxy(i1,i2,i3,0,1)
                ajsy = rsxy(i1,i2,i3,1,1)
                ajty = rsxy(i1,i2,i3,2,1)
                ajrz = rsxy(i1,i2,i3,0,2)
                ajsz = rsxy(i1,i2,i3,1,2)
                ajtz = rsxy(i1,i2,i3,2,2)
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = rx*ur+sx*us+tx*ut
                  cur = ajrx
                  cus = ajsx
                  cut = ajtx
                  xCoeff(ma3(-1,-1,-1)) = 0
                  xCoeff(ma3( 0,-1,-1)) = 0
                  xCoeff(ma3( 1,-1,-1)) = 0
                  xCoeff(ma3(-1, 0,-1)) = 0
                  xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  xCoeff(ma3( 1, 0,-1)) = 0
                  xCoeff(ma3(-1, 1,-1)) = 0
                  xCoeff(ma3( 0, 1,-1)) = 0
                  xCoeff(ma3( 1, 1,-1)) = 0
                  xCoeff(ma3(-1,-1, 0)) = 0
                  xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  xCoeff(ma3( 1,-1, 0)) = 0
                  xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  xCoeff(ma3( 0, 0, 0)) = 0
                  xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  xCoeff(ma3(-1, 1, 0)) = 0
                  xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  xCoeff(ma3( 1, 1, 0)) = 0
                  xCoeff(ma3(-1,-1, 1)) = 0
                  xCoeff(ma3( 0,-1, 1)) = 0
                  xCoeff(ma3( 1,-1, 1)) = 0
                  xCoeff(ma3(-1, 0, 1)) = 0
                  xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  xCoeff(ma3( 1, 0, 1)) = 0
                  xCoeff(ma3(-1, 1, 1)) = 0
                  xCoeff(ma3( 0, 1, 1)) = 0
                  xCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator y = ry*ur+sy*us+ty*ut
                  cur = ajry
                  cus = ajsy
                  cut = ajty
                  yCoeff(ma3(-1,-1,-1)) = 0
                  yCoeff(ma3( 0,-1,-1)) = 0
                  yCoeff(ma3( 1,-1,-1)) = 0
                  yCoeff(ma3(-1, 0,-1)) = 0
                  yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  yCoeff(ma3( 1, 0,-1)) = 0
                  yCoeff(ma3(-1, 1,-1)) = 0
                  yCoeff(ma3( 0, 1,-1)) = 0
                  yCoeff(ma3( 1, 1,-1)) = 0
                  yCoeff(ma3(-1,-1, 0)) = 0
                  yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  yCoeff(ma3( 1,-1, 0)) = 0
                  yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  yCoeff(ma3( 0, 0, 0)) = 0
                  yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  yCoeff(ma3(-1, 1, 0)) = 0
                  yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  yCoeff(ma3( 1, 1, 0)) = 0
                  yCoeff(ma3(-1,-1, 1)) = 0
                  yCoeff(ma3( 0,-1, 1)) = 0
                  yCoeff(ma3( 1,-1, 1)) = 0
                  yCoeff(ma3(-1, 0, 1)) = 0
                  yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  yCoeff(ma3( 1, 0, 1)) = 0
                  yCoeff(ma3(-1, 1, 1)) = 0
                  yCoeff(ma3( 0, 1, 1)) = 0
                  yCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator identity 
                  iCoeff(ma3(-1,-1,-1)) = 0
                  iCoeff(ma3( 0,-1,-1)) = 0
                  iCoeff(ma3( 1,-1,-1)) = 0
                  iCoeff(ma3(-1, 0,-1)) = 0
                  iCoeff(ma3( 0, 0,-1)) = 0
                  iCoeff(ma3( 1, 0,-1)) = 0
                  iCoeff(ma3(-1, 1,-1)) = 0
                  iCoeff(ma3( 0, 1,-1)) = 0
                  iCoeff(ma3( 1, 1,-1)) = 0
                  iCoeff(ma3(-1,-1, 0)) = 0
                  iCoeff(ma3( 0,-1, 0)) = 0
                  iCoeff(ma3( 1,-1, 0)) = 0
                  iCoeff(ma3(-1, 0, 0)) = 0
                  iCoeff(ma3( 0, 0, 0)) = 1.
                  iCoeff(ma3( 1, 0, 0)) = 0
                  iCoeff(ma3(-1, 1, 0)) = 0
                  iCoeff(ma3( 0, 1, 0)) = 0
                  iCoeff(ma3( 1, 1, 0)) = 0
                  iCoeff(ma3(-1,-1, 1)) = 0
                  iCoeff(ma3( 0,-1, 1)) = 0
                  iCoeff(ma3( 1,-1, 1)) = 0
                  iCoeff(ma3(-1, 0, 1)) = 0
                  iCoeff(ma3( 0, 0, 1)) = 0
                  iCoeff(ma3( 1, 0, 1)) = 0
                  iCoeff(ma3(-1, 1, 1)) = 0
                  iCoeff(ma3( 0, 1, 1)) = 0
                  iCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator z = rz*ur+sz*us+tz*ut
                   cur = ajrz
                   cus = ajsz
                   cut = ajtz
                   zCoeff(ma3(-1,-1,-1)) = 0
                   zCoeff(ma3( 0,-1,-1)) = 0
                   zCoeff(ma3( 1,-1,-1)) = 0
                   zCoeff(ma3(-1, 0,-1)) = 0
                   zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   zCoeff(ma3( 1, 0,-1)) = 0
                   zCoeff(ma3(-1, 1,-1)) = 0
                   zCoeff(ma3( 0, 1,-1)) = 0
                   zCoeff(ma3( 1, 1,-1)) = 0
                   zCoeff(ma3(-1,-1, 0)) = 0
                   zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   zCoeff(ma3( 1,-1, 0)) = 0
                   zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   zCoeff(ma3( 0, 0, 0)) = 0
                   zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   zCoeff(ma3(-1, 1, 0)) = 0
                   zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   zCoeff(ma3( 1, 1, 0)) = 0
                   zCoeff(ma3(-1,-1, 1)) = 0
                   zCoeff(ma3( 0,-1, 1)) = 0
                   zCoeff(ma3( 1,-1, 1)) = 0
                   zCoeff(ma3(-1, 0, 1)) = 0
                   zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   zCoeff(ma3( 1, 0, 1)) = 0
                   zCoeff(ma3(-1, 1, 1)) = 0
                   zCoeff(ma3( 0, 1, 1)) = 0
                   zCoeff(ma3( 1, 1, 1)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma3(m1,m2,m3)
                mm=mce3(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
          else if( outflowOption.ne.0 )then
            write(*,'("insImpINS: fill outflow BC into matrix: ERROR: 
     & outflowOption=",i6)') outflowOption
          end if
         else if( bc0.eq.neumannBoundaryCondition )then
           ! Neumann BC (used by slipWall and scalar systems)
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  an(2)=rsxy(i1,i2,i3,axis,2)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 + an(2)**2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
                  an(2)=an(2)*anNorm
            do n=0,ndu-1
               ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
               ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                ajrx = rsxy(i1,i2,i3,0,0)
                ajsx = rsxy(i1,i2,i3,1,0)
                ajtx = rsxy(i1,i2,i3,2,0)
                ajry = rsxy(i1,i2,i3,0,1)
                ajsy = rsxy(i1,i2,i3,1,1)
                ajty = rsxy(i1,i2,i3,2,1)
                ajrz = rsxy(i1,i2,i3,0,2)
                ajsz = rsxy(i1,i2,i3,1,2)
                ajtz = rsxy(i1,i2,i3,2,2)
               ! evaluate the coeff operators 
               ! getCoeff(identity, iCoeff,aj)
                 ! Operator x = rx*ur+sx*us+tx*ut
                  cur = ajrx
                  cus = ajsx
                  cut = ajtx
                  xCoeff(ma3(-1,-1,-1)) = 0
                  xCoeff(ma3( 0,-1,-1)) = 0
                  xCoeff(ma3( 1,-1,-1)) = 0
                  xCoeff(ma3(-1, 0,-1)) = 0
                  xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  xCoeff(ma3( 1, 0,-1)) = 0
                  xCoeff(ma3(-1, 1,-1)) = 0
                  xCoeff(ma3( 0, 1,-1)) = 0
                  xCoeff(ma3( 1, 1,-1)) = 0
                  xCoeff(ma3(-1,-1, 0)) = 0
                  xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  xCoeff(ma3( 1,-1, 0)) = 0
                  xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  xCoeff(ma3( 0, 0, 0)) = 0
                  xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  xCoeff(ma3(-1, 1, 0)) = 0
                  xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  xCoeff(ma3( 1, 1, 0)) = 0
                  xCoeff(ma3(-1,-1, 1)) = 0
                  xCoeff(ma3( 0,-1, 1)) = 0
                  xCoeff(ma3( 1,-1, 1)) = 0
                  xCoeff(ma3(-1, 0, 1)) = 0
                  xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  xCoeff(ma3( 1, 0, 1)) = 0
                  xCoeff(ma3(-1, 1, 1)) = 0
                  xCoeff(ma3( 0, 1, 1)) = 0
                  xCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator y = ry*ur+sy*us+ty*ut
                  cur = ajry
                  cus = ajsy
                  cut = ajty
                  yCoeff(ma3(-1,-1,-1)) = 0
                  yCoeff(ma3( 0,-1,-1)) = 0
                  yCoeff(ma3( 1,-1,-1)) = 0
                  yCoeff(ma3(-1, 0,-1)) = 0
                  yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  yCoeff(ma3( 1, 0,-1)) = 0
                  yCoeff(ma3(-1, 1,-1)) = 0
                  yCoeff(ma3( 0, 1,-1)) = 0
                  yCoeff(ma3( 1, 1,-1)) = 0
                  yCoeff(ma3(-1,-1, 0)) = 0
                  yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  yCoeff(ma3( 1,-1, 0)) = 0
                  yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  yCoeff(ma3( 0, 0, 0)) = 0
                  yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  yCoeff(ma3(-1, 1, 0)) = 0
                  yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  yCoeff(ma3( 1, 1, 0)) = 0
                  yCoeff(ma3(-1,-1, 1)) = 0
                  yCoeff(ma3( 0,-1, 1)) = 0
                  yCoeff(ma3( 1,-1, 1)) = 0
                  yCoeff(ma3(-1, 0, 1)) = 0
                  yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  yCoeff(ma3( 1, 0, 1)) = 0
                  yCoeff(ma3(-1, 1, 1)) = 0
                  yCoeff(ma3( 0, 1, 1)) = 0
                  yCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator identity 
                  iCoeff(ma3(-1,-1,-1)) = 0
                  iCoeff(ma3( 0,-1,-1)) = 0
                  iCoeff(ma3( 1,-1,-1)) = 0
                  iCoeff(ma3(-1, 0,-1)) = 0
                  iCoeff(ma3( 0, 0,-1)) = 0
                  iCoeff(ma3( 1, 0,-1)) = 0
                  iCoeff(ma3(-1, 1,-1)) = 0
                  iCoeff(ma3( 0, 1,-1)) = 0
                  iCoeff(ma3( 1, 1,-1)) = 0
                  iCoeff(ma3(-1,-1, 0)) = 0
                  iCoeff(ma3( 0,-1, 0)) = 0
                  iCoeff(ma3( 1,-1, 0)) = 0
                  iCoeff(ma3(-1, 0, 0)) = 0
                  iCoeff(ma3( 0, 0, 0)) = 1.
                  iCoeff(ma3( 1, 0, 0)) = 0
                  iCoeff(ma3(-1, 1, 0)) = 0
                  iCoeff(ma3( 0, 1, 0)) = 0
                  iCoeff(ma3( 1, 1, 0)) = 0
                  iCoeff(ma3(-1,-1, 1)) = 0
                  iCoeff(ma3( 0,-1, 1)) = 0
                  iCoeff(ma3( 1,-1, 1)) = 0
                  iCoeff(ma3(-1, 0, 1)) = 0
                  iCoeff(ma3( 0, 0, 1)) = 0
                  iCoeff(ma3( 1, 0, 1)) = 0
                  iCoeff(ma3(-1, 1, 1)) = 0
                  iCoeff(ma3( 0, 1, 1)) = 0
                  iCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator z = rz*ur+sz*us+tz*ut
                   cur = ajrz
                   cus = ajsz
                   cut = ajtz
                   zCoeff(ma3(-1,-1,-1)) = 0
                   zCoeff(ma3( 0,-1,-1)) = 0
                   zCoeff(ma3( 1,-1,-1)) = 0
                   zCoeff(ma3(-1, 0,-1)) = 0
                   zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   zCoeff(ma3( 1, 0,-1)) = 0
                   zCoeff(ma3(-1, 1,-1)) = 0
                   zCoeff(ma3( 0, 1,-1)) = 0
                   zCoeff(ma3( 1, 1,-1)) = 0
                   zCoeff(ma3(-1,-1, 0)) = 0
                   zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   zCoeff(ma3( 1,-1, 0)) = 0
                   zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   zCoeff(ma3( 0, 0, 0)) = 0
                   zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   zCoeff(ma3(-1, 1, 0)) = 0
                   zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   zCoeff(ma3( 1, 1, 0)) = 0
                   zCoeff(ma3(-1,-1, 1)) = 0
                   zCoeff(ma3( 0,-1, 1)) = 0
                   zCoeff(ma3( 1,-1, 1)) = 0
                   zCoeff(ma3(-1, 0, 1)) = 0
                   zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   zCoeff(ma3( 1, 0, 1)) = 0
                   zCoeff(ma3(-1, 1, 1)) = 0
                   zCoeff(ma3( 0, 1, 1)) = 0
                   zCoeff(ma3( 1, 1, 1)) = 0
               i1m=i1-is1  ! ghost point
               i2m=i2-is2
               i3m=i3-is3
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                m=ma3(m1,m2,m3)
                mm=mce3(m1,m2,m3,cmpu+n,eqnu+n)
                 coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                 equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                end do
                end do
                end do
                classify(i1m,i2m,i3m,eqnu+n)=ghost1
            end do
             end if
            end do
            end do
            end do
         else if( bc0.eq.freeSurfaceBoundaryCondition )then
           ! **FREE SURFACE BCs *** 
           ! NEW way: proper free-surface conditions *wdh* Sept 30, 2017
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
                  ! get the outward normal for curvilinear grids
                  an(0)=rsxy(i1,i2,i3,axis,0)
                  an(1)=rsxy(i1,i2,i3,axis,1)
                    an(2)=rsxy(i1,i2,i3,axis,2)
                    anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(
     & 1)**2 + an(2)**2 ) )
                    an(0)=an(0)*anNorm
                    an(1)=an(1)*anNorm
                    an(2)=an(2)*anNorm
              ! write(*,'(" IMP: FREE SURFACE i1,i2=",2i2," ndu=",i4," normal=",2e10.2)') i1,i2,ndu,an(0),an(1)
              ! write(*,'("    :              i1m,i2m,i3m=",3i3)') i1m,i2m,i3m
              ! write(*,'("    : c000,c001,c010,c011=",4e10.2)') CSF(0,0,0),CSF(0,0,1),CSF(0,1,0),CSF(0,1,1)
              ! write(*,'("    : c100,c101,c110,c111=",4e10.2)') CSF(1,0,0),CSF(1,0,1),CSF(1,1,0),CSF(1,1,1)
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! this next call will define the jacobian and its derivatives (parameteric and spatial)
               ajrx = rsxy(i1,i2,i3,0,0)
               ajsx = rsxy(i1,i2,i3,1,0)
               ajtx = rsxy(i1,i2,i3,2,0)
               ajry = rsxy(i1,i2,i3,0,1)
               ajsy = rsxy(i1,i2,i3,1,1)
               ajty = rsxy(i1,i2,i3,2,1)
               ajrz = rsxy(i1,i2,i3,0,2)
               ajsz = rsxy(i1,i2,i3,1,2)
               ajtz = rsxy(i1,i2,i3,2,2)
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = rx*ur+sx*us+tx*ut
                 cur = ajrx
                 cus = ajsx
                 cut = ajtx
                 xCoeff(ma3(-1,-1,-1)) = 0
                 xCoeff(ma3( 0,-1,-1)) = 0
                 xCoeff(ma3( 1,-1,-1)) = 0
                 xCoeff(ma3(-1, 0,-1)) = 0
                 xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 xCoeff(ma3( 1, 0,-1)) = 0
                 xCoeff(ma3(-1, 1,-1)) = 0
                 xCoeff(ma3( 0, 1,-1)) = 0
                 xCoeff(ma3( 1, 1,-1)) = 0
                 xCoeff(ma3(-1,-1, 0)) = 0
                 xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 xCoeff(ma3( 1,-1, 0)) = 0
                 xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 xCoeff(ma3( 0, 0, 0)) = 0
                 xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 xCoeff(ma3(-1, 1, 0)) = 0
                 xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 xCoeff(ma3( 1, 1, 0)) = 0
                 xCoeff(ma3(-1,-1, 1)) = 0
                 xCoeff(ma3( 0,-1, 1)) = 0
                 xCoeff(ma3( 1,-1, 1)) = 0
                 xCoeff(ma3(-1, 0, 1)) = 0
                 xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 xCoeff(ma3( 1, 0, 1)) = 0
                 xCoeff(ma3(-1, 1, 1)) = 0
                 xCoeff(ma3( 0, 1, 1)) = 0
                 xCoeff(ma3( 1, 1, 1)) = 0
                ! Operator y = ry*ur+sy*us+ty*ut
                 cur = ajry
                 cus = ajsy
                 cut = ajty
                 yCoeff(ma3(-1,-1,-1)) = 0
                 yCoeff(ma3( 0,-1,-1)) = 0
                 yCoeff(ma3( 1,-1,-1)) = 0
                 yCoeff(ma3(-1, 0,-1)) = 0
                 yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 yCoeff(ma3( 1, 0,-1)) = 0
                 yCoeff(ma3(-1, 1,-1)) = 0
                 yCoeff(ma3( 0, 1,-1)) = 0
                 yCoeff(ma3( 1, 1,-1)) = 0
                 yCoeff(ma3(-1,-1, 0)) = 0
                 yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 yCoeff(ma3( 1,-1, 0)) = 0
                 yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 yCoeff(ma3( 0, 0, 0)) = 0
                 yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 yCoeff(ma3(-1, 1, 0)) = 0
                 yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 yCoeff(ma3( 1, 1, 0)) = 0
                 yCoeff(ma3(-1,-1, 1)) = 0
                 yCoeff(ma3( 0,-1, 1)) = 0
                 yCoeff(ma3( 1,-1, 1)) = 0
                 yCoeff(ma3(-1, 0, 1)) = 0
                 yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 yCoeff(ma3( 1, 0, 1)) = 0
                 yCoeff(ma3(-1, 1, 1)) = 0
                 yCoeff(ma3( 0, 1, 1)) = 0
                 yCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator z = rz*ur+sz*us+tz*ut
                  cur = ajrz
                  cus = ajsz
                  cut = ajtz
                  zCoeff(ma3(-1,-1,-1)) = 0
                  zCoeff(ma3( 0,-1,-1)) = 0
                  zCoeff(ma3( 1,-1,-1)) = 0
                  zCoeff(ma3(-1, 0,-1)) = 0
                  zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  zCoeff(ma3( 1, 0,-1)) = 0
                  zCoeff(ma3(-1, 1,-1)) = 0
                  zCoeff(ma3( 0, 1,-1)) = 0
                  zCoeff(ma3( 1, 1,-1)) = 0
                  zCoeff(ma3(-1,-1, 0)) = 0
                  zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  zCoeff(ma3( 1,-1, 0)) = 0
                  zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  zCoeff(ma3( 0, 0, 0)) = 0
                  zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  zCoeff(ma3(-1, 1, 0)) = 0
                  zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  zCoeff(ma3( 1, 1, 0)) = 0
                  zCoeff(ma3(-1,-1, 1)) = 0
                  zCoeff(ma3( 0,-1, 1)) = 0
                  zCoeff(ma3( 1,-1, 1)) = 0
                  zCoeff(ma3(-1, 0, 1)) = 0
                  zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  zCoeff(ma3( 1, 0, 1)) = 0
                  zCoeff(ma3(-1, 1, 1)) = 0
                  zCoeff(ma3( 0, 1, 1)) = 0
                  zCoeff(ma3( 1, 1, 1)) = 0
              do m=0,ndc-1
               coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
              end do
               ! ---  3D ---
               if( fillCoefficientsScalarSystem.eq.0 )then
                ! Fill in the coupled equations for u, v and w
                ! write(*,'("(i1,i2,i3) = ",3i3)') i1,i2,i3
                do n=0,nd-1
                  ! equation n:   (equation numbers and classify  are set in these calls)
                  ! write(*,'("n = ",1i3)') n
                  ! write(*,'("    : cn00,cn01,cn02",3e10.2)') CSF(n,0,0),CSF(n,0,1),CSF(n,0,2)
                  ! write(*,'("    : cn10,cn11,cn12",3e10.2)') CSF(n,1,0),CSF(n,1,1),CSF(n,1,2)
                  ! write(*,'("    : cn20,cn21,cn22",3e10.2)') CSF(n,2,0),CSF(n,2,1),CSF(n,2,2)
                    classify(i1m,i2m,i3m,eqnu+n)=ghost1
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                     equationNumber(mce3(m1,m2,m3,cmpu,eqnu+n),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,i3m)+((delta(1,0)*an(
     & n)+delta(n,1)*an(0)+delta(n,0)*an(1)-2.*an(n)*an(1)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(1,1)*an(n)+delta(n,1)*an(1)+
     & delta(n,1)*an(1)-2.*an(n)*an(1)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(1,2)*an(n)+delta(n,1)*an(2)+delta(n,2)*an(1)-2.*an(n)*
     & an(1)*an(2))*zCoeff(ma3(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                     equationNumber(mce3(m1,m2,m3,cmpv,eqnu+n),i1m,i2m,
     & i3m)=(cmpv+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                   do m3=-halfWidth3,halfWidth3
                   do m2=-halfWidth,halfWidth
                   do m1=-halfWidth,halfWidth
                     coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)
     & =coeff(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,i3m)+((delta(2,0)*an(
     & n)+delta(n,2)*an(0)+delta(n,0)*an(2)-2.*an(n)*an(2)*an(0))*
     & xCoeff(ma3(m1,m2,m3)))+((delta(2,1)*an(n)+delta(n,2)*an(1)+
     & delta(n,1)*an(2)-2.*an(n)*an(2)*an(1))*yCoeff(ma3(m1,m2,m3)))+(
     & (delta(2,2)*an(n)+delta(n,2)*an(2)+delta(n,2)*an(2)-2.*an(n)*
     & an(2)*an(2))*zCoeff(ma3(m1,m2,m3)))
                    ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                     equationNumber(mce3(m1,m2,m3,cmpw,eqnu+n),i1m,i2m,
     & i3m)=(cmpw+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                   end do
                   end do
                   end do
                end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffU )
     & then
                 ! We decouple the coupled velocity components: Only add coefficients of u 
                 n=0
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffv )
     & then
                 ! We decouple the coupled velocity components: Only add components of v 
                 n=1
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               else if( fillCoefficientsScalarSystem.eq.fillCoeffw )
     & then
                 ! We decouple the coupled velocity components: Only add components of w
                 n=2
                   classify(i1m,i2m,i3m,eqnu)=ghost1
                  do m3=-halfWidth3,halfWidth3
                  do m2=-halfWidth,halfWidth
                  do m1=-halfWidth,halfWidth
                    coeff(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,i3m)=((
     & delta(0,0)*an(n)+delta(n,0)*an(0)+delta(n,0)*an(0)-2.*an(n)*an(
     & 0)*an(0))*xCoeff(ma3(m1,m2,m3)))+((delta(0,1)*an(n)+delta(n,0)*
     & an(1)+delta(n,1)*an(0)-2.*an(n)*an(0)*an(1))*yCoeff(ma3(m1,m2,
     & m3)))+((delta(0,2)*an(n)+delta(n,0)*an(2)+delta(n,2)*an(0)-2.*
     & an(n)*an(0)*an(2))*zCoeff(ma3(m1,m2,m3)))
                   ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                    equationNumber(mce3(m1,m2,m3,cmpu,eqnu),i1m,i2m,
     & i3m)=(cmpu+1+numberOfComponentsForCoefficients*(i1+m1-
     & equationNumberBase1+equationNumberLength1*(i2+m2-
     & equationNumberBase2+equationNumberLength2*(i3+m3-
     & equationNumberBase3)))+equationOffset)
                  end do
                  end do
                  end do
               end if
             end if
            end do
            end do
            end do
           ! Check for two adjacent free surface BCs -- not supported yet.
           ! Use extrapolation or compatibility at corner since equations are duplicate:
           !     u_x + v_y =0 
           !     u_y + v_x =0
           !Corner:
           !     u_xx = - v_xy = u_yy  -> u_xx - u_yy = 0 
           !     v_xx = - u_xy = v_yy  -> v_xx - v_yy = 0 
           axisp1 = mod(axis+1,nd)
           if( nd.eq.3 )then
             axisp2 = mod(axis+2,nd)
           else
             axisp2=axisp1
           end if
           if( bc(0,axisp1).eq.freeSurfaceBoundaryCondition .or. bc(1,
     & axisp1).eq.freeSurfaceBoundaryCondition .or. bc(0,axisp2)
     & .eq.freeSurfaceBoundaryCondition .or. bc(1,axisp2)
     & .eq.freeSurfaceBoundaryCondition )then
             write(*,'("insImpINS: ERROR: two free surfaces meet at a 
     & corner -- not implemented -- fix me")')
             stop 9099
           end if
         else if( bc0.eq.slipWall )then
           ! SLIP-WALL
           ! NOTE: Here we assume the matrix already includes the interior equations on the boundary 
           ! NOTE: what about corners ???
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
            write(*,'(" insImpINS: slipWall BC not finished for scalar 
     & systems")')
            stop 8130
          end if
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
               ! get the outward normal for curvilinear grids
               an(0)=rsxy(i1,i2,i3,axis,0)
               an(1)=rsxy(i1,i2,i3,axis,1)
                 an(2)=rsxy(i1,i2,i3,axis,2)
                 anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)*
     & *2 + an(2)**2 ) )
                 an(0)=an(0)*anNorm
                 an(1)=an(1)*anNorm
                 an(2)=an(2)*anNorm
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.u"  -->  nDot(mc3(m1,m2,m3,c)) = iCoeff(m1,m2,m3)*an(c-cmpu)
           !nDot=0
           !nDot(mc3(0,0,0,cmpu))=an(0)
           !nDot(mc3(0,0,0,cmpv))=an(1)
           !nDot(mc3(0,0,0,cmpw))=an(2)
           ! Form the matrix for "n.Lu"
           nDotL(0)=an(0)*coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpu,eqnw),i1,i2,i3)
           nDotL(1)=an(0)*coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpv,eqnw),i1,i2,i3)
           nDotL(2)=an(0)*coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpw,eqnw),i1,i2,i3)
           ! form the matrix for  Lu + [ (n.u) - (n.(Lu)) ] n 
           !  eqnu:  (n1*u1+n2*u2+n3*u3)*n1 + L1(u) - nDotL*n1    
           !  eqnv:  (n1*u1+n2*u2+n3*u3)*n2 + L2(u) - nDotL*n2
           !  eqnw:  (n1*u1+n2*u2+n3*u3)*n3 + L3(u) - nDotL*n3
           !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
           do e=eqnu,eqnu+nd-1
           do c=cmpu,cmpu+nd-1
            coeff(mce3(m1,m2,m3,c,e),i1,i2,i3)= coeff(mce3(m1,m2,m3,c,
     & e),i1,i2,i3) + an(e-eqnu)*(iCoeff(ma3(m1,m2,m3))*an(c-cmpu)-
     & nDotL(c-cmpu))
           end do
           end do
           end do
           end do
           end do
          ! fill ghost pt eqn's with a vector symmetry condition:
           ! write(*,'(" VS: i1,i2=",2i2," normal=",2f5.2)') i1,i2,an(0),an(1)
           i1m=i1-is1  ! ghost point
           i2m=i2-is2
           i3m=i3-is3
           do m=0,ndc-1
            coeff(m,i1m,i2m,i3m)=0.  ! init all elements to zero
           end do
           mv(0)=0
           mv(1)=0
           mv(2)=0
           do e=eqnu,eqnu+nd-1
            c=cmpu+e-eqnu
            mv(axis)=2*side-1
            mm=mce3(mv(0),mv(1),mv(2),c,e)  ! matrix index for ghost pt
            coeff(mm,i1m,i2m,i3m)=1.  ! coeff of ghost point
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            mv(axis)=-(2*side-1)
            mm=mce3(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
            coeff(mm,i1m,i2m,i3m)=-1.
             equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            ! now add on the term: 2*(n.u(1))n 
            do c=cmpu,cmpu+nd-1
             mm=mce3(mv(0),mv(1),mv(2),c,e)  ! matrix index for first pt inside
             ! write(*,'(" VS: mm,i1,i2,e,c=",5i2," n,n=",2f5.2)') mm,i1,i2,e,c,an(c-cmpu),an(e-eqnu)
             coeff(mm,i1m,i2m,i3m)=coeff(mm,i1m,i2m,i3m) + 2.*an(c-
     & cmpu)*an(e-eqnu)
              equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(i1+mv(0)-
     & equationNumberBase1+equationNumberLength1*(i2+mv(1)-
     & equationNumberBase2+equationNumberLength2*(i3+mv(2)-
     & equationNumberBase3)))+equationOffset)
            end do
             classify(i1m,i2m,i3m,e)=ghost1
           end do
            end if
           end do
           end do
           end do
         else if( bc0.eq.inflowWithPandTV )then
           ! ------------------------------------------------
           ! ---- pressure and tangential velocity given ----
           ! ------------------------------------------------
          write(*,'("insImpINS: fill in BC pressure and tangential 
     & velocity ** check me** ")')
          if( fillCoefficientsScalarSystem.ge.fillCoeffU .and. 
     & fillCoefficientsScalarSystem.le.fillCoeffW )then
           write(*,'(" fillCoefficientsScalarSystem=",i4)') 
     & fillCoefficientsScalarSystem
           ! --- fill coefficients for scalar systems ---
           ! This only works if the boundary face is on a plane x=constant, y=constant or z=constant 
           ! Added May 13, 2017 *wdh*
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*
     & dr(2))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*
     & dr(2))
             ajtx = rsxy(i1,i2,i3,2,0)
             ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*
     & dr(0))
             ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*
     & dr(1))
             ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*
     & dr(2))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*
     & dr(2))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*
     & dr(2))
             ajty = rsxy(i1,i2,i3,2,1)
             ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*
     & dr(0))
             ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*
     & dr(1))
             ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*
     & dr(2))
             ajrz = rsxy(i1,i2,i3,0,2)
             ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*
     & dr(0))
             ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*
     & dr(1))
             ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*
     & dr(2))
             ajsz = rsxy(i1,i2,i3,1,2)
             ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*
     & dr(0))
             ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*
     & dr(1))
             ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*
     & dr(2))
             ajtz = rsxy(i1,i2,i3,2,2)
             ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*
     & dr(0))
             ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*
     & dr(1))
             ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*
     & dr(2))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
             ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
             ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
             ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
             ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
             ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
             ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
             ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
             ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
             ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
             ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
             ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
             ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
             ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
             ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
             ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
             ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
             ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
             ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
             ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
             ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
             ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
             ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
             ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
             ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
             ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
             ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  an(2)=rsxy(i1,i2,i3,axis,2)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 + an(2)**2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
                  an(2)=an(2)*anNorm
            ! -- The grid face should be in a coordinate direction,
            !   normalAxis = 0,1, or 2 indicates this direction
            if( abs(abs(an(0))-1.) .lt. normalTol )then
             normalAxis=0
            else if( abs(abs(an(1))-1.) .lt. normalTol )then
             normalAxis=1
            else if(  abs(abs(an(2))-1.) .lt. normalTol )then
             normalAxis=2
            else
              write(*,'(" insImpINS: ERROR: inflowWithPandTV, scalar 
     & systems but normals funny")')
              write(*,'("  --> the normals should be in a coordinate 
     & direction")')
              stop 1287
            end if
            !  --- equations for u ---
            if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
              if( normalAxis.eq.0 )then
               ! boundary face is x=constant:
               !  Give u.n = 0 
                   ! get the outward normal for curvilinear grids
                   an(0)=rsxy(i1,i2,i3,axis,0)
                   an(1)=rsxy(i1,i2,i3,axis,1)
                     an(2)=rsxy(i1,i2,i3,axis,2)
                     anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + 
     & an(1)**2 + an(2)**2 ) )
                     an(0)=an(0)*anNorm
                     an(1)=an(1)*anNorm
                     an(2)=an(2)*anNorm
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                 ajrx = rsxy(i1,i2,i3,0,0)
                 ajsx = rsxy(i1,i2,i3,1,0)
                 ajtx = rsxy(i1,i2,i3,2,0)
                 ajry = rsxy(i1,i2,i3,0,1)
                 ajsy = rsxy(i1,i2,i3,1,1)
                 ajty = rsxy(i1,i2,i3,2,1)
                 ajrz = rsxy(i1,i2,i3,0,2)
                 ajsz = rsxy(i1,i2,i3,1,2)
                 ajtz = rsxy(i1,i2,i3,2,2)
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = rx*ur+sx*us+tx*ut
                   cur = ajrx
                   cus = ajsx
                   cut = ajtx
                   xCoeff(ma3(-1,-1,-1)) = 0
                   xCoeff(ma3( 0,-1,-1)) = 0
                   xCoeff(ma3( 1,-1,-1)) = 0
                   xCoeff(ma3(-1, 0,-1)) = 0
                   xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   xCoeff(ma3( 1, 0,-1)) = 0
                   xCoeff(ma3(-1, 1,-1)) = 0
                   xCoeff(ma3( 0, 1,-1)) = 0
                   xCoeff(ma3( 1, 1,-1)) = 0
                   xCoeff(ma3(-1,-1, 0)) = 0
                   xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   xCoeff(ma3( 1,-1, 0)) = 0
                   xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   xCoeff(ma3( 0, 0, 0)) = 0
                   xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   xCoeff(ma3(-1, 1, 0)) = 0
                   xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   xCoeff(ma3( 1, 1, 0)) = 0
                   xCoeff(ma3(-1,-1, 1)) = 0
                   xCoeff(ma3( 0,-1, 1)) = 0
                   xCoeff(ma3( 1,-1, 1)) = 0
                   xCoeff(ma3(-1, 0, 1)) = 0
                   xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   xCoeff(ma3( 1, 0, 1)) = 0
                   xCoeff(ma3(-1, 1, 1)) = 0
                   xCoeff(ma3( 0, 1, 1)) = 0
                   xCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator y = ry*ur+sy*us+ty*ut
                   cur = ajry
                   cus = ajsy
                   cut = ajty
                   yCoeff(ma3(-1,-1,-1)) = 0
                   yCoeff(ma3( 0,-1,-1)) = 0
                   yCoeff(ma3( 1,-1,-1)) = 0
                   yCoeff(ma3(-1, 0,-1)) = 0
                   yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   yCoeff(ma3( 1, 0,-1)) = 0
                   yCoeff(ma3(-1, 1,-1)) = 0
                   yCoeff(ma3( 0, 1,-1)) = 0
                   yCoeff(ma3( 1, 1,-1)) = 0
                   yCoeff(ma3(-1,-1, 0)) = 0
                   yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   yCoeff(ma3( 1,-1, 0)) = 0
                   yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   yCoeff(ma3( 0, 0, 0)) = 0
                   yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   yCoeff(ma3(-1, 1, 0)) = 0
                   yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   yCoeff(ma3( 1, 1, 0)) = 0
                   yCoeff(ma3(-1,-1, 1)) = 0
                   yCoeff(ma3( 0,-1, 1)) = 0
                   yCoeff(ma3( 1,-1, 1)) = 0
                   yCoeff(ma3(-1, 0, 1)) = 0
                   yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   yCoeff(ma3( 1, 0, 1)) = 0
                   yCoeff(ma3(-1, 1, 1)) = 0
                   yCoeff(ma3( 0, 1, 1)) = 0
                   yCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator identity 
                   iCoeff(ma3(-1,-1,-1)) = 0
                   iCoeff(ma3( 0,-1,-1)) = 0
                   iCoeff(ma3( 1,-1,-1)) = 0
                   iCoeff(ma3(-1, 0,-1)) = 0
                   iCoeff(ma3( 0, 0,-1)) = 0
                   iCoeff(ma3( 1, 0,-1)) = 0
                   iCoeff(ma3(-1, 1,-1)) = 0
                   iCoeff(ma3( 0, 1,-1)) = 0
                   iCoeff(ma3( 1, 1,-1)) = 0
                   iCoeff(ma3(-1,-1, 0)) = 0
                   iCoeff(ma3( 0,-1, 0)) = 0
                   iCoeff(ma3( 1,-1, 0)) = 0
                   iCoeff(ma3(-1, 0, 0)) = 0
                   iCoeff(ma3( 0, 0, 0)) = 1.
                   iCoeff(ma3( 1, 0, 0)) = 0
                   iCoeff(ma3(-1, 1, 0)) = 0
                   iCoeff(ma3( 0, 1, 0)) = 0
                   iCoeff(ma3( 1, 1, 0)) = 0
                   iCoeff(ma3(-1,-1, 1)) = 0
                   iCoeff(ma3( 0,-1, 1)) = 0
                   iCoeff(ma3( 1,-1, 1)) = 0
                   iCoeff(ma3(-1, 0, 1)) = 0
                   iCoeff(ma3( 0, 0, 1)) = 0
                   iCoeff(ma3( 1, 0, 1)) = 0
                   iCoeff(ma3(-1, 1, 1)) = 0
                   iCoeff(ma3( 0, 1, 1)) = 0
                   iCoeff(ma3( 1, 1, 1)) = 0
                   ! Operator z = rz*ur+sz*us+tz*ut
                    cur = ajrz
                    cus = ajsz
                    cut = ajtz
                    zCoeff(ma3(-1,-1,-1)) = 0
                    zCoeff(ma3( 0,-1,-1)) = 0
                    zCoeff(ma3( 1,-1,-1)) = 0
                    zCoeff(ma3(-1, 0,-1)) = 0
                    zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                    zCoeff(ma3( 1, 0,-1)) = 0
                    zCoeff(ma3(-1, 1,-1)) = 0
                    zCoeff(ma3( 0, 1,-1)) = 0
                    zCoeff(ma3( 1, 1,-1)) = 0
                    zCoeff(ma3(-1,-1, 0)) = 0
                    zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                    zCoeff(ma3( 1,-1, 0)) = 0
                    zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                    zCoeff(ma3( 0, 0, 0)) = 0
                    zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                    zCoeff(ma3(-1, 1, 0)) = 0
                    zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                    zCoeff(ma3( 1, 1, 0)) = 0
                    zCoeff(ma3(-1,-1, 1)) = 0
                    zCoeff(ma3( 0,-1, 1)) = 0
                    zCoeff(ma3( 1,-1, 1)) = 0
                    zCoeff(ma3(-1, 0, 1)) = 0
                    zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                    zCoeff(ma3( 1, 0, 1)) = 0
                    zCoeff(ma3(-1, 1, 1)) = 0
                    zCoeff(ma3( 0, 1, 1)) = 0
                    zCoeff(ma3( 1, 1, 1)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma3(m1,m2,m3)
                 mm=mce3(m1,m2,m3,cmpu,eqnu)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnu)=ghost1
              else
               ! boundary face is y=constant, or z=constant : give u=0 
               do m=ce(0,eqnu),ce(0,eqnu+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpu,eqnu)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnu)=extrapolation
              end if
            !  --- equations for v ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
              if( normalAxis.eq.1 )then
               ! boundary face is y=constant:
               !  Give v.n = 0 
                   ! get the outward normal for curvilinear grids
                   an(0)=rsxy(i1,i2,i3,axis,0)
                   an(1)=rsxy(i1,i2,i3,axis,1)
                     an(2)=rsxy(i1,i2,i3,axis,2)
                     anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + 
     & an(1)**2 + an(2)**2 ) )
                     an(0)=an(0)*anNorm
                     an(1)=an(1)*anNorm
                     an(2)=an(2)*anNorm
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                 ajrx = rsxy(i1,i2,i3,0,0)
                 ajsx = rsxy(i1,i2,i3,1,0)
                 ajtx = rsxy(i1,i2,i3,2,0)
                 ajry = rsxy(i1,i2,i3,0,1)
                 ajsy = rsxy(i1,i2,i3,1,1)
                 ajty = rsxy(i1,i2,i3,2,1)
                 ajrz = rsxy(i1,i2,i3,0,2)
                 ajsz = rsxy(i1,i2,i3,1,2)
                 ajtz = rsxy(i1,i2,i3,2,2)
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = rx*ur+sx*us+tx*ut
                   cur = ajrx
                   cus = ajsx
                   cut = ajtx
                   xCoeff(ma3(-1,-1,-1)) = 0
                   xCoeff(ma3( 0,-1,-1)) = 0
                   xCoeff(ma3( 1,-1,-1)) = 0
                   xCoeff(ma3(-1, 0,-1)) = 0
                   xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   xCoeff(ma3( 1, 0,-1)) = 0
                   xCoeff(ma3(-1, 1,-1)) = 0
                   xCoeff(ma3( 0, 1,-1)) = 0
                   xCoeff(ma3( 1, 1,-1)) = 0
                   xCoeff(ma3(-1,-1, 0)) = 0
                   xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   xCoeff(ma3( 1,-1, 0)) = 0
                   xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   xCoeff(ma3( 0, 0, 0)) = 0
                   xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   xCoeff(ma3(-1, 1, 0)) = 0
                   xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   xCoeff(ma3( 1, 1, 0)) = 0
                   xCoeff(ma3(-1,-1, 1)) = 0
                   xCoeff(ma3( 0,-1, 1)) = 0
                   xCoeff(ma3( 1,-1, 1)) = 0
                   xCoeff(ma3(-1, 0, 1)) = 0
                   xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   xCoeff(ma3( 1, 0, 1)) = 0
                   xCoeff(ma3(-1, 1, 1)) = 0
                   xCoeff(ma3( 0, 1, 1)) = 0
                   xCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator y = ry*ur+sy*us+ty*ut
                   cur = ajry
                   cus = ajsy
                   cut = ajty
                   yCoeff(ma3(-1,-1,-1)) = 0
                   yCoeff(ma3( 0,-1,-1)) = 0
                   yCoeff(ma3( 1,-1,-1)) = 0
                   yCoeff(ma3(-1, 0,-1)) = 0
                   yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   yCoeff(ma3( 1, 0,-1)) = 0
                   yCoeff(ma3(-1, 1,-1)) = 0
                   yCoeff(ma3( 0, 1,-1)) = 0
                   yCoeff(ma3( 1, 1,-1)) = 0
                   yCoeff(ma3(-1,-1, 0)) = 0
                   yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   yCoeff(ma3( 1,-1, 0)) = 0
                   yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   yCoeff(ma3( 0, 0, 0)) = 0
                   yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   yCoeff(ma3(-1, 1, 0)) = 0
                   yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   yCoeff(ma3( 1, 1, 0)) = 0
                   yCoeff(ma3(-1,-1, 1)) = 0
                   yCoeff(ma3( 0,-1, 1)) = 0
                   yCoeff(ma3( 1,-1, 1)) = 0
                   yCoeff(ma3(-1, 0, 1)) = 0
                   yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   yCoeff(ma3( 1, 0, 1)) = 0
                   yCoeff(ma3(-1, 1, 1)) = 0
                   yCoeff(ma3( 0, 1, 1)) = 0
                   yCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator identity 
                   iCoeff(ma3(-1,-1,-1)) = 0
                   iCoeff(ma3( 0,-1,-1)) = 0
                   iCoeff(ma3( 1,-1,-1)) = 0
                   iCoeff(ma3(-1, 0,-1)) = 0
                   iCoeff(ma3( 0, 0,-1)) = 0
                   iCoeff(ma3( 1, 0,-1)) = 0
                   iCoeff(ma3(-1, 1,-1)) = 0
                   iCoeff(ma3( 0, 1,-1)) = 0
                   iCoeff(ma3( 1, 1,-1)) = 0
                   iCoeff(ma3(-1,-1, 0)) = 0
                   iCoeff(ma3( 0,-1, 0)) = 0
                   iCoeff(ma3( 1,-1, 0)) = 0
                   iCoeff(ma3(-1, 0, 0)) = 0
                   iCoeff(ma3( 0, 0, 0)) = 1.
                   iCoeff(ma3( 1, 0, 0)) = 0
                   iCoeff(ma3(-1, 1, 0)) = 0
                   iCoeff(ma3( 0, 1, 0)) = 0
                   iCoeff(ma3( 1, 1, 0)) = 0
                   iCoeff(ma3(-1,-1, 1)) = 0
                   iCoeff(ma3( 0,-1, 1)) = 0
                   iCoeff(ma3( 1,-1, 1)) = 0
                   iCoeff(ma3(-1, 0, 1)) = 0
                   iCoeff(ma3( 0, 0, 1)) = 0
                   iCoeff(ma3( 1, 0, 1)) = 0
                   iCoeff(ma3(-1, 1, 1)) = 0
                   iCoeff(ma3( 0, 1, 1)) = 0
                   iCoeff(ma3( 1, 1, 1)) = 0
                   ! Operator z = rz*ur+sz*us+tz*ut
                    cur = ajrz
                    cus = ajsz
                    cut = ajtz
                    zCoeff(ma3(-1,-1,-1)) = 0
                    zCoeff(ma3( 0,-1,-1)) = 0
                    zCoeff(ma3( 1,-1,-1)) = 0
                    zCoeff(ma3(-1, 0,-1)) = 0
                    zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                    zCoeff(ma3( 1, 0,-1)) = 0
                    zCoeff(ma3(-1, 1,-1)) = 0
                    zCoeff(ma3( 0, 1,-1)) = 0
                    zCoeff(ma3( 1, 1,-1)) = 0
                    zCoeff(ma3(-1,-1, 0)) = 0
                    zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                    zCoeff(ma3( 1,-1, 0)) = 0
                    zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                    zCoeff(ma3( 0, 0, 0)) = 0
                    zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                    zCoeff(ma3(-1, 1, 0)) = 0
                    zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                    zCoeff(ma3( 1, 1, 0)) = 0
                    zCoeff(ma3(-1,-1, 1)) = 0
                    zCoeff(ma3( 0,-1, 1)) = 0
                    zCoeff(ma3( 1,-1, 1)) = 0
                    zCoeff(ma3(-1, 0, 1)) = 0
                    zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                    zCoeff(ma3( 1, 0, 1)) = 0
                    zCoeff(ma3(-1, 1, 1)) = 0
                    zCoeff(ma3( 0, 1, 1)) = 0
                    zCoeff(ma3( 1, 1, 1)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma3(m1,m2,m3)
                 mm=mce3(m1,m2,m3,cmpv,eqnv)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnv,i1m,i2m,i3m) is centered on (cmpv,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnv)=ghost1
              else
               ! boundary face is x=constant, or z=constant : give v=0 
               do m=ce(0,eqnv),ce(0,eqnv+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpv,eqnv)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnv)=extrapolation
              end if
            !  --- equations for w ---
            else if( fillCoefficientsScalarSystem.eq.fillCoeffW )then
              if( normalAxis.eq.2 )then
               ! boundary face is z=constant:
               !  Give w.n = 0 
                   ! get the outward normal for curvilinear grids
                   an(0)=rsxy(i1,i2,i3,axis,0)
                   an(1)=rsxy(i1,i2,i3,axis,1)
                     an(2)=rsxy(i1,i2,i3,axis,2)
                     anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + 
     & an(1)**2 + an(2)**2 ) )
                     an(0)=an(0)*anNorm
                     an(1)=an(1)*anNorm
                     an(2)=an(2)*anNorm
                ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
                ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
                 ! this next call will define the jacobian and its derivatives (parameteric and spatial)
                 ajrx = rsxy(i1,i2,i3,0,0)
                 ajsx = rsxy(i1,i2,i3,1,0)
                 ajtx = rsxy(i1,i2,i3,2,0)
                 ajry = rsxy(i1,i2,i3,0,1)
                 ajsy = rsxy(i1,i2,i3,1,1)
                 ajty = rsxy(i1,i2,i3,2,1)
                 ajrz = rsxy(i1,i2,i3,0,2)
                 ajsz = rsxy(i1,i2,i3,1,2)
                 ajtz = rsxy(i1,i2,i3,2,2)
                ! evaluate the coeff operators 
                ! getCoeff(identity, iCoeff,aj)
                  ! Operator x = rx*ur+sx*us+tx*ut
                   cur = ajrx
                   cus = ajsx
                   cut = ajtx
                   xCoeff(ma3(-1,-1,-1)) = 0
                   xCoeff(ma3( 0,-1,-1)) = 0
                   xCoeff(ma3( 1,-1,-1)) = 0
                   xCoeff(ma3(-1, 0,-1)) = 0
                   xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   xCoeff(ma3( 1, 0,-1)) = 0
                   xCoeff(ma3(-1, 1,-1)) = 0
                   xCoeff(ma3( 0, 1,-1)) = 0
                   xCoeff(ma3( 1, 1,-1)) = 0
                   xCoeff(ma3(-1,-1, 0)) = 0
                   xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   xCoeff(ma3( 1,-1, 0)) = 0
                   xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   xCoeff(ma3( 0, 0, 0)) = 0
                   xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   xCoeff(ma3(-1, 1, 0)) = 0
                   xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   xCoeff(ma3( 1, 1, 0)) = 0
                   xCoeff(ma3(-1,-1, 1)) = 0
                   xCoeff(ma3( 0,-1, 1)) = 0
                   xCoeff(ma3( 1,-1, 1)) = 0
                   xCoeff(ma3(-1, 0, 1)) = 0
                   xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   xCoeff(ma3( 1, 0, 1)) = 0
                   xCoeff(ma3(-1, 1, 1)) = 0
                   xCoeff(ma3( 0, 1, 1)) = 0
                   xCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator y = ry*ur+sy*us+ty*ut
                   cur = ajry
                   cus = ajsy
                   cut = ajty
                   yCoeff(ma3(-1,-1,-1)) = 0
                   yCoeff(ma3( 0,-1,-1)) = 0
                   yCoeff(ma3( 1,-1,-1)) = 0
                   yCoeff(ma3(-1, 0,-1)) = 0
                   yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                   yCoeff(ma3( 1, 0,-1)) = 0
                   yCoeff(ma3(-1, 1,-1)) = 0
                   yCoeff(ma3( 0, 1,-1)) = 0
                   yCoeff(ma3( 1, 1,-1)) = 0
                   yCoeff(ma3(-1,-1, 0)) = 0
                   yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                   yCoeff(ma3( 1,-1, 0)) = 0
                   yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                   yCoeff(ma3( 0, 0, 0)) = 0
                   yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                   yCoeff(ma3(-1, 1, 0)) = 0
                   yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                   yCoeff(ma3( 1, 1, 0)) = 0
                   yCoeff(ma3(-1,-1, 1)) = 0
                   yCoeff(ma3( 0,-1, 1)) = 0
                   yCoeff(ma3( 1,-1, 1)) = 0
                   yCoeff(ma3(-1, 0, 1)) = 0
                   yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                   yCoeff(ma3( 1, 0, 1)) = 0
                   yCoeff(ma3(-1, 1, 1)) = 0
                   yCoeff(ma3( 0, 1, 1)) = 0
                   yCoeff(ma3( 1, 1, 1)) = 0
                  ! Operator identity 
                   iCoeff(ma3(-1,-1,-1)) = 0
                   iCoeff(ma3( 0,-1,-1)) = 0
                   iCoeff(ma3( 1,-1,-1)) = 0
                   iCoeff(ma3(-1, 0,-1)) = 0
                   iCoeff(ma3( 0, 0,-1)) = 0
                   iCoeff(ma3( 1, 0,-1)) = 0
                   iCoeff(ma3(-1, 1,-1)) = 0
                   iCoeff(ma3( 0, 1,-1)) = 0
                   iCoeff(ma3( 1, 1,-1)) = 0
                   iCoeff(ma3(-1,-1, 0)) = 0
                   iCoeff(ma3( 0,-1, 0)) = 0
                   iCoeff(ma3( 1,-1, 0)) = 0
                   iCoeff(ma3(-1, 0, 0)) = 0
                   iCoeff(ma3( 0, 0, 0)) = 1.
                   iCoeff(ma3( 1, 0, 0)) = 0
                   iCoeff(ma3(-1, 1, 0)) = 0
                   iCoeff(ma3( 0, 1, 0)) = 0
                   iCoeff(ma3( 1, 1, 0)) = 0
                   iCoeff(ma3(-1,-1, 1)) = 0
                   iCoeff(ma3( 0,-1, 1)) = 0
                   iCoeff(ma3( 1,-1, 1)) = 0
                   iCoeff(ma3(-1, 0, 1)) = 0
                   iCoeff(ma3( 0, 0, 1)) = 0
                   iCoeff(ma3( 1, 0, 1)) = 0
                   iCoeff(ma3(-1, 1, 1)) = 0
                   iCoeff(ma3( 0, 1, 1)) = 0
                   iCoeff(ma3( 1, 1, 1)) = 0
                   ! Operator z = rz*ur+sz*us+tz*ut
                    cur = ajrz
                    cus = ajsz
                    cut = ajtz
                    zCoeff(ma3(-1,-1,-1)) = 0
                    zCoeff(ma3( 0,-1,-1)) = 0
                    zCoeff(ma3( 1,-1,-1)) = 0
                    zCoeff(ma3(-1, 0,-1)) = 0
                    zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                    zCoeff(ma3( 1, 0,-1)) = 0
                    zCoeff(ma3(-1, 1,-1)) = 0
                    zCoeff(ma3( 0, 1,-1)) = 0
                    zCoeff(ma3( 1, 1,-1)) = 0
                    zCoeff(ma3(-1,-1, 0)) = 0
                    zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                    zCoeff(ma3( 1,-1, 0)) = 0
                    zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                    zCoeff(ma3( 0, 0, 0)) = 0
                    zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                    zCoeff(ma3(-1, 1, 0)) = 0
                    zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                    zCoeff(ma3( 1, 1, 0)) = 0
                    zCoeff(ma3(-1,-1, 1)) = 0
                    zCoeff(ma3( 0,-1, 1)) = 0
                    zCoeff(ma3( 1,-1, 1)) = 0
                    zCoeff(ma3(-1, 0, 1)) = 0
                    zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                    zCoeff(ma3( 1, 0, 1)) = 0
                    zCoeff(ma3(-1, 1, 1)) = 0
                    zCoeff(ma3( 0, 1, 1)) = 0
                    zCoeff(ma3( 1, 1, 1)) = 0
                i1m=i1-is1  ! ghost point
                i2m=i2-is2
                i3m=i3-is3
                 do m3=-halfWidth3,halfWidth3
                 do m2=-halfWidth,halfWidth
                 do m1=-halfWidth,halfWidth
                 m=ma3(m1,m2,m3)
                 mm=mce3(m1,m2,m3,cmpw,eqnw)
                  coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*
     & yCoeff(m)+an(2)*zCoeff(m))+0.*iCoeff(m)
                 ! The equation for pt (eqnw,i1m,i2m,i3m) is centered on (cmpw,i1,i2,i3): 
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
                 end do
                 end do
                 end do
                 classify(i1m,i2m,i3m,eqnw)=ghost1
              else
               ! boundary face is x=constant, or y=constant : give w=0 
               do m=ce(0,eqnw),ce(0,eqnw+1)-1
                coeff(m,i1,i2,i3)=0.
               end do
                do m3=-halfWidth3,halfWidth3
                do m2=-halfWidth,halfWidth
                do m1=-halfWidth,halfWidth
                  coeff(mce3(m1,m2,m3,cmpw,eqnw),i1,i2,i3)=(iCoeff(ma3(
     & m1,m2,m3)))
                end do
                end do
                end do
                if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                  stop 7734
                end if
                i1m=i1-is1*(1)  ! 1 point
                i2m=i2-is2*(1)
                i3m=i3-is3*(1)
                do m=0,orderOfExtrapolation
                 j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
                 j2=i2m+is2*m
                 j3=i3m+is3*m
                 mm = ce(cmpw,eqnw)+m
                 coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                  equationNumber(mm,i1m,i2m,i3m)=(cmpw+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
                end do
                 classify(i1m,i2m,i3m,eqnw)=extrapolation
              end if
            else
              write(*,'(" insImpINS: bc0.eq.inflowWithPandTV -- 
     & unknown option")')
              stop 8141
            end if
             end if
            end do
            end do
            end do
         else
           ! ****** inflowWithPandTV: vector system *********
            ! Operator identity 
             iCoeff(ma3(-1,-1,-1)) = 0
             iCoeff(ma3( 0,-1,-1)) = 0
             iCoeff(ma3( 1,-1,-1)) = 0
             iCoeff(ma3(-1, 0,-1)) = 0
             iCoeff(ma3( 0, 0,-1)) = 0
             iCoeff(ma3( 1, 0,-1)) = 0
             iCoeff(ma3(-1, 1,-1)) = 0
             iCoeff(ma3( 0, 1,-1)) = 0
             iCoeff(ma3( 1, 1,-1)) = 0
             iCoeff(ma3(-1,-1, 0)) = 0
             iCoeff(ma3( 0,-1, 0)) = 0
             iCoeff(ma3( 1,-1, 0)) = 0
             iCoeff(ma3(-1, 0, 0)) = 0
             iCoeff(ma3( 0, 0, 0)) = 1.
             iCoeff(ma3( 1, 0, 0)) = 0
             iCoeff(ma3(-1, 1, 0)) = 0
             iCoeff(ma3( 0, 1, 0)) = 0
             iCoeff(ma3( 1, 1, 0)) = 0
             iCoeff(ma3(-1,-1, 1)) = 0
             iCoeff(ma3( 0,-1, 1)) = 0
             iCoeff(ma3( 1,-1, 1)) = 0
             iCoeff(ma3(-1, 0, 1)) = 0
             iCoeff(ma3( 0, 0, 1)) = 0
             iCoeff(ma3( 1, 0, 1)) = 0
             iCoeff(ma3(-1, 1, 1)) = 0
             iCoeff(ma3( 0, 1, 1)) = 0
             iCoeff(ma3( 1, 1, 1)) = 0
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
               ! get the outward normal for curvilinear grids
               an(0)=rsxy(i1,i2,i3,axis,0)
               an(1)=rsxy(i1,i2,i3,axis,1)
                 an(2)=rsxy(i1,i2,i3,axis,2)
                 anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)*
     & *2 + an(2)**2 ) )
                 an(0)=an(0)*anNorm
                 an(1)=an(1)*anNorm
                 an(2)=an(2)*anNorm
            do m3=-halfWidth3,halfWidth3
            do m2=-halfWidth,halfWidth
            do m1=-halfWidth,halfWidth
           ! Form the matrix for "n.Lu"
            nDotL(0)=an(0)*coeff(mce3(m1,m2,m3,cmpu,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpu,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpu,eqnw),i1,i2,i3)
            nDotL(1)=an(0)*coeff(mce3(m1,m2,m3,cmpv,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpv,eqnw),i1,i2,i3)
            nDotL(2)=an(0)*coeff(mce3(m1,m2,m3,cmpw,eqnu),i1,i2,i3)+an(
     & 1)*coeff(mce3(m1,m2,m3,cmpw,eqnv),i1,i2,i3)+an(2)*coeff(mce3(
     & m1,m2,m3,cmpw,eqnw),i1,i2,i3)
            ! form the matrix for  Iu + [ (n.(Lu)) - (n.u) ] n 
            !  eqnu:     u1 + nDotL*n1 - (n1*u1+n2*u2+n3*u3)*n1 
            !  eqnv:     u2 + nDotL*n2 - (n1*u1+n2*u2+n3*u3)*n2
            !  eqnw:     u3 + nDotL*n3 - (n1*u1+n2*u2+n3*u3)*n3
            !  nDotL = L1(u)*n1 + L2(u)*n2 + L3(u)*n3 
            do e=eqnu,eqnu+nd-1
            do c=cmpu,cmpu+nd-1
             ! *** check this ***
             coeff(mce3(m1,m2,m3,c,e),i1,i2,i3)= iCoeff(ma3(m1,m2,m3))*
     & delta(c-cmpu,e-eqnu) + an(e-eqnu)*( nDotL(c-cmpu) - iCoeff(ma3(
     & m1,m2,m3))*an(c-cmpu) )
            end do
            end do
            end do
            end do
            end do
           ! Neumann condition for ghost: **** is this right? or extrapolate ?? ****
           do n=0,ndu-1
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! this next call will define the jacobian and its derivatives (parameteric and spatial)
               ajrx = rsxy(i1,i2,i3,0,0)
               ajsx = rsxy(i1,i2,i3,1,0)
               ajtx = rsxy(i1,i2,i3,2,0)
               ajry = rsxy(i1,i2,i3,0,1)
               ajsy = rsxy(i1,i2,i3,1,1)
               ajty = rsxy(i1,i2,i3,2,1)
               ajrz = rsxy(i1,i2,i3,0,2)
               ajsz = rsxy(i1,i2,i3,1,2)
               ajtz = rsxy(i1,i2,i3,2,2)
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = rx*ur+sx*us+tx*ut
                 cur = ajrx
                 cus = ajsx
                 cut = ajtx
                 xCoeff(ma3(-1,-1,-1)) = 0
                 xCoeff(ma3( 0,-1,-1)) = 0
                 xCoeff(ma3( 1,-1,-1)) = 0
                 xCoeff(ma3(-1, 0,-1)) = 0
                 xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 xCoeff(ma3( 1, 0,-1)) = 0
                 xCoeff(ma3(-1, 1,-1)) = 0
                 xCoeff(ma3( 0, 1,-1)) = 0
                 xCoeff(ma3( 1, 1,-1)) = 0
                 xCoeff(ma3(-1,-1, 0)) = 0
                 xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 xCoeff(ma3( 1,-1, 0)) = 0
                 xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 xCoeff(ma3( 0, 0, 0)) = 0
                 xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 xCoeff(ma3(-1, 1, 0)) = 0
                 xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 xCoeff(ma3( 1, 1, 0)) = 0
                 xCoeff(ma3(-1,-1, 1)) = 0
                 xCoeff(ma3( 0,-1, 1)) = 0
                 xCoeff(ma3( 1,-1, 1)) = 0
                 xCoeff(ma3(-1, 0, 1)) = 0
                 xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 xCoeff(ma3( 1, 0, 1)) = 0
                 xCoeff(ma3(-1, 1, 1)) = 0
                 xCoeff(ma3( 0, 1, 1)) = 0
                 xCoeff(ma3( 1, 1, 1)) = 0
                ! Operator y = ry*ur+sy*us+ty*ut
                 cur = ajry
                 cus = ajsy
                 cut = ajty
                 yCoeff(ma3(-1,-1,-1)) = 0
                 yCoeff(ma3( 0,-1,-1)) = 0
                 yCoeff(ma3( 1,-1,-1)) = 0
                 yCoeff(ma3(-1, 0,-1)) = 0
                 yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 yCoeff(ma3( 1, 0,-1)) = 0
                 yCoeff(ma3(-1, 1,-1)) = 0
                 yCoeff(ma3( 0, 1,-1)) = 0
                 yCoeff(ma3( 1, 1,-1)) = 0
                 yCoeff(ma3(-1,-1, 0)) = 0
                 yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 yCoeff(ma3( 1,-1, 0)) = 0
                 yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 yCoeff(ma3( 0, 0, 0)) = 0
                 yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 yCoeff(ma3(-1, 1, 0)) = 0
                 yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 yCoeff(ma3( 1, 1, 0)) = 0
                 yCoeff(ma3(-1,-1, 1)) = 0
                 yCoeff(ma3( 0,-1, 1)) = 0
                 yCoeff(ma3( 1,-1, 1)) = 0
                 yCoeff(ma3(-1, 0, 1)) = 0
                 yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 yCoeff(ma3( 1, 0, 1)) = 0
                 yCoeff(ma3(-1, 1, 1)) = 0
                 yCoeff(ma3( 0, 1, 1)) = 0
                 yCoeff(ma3( 1, 1, 1)) = 0
                ! Operator identity 
                 iCoeff(ma3(-1,-1,-1)) = 0
                 iCoeff(ma3( 0,-1,-1)) = 0
                 iCoeff(ma3( 1,-1,-1)) = 0
                 iCoeff(ma3(-1, 0,-1)) = 0
                 iCoeff(ma3( 0, 0,-1)) = 0
                 iCoeff(ma3( 1, 0,-1)) = 0
                 iCoeff(ma3(-1, 1,-1)) = 0
                 iCoeff(ma3( 0, 1,-1)) = 0
                 iCoeff(ma3( 1, 1,-1)) = 0
                 iCoeff(ma3(-1,-1, 0)) = 0
                 iCoeff(ma3( 0,-1, 0)) = 0
                 iCoeff(ma3( 1,-1, 0)) = 0
                 iCoeff(ma3(-1, 0, 0)) = 0
                 iCoeff(ma3( 0, 0, 0)) = 1.
                 iCoeff(ma3( 1, 0, 0)) = 0
                 iCoeff(ma3(-1, 1, 0)) = 0
                 iCoeff(ma3( 0, 1, 0)) = 0
                 iCoeff(ma3( 1, 1, 0)) = 0
                 iCoeff(ma3(-1,-1, 1)) = 0
                 iCoeff(ma3( 0,-1, 1)) = 0
                 iCoeff(ma3( 1,-1, 1)) = 0
                 iCoeff(ma3(-1, 0, 1)) = 0
                 iCoeff(ma3( 0, 0, 1)) = 0
                 iCoeff(ma3( 1, 0, 1)) = 0
                 iCoeff(ma3(-1, 1, 1)) = 0
                 iCoeff(ma3( 0, 1, 1)) = 0
                 iCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator z = rz*ur+sz*us+tz*ut
                  cur = ajrz
                  cus = ajsz
                  cut = ajtz
                  zCoeff(ma3(-1,-1,-1)) = 0
                  zCoeff(ma3( 0,-1,-1)) = 0
                  zCoeff(ma3( 1,-1,-1)) = 0
                  zCoeff(ma3(-1, 0,-1)) = 0
                  zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  zCoeff(ma3( 1, 0,-1)) = 0
                  zCoeff(ma3(-1, 1,-1)) = 0
                  zCoeff(ma3( 0, 1,-1)) = 0
                  zCoeff(ma3( 1, 1,-1)) = 0
                  zCoeff(ma3(-1,-1, 0)) = 0
                  zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  zCoeff(ma3( 1,-1, 0)) = 0
                  zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  zCoeff(ma3( 0, 0, 0)) = 0
                  zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  zCoeff(ma3(-1, 1, 0)) = 0
                  zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  zCoeff(ma3( 1, 1, 0)) = 0
                  zCoeff(ma3(-1,-1, 1)) = 0
                  zCoeff(ma3( 0,-1, 1)) = 0
                  zCoeff(ma3( 1,-1, 1)) = 0
                  zCoeff(ma3(-1, 0, 1)) = 0
                  zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  zCoeff(ma3( 1, 0, 1)) = 0
                  zCoeff(ma3(-1, 1, 1)) = 0
                  zCoeff(ma3( 0, 1, 1)) = 0
                  zCoeff(ma3( 1, 1, 1)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma3(m1,m2,m3)
               mm=mce3(m1,m2,m3,cmpu+n,eqnu+n)
                coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+0.*iCoeff(m)
               ! The equation for pt (eqnu+n,i1m,i2m,i3m) is centered on (cmpu+n,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpu+n+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnu+n)=ghost1
           end do
            end if
           end do
           end do
           end do
         end if  ! end vector system
         else if( bc0.eq.axisymmetric )then
          if( fillCoefficientsScalarSystem.eq.fillCoeffU )then
           ! BC on an axisymmetric side : scalar matrix for U 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*
     & dr(2))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*
     & dr(2))
             ajtx = rsxy(i1,i2,i3,2,0)
             ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*
     & dr(0))
             ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*
     & dr(1))
             ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*
     & dr(2))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*
     & dr(2))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*
     & dr(2))
             ajty = rsxy(i1,i2,i3,2,1)
             ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*
     & dr(0))
             ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*
     & dr(1))
             ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*
     & dr(2))
             ajrz = rsxy(i1,i2,i3,0,2)
             ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*
     & dr(0))
             ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*
     & dr(1))
             ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*
     & dr(2))
             ajsz = rsxy(i1,i2,i3,1,2)
             ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*
     & dr(0))
             ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*
     & dr(1))
             ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*
     & dr(2))
             ajtz = rsxy(i1,i2,i3,2,2)
             ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*
     & dr(0))
             ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*
     & dr(1))
             ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*
     & dr(2))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
             ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
             ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
             ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
             ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
             ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
             ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
             ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
             ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
             ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
             ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
             ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
             ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
             ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
             ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
             ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
             ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
             ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
             ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
             ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
             ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
             ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
             ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
             ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
             ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
             ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
             ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
            ! getCoeff(identity, iCoeff,aj)
            !zeroMatrixCoefficients( coeff,eqnv,eqnv, i1,i2,i3 )  ! set v eqn coeffs to zero
            !setCoeff1(cmpv,eqnv,coeff,iCoeff)                ! dirichlet: V= 
            !fillMatrixExtrapolation(coe<ff,cmpv,eqnv,i1,i2,i3,orderOfExtrapolation,1)  ! extrap ghost for V 
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  an(2)=rsxy(i1,i2,i3,axis,2)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 + an(2)**2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
                  an(2)=an(2)*anNorm
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! this next call will define the jacobian and its derivatives (parameteric and spatial)
              ajrx = rsxy(i1,i2,i3,0,0)
              ajsx = rsxy(i1,i2,i3,1,0)
              ajtx = rsxy(i1,i2,i3,2,0)
              ajry = rsxy(i1,i2,i3,0,1)
              ajsy = rsxy(i1,i2,i3,1,1)
              ajty = rsxy(i1,i2,i3,2,1)
              ajrz = rsxy(i1,i2,i3,0,2)
              ajsz = rsxy(i1,i2,i3,1,2)
              ajtz = rsxy(i1,i2,i3,2,2)
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = rx*ur+sx*us+tx*ut
                cur = ajrx
                cus = ajsx
                cut = ajtx
                xCoeff(ma3(-1,-1,-1)) = 0
                xCoeff(ma3( 0,-1,-1)) = 0
                xCoeff(ma3( 1,-1,-1)) = 0
                xCoeff(ma3(-1, 0,-1)) = 0
                xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                xCoeff(ma3( 1, 0,-1)) = 0
                xCoeff(ma3(-1, 1,-1)) = 0
                xCoeff(ma3( 0, 1,-1)) = 0
                xCoeff(ma3( 1, 1,-1)) = 0
                xCoeff(ma3(-1,-1, 0)) = 0
                xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                xCoeff(ma3( 1,-1, 0)) = 0
                xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                xCoeff(ma3( 0, 0, 0)) = 0
                xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                xCoeff(ma3(-1, 1, 0)) = 0
                xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                xCoeff(ma3( 1, 1, 0)) = 0
                xCoeff(ma3(-1,-1, 1)) = 0
                xCoeff(ma3( 0,-1, 1)) = 0
                xCoeff(ma3( 1,-1, 1)) = 0
                xCoeff(ma3(-1, 0, 1)) = 0
                xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                xCoeff(ma3( 1, 0, 1)) = 0
                xCoeff(ma3(-1, 1, 1)) = 0
                xCoeff(ma3( 0, 1, 1)) = 0
                xCoeff(ma3( 1, 1, 1)) = 0
               ! Operator y = ry*ur+sy*us+ty*ut
                cur = ajry
                cus = ajsy
                cut = ajty
                yCoeff(ma3(-1,-1,-1)) = 0
                yCoeff(ma3( 0,-1,-1)) = 0
                yCoeff(ma3( 1,-1,-1)) = 0
                yCoeff(ma3(-1, 0,-1)) = 0
                yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                yCoeff(ma3( 1, 0,-1)) = 0
                yCoeff(ma3(-1, 1,-1)) = 0
                yCoeff(ma3( 0, 1,-1)) = 0
                yCoeff(ma3( 1, 1,-1)) = 0
                yCoeff(ma3(-1,-1, 0)) = 0
                yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma3( 1,-1, 0)) = 0
                yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma3( 0, 0, 0)) = 0
                yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma3(-1, 1, 0)) = 0
                yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma3( 1, 1, 0)) = 0
                yCoeff(ma3(-1,-1, 1)) = 0
                yCoeff(ma3( 0,-1, 1)) = 0
                yCoeff(ma3( 1,-1, 1)) = 0
                yCoeff(ma3(-1, 0, 1)) = 0
                yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                yCoeff(ma3( 1, 0, 1)) = 0
                yCoeff(ma3(-1, 1, 1)) = 0
                yCoeff(ma3( 0, 1, 1)) = 0
                yCoeff(ma3( 1, 1, 1)) = 0
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
                ! Operator z = rz*ur+sz*us+tz*ut
                 cur = ajrz
                 cus = ajsz
                 cut = ajtz
                 zCoeff(ma3(-1,-1,-1)) = 0
                 zCoeff(ma3( 0,-1,-1)) = 0
                 zCoeff(ma3( 1,-1,-1)) = 0
                 zCoeff(ma3(-1, 0,-1)) = 0
                 zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 zCoeff(ma3( 1, 0,-1)) = 0
                 zCoeff(ma3(-1, 1,-1)) = 0
                 zCoeff(ma3( 0, 1,-1)) = 0
                 zCoeff(ma3( 1, 1,-1)) = 0
                 zCoeff(ma3(-1,-1, 0)) = 0
                 zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 zCoeff(ma3( 1,-1, 0)) = 0
                 zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 zCoeff(ma3( 0, 0, 0)) = 0
                 zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 zCoeff(ma3(-1, 1, 0)) = 0
                 zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 zCoeff(ma3( 1, 1, 0)) = 0
                 zCoeff(ma3(-1,-1, 1)) = 0
                 zCoeff(ma3( 0,-1, 1)) = 0
                 zCoeff(ma3( 1,-1, 1)) = 0
                 zCoeff(ma3(-1, 0, 1)) = 0
                 zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 zCoeff(ma3( 1, 0, 1)) = 0
                 zCoeff(ma3(-1, 1, 1)) = 0
                 zCoeff(ma3( 0, 1, 1)) = 0
                 zCoeff(ma3( 1, 1, 1)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma3(m1,m2,m3)
              mm=mce3(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          else if( fillCoefficientsScalarSystem.eq.fillCoeffV )then
           ! BC on an axisymmetric side : scalar matrix for V 
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*
     & dr(2))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*
     & dr(2))
             ajtx = rsxy(i1,i2,i3,2,0)
             ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*
     & dr(0))
             ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*
     & dr(1))
             ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*
     & dr(2))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*
     & dr(2))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*
     & dr(2))
             ajty = rsxy(i1,i2,i3,2,1)
             ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*
     & dr(0))
             ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*
     & dr(1))
             ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*
     & dr(2))
             ajrz = rsxy(i1,i2,i3,0,2)
             ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*
     & dr(0))
             ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*
     & dr(1))
             ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*
     & dr(2))
             ajsz = rsxy(i1,i2,i3,1,2)
             ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*
     & dr(0))
             ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*
     & dr(1))
             ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*
     & dr(2))
             ajtz = rsxy(i1,i2,i3,2,2)
             ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*
     & dr(0))
             ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*
     & dr(1))
             ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*
     & dr(2))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
             ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
             ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
             ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
             ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
             ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
             ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
             ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
             ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
             ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
             ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
             ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
             ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
             ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
             ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
             ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
             ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
             ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
             ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
             ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
             ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
             ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
             ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
             ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
             ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
             ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
             ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
            !getNormalForCurvilinearGrid(side,axis,i1,i2,i3)
            !fillMatrixNeumann(coeff, cmpu,eqnu, i1,i2,i3, an,0.,1. )  ! Neuman: U_r = 
             end if
            end do
            end do
            end do
          else
           ! BC on an axisymmetric side  
            do i3=n3a,n3b
            do i2=n2a,n2b
            do i1=n1a,n1b
             ! if( btest(mask(i1,i2,i3),28) )then
             !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
             ! end if
             if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
            ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
            ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
             ! this next call will define the jacobian and its derivatives (parameteric and spatial)
             ajrx = rsxy(i1,i2,i3,0,0)
             ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
             ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
             ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*
     & dr(2))
             ajsx = rsxy(i1,i2,i3,1,0)
             ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
             ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
             ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*
     & dr(2))
             ajtx = rsxy(i1,i2,i3,2,0)
             ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*
     & dr(0))
             ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*
     & dr(1))
             ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*
     & dr(2))
             ajry = rsxy(i1,i2,i3,0,1)
             ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
             ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
             ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*
     & dr(2))
             ajsy = rsxy(i1,i2,i3,1,1)
             ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
             ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
             ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*
     & dr(2))
             ajty = rsxy(i1,i2,i3,2,1)
             ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*
     & dr(0))
             ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*
     & dr(1))
             ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*
     & dr(2))
             ajrz = rsxy(i1,i2,i3,0,2)
             ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*
     & dr(0))
             ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*
     & dr(1))
             ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*
     & dr(2))
             ajsz = rsxy(i1,i2,i3,1,2)
             ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*
     & dr(0))
             ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*
     & dr(1))
             ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*
     & dr(2))
             ajtz = rsxy(i1,i2,i3,2,2)
             ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*
     & dr(0))
             ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*
     & dr(1))
             ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*
     & dr(2))
             ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
             ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
             ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
             ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
             ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
             ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
             ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
             ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
             ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
             ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
             ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
             ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
             ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
             ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
             ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
             ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
             ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
             ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
             ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
             ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
             ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
             ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
             ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
             ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
             ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
             ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
             ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
            do m=ce(0,eqnv),ce(0,eqnv+1)-1
             coeff(m,i1,i2,i3)=0.
            end do
             do m3=-halfWidth3,halfWidth3
             do m2=-halfWidth,halfWidth
             do m1=-halfWidth,halfWidth
               coeff(mce3(m1,m2,m3,cmpv,eqnv),i1,i2,i3)=(iCoeff(ma3(m1,
     & m2,m3)))
             end do
             end do
             end do
             if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrapolation
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(cmpv,eqnv)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrapolation) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(cmpv+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,eqnv)=extrapolation
                ! get the outward normal for curvilinear grids
                an(0)=rsxy(i1,i2,i3,axis,0)
                an(1)=rsxy(i1,i2,i3,axis,1)
                  an(2)=rsxy(i1,i2,i3,axis,2)
                  anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(1)
     & **2 + an(2)**2 ) )
                  an(0)=an(0)*anNorm
                  an(1)=an(1)*anNorm
                  an(2)=an(2)*anNorm
             ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
             ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
              ! this next call will define the jacobian and its derivatives (parameteric and spatial)
              ajrx = rsxy(i1,i2,i3,0,0)
              ajsx = rsxy(i1,i2,i3,1,0)
              ajtx = rsxy(i1,i2,i3,2,0)
              ajry = rsxy(i1,i2,i3,0,1)
              ajsy = rsxy(i1,i2,i3,1,1)
              ajty = rsxy(i1,i2,i3,2,1)
              ajrz = rsxy(i1,i2,i3,0,2)
              ajsz = rsxy(i1,i2,i3,1,2)
              ajtz = rsxy(i1,i2,i3,2,2)
             ! evaluate the coeff operators 
             ! getCoeff(identity, iCoeff,aj)
               ! Operator x = rx*ur+sx*us+tx*ut
                cur = ajrx
                cus = ajsx
                cut = ajtx
                xCoeff(ma3(-1,-1,-1)) = 0
                xCoeff(ma3( 0,-1,-1)) = 0
                xCoeff(ma3( 1,-1,-1)) = 0
                xCoeff(ma3(-1, 0,-1)) = 0
                xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                xCoeff(ma3( 1, 0,-1)) = 0
                xCoeff(ma3(-1, 1,-1)) = 0
                xCoeff(ma3( 0, 1,-1)) = 0
                xCoeff(ma3( 1, 1,-1)) = 0
                xCoeff(ma3(-1,-1, 0)) = 0
                xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                xCoeff(ma3( 1,-1, 0)) = 0
                xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                xCoeff(ma3( 0, 0, 0)) = 0
                xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                xCoeff(ma3(-1, 1, 0)) = 0
                xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                xCoeff(ma3( 1, 1, 0)) = 0
                xCoeff(ma3(-1,-1, 1)) = 0
                xCoeff(ma3( 0,-1, 1)) = 0
                xCoeff(ma3( 1,-1, 1)) = 0
                xCoeff(ma3(-1, 0, 1)) = 0
                xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                xCoeff(ma3( 1, 0, 1)) = 0
                xCoeff(ma3(-1, 1, 1)) = 0
                xCoeff(ma3( 0, 1, 1)) = 0
                xCoeff(ma3( 1, 1, 1)) = 0
               ! Operator y = ry*ur+sy*us+ty*ut
                cur = ajry
                cus = ajsy
                cut = ajty
                yCoeff(ma3(-1,-1,-1)) = 0
                yCoeff(ma3( 0,-1,-1)) = 0
                yCoeff(ma3( 1,-1,-1)) = 0
                yCoeff(ma3(-1, 0,-1)) = 0
                yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                yCoeff(ma3( 1, 0,-1)) = 0
                yCoeff(ma3(-1, 1,-1)) = 0
                yCoeff(ma3( 0, 1,-1)) = 0
                yCoeff(ma3( 1, 1,-1)) = 0
                yCoeff(ma3(-1,-1, 0)) = 0
                yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                yCoeff(ma3( 1,-1, 0)) = 0
                yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                yCoeff(ma3( 0, 0, 0)) = 0
                yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                yCoeff(ma3(-1, 1, 0)) = 0
                yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                yCoeff(ma3( 1, 1, 0)) = 0
                yCoeff(ma3(-1,-1, 1)) = 0
                yCoeff(ma3( 0,-1, 1)) = 0
                yCoeff(ma3( 1,-1, 1)) = 0
                yCoeff(ma3(-1, 0, 1)) = 0
                yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                yCoeff(ma3( 1, 0, 1)) = 0
                yCoeff(ma3(-1, 1, 1)) = 0
                yCoeff(ma3( 0, 1, 1)) = 0
                yCoeff(ma3( 1, 1, 1)) = 0
               ! Operator identity 
                iCoeff(ma3(-1,-1,-1)) = 0
                iCoeff(ma3( 0,-1,-1)) = 0
                iCoeff(ma3( 1,-1,-1)) = 0
                iCoeff(ma3(-1, 0,-1)) = 0
                iCoeff(ma3( 0, 0,-1)) = 0
                iCoeff(ma3( 1, 0,-1)) = 0
                iCoeff(ma3(-1, 1,-1)) = 0
                iCoeff(ma3( 0, 1,-1)) = 0
                iCoeff(ma3( 1, 1,-1)) = 0
                iCoeff(ma3(-1,-1, 0)) = 0
                iCoeff(ma3( 0,-1, 0)) = 0
                iCoeff(ma3( 1,-1, 0)) = 0
                iCoeff(ma3(-1, 0, 0)) = 0
                iCoeff(ma3( 0, 0, 0)) = 1.
                iCoeff(ma3( 1, 0, 0)) = 0
                iCoeff(ma3(-1, 1, 0)) = 0
                iCoeff(ma3( 0, 1, 0)) = 0
                iCoeff(ma3( 1, 1, 0)) = 0
                iCoeff(ma3(-1,-1, 1)) = 0
                iCoeff(ma3( 0,-1, 1)) = 0
                iCoeff(ma3( 1,-1, 1)) = 0
                iCoeff(ma3(-1, 0, 1)) = 0
                iCoeff(ma3( 0, 0, 1)) = 0
                iCoeff(ma3( 1, 0, 1)) = 0
                iCoeff(ma3(-1, 1, 1)) = 0
                iCoeff(ma3( 0, 1, 1)) = 0
                iCoeff(ma3( 1, 1, 1)) = 0
                ! Operator z = rz*ur+sz*us+tz*ut
                 cur = ajrz
                 cus = ajsz
                 cut = ajtz
                 zCoeff(ma3(-1,-1,-1)) = 0
                 zCoeff(ma3( 0,-1,-1)) = 0
                 zCoeff(ma3( 1,-1,-1)) = 0
                 zCoeff(ma3(-1, 0,-1)) = 0
                 zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 zCoeff(ma3( 1, 0,-1)) = 0
                 zCoeff(ma3(-1, 1,-1)) = 0
                 zCoeff(ma3( 0, 1,-1)) = 0
                 zCoeff(ma3( 1, 1,-1)) = 0
                 zCoeff(ma3(-1,-1, 0)) = 0
                 zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 zCoeff(ma3( 1,-1, 0)) = 0
                 zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 zCoeff(ma3( 0, 0, 0)) = 0
                 zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 zCoeff(ma3(-1, 1, 0)) = 0
                 zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 zCoeff(ma3( 1, 1, 0)) = 0
                 zCoeff(ma3(-1,-1, 1)) = 0
                 zCoeff(ma3( 0,-1, 1)) = 0
                 zCoeff(ma3( 1,-1, 1)) = 0
                 zCoeff(ma3(-1, 0, 1)) = 0
                 zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 zCoeff(ma3( 1, 0, 1)) = 0
                 zCoeff(ma3(-1, 1, 1)) = 0
                 zCoeff(ma3( 0, 1, 1)) = 0
                 zCoeff(ma3( 1, 1, 1)) = 0
             i1m=i1-is1  ! ghost point
             i2m=i2-is2
             i3m=i3-is3
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
              m=ma3(m1,m2,m3)
              mm=mce3(m1,m2,m3,cmpu,eqnu)
               coeff(mm,i1m,i2m,i3m)=1.*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+0.*iCoeff(m)
              ! The equation for pt (eqnu,i1m,i2m,i3m) is centered on (cmpu,i1,i2,i3): 
               equationNumber(mm,i1m,i2m,i3m)=(cmpu+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
              end do
              end do
              end do
              classify(i1m,i2m,i3m,eqnu)=ghost1
             end if
            end do
            end do
            end do
          end if
         else if( bc0.gt.0 )then
           write(*,'("insimp:BC: ERROR unknown bc=",i4)') bc0
           stop 5501
         end if
         if( extrapolateGhostByDefault.eq.1 .and. (
     & bc0.eq.dirichletBoundaryCondition 
     & .or.bc0.eq.noSlipWall.or.bc0.eq.inflowWithVelocityGiven .or.(
     & bc0.eq.outflow .and. outflowOption.eq.0) 
     & .or.bc0.eq.interfaceBoundaryCondition) )then
          ! === extrapolation ===
          orderOfExtrap=orderOfExtrapolation
          if( bc0.eq.outflow .and. orderOfExtrapolationForOutflow.gt.0 
     & )then
            orderOfExtrap=orderOfExtrapolationForOutflow
          end if
          if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
           write(*,'("insimp:BC:ERROR: requesting orderOfExtrap=",i6)')
     &  orderOfExtrap
           stop 5502
          end if
          if( .false. .and. bc0.eq.outflow )then
           write(*,'("insimp:BC: fill extrap outflow BC into matrix, 
     & orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') 
     & orderOfExtrap,orderOfExtrapolationForOutflow
          end if
          ! write(*,'("insimp:BC: orderOfExtrap,orderOfExtrapolationForOutflow=",2i4)') orderOfExtrap,orderOfExtrapolationForOutflow
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            ! if( btest(mask(i1,i2,i3),28) )then
            !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
            ! end if
            if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),28)
     &  )then
           ! i1m=i1-is1  ! ghost point
           ! i2m=i2-is2
           ! i3m=i3-is3
           ! zeroMatrixCoefficients( coeff,eqnu,eqnu+ndu-1, i1,i2,i3 )
           do n=0,ndu-1
            c=cmpu+n
            e=eqnu+n
             if( orderOfExtrap.lt.1 .or. 
     & orderOfExtrap.gt.maxOrderOfExtrapolation )then
               stop 7734
             end if
             i1m=i1-is1*(1)  ! 1 point
             i2m=i2-is2*(1)
             i3m=i3-is3*(1)
             do m=0,orderOfExtrap
              j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
              j2=i2m+is2*m
              j3=i3m+is3*m
              mm = ce(c,e)+m
              coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,orderOfExtrap) ! m=0,1,2,..
               equationNumber(mm,i1m,i2m,i3m)=(c+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
             end do
              classify(i1m,i2m,i3m,e)=extrapolation
           end do
            end if
           end do
           end do
           end do
         end if
         end if
         if( pdeModel.eq.BoussinesqModel .and. (
     & fillCoefficientsScalarSystem.eq.0 .or. 
     & fillCoefficientsScalarSystem.eq.fillCoeffT) )then
          ! ----------------------------
          ! --- Assign the BCs for T --- (this is duplicated from insImpVP.bf : we could share 
          ! ----------------------------
          bc0 = bc(side,axis)
          a0 = mixedCoeff(tc,side,axis,grid)
          a1 = mixedNormalCoeff(tc,side,axis,grid)
          if( debug.gt.3 )then
            write(*,'(" insImpINS: T BC: bc=",i3," (a0,a1)=(",f5.1,",",
     & f5.1,") for side,axis,grid=",3i3)') bc0,a0,a1,side,axis,grid
            write(*,'(" cmpu,eqnu=",2i2," cmpq,eqnq=",2i2," 
     & orderOfExtrap=",i2)') cmpu,eqnu, cmpq,eqnq,orderOfExtrap
          endif
          ! '
          if( bc0.eq.dirichletBoundaryCondition .or.bc0.eq.noSlipWall 
     & .or.bc0.eq.slipWall .or.bc0.eq.inflowWithVelocityGiven 
     & .or.bc0.eq.outflow .or.bc0.eq.axisymmetric 
     & .or.bc0.eq.interfaceBoundaryCondition .or. 
     & bc0.eq.freeSurfaceBoundaryCondition )then
            if( bc0.eq.outflow .or. bc0.eq.axisymmetric )then
             ! outflow is Neumann
             a0=0.
             a1=1.
            end if
           if( a1.ne.0. )then
            ! Mixed BC 
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
                 ! get the outward normal for curvilinear grids
                 an(0)=rsxy(i1,i2,i3,axis,0)
                 an(1)=rsxy(i1,i2,i3,axis,1)
                   an(2)=rsxy(i1,i2,i3,axis,2)
                   anNorm = (2*side-1)/max( epsX, sqrt( an(0)**2 + an(
     & 1)**2 + an(2)**2 ) )
                   an(0)=an(0)*anNorm
                   an(1)=an(1)*anNorm
                   an(2)=an(2)*anNorm
              ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
              ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
               ! this next call will define the jacobian and its derivatives (parameteric and spatial)
               ajrx = rsxy(i1,i2,i3,0,0)
               ajsx = rsxy(i1,i2,i3,1,0)
               ajtx = rsxy(i1,i2,i3,2,0)
               ajry = rsxy(i1,i2,i3,0,1)
               ajsy = rsxy(i1,i2,i3,1,1)
               ajty = rsxy(i1,i2,i3,2,1)
               ajrz = rsxy(i1,i2,i3,0,2)
               ajsz = rsxy(i1,i2,i3,1,2)
               ajtz = rsxy(i1,i2,i3,2,2)
              ! evaluate the coeff operators 
              ! getCoeff(identity, iCoeff,aj)
                ! Operator x = rx*ur+sx*us+tx*ut
                 cur = ajrx
                 cus = ajsx
                 cut = ajtx
                 xCoeff(ma3(-1,-1,-1)) = 0
                 xCoeff(ma3( 0,-1,-1)) = 0
                 xCoeff(ma3( 1,-1,-1)) = 0
                 xCoeff(ma3(-1, 0,-1)) = 0
                 xCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 xCoeff(ma3( 1, 0,-1)) = 0
                 xCoeff(ma3(-1, 1,-1)) = 0
                 xCoeff(ma3( 0, 1,-1)) = 0
                 xCoeff(ma3( 1, 1,-1)) = 0
                 xCoeff(ma3(-1,-1, 0)) = 0
                 xCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 xCoeff(ma3( 1,-1, 0)) = 0
                 xCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 xCoeff(ma3( 0, 0, 0)) = 0
                 xCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 xCoeff(ma3(-1, 1, 0)) = 0
                 xCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 xCoeff(ma3( 1, 1, 0)) = 0
                 xCoeff(ma3(-1,-1, 1)) = 0
                 xCoeff(ma3( 0,-1, 1)) = 0
                 xCoeff(ma3( 1,-1, 1)) = 0
                 xCoeff(ma3(-1, 0, 1)) = 0
                 xCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 xCoeff(ma3( 1, 0, 1)) = 0
                 xCoeff(ma3(-1, 1, 1)) = 0
                 xCoeff(ma3( 0, 1, 1)) = 0
                 xCoeff(ma3( 1, 1, 1)) = 0
                ! Operator y = ry*ur+sy*us+ty*ut
                 cur = ajry
                 cus = ajsy
                 cut = ajty
                 yCoeff(ma3(-1,-1,-1)) = 0
                 yCoeff(ma3( 0,-1,-1)) = 0
                 yCoeff(ma3( 1,-1,-1)) = 0
                 yCoeff(ma3(-1, 0,-1)) = 0
                 yCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                 yCoeff(ma3( 1, 0,-1)) = 0
                 yCoeff(ma3(-1, 1,-1)) = 0
                 yCoeff(ma3( 0, 1,-1)) = 0
                 yCoeff(ma3( 1, 1,-1)) = 0
                 yCoeff(ma3(-1,-1, 0)) = 0
                 yCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                 yCoeff(ma3( 1,-1, 0)) = 0
                 yCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                 yCoeff(ma3( 0, 0, 0)) = 0
                 yCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                 yCoeff(ma3(-1, 1, 0)) = 0
                 yCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                 yCoeff(ma3( 1, 1, 0)) = 0
                 yCoeff(ma3(-1,-1, 1)) = 0
                 yCoeff(ma3( 0,-1, 1)) = 0
                 yCoeff(ma3( 1,-1, 1)) = 0
                 yCoeff(ma3(-1, 0, 1)) = 0
                 yCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                 yCoeff(ma3( 1, 0, 1)) = 0
                 yCoeff(ma3(-1, 1, 1)) = 0
                 yCoeff(ma3( 0, 1, 1)) = 0
                 yCoeff(ma3( 1, 1, 1)) = 0
                ! Operator identity 
                 iCoeff(ma3(-1,-1,-1)) = 0
                 iCoeff(ma3( 0,-1,-1)) = 0
                 iCoeff(ma3( 1,-1,-1)) = 0
                 iCoeff(ma3(-1, 0,-1)) = 0
                 iCoeff(ma3( 0, 0,-1)) = 0
                 iCoeff(ma3( 1, 0,-1)) = 0
                 iCoeff(ma3(-1, 1,-1)) = 0
                 iCoeff(ma3( 0, 1,-1)) = 0
                 iCoeff(ma3( 1, 1,-1)) = 0
                 iCoeff(ma3(-1,-1, 0)) = 0
                 iCoeff(ma3( 0,-1, 0)) = 0
                 iCoeff(ma3( 1,-1, 0)) = 0
                 iCoeff(ma3(-1, 0, 0)) = 0
                 iCoeff(ma3( 0, 0, 0)) = 1.
                 iCoeff(ma3( 1, 0, 0)) = 0
                 iCoeff(ma3(-1, 1, 0)) = 0
                 iCoeff(ma3( 0, 1, 0)) = 0
                 iCoeff(ma3( 1, 1, 0)) = 0
                 iCoeff(ma3(-1,-1, 1)) = 0
                 iCoeff(ma3( 0,-1, 1)) = 0
                 iCoeff(ma3( 1,-1, 1)) = 0
                 iCoeff(ma3(-1, 0, 1)) = 0
                 iCoeff(ma3( 0, 0, 1)) = 0
                 iCoeff(ma3( 1, 0, 1)) = 0
                 iCoeff(ma3(-1, 1, 1)) = 0
                 iCoeff(ma3( 0, 1, 1)) = 0
                 iCoeff(ma3( 1, 1, 1)) = 0
                 ! Operator z = rz*ur+sz*us+tz*ut
                  cur = ajrz
                  cus = ajsz
                  cut = ajtz
                  zCoeff(ma3(-1,-1,-1)) = 0
                  zCoeff(ma3( 0,-1,-1)) = 0
                  zCoeff(ma3( 1,-1,-1)) = 0
                  zCoeff(ma3(-1, 0,-1)) = 0
                  zCoeff(ma3( 0, 0,-1)) = -1./2.*cut/dr(2)
                  zCoeff(ma3( 1, 0,-1)) = 0
                  zCoeff(ma3(-1, 1,-1)) = 0
                  zCoeff(ma3( 0, 1,-1)) = 0
                  zCoeff(ma3( 1, 1,-1)) = 0
                  zCoeff(ma3(-1,-1, 0)) = 0
                  zCoeff(ma3( 0,-1, 0)) = -1./2.*cus/dr(1)
                  zCoeff(ma3( 1,-1, 0)) = 0
                  zCoeff(ma3(-1, 0, 0)) = -1./2.*cur/dr(0)
                  zCoeff(ma3( 0, 0, 0)) = 0
                  zCoeff(ma3( 1, 0, 0)) = 1./2.*cur/dr(0)
                  zCoeff(ma3(-1, 1, 0)) = 0
                  zCoeff(ma3( 0, 1, 0)) = 1./2.*cus/dr(1)
                  zCoeff(ma3( 1, 1, 0)) = 0
                  zCoeff(ma3(-1,-1, 1)) = 0
                  zCoeff(ma3( 0,-1, 1)) = 0
                  zCoeff(ma3( 1,-1, 1)) = 0
                  zCoeff(ma3(-1, 0, 1)) = 0
                  zCoeff(ma3( 0, 0, 1)) = 1./2.*cut/dr(2)
                  zCoeff(ma3( 1, 0, 1)) = 0
                  zCoeff(ma3(-1, 1, 1)) = 0
                  zCoeff(ma3( 0, 1, 1)) = 0
                  zCoeff(ma3( 1, 1, 1)) = 0
              i1m=i1-is1  ! ghost point
              i2m=i2-is2
              i3m=i3-is3
               do m3=-halfWidth3,halfWidth3
               do m2=-halfWidth,halfWidth
               do m1=-halfWidth,halfWidth
               m=ma3(m1,m2,m3)
               mm=mce3(m1,m2,m3,cmpq,eqnq)
                coeff(mm,i1m,i2m,i3m)=a1*(an(0)*xCoeff(m)+an(1)*yCoeff(
     & m)+an(2)*zCoeff(m))+a0*iCoeff(m)
               ! The equation for pt (eqnq,i1m,i2m,i3m) is centered on (cmpq,i1,i2,i3): 
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(i1+m1-equationNumberBase1+
     & equationNumberLength1*(i2+m2-equationNumberBase2+
     & equationNumberLength2*(i3+m3-equationNumberBase3)))+
     & equationOffset)
               end do
               end do
               end do
               classify(i1m,i2m,i3m,eqnq)=ghost1
              end if
             end do
             end do
             end do
           else
            ! Dirichlet + extrap ghost line values
              ! Operator identity 
               iCoeff(ma3(-1,-1,-1)) = 0
               iCoeff(ma3( 0,-1,-1)) = 0
               iCoeff(ma3( 1,-1,-1)) = 0
               iCoeff(ma3(-1, 0,-1)) = 0
               iCoeff(ma3( 0, 0,-1)) = 0
               iCoeff(ma3( 1, 0,-1)) = 0
               iCoeff(ma3(-1, 1,-1)) = 0
               iCoeff(ma3( 0, 1,-1)) = 0
               iCoeff(ma3( 1, 1,-1)) = 0
               iCoeff(ma3(-1,-1, 0)) = 0
               iCoeff(ma3( 0,-1, 0)) = 0
               iCoeff(ma3( 1,-1, 0)) = 0
               iCoeff(ma3(-1, 0, 0)) = 0
               iCoeff(ma3( 0, 0, 0)) = 1.
               iCoeff(ma3( 1, 0, 0)) = 0
               iCoeff(ma3(-1, 1, 0)) = 0
               iCoeff(ma3( 0, 1, 0)) = 0
               iCoeff(ma3( 1, 1, 0)) = 0
               iCoeff(ma3(-1,-1, 1)) = 0
               iCoeff(ma3( 0,-1, 1)) = 0
               iCoeff(ma3( 1,-1, 1)) = 0
               iCoeff(ma3(-1, 0, 1)) = 0
               iCoeff(ma3( 0, 0, 1)) = 0
               iCoeff(ma3( 1, 0, 1)) = 0
               iCoeff(ma3(-1, 1, 1)) = 0
               iCoeff(ma3( 0, 1, 1)) = 0
               iCoeff(ma3( 1, 1, 1)) = 0
             do i3=n3a,n3b
             do i2=n2a,n2b
             do i1=n1a,n1b
              ! if( btest(mask(i1,i2,i3),28) )then
              !   write(*,'("+++ Point i=(",3i5,") is an interiorBoundaryPoint")') i1,i2,i3
              ! end if
              if( mask(i1,i2,i3).gt.0 .and. .not.btest(mask(i1,i2,i3),
     & 28) )then
             do m=ce(0,eqnq),ce(0,eqnq+1)-1
              coeff(m,i1,i2,i3)=0.
             end do
              do m3=-halfWidth3,halfWidth3
              do m2=-halfWidth,halfWidth
              do m1=-halfWidth,halfWidth
                coeff(mce3(m1,m2,m3,cmpq,eqnq),i1,i2,i3)=(a0*iCoeff(
     & ma3(m1,m2,m3)))
              end do
              end do
              end do
              if( orderOfExtrapolation.lt.1 .or. 
     & orderOfExtrapolation.gt.maxOrderOfExtrapolation )then
                stop 7734
              end if
              i1m=i1-is1*(1)  ! 1 point
              i2m=i2-is2*(1)
              i3m=i3-is3*(1)
              do m=0,orderOfExtrapolation
               j1=i1m+is1*m  ! m-th point moving inward from the 1 point (i1,i2,i3)
               j2=i2m+is2*m
               j3=i3m+is3*m
               mm = ce(cmpq,eqnq)+m
               coeff(mm,i1m,i2m,i3m)=extrapCoeff(m,
     & orderOfExtrapolation) ! m=0,1,2,..
                equationNumber(mm,i1m,i2m,i3m)=(cmpq+1+
     & numberOfComponentsForCoefficients*(j1-equationNumberBase1+
     & equationNumberLength1*(j2-equationNumberBase2+
     & equationNumberLength2*(j3-equationNumberBase3)))+
     & equationOffset)
              end do
               classify(i1m,i2m,i3m,eqnq)=extrapolation
              end if
             end do
             end do
             end do
           end if
         !  else if( bc0.eq.outflow )then
         !    ! === extrapolation ===
         !   beginLoopsMixedBoundary()
         !    fillMatrixExtrapolation(coeff,cmpq,eqnq,i1,i2,i3,orderOfExtrap,1)
         !   endLoops()
          else if( bc0.gt.0 )then
           write(*,'("insImpINS:T: ERROR unknown bc=",i4)') bc0
           stop 9167
          end if
         endif
         end if ! end if( fillCoefficients.eq.1 )
         if( evalResidualForBoundaryConditions.eq.1 )then
         if( bc(side,axis).eq.dirichletBoundaryCondition .or.bc(side,
     & axis).eq.noSlipWall.or.bc(side,axis)
     & .eq.inflowWithVelocityGiven.or.bc(side,axis)
     & .eq.interfaceBoundaryCondition )then
          ! Dirichlet BC
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           ! do n=0,ntdc-1             ! ntdc = number of time depenedent components
           do n=0,nd-1  ! ntdc = number of time depenedent components
            ! fe(i1,i2,i3,uc+n)=0.  
            fe(i1,i2,i3,uc+n)=fi(i1,i2,i3,uc+n)-u(i1,i2,i3,uc+n)
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.outflow )then
         else if( bc(side,axis).eq.axisymmetric )then
         ! do nothing for now
         else if( bc(side,axis).eq.freeSurfaceBoundaryCondition )then
         ! do nothing for now
         else if( bc(side,axis).eq.slipWall )then
           ! SLIP-WALL
           ! boundary values use:
           !    n.u = f
           !    tau.(Lu) = tau.g   (tangential component of the equations on the boundary
           ! To avoid a zero pivot we combine the above equations as
           !     (n.u) n + ( tau.(Lu) ) tau = n f + tau g 
           !
           ! OR:  ( tau.(Lu) ) tau = Lu - (n.(Lu)) n 
           !    (n.u) n + Lu - (n.(Lu)) n = n f +  g - (n.g) n 
           !       
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).eq.inflowWithPandTV )then
          ! pressure and tangential velocity given
           do i3=n3a,n3b
           do i2=n2a,n2b
           do i1=n1a,n1b
            if( mask(i1,i2,i3).gt.0 )then
           do n=0,nd-1
            fe(i1,i2,i3,uc+n)=0.  ! *** do this for now
           end do
            end if
           end do
           end do
           end do
         else if( bc(side,axis).gt.0 )then
           write(*,'("insimp:residual:BC: ERROR unknown bc=",i4)') bc(
     & side,axis)
           stop 9099
         end if
         end if ! end if( evalResidualForBoundaryConditions.eq.1 )
       !*   if( side.eq.0 .and. axis.eq.0 )then
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal00)
       !*    getBoundaryResidualINS(normal00)
       !*   else if( side.eq.1 .and. axis.eq.0 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal10)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.0 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal01)
       !*    getBoundaryResidualINS(normal10)
       !*   else if( side.eq.1 .and. axis.eq.1 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal11)
       !*    getBoundaryResidualINS(normal11)
       !*   else if( side.eq.0 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal02)
       !*    getBoundaryResidualINS(normal02)
       !*   else if( side.eq.1 .and. axis.eq.2 )then    
       !*    fillMatrixBoundaryConditionsOnAFaceINS(normal12)
       !*    getBoundaryResidualINS(normal12)
       !*  else
       !* !    stop 2077
       !*  end if
         ! reset values
         if( axis.eq.0 )then
           n1a=indexRange(0,axis)
           n1b=indexRange(1,axis)
         else if( axis.eq.1 )then
           n2a=indexRange(0,axis)
           n2b=indexRange(1,axis)
         else
           n3a=indexRange(0,axis)
           n3b=indexRange(1,axis)
         end if
        end do ! side
        end do ! axis
       end if
       ! assign the RHS:
         ! the next macro is defined in insImpINS.bf, or insImpVP.bf, etc. 
         if( evalRightHandSide.eq.1 .or. evalResidual.eq.1 )then
         ! **** to do : optimize this for backward-Euler : fe=0, fi=0 !!
         ! NOTE: For moving grid problems we must eval the RHS as some mask==0 (exposed) points
          do i3=n3a,n3b
          do i2=n2a,n2b
          do i1=n1a,n1b
           ! Evaluate the jacobian derivatives used by the coefficient and forward derivatives:
           ! opEvalJacobianDerivatives(MAXDER) : MAXDER = max number of derivatives to precompute.
            ! this next call will define the jacobian and its derivatives (parameteric and spatial)
            ajrx = rsxy(i1,i2,i3,0,0)
            ajrxr = (-rsxy(i1-1,i2,i3,0,0)+rsxy(i1+1,i2,i3,0,0))/(2.*
     & dr(0))
            ajrxs = (-rsxy(i1,i2-1,i3,0,0)+rsxy(i1,i2+1,i3,0,0))/(2.*
     & dr(1))
            ajrxt = (-rsxy(i1,i2,i3-1,0,0)+rsxy(i1,i2,i3+1,0,0))/(2.*
     & dr(2))
            ajsx = rsxy(i1,i2,i3,1,0)
            ajsxr = (-rsxy(i1-1,i2,i3,1,0)+rsxy(i1+1,i2,i3,1,0))/(2.*
     & dr(0))
            ajsxs = (-rsxy(i1,i2-1,i3,1,0)+rsxy(i1,i2+1,i3,1,0))/(2.*
     & dr(1))
            ajsxt = (-rsxy(i1,i2,i3-1,1,0)+rsxy(i1,i2,i3+1,1,0))/(2.*
     & dr(2))
            ajtx = rsxy(i1,i2,i3,2,0)
            ajtxr = (-rsxy(i1-1,i2,i3,2,0)+rsxy(i1+1,i2,i3,2,0))/(2.*
     & dr(0))
            ajtxs = (-rsxy(i1,i2-1,i3,2,0)+rsxy(i1,i2+1,i3,2,0))/(2.*
     & dr(1))
            ajtxt = (-rsxy(i1,i2,i3-1,2,0)+rsxy(i1,i2,i3+1,2,0))/(2.*
     & dr(2))
            ajry = rsxy(i1,i2,i3,0,1)
            ajryr = (-rsxy(i1-1,i2,i3,0,1)+rsxy(i1+1,i2,i3,0,1))/(2.*
     & dr(0))
            ajrys = (-rsxy(i1,i2-1,i3,0,1)+rsxy(i1,i2+1,i3,0,1))/(2.*
     & dr(1))
            ajryt = (-rsxy(i1,i2,i3-1,0,1)+rsxy(i1,i2,i3+1,0,1))/(2.*
     & dr(2))
            ajsy = rsxy(i1,i2,i3,1,1)
            ajsyr = (-rsxy(i1-1,i2,i3,1,1)+rsxy(i1+1,i2,i3,1,1))/(2.*
     & dr(0))
            ajsys = (-rsxy(i1,i2-1,i3,1,1)+rsxy(i1,i2+1,i3,1,1))/(2.*
     & dr(1))
            ajsyt = (-rsxy(i1,i2,i3-1,1,1)+rsxy(i1,i2,i3+1,1,1))/(2.*
     & dr(2))
            ajty = rsxy(i1,i2,i3,2,1)
            ajtyr = (-rsxy(i1-1,i2,i3,2,1)+rsxy(i1+1,i2,i3,2,1))/(2.*
     & dr(0))
            ajtys = (-rsxy(i1,i2-1,i3,2,1)+rsxy(i1,i2+1,i3,2,1))/(2.*
     & dr(1))
            ajtyt = (-rsxy(i1,i2,i3-1,2,1)+rsxy(i1,i2,i3+1,2,1))/(2.*
     & dr(2))
            ajrz = rsxy(i1,i2,i3,0,2)
            ajrzr = (-rsxy(i1-1,i2,i3,0,2)+rsxy(i1+1,i2,i3,0,2))/(2.*
     & dr(0))
            ajrzs = (-rsxy(i1,i2-1,i3,0,2)+rsxy(i1,i2+1,i3,0,2))/(2.*
     & dr(1))
            ajrzt = (-rsxy(i1,i2,i3-1,0,2)+rsxy(i1,i2,i3+1,0,2))/(2.*
     & dr(2))
            ajsz = rsxy(i1,i2,i3,1,2)
            ajszr = (-rsxy(i1-1,i2,i3,1,2)+rsxy(i1+1,i2,i3,1,2))/(2.*
     & dr(0))
            ajszs = (-rsxy(i1,i2-1,i3,1,2)+rsxy(i1,i2+1,i3,1,2))/(2.*
     & dr(1))
            ajszt = (-rsxy(i1,i2,i3-1,1,2)+rsxy(i1,i2,i3+1,1,2))/(2.*
     & dr(2))
            ajtz = rsxy(i1,i2,i3,2,2)
            ajtzr = (-rsxy(i1-1,i2,i3,2,2)+rsxy(i1+1,i2,i3,2,2))/(2.*
     & dr(0))
            ajtzs = (-rsxy(i1,i2-1,i3,2,2)+rsxy(i1,i2+1,i3,2,2))/(2.*
     & dr(1))
            ajtzt = (-rsxy(i1,i2,i3-1,2,2)+rsxy(i1,i2,i3+1,2,2))/(2.*
     & dr(2))
            ajrxx = ajrx*ajrxr+ajsx*ajrxs+ajtx*ajrxt
            ajrxy = ajry*ajrxr+ajsy*ajrxs+ajty*ajrxt
            ajrxz = ajrz*ajrxr+ajsz*ajrxs+ajtz*ajrxt
            ajsxx = ajrx*ajsxr+ajsx*ajsxs+ajtx*ajsxt
            ajsxy = ajry*ajsxr+ajsy*ajsxs+ajty*ajsxt
            ajsxz = ajrz*ajsxr+ajsz*ajsxs+ajtz*ajsxt
            ajtxx = ajrx*ajtxr+ajsx*ajtxs+ajtx*ajtxt
            ajtxy = ajry*ajtxr+ajsy*ajtxs+ajty*ajtxt
            ajtxz = ajrz*ajtxr+ajsz*ajtxs+ajtz*ajtxt
            ajryx = ajrx*ajryr+ajsx*ajrys+ajtx*ajryt
            ajryy = ajry*ajryr+ajsy*ajrys+ajty*ajryt
            ajryz = ajrz*ajryr+ajsz*ajrys+ajtz*ajryt
            ajsyx = ajrx*ajsyr+ajsx*ajsys+ajtx*ajsyt
            ajsyy = ajry*ajsyr+ajsy*ajsys+ajty*ajsyt
            ajsyz = ajrz*ajsyr+ajsz*ajsys+ajtz*ajsyt
            ajtyx = ajrx*ajtyr+ajsx*ajtys+ajtx*ajtyt
            ajtyy = ajry*ajtyr+ajsy*ajtys+ajty*ajtyt
            ajtyz = ajrz*ajtyr+ajsz*ajtys+ajtz*ajtyt
            ajrzx = ajrx*ajrzr+ajsx*ajrzs+ajtx*ajrzt
            ajrzy = ajry*ajrzr+ajsy*ajrzs+ajty*ajrzt
            ajrzz = ajrz*ajrzr+ajsz*ajrzs+ajtz*ajrzt
            ajszx = ajrx*ajszr+ajsx*ajszs+ajtx*ajszt
            ajszy = ajry*ajszr+ajsy*ajszs+ajty*ajszt
            ajszz = ajrz*ajszr+ajsz*ajszs+ajtz*ajszt
            ajtzx = ajrx*ajtzr+ajsx*ajtzs+ajtx*ajtzt
            ajtzy = ajry*ajtzr+ajsy*ajtzs+ajty*ajtzt
            ajtzz = ajrz*ajtzr+ajsz*ajtzs+ajtz*ajtzt
           ! evaluate forward derivatives of the current solution: 
           ! First evaluate the parametric derivatives of u, used later by the spatial derivatives. 
           ! MAXDER = max number of parametric derivatives to precompute.
            uu = u(i1,i2,i3,uc)
            uur = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
            uus = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
            uut = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
            uurr = (u(i1-1,i2,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1+1,i2,i3,uc)
     & )/(dr(0)**2)
            uurs = (-(-u(i1-1,i2-1,i3,uc)+u(i1-1,i2+1,i3,uc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,uc)+u(i1+1,i2+1,i3,uc))/(2.*dr(1)))/(2.*dr(
     & 0))
            uuss = (u(i1,i2-1,i3,uc)-2.*u(i1,i2,i3,uc)+u(i1,i2+1,i3,uc)
     & )/(dr(1)**2)
            uurt = (-(-u(i1-1,i2,i3-1,uc)+u(i1-1,i2,i3+1,uc))/(2.*dr(2)
     & )+(-u(i1+1,i2,i3-1,uc)+u(i1+1,i2,i3+1,uc))/(2.*dr(2)))/(2.*dr(
     & 0))
            uust = (-(-u(i1,i2-1,i3-1,uc)+u(i1,i2-1,i3+1,uc))/(2.*dr(2)
     & )+(-u(i1,i2+1,i3-1,uc)+u(i1,i2+1,i3+1,uc))/(2.*dr(2)))/(2.*dr(
     & 1))
            uutt = (u(i1,i2,i3-1,uc)-2.*u(i1,i2,i3,uc)+u(i1,i2,i3+1,uc)
     & )/(dr(2)**2)
           ! Evaluate the spatial derivatives of u:
             u0x = ajrx*uur+ajsx*uus+ajtx*uut
             u0y = ajry*uur+ajsy*uus+ajty*uut
             t1 = ajrx**2
             t6 = ajsx**2
             t14 = ajtx**2
             u0xx = t1*uurr+2*ajrx*ajsx*uurs+t6*uuss+2*ajrx*ajtx*uurt+
     & 2*ajsx*ajtx*uust+t14*uutt+ajrxx*uur+ajsxx*uus+ajtxx*uut
             t1 = ajry**2
             t6 = ajsy**2
             t14 = ajty**2
             u0yy = t1*uurr+2*ajry*ajsy*uurs+t6*uuss+2*ajry*ajty*uurt+
     & 2*ajsy*ajty*uust+t14*uutt+ajryy*uur+ajsyy*uus+ajtyy*uut
           ! Evaluate the spatial derivatives of v:
            vv = u(i1,i2,i3,vc)
            vvr = (-u(i1-1,i2,i3,vc)+u(i1+1,i2,i3,vc))/(2.*dr(0))
            vvs = (-u(i1,i2-1,i3,vc)+u(i1,i2+1,i3,vc))/(2.*dr(1))
            vvt = (-u(i1,i2,i3-1,vc)+u(i1,i2,i3+1,vc))/(2.*dr(2))
            vvrr = (u(i1-1,i2,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1+1,i2,i3,vc)
     & )/(dr(0)**2)
            vvrs = (-(-u(i1-1,i2-1,i3,vc)+u(i1-1,i2+1,i3,vc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,vc)+u(i1+1,i2+1,i3,vc))/(2.*dr(1)))/(2.*dr(
     & 0))
            vvss = (u(i1,i2-1,i3,vc)-2.*u(i1,i2,i3,vc)+u(i1,i2+1,i3,vc)
     & )/(dr(1)**2)
            vvrt = (-(-u(i1-1,i2,i3-1,vc)+u(i1-1,i2,i3+1,vc))/(2.*dr(2)
     & )+(-u(i1+1,i2,i3-1,vc)+u(i1+1,i2,i3+1,vc))/(2.*dr(2)))/(2.*dr(
     & 0))
            vvst = (-(-u(i1,i2-1,i3-1,vc)+u(i1,i2-1,i3+1,vc))/(2.*dr(2)
     & )+(-u(i1,i2+1,i3-1,vc)+u(i1,i2+1,i3+1,vc))/(2.*dr(2)))/(2.*dr(
     & 1))
            vvtt = (u(i1,i2,i3-1,vc)-2.*u(i1,i2,i3,vc)+u(i1,i2,i3+1,vc)
     & )/(dr(2)**2)
             v0x = ajrx*vvr+ajsx*vvs+ajtx*vvt
             v0y = ajry*vvr+ajsy*vvs+ajty*vvt
             t1 = ajrx**2
             t6 = ajsx**2
             t14 = ajtx**2
             v0xx = t1*vvrr+2*ajrx*ajsx*vvrs+t6*vvss+2*ajrx*ajtx*vvrt+
     & 2*ajsx*ajtx*vvst+t14*vvtt+ajrxx*vvr+ajsxx*vvs+ajtxx*vvt
             t1 = ajry**2
             t6 = ajsy**2
             t14 = ajty**2
             v0yy = t1*vvrr+2*ajry*ajsy*vvrs+t6*vvss+2*ajry*ajty*vvrt+
     & 2*ajsy*ajty*vvst+t14*vvtt+ajryy*vvr+ajsyy*vvs+ajtyy*vvt
           ! Evaluate the spatial derivatives of p:
            pp = u(i1,i2,i3,pc)
            ppr = (-u(i1-1,i2,i3,pc)+u(i1+1,i2,i3,pc))/(2.*dr(0))
            pps = (-u(i1,i2-1,i3,pc)+u(i1,i2+1,i3,pc))/(2.*dr(1))
            ppt = (-u(i1,i2,i3-1,pc)+u(i1,i2,i3+1,pc))/(2.*dr(2))
             p0x = ajrx*ppr+ajsx*pps+ajtx*ppt
             p0y = ajry*ppr+ajsy*pps+ajty*ppt
             u0z = ajrz*uur+ajsz*uus+ajtz*uut
             v0z = ajrz*vvr+ajsz*vvs+ajtz*vvt
             p0z = ajrz*ppr+ajsz*pps+ajtz*ppt
             t1 = ajrz**2
             t6 = ajsz**2
             t14 = ajtz**2
             u0zz = t1*uurr+2*ajrz*ajsz*uurs+t6*uuss+2*ajrz*ajtz*uurt+
     & 2*ajsz*ajtz*uust+t14*uutt+ajrzz*uur+ajszz*uus+ajtzz*uut
             t1 = ajrz**2
             t6 = ajsz**2
             t14 = ajtz**2
             v0zz = t1*vvrr+2*ajrz*ajsz*vvrs+t6*vvss+2*ajrz*ajtz*vvrt+
     & 2*ajsz*ajtz*vvst+t14*vvtt+ajrzz*vvr+ajszz*vvs+ajtzz*vvt
            ww = u(i1,i2,i3,wc)
            wwr = (-u(i1-1,i2,i3,wc)+u(i1+1,i2,i3,wc))/(2.*dr(0))
            wws = (-u(i1,i2-1,i3,wc)+u(i1,i2+1,i3,wc))/(2.*dr(1))
            wwt = (-u(i1,i2,i3-1,wc)+u(i1,i2,i3+1,wc))/(2.*dr(2))
            wwrr = (u(i1-1,i2,i3,wc)-2.*u(i1,i2,i3,wc)+u(i1+1,i2,i3,wc)
     & )/(dr(0)**2)
            wwrs = (-(-u(i1-1,i2-1,i3,wc)+u(i1-1,i2+1,i3,wc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,wc)+u(i1+1,i2+1,i3,wc))/(2.*dr(1)))/(2.*dr(
     & 0))
            wwss = (u(i1,i2-1,i3,wc)-2.*u(i1,i2,i3,wc)+u(i1,i2+1,i3,wc)
     & )/(dr(1)**2)
            wwrt = (-(-u(i1-1,i2,i3-1,wc)+u(i1-1,i2,i3+1,wc))/(2.*dr(2)
     & )+(-u(i1+1,i2,i3-1,wc)+u(i1+1,i2,i3+1,wc))/(2.*dr(2)))/(2.*dr(
     & 0))
            wwst = (-(-u(i1,i2-1,i3-1,wc)+u(i1,i2-1,i3+1,wc))/(2.*dr(2)
     & )+(-u(i1,i2+1,i3-1,wc)+u(i1,i2+1,i3+1,wc))/(2.*dr(2)))/(2.*dr(
     & 1))
            wwtt = (u(i1,i2,i3-1,wc)-2.*u(i1,i2,i3,wc)+u(i1,i2,i3+1,wc)
     & )/(dr(2)**2)
             w0x = ajrx*wwr+ajsx*wws+ajtx*wwt
             w0y = ajry*wwr+ajsy*wws+ajty*wwt
             w0z = ajrz*wwr+ajsz*wws+ajtz*wwt
             t1 = ajrx**2
             t6 = ajsx**2
             t14 = ajtx**2
             w0xx = t1*wwrr+2*ajrx*ajsx*wwrs+t6*wwss+2*ajrx*ajtx*wwrt+
     & 2*ajsx*ajtx*wwst+t14*wwtt+ajrxx*wwr+ajsxx*wws+ajtxx*wwt
             t1 = ajry**2
             t6 = ajsy**2
             t14 = ajty**2
             w0yy = t1*wwrr+2*ajry*ajsy*wwrs+t6*wwss+2*ajry*ajty*wwrt+
     & 2*ajsy*ajty*wwst+t14*wwtt+ajryy*wwr+ajsyy*wws+ajtyy*wwt
             t1 = ajrz**2
             t6 = ajsz**2
             t14 = ajtz**2
             w0zz = t1*wwrr+2*ajrz*ajsz*wwrs+t6*wwss+2*ajrz*ajtz*wwrt+
     & 2*ajsz*ajtz*wwst+t14*wwtt+ajrzz*wwr+ajszz*wws+ajtzz*wwt
          if( evalLinearizedDerivatives.eq.1 )then
             uul = ul(i1,i2,i3,uc)
             uulr = (-ul(i1-1,i2,i3,uc)+ul(i1+1,i2,i3,uc))/(2.*dr(0))
             uuls = (-ul(i1,i2-1,i3,uc)+ul(i1,i2+1,i3,uc))/(2.*dr(1))
             uult = (-ul(i1,i2,i3-1,uc)+ul(i1,i2,i3+1,uc))/(2.*dr(2))
              ulx = ajrx*uulr+ajsx*uuls+ajtx*uult
              uly = ajry*uulr+ajsy*uuls+ajty*uult
              ulz = ajrz*uulr+ajsz*uuls+ajtz*uult
             vvl = ul(i1,i2,i3,vc)
             vvlr = (-ul(i1-1,i2,i3,vc)+ul(i1+1,i2,i3,vc))/(2.*dr(0))
             vvls = (-ul(i1,i2-1,i3,vc)+ul(i1,i2+1,i3,vc))/(2.*dr(1))
             vvlt = (-ul(i1,i2,i3-1,vc)+ul(i1,i2,i3+1,vc))/(2.*dr(2))
              vlx = ajrx*vvlr+ajsx*vvls+ajtx*vvlt
              vly = ajry*vvlr+ajsy*vvls+ajty*vvlt
              vlz = ajrz*vvlr+ajsz*vvls+ajtz*vvlt
             wwl = ul(i1,i2,i3,wc)
             wwlr = (-ul(i1-1,i2,i3,wc)+ul(i1+1,i2,i3,wc))/(2.*dr(0))
             wwls = (-ul(i1,i2-1,i3,wc)+ul(i1,i2+1,i3,wc))/(2.*dr(1))
             wwlt = (-ul(i1,i2,i3-1,wc)+ul(i1,i2,i3+1,wc))/(2.*dr(2))
              wlx = ajrx*wwlr+ajsx*wwls+ajtx*wwlt
              wly = ajry*wwlr+ajsy*wwls+ajty*wwlt
              wlz = ajrz*wwlr+ajsz*wwls+ajtz*wwlt
          end if
          if( pdeModel.eq.BoussinesqModel )then
           ! Evaluate the spatial derivatives of q:
            qq = u(i1,i2,i3,qc)
            qqr = (-u(i1-1,i2,i3,qc)+u(i1+1,i2,i3,qc))/(2.*dr(0))
            qqs = (-u(i1,i2-1,i3,qc)+u(i1,i2+1,i3,qc))/(2.*dr(1))
            qqt = (-u(i1,i2,i3-1,qc)+u(i1,i2,i3+1,qc))/(2.*dr(2))
            qqrr = (u(i1-1,i2,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1+1,i2,i3,qc)
     & )/(dr(0)**2)
            qqrs = (-(-u(i1-1,i2-1,i3,qc)+u(i1-1,i2+1,i3,qc))/(2.*dr(1)
     & )+(-u(i1+1,i2-1,i3,qc)+u(i1+1,i2+1,i3,qc))/(2.*dr(1)))/(2.*dr(
     & 0))
            qqss = (u(i1,i2-1,i3,qc)-2.*u(i1,i2,i3,qc)+u(i1,i2+1,i3,qc)
     & )/(dr(1)**2)
            qqrt = (-(-u(i1-1,i2,i3-1,qc)+u(i1-1,i2,i3+1,qc))/(2.*dr(2)
     & )+(-u(i1+1,i2,i3-1,qc)+u(i1+1,i2,i3+1,qc))/(2.*dr(2)))/(2.*dr(
     & 0))
            qqst = (-(-u(i1,i2-1,i3-1,qc)+u(i1,i2-1,i3+1,qc))/(2.*dr(2)
     & )+(-u(i1,i2+1,i3-1,qc)+u(i1,i2+1,i3+1,qc))/(2.*dr(2)))/(2.*dr(
     & 1))
            qqtt = (u(i1,i2,i3-1,qc)-2.*u(i1,i2,i3,qc)+u(i1,i2,i3+1,qc)
     & )/(dr(2)**2)
             q0x = ajrx*qqr+ajsx*qqs+ajtx*qqt
             q0y = ajry*qqr+ajsy*qqs+ajty*qqt
             t1 = ajrx**2
             t6 = ajsx**2
             t14 = ajtx**2
             q0xx = t1*qqrr+2*ajrx*ajsx*qqrs+t6*qqss+2*ajrx*ajtx*qqrt+
     & 2*ajsx*ajtx*qqst+t14*qqtt+ajrxx*qqr+ajsxx*qqs+ajtxx*qqt
             t1 = ajry**2
             t6 = ajsy**2
             t14 = ajty**2
             q0yy = t1*qqrr+2*ajry*ajsy*qqrs+t6*qqss+2*ajry*ajty*qqrt+
     & 2*ajsy*ajty*qqst+t14*qqtt+ajryy*qqr+ajsyy*qqs+ajtyy*qqt
              q0z = ajrz*qqr+ajsz*qqs+ajtz*qqt
              t1 = ajrz**2
              t6 = ajsz**2
              t14 = ajtz**2
              q0zz = t1*qqrr+2*ajrz*ajsz*qqrs+t6*qqss+2*ajrz*ajtz*qqrt+
     & 2*ajsz*ajtz*qqst+t14*qqtt+ajrzz*qqr+ajszz*qqs+ajtzz*qqt
          end if
          if( gridIsMoving.ne.0 )then
            ugv = uu - gv(i1,i2,i3,0)
            vgv = vv - gv(i1,i2,i3,1)
            wgv = ww - gv(i1,i3,i3,2)
          else
            ugv = uu
            vgv = vv
            wgv = ww
          end if
          ! eval the nonlinear coeff. of artificial dissipation: 
            adCoeff = ad21 + cd22*( abs(u0x)+abs(u0y)+abs(u0z) + abs(
     & v0x)+abs(v0y)+abs(v0z) + abs(w0x)+abs(w0y)+abs(w0z) )
           ! ---- 3D -----
          if( evalRightHandSide.eq.1 )then
           if( gridIsImplicit.eq.0 )then
             ! explicit
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y -wgv*u0z - p0x+ nu*(
     & u0xx+u0yy+u0zz) + adCoeff*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(
     & i1,i2,i3-1,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)+u(i1,i2,i3+1,
     & uc)-6.*u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y -wgv*v0z - p0y+ nu*(
     & v0xx+v0yy+v0zz) + adCoeff*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(
     & i1,i2,i3-1,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)+u(i1,i2,i3+1,
     & vc)-6.*u(i1,i2,i3,vc))
             fe(i1,i2,i3,wc) = -ugv*w0x -vgv*w0y -wgv*w0z - p0z+ nu*(
     & w0xx+w0yy+w0zz) + adCoeff*(u(i1-1,i2,i3,wc)+u(i1,i2-1,i3,wc)+u(
     & i1,i2,i3-1,wc)+u(i1+1,i2,i3,wc)+u(i1,i2+1,i3,wc)+u(i1,i2,i3+1,
     & wc)-6.*u(i1,i2,i3,wc))
             if( pdeModel.eq.BoussinesqModel )then
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
              fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) -thermalExpansivity*
     & gravity(2)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y -wgv*q0z + 
     & adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1,i2,i3-1,
     & qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)+u(i1,i2,i3+1,qc)-6.*u(i1,
     & i2,i3,qc))
              if( materialFormat.eq.constantMaterialProperties )then
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + kThermal*(q0xx+
     & q0yy+q0zz)
              else
               ! -- variable material properties : 
               ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                ! ---------- 3D -----------
                ! Get coefficients at nearby points: 
                if( materialFormat.eq.constantMaterialProperties )then
                  ! const material properties 
                  stop 11199
                else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                  ! piecewise constant material properties
                  scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                  Kzzm=thermalKpc(i1  ,i2  ,i3-1)
                  Kzmz=thermalKpc(i1  ,i2-1,i3  )
                  Kmzz=thermalKpc(i1-1,i2  ,i3  )
                  Kzzz=thermalKpc(i1  ,i2  ,i3  )
                  Kpzz=thermalKpc(i1+1,i2  ,i3  )
                  Kzpz=thermalKpc(i1  ,i2+1,i3  )
                  Kzzp=thermalKpc(i1  ,i2  ,i3+1)
                else if( materialFormat.eq.variableMaterialProperties )
     & then
                  ! variable material properties
                  scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                  Kzzm=thermalKv(i1  ,i2  ,i3-1)
                  Kzmz=thermalKv(i1  ,i2-1,i3  )
                  Kmzz=thermalKv(i1-1,i2  ,i3  )
                  Kzzz=thermalKv(i1  ,i2  ,i3  )
                  Kpzz=thermalKv(i1+1,i2  ,i3  )
                  Kzpz=thermalKv(i1  ,i2+1,i3  )
                  Kzzp=thermalKv(i1  ,i2  ,i3+1)
                end if
                !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
                 ! evaluate the jacobian at nearby points:
                 ajzzm = (1./((rx(i1,i2,i3-1)*sy(i1,i2,i3-1)-ry(i1,i2,
     & i3-1)*sx(i1,i2,i3-1))*tz(i1,i2,i3-1)+(ry(i1,i2,i3-1)*sz(i1,i2,
     & i3-1)-rz(i1,i2,i3-1)*sy(i1,i2,i3-1))*tx(i1,i2,i3-1)+(rz(i1,i2,
     & i3-1)*sx(i1,i2,i3-1)-rx(i1,i2,i3-1)*sz(i1,i2,i3-1))*ty(i1,i2,
     & i3-1)))
                 ajzmz = (1./((rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-
     & 1,i3)*sx(i1,i2-1,i3))*tz(i1,i2-1,i3)+(ry(i1,i2-1,i3)*sz(i1,i2-
     & 1,i3)-rz(i1,i2-1,i3)*sy(i1,i2-1,i3))*tx(i1,i2-1,i3)+(rz(i1,i2-
     & 1,i3)*sx(i1,i2-1,i3)-rx(i1,i2-1,i3)*sz(i1,i2-1,i3))*ty(i1,i2-1,
     & i3)))
                 ajmzz = (1./((rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,
     & i2,i3)*sx(i1-1,i2,i3))*tz(i1-1,i2,i3)+(ry(i1-1,i2,i3)*sz(i1-1,
     & i2,i3)-rz(i1-1,i2,i3)*sy(i1-1,i2,i3))*tx(i1-1,i2,i3)+(rz(i1-1,
     & i2,i3)*sx(i1-1,i2,i3)-rx(i1-1,i2,i3)*sz(i1-1,i2,i3))*ty(i1-1,
     & i2,i3)))
                 ajzzz = (1./((rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*
     & sx(i1,i2,i3))*tz(i1,i2,i3)+(ry(i1,i2,i3)*sz(i1,i2,i3)-rz(i1,i2,
     & i3)*sy(i1,i2,i3))*tx(i1,i2,i3)+(rz(i1,i2,i3)*sx(i1,i2,i3)-rx(
     & i1,i2,i3)*sz(i1,i2,i3))*ty(i1,i2,i3)))
                 ajpzz = (1./((rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,
     & i2,i3)*sx(i1+1,i2,i3))*tz(i1+1,i2,i3)+(ry(i1+1,i2,i3)*sz(i1+1,
     & i2,i3)-rz(i1+1,i2,i3)*sy(i1+1,i2,i3))*tx(i1+1,i2,i3)+(rz(i1+1,
     & i2,i3)*sx(i1+1,i2,i3)-rx(i1+1,i2,i3)*sz(i1+1,i2,i3))*ty(i1+1,
     & i2,i3)))
                 ajzpz = (1./((rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+
     & 1,i3)*sx(i1,i2+1,i3))*tz(i1,i2+1,i3)+(ry(i1,i2+1,i3)*sz(i1,i2+
     & 1,i3)-rz(i1,i2+1,i3)*sy(i1,i2+1,i3))*tx(i1,i2+1,i3)+(rz(i1,i2+
     & 1,i3)*sx(i1,i2+1,i3)-rx(i1,i2+1,i3)*sz(i1,i2+1,i3))*ty(i1,i2+1,
     & i3)))
                 ajzzp = (1./((rx(i1,i2,i3+1)*sy(i1,i2,i3+1)-ry(i1,i2,
     & i3+1)*sx(i1,i2,i3+1))*tz(i1,i2,i3+1)+(ry(i1,i2,i3+1)*sz(i1,i2,
     & i3+1)-rz(i1,i2,i3+1)*sy(i1,i2,i3+1))*tx(i1,i2,i3+1)+(rz(i1,i2,
     & i3+1)*sx(i1,i2,i3+1)-rx(i1,i2,i3+1)*sz(i1,i2,i3+1))*ty(i1,i2,
     & i3+1)))
                 ! ------------------------------------------------------------------------------------------------------------
                 ! au. Get coefficients au11ph, au11mh, au22ph, etc. for 
                 !          Dx( K*u.x ) + Dy( K*u.y ) + Dz( K*u.z )  
                  au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,
     & i3)*rz(i1-1,i2,i3) )
                  au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,
     & i3)*rz(i1  ,i2,i3) )
                  au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,
     & i3)*rz(i1+1,i2,i3) )
                  au11ph = .5*( au11zzz+au11pzz )
                  au11mh = .5*( au11zzz+au11mzz )
                  au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,
     & i3)*sz(i1,i2-1,i3) )
                  au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,
     & i3)*sz(i1,i2  ,i3) )
                  au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,
     & i3)*sz(i1,i2+1,i3) )
                  au22ph = .5*( au22zzz+au22zpz )
                  au22mh = .5*( au22zzz+au22zmz )
                  au33zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*tx(i1,i2,i3-
     & 1) + (Kzzm)*ty(i1,i2,i3-1)*ty(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-
     & 1)*tz(i1,i2,i3-1) )
                  au33zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*tx(i1,i2,i3  
     & ) + (Kzzz)*ty(i1,i2,i3  )*ty(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  
     & )*tz(i1,i2,i3  ) )
                  au33zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*tx(i1,i2,i3+
     & 1) + (Kzzp)*ty(i1,i2,i3+1)*ty(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+
     & 1)*tz(i1,i2,i3+1) )
                  au33ph = .5*( au33zzz+au33zzp )
                  au33mh = .5*( au33zzz+au33zzm )
                  au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,
     & i3)*sz(i1-1,i2,i3) )
                  au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,
     & i3)*sz(i1  ,i2,i3) )
                  au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,
     & i3)*sz(i1+1,i2,i3) )
                  au13mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*tx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*ty(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,
     & i3)*tz(i1-1,i2,i3) )
                  au13zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*tx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*ty(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,
     & i3)*tz(i1  ,i2,i3) )
                  au13pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*tx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*ty(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,
     & i3)*tz(i1+1,i2,i3) )
                  au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,
     & i3)*rz(i1,i2-1,i3) )
                  au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,
     & i3)*rz(i1,i2  ,i3) )
                  au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,
     & i3)*rz(i1,i2+1,i3) )
                  au23zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*tx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*ty(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,
     & i3)*tz(i1,i2-1,i3) )
                  au23zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*tx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*ty(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,
     & i3)*tz(i1,i2  ,i3) )
                  au23zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*tx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*ty(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,
     & i3)*tz(i1,i2+1,i3) )
                  au31zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*rx(i1,i2,i3-
     & 1) + (Kzzm)*ty(i1,i2,i3-1)*ry(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-
     & 1)*rz(i1,i2,i3-1) )
                  au31zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*rx(i1,i2,i3  
     & ) + (Kzzz)*ty(i1,i2,i3  )*ry(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  
     & )*rz(i1,i2,i3  ) )
                  au31zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*rx(i1,i2,i3+
     & 1) + (Kzzp)*ty(i1,i2,i3+1)*ry(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+
     & 1)*rz(i1,i2,i3+1) )
                  au32zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*sx(i1,i2,i3-
     & 1) + (Kzzm)*ty(i1,i2,i3-1)*sy(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-
     & 1)*sz(i1,i2,i3-1) )
                  au32zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*sx(i1,i2,i3  
     & ) + (Kzzz)*ty(i1,i2,i3  )*sy(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  
     & )*sz(i1,i2,i3  ) )
                  au32zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*sx(i1,i2,i3+
     & 1) + (Kzzp)*ty(i1,i2,i3+1)*sy(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+
     & 1)*sz(i1,i2,i3+1) )
                 ! scaling factors: 
                 dr0i = (scale)/(ajzzz*dr(0)**2)
                 dr1i = (scale)/(ajzzz*dr(1)**2)
                 dr2i = (scale)/(ajzzz*dr(2)**2)
                 dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
                 dr0dr2 = (scale)/(ajzzz*4.*dr(0)*dr(2))
                 dr1dr2 = (scale)/(ajzzz*4.*dr(1)*dr(2))
                  au11ph=au11ph*dr0i
                  au11mh=au11mh*dr0i
                  au22ph=au22ph*dr1i
                  au22mh=au22mh*dr1i
                  au33ph=au33ph*dr2i
                  au33mh=au33mh*dr2i
                  au12pzz=au12pzz*dr0dr1
                  au12mzz=au12mzz*dr0dr1
                  au13pzz=au13pzz*dr0dr2
                  au13mzz=au13mzz*dr0dr2
                  au21zpz=au21zpz*dr0dr1
                  au21zmz=au21zmz*dr0dr1
                  au23zpz=au23zpz*dr1dr2
                  au23zmz=au23zmz*dr1dr2
                  au31zzp=au31zzp*dr0dr2
                  au31zzm=au31zzm*dr0dr2
                  au32zzp=au32zzp*dr1dr2
                  au32zzm=au32zzm*dr1dr2
                 ! 3D, order 2:
                 dsgT = ( ( au23zmz+au32zzm)*u(i1  ,i2-1,i3-1,qc) +( 
     & au13mzz+au31zzm)*u(i1-1,i2  ,i3-1,qc) +( au33mh            )*u(
     & i1  ,i2  ,i3-1,qc) +(-au13pzz-au31zzm)*u(i1+1,i2  ,i3-1,qc) +(-
     & au23zpz-au32zzm)*u(i1  ,i2+1,i3-1,qc) +( au12mzz+au21zmz)*u(i1-
     & 1,i2-1,i3  ,qc) +( au22mh            )*u(i1  ,i2-1,i3  ,qc) +(-
     & au12pzz-au21zmz)*u(i1+1,i2-1,i3  ,qc) +( au11mh            )*u(
     & i1-1,i2  ,i3  ,qc) +(-au11ph-au11mh -au22ph -au22mh -au33ph -
     & au33mh)*u(i1  ,i2  ,i3  ,qc) +( au11ph            )*u(i1+1,i2  
     & ,i3  ,qc) +(-au12mzz-au21zpz)*u(i1-1,i2+1,i3  ,qc) +( au22ph   
     &          )*u(i1  ,i2+1,i3  ,qc) +( au12pzz+au21zpz)*u(i1+1,i2+
     & 1,i3  ,qc) +(-au23zmz-au32zzp)*u(i1  ,i2-1,i3+1,qc) +(-au13mzz-
     & au31zzp)*u(i1-1,i2  ,i3+1,qc) +( au33ph            )*u(i1  ,i2 
     &  ,i3+1,qc) +( au13pzz+au31zzp)*u(i1+1,i2  ,i3+1,qc) +( au23zpz+
     & au32zzp)*u(i1  ,i2+1,i3+1,qc) )
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
              endif
             end if
           else
             ! eval the nonlinear coeff. of artificial dissipation for the linearized solution:
               adCoeffl = ad21 + cd22*( abs(ulx)+abs(uly)+abs(ulz) + 
     & abs(vlx)+abs(vly)+abs(vlz) + abs(wlx)+abs(wly)+abs(wlz) )
             ! implicit method -- compute explicit part
             fe(i1,i2,i3,uc) = -ugv*u0x -vgv*u0y -wgv*u0z - p0x + (
     & adCoeff-adCoeffl)*(u(i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1,i2,
     & i3-1,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,uc)+u(i1,i2,i3+1,uc)-6.*
     & u(i1,i2,i3,uc))
             fe(i1,i2,i3,vc) = -ugv*v0x -vgv*v0y -wgv*v0z - p0y + (
     & adCoeff-adCoeffl)*(u(i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1,i2,
     & i3-1,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,vc)+u(i1,i2,i3+1,vc)-6.*
     & u(i1,i2,i3,vc))
             fe(i1,i2,i3,wc) = -ugv*w0x -vgv*w0y -wgv*w0z - p0z + (
     & adCoeff-adCoeffl)*(u(i1-1,i2,i3,wc)+u(i1,i2-1,i3,wc)+u(i1,i2,
     & i3-1,wc)+u(i1+1,i2,i3,wc)+u(i1,i2+1,i3,wc)+u(i1,i2,i3+1,wc)-6.*
     & u(i1,i2,i3,wc))
             if( nonlinearTermsAreImplicit.eq.1 )then
               ! include linearized terms u0*ulx + ul*u0x + ...
               if( gridIsMoving.ne.0 )then
                ugvl = uul - gvl(i1,i2,i3,0)
                vgvl = vvl - gvl(i1,i2,i3,1)
                wgvl = wwl - gvl(i1,i3,i3,2)
               else
                ugvl = uul
                vgvl = vvl
                wgvl = wwl
               end if
               ! ulterm = uul*u0x + vvl*u0y + bImp*(uu*ulx +  vv*uly)
               ulterm = ugvl*u0x + vgvl*u0y + wgvl*u0z + bImp*(uu*ulx +
     &  vv*uly + ww*ulz)
               vlterm = ugvl*v0x + vgvl*v0y + wgvl*v0z + bImp*(uu*vlx +
     &  vv*vly + ww*vlz)
               wlterm = ugvl*w0x + vgvl*w0y + wgvl*w0z + bImp*(uu*wlx +
     &  vv*wly + ww*wlz)
               fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) + ulterm
               fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) + vlterm
               fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) + wlterm
             end if
             if( implicitOption.eq.computeImplicitTermsSeparately )then
               ! implicit method -- compute implicit part 
               fi(i1,i2,i3,uc) = nuImp*(u0xx+u0yy+u0zz) + adCoeffl*(u(
     & i1-1,i2,i3,uc)+u(i1,i2-1,i3,uc)+u(i1,i2,i3-1,uc)+u(i1+1,i2,i3,
     & uc)+u(i1,i2+1,i3,uc)+u(i1,i2,i3+1,uc)-6.*u(i1,i2,i3,uc))
               fi(i1,i2,i3,vc) = nuImp*(v0xx+v0yy+v0zz) + adCoeffl*(u(
     & i1-1,i2,i3,vc)+u(i1,i2-1,i3,vc)+u(i1,i2,i3-1,vc)+u(i1+1,i2,i3,
     & vc)+u(i1,i2+1,i3,vc)+u(i1,i2,i3+1,vc)-6.*u(i1,i2,i3,vc))
               fi(i1,i2,i3,wc) = nuImp*(w0xx+w0yy+w0zz) + adCoeffl*(u(
     & i1-1,i2,i3,wc)+u(i1,i2-1,i3,wc)+u(i1,i2,i3-1,wc)+u(i1+1,i2,i3,
     & wc)+u(i1,i2+1,i3,wc)+u(i1,i2,i3+1,wc)-6.*u(i1,i2,i3,wc))
               if( nonlinearTermsAreImplicit.eq.1 )then
                 ! include linearized terms u0*ulx + ul*u0x 
                 fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) - aImp*( ulterm )
                 fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) - aImp*( vlterm )
                 fi(i1,i2,i3,wc) = fi(i1,i2,i3,wc) - aImp*( wlterm )
               end if
             end if
             ! add Boussinesq terms 
             if( pdeModel.eq.BoussinesqModel )then
              fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -(1.-tImp)*
     & thermalExpansivity*gravity(0)*qq
              fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -(1.-tImp)*
     & thermalExpansivity*gravity(1)*qq
              fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) -(1.-tImp)*
     & thermalExpansivity*gravity(2)*qq
              fe(i1,i2,i3,qc) = -ugv*q0x -vgv*q0y -wgv*q0z
              if( nonlinearTermsAreImplicit.eq.1 )then
                 qql = ul(i1,i2,i3,qc)
                 qqlr = (-ul(i1-1,i2,i3,qc)+ul(i1+1,i2,i3,qc))/(2.*dr(
     & 0))
                 qqls = (-ul(i1,i2-1,i3,qc)+ul(i1,i2+1,i3,qc))/(2.*dr(
     & 1))
                 qqlt = (-ul(i1,i2,i3-1,qc)+ul(i1,i2,i3+1,qc))/(2.*dr(
     & 2))
                  qlx = ajrx*qqlr+ajsx*qqls+ajtx*qqlt
                  qly = ajry*qqlr+ajsy*qqls+ajty*qqlt
                  qlz = ajrz*qqlr+ajsz*qqls+ajtz*qqlt
                qlterm = ugvl*q0x + vgvl*q0y + wgvl*q0z + bImp*(uu*qlx 
     & + vv*qly+ ww*qlz)
                fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + qlterm
              end if
              if( implicitOption.eq.computeImplicitTermsSeparately )
     & then
               ! implicit method -- compute implicit part 
               fi(i1,i2,i3,uc) = fi(i1,i2,i3,uc) -tImp*
     & thermalExpansivity*gravity(0)*qq
               fi(i1,i2,i3,vc) = fi(i1,i2,i3,vc) -tImp*
     & thermalExpansivity*gravity(1)*qq
               fi(i1,i2,i3,wc) = fi(i1,i2,i3,wc) -tImp*
     & thermalExpansivity*gravity(2)*qq
               if( materialFormat.eq.constantMaterialProperties )then
                 fi(i1,i2,i3,qc) = kThermal*(q0xx+q0yy+q0zz) + 
     & adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1,i2,i3-1,
     & qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)+u(i1,i2,i3+1,qc)-6.*u(i1,
     & i2,i3,qc))
               else
                ! -- variable material properties : 
                ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
                 ! ---------- 3D -----------
                 ! Get coefficients at nearby points: 
                 if( materialFormat.eq.constantMaterialProperties )then
                   ! const material properties 
                   stop 11199
                 else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                   ! piecewise constant material properties
                   scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                   Kzzm=thermalKpc(i1  ,i2  ,i3-1)
                   Kzmz=thermalKpc(i1  ,i2-1,i3  )
                   Kmzz=thermalKpc(i1-1,i2  ,i3  )
                   Kzzz=thermalKpc(i1  ,i2  ,i3  )
                   Kpzz=thermalKpc(i1+1,i2  ,i3  )
                   Kzpz=thermalKpc(i1  ,i2+1,i3  )
                   Kzzp=thermalKpc(i1  ,i2  ,i3+1)
                 else if( materialFormat.eq.variableMaterialProperties 
     & )then
                   ! variable material properties
                   scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                   Kzzm=thermalKv(i1  ,i2  ,i3-1)
                   Kzmz=thermalKv(i1  ,i2-1,i3  )
                   Kmzz=thermalKv(i1-1,i2  ,i3  )
                   Kzzz=thermalKv(i1  ,i2  ,i3  )
                   Kpzz=thermalKv(i1+1,i2  ,i3  )
                   Kzpz=thermalKv(i1  ,i2+1,i3  )
                   Kzzp=thermalKv(i1  ,i2  ,i3+1)
                 end if
                 !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
                  ! evaluate the jacobian at nearby points:
                  ajzzm = (1./((rx(i1,i2,i3-1)*sy(i1,i2,i3-1)-ry(i1,i2,
     & i3-1)*sx(i1,i2,i3-1))*tz(i1,i2,i3-1)+(ry(i1,i2,i3-1)*sz(i1,i2,
     & i3-1)-rz(i1,i2,i3-1)*sy(i1,i2,i3-1))*tx(i1,i2,i3-1)+(rz(i1,i2,
     & i3-1)*sx(i1,i2,i3-1)-rx(i1,i2,i3-1)*sz(i1,i2,i3-1))*ty(i1,i2,
     & i3-1)))
                  ajzmz = (1./((rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-
     & 1,i3)*sx(i1,i2-1,i3))*tz(i1,i2-1,i3)+(ry(i1,i2-1,i3)*sz(i1,i2-
     & 1,i3)-rz(i1,i2-1,i3)*sy(i1,i2-1,i3))*tx(i1,i2-1,i3)+(rz(i1,i2-
     & 1,i3)*sx(i1,i2-1,i3)-rx(i1,i2-1,i3)*sz(i1,i2-1,i3))*ty(i1,i2-1,
     & i3)))
                  ajmzz = (1./((rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,
     & i2,i3)*sx(i1-1,i2,i3))*tz(i1-1,i2,i3)+(ry(i1-1,i2,i3)*sz(i1-1,
     & i2,i3)-rz(i1-1,i2,i3)*sy(i1-1,i2,i3))*tx(i1-1,i2,i3)+(rz(i1-1,
     & i2,i3)*sx(i1-1,i2,i3)-rx(i1-1,i2,i3)*sz(i1-1,i2,i3))*ty(i1-1,
     & i2,i3)))
                  ajzzz = (1./((rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*
     & sx(i1,i2,i3))*tz(i1,i2,i3)+(ry(i1,i2,i3)*sz(i1,i2,i3)-rz(i1,i2,
     & i3)*sy(i1,i2,i3))*tx(i1,i2,i3)+(rz(i1,i2,i3)*sx(i1,i2,i3)-rx(
     & i1,i2,i3)*sz(i1,i2,i3))*ty(i1,i2,i3)))
                  ajpzz = (1./((rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,
     & i2,i3)*sx(i1+1,i2,i3))*tz(i1+1,i2,i3)+(ry(i1+1,i2,i3)*sz(i1+1,
     & i2,i3)-rz(i1+1,i2,i3)*sy(i1+1,i2,i3))*tx(i1+1,i2,i3)+(rz(i1+1,
     & i2,i3)*sx(i1+1,i2,i3)-rx(i1+1,i2,i3)*sz(i1+1,i2,i3))*ty(i1+1,
     & i2,i3)))
                  ajzpz = (1./((rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+
     & 1,i3)*sx(i1,i2+1,i3))*tz(i1,i2+1,i3)+(ry(i1,i2+1,i3)*sz(i1,i2+
     & 1,i3)-rz(i1,i2+1,i3)*sy(i1,i2+1,i3))*tx(i1,i2+1,i3)+(rz(i1,i2+
     & 1,i3)*sx(i1,i2+1,i3)-rx(i1,i2+1,i3)*sz(i1,i2+1,i3))*ty(i1,i2+1,
     & i3)))
                  ajzzp = (1./((rx(i1,i2,i3+1)*sy(i1,i2,i3+1)-ry(i1,i2,
     & i3+1)*sx(i1,i2,i3+1))*tz(i1,i2,i3+1)+(ry(i1,i2,i3+1)*sz(i1,i2,
     & i3+1)-rz(i1,i2,i3+1)*sy(i1,i2,i3+1))*tx(i1,i2,i3+1)+(rz(i1,i2,
     & i3+1)*sx(i1,i2,i3+1)-rx(i1,i2,i3+1)*sz(i1,i2,i3+1))*ty(i1,i2,
     & i3+1)))
                  ! ------------------------------------------------------------------------------------------------------------
                  ! au. Get coefficients au11ph, au11mh, au22ph, etc. for 
                  !          Dx( K*u.x ) + Dy( K*u.y ) + Dz( K*u.z )  
                   au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,
     & i3)*rz(i1-1,i2,i3) )
                   au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,
     & i3)*rz(i1  ,i2,i3) )
                   au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,
     & i3)*rz(i1+1,i2,i3) )
                   au11ph = .5*( au11zzz+au11pzz )
                   au11mh = .5*( au11zzz+au11mzz )
                   au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,
     & i3)*sz(i1,i2-1,i3) )
                   au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,
     & i3)*sz(i1,i2  ,i3) )
                   au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,
     & i3)*sz(i1,i2+1,i3) )
                   au22ph = .5*( au22zzz+au22zpz )
                   au22mh = .5*( au22zzz+au22zmz )
                   au33zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*tx(i1,i2,i3-
     & 1) + (Kzzm)*ty(i1,i2,i3-1)*ty(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-
     & 1)*tz(i1,i2,i3-1) )
                   au33zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*tx(i1,i2,i3 
     &  ) + (Kzzz)*ty(i1,i2,i3  )*ty(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3 
     &  )*tz(i1,i2,i3  ) )
                   au33zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*tx(i1,i2,i3+
     & 1) + (Kzzp)*ty(i1,i2,i3+1)*ty(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+
     & 1)*tz(i1,i2,i3+1) )
                   au33ph = .5*( au33zzz+au33zzp )
                   au33mh = .5*( au33zzz+au33zzm )
                   au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,
     & i3)*sz(i1-1,i2,i3) )
                   au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,
     & i3)*sz(i1  ,i2,i3) )
                   au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,
     & i3)*sz(i1+1,i2,i3) )
                   au13mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*tx(i1-1,i2,
     & i3) + (Kmzz)*ry(i1-1,i2,i3)*ty(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,
     & i3)*tz(i1-1,i2,i3) )
                   au13zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*tx(i1  ,i2,
     & i3) + (Kzzz)*ry(i1  ,i2,i3)*ty(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,
     & i3)*tz(i1  ,i2,i3) )
                   au13pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*tx(i1+1,i2,
     & i3) + (Kpzz)*ry(i1+1,i2,i3)*ty(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,
     & i3)*tz(i1+1,i2,i3) )
                   au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,
     & i3)*rz(i1,i2-1,i3) )
                   au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,
     & i3)*rz(i1,i2  ,i3) )
                   au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,
     & i3)*rz(i1,i2+1,i3) )
                   au23zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*tx(i1,i2-1,
     & i3) + (Kzmz)*sy(i1,i2-1,i3)*ty(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,
     & i3)*tz(i1,i2-1,i3) )
                   au23zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*tx(i1,i2  ,
     & i3) + (Kzzz)*sy(i1,i2  ,i3)*ty(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,
     & i3)*tz(i1,i2  ,i3) )
                   au23zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*tx(i1,i2+1,
     & i3) + (Kzpz)*sy(i1,i2+1,i3)*ty(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,
     & i3)*tz(i1,i2+1,i3) )
                   au31zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*rx(i1,i2,i3-
     & 1) + (Kzzm)*ty(i1,i2,i3-1)*ry(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-
     & 1)*rz(i1,i2,i3-1) )
                   au31zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*rx(i1,i2,i3 
     &  ) + (Kzzz)*ty(i1,i2,i3  )*ry(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3 
     &  )*rz(i1,i2,i3  ) )
                   au31zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*rx(i1,i2,i3+
     & 1) + (Kzzp)*ty(i1,i2,i3+1)*ry(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+
     & 1)*rz(i1,i2,i3+1) )
                   au32zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*sx(i1,i2,i3-
     & 1) + (Kzzm)*ty(i1,i2,i3-1)*sy(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-
     & 1)*sz(i1,i2,i3-1) )
                   au32zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*sx(i1,i2,i3 
     &  ) + (Kzzz)*ty(i1,i2,i3  )*sy(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3 
     &  )*sz(i1,i2,i3  ) )
                   au32zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*sx(i1,i2,i3+
     & 1) + (Kzzp)*ty(i1,i2,i3+1)*sy(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+
     & 1)*sz(i1,i2,i3+1) )
                  ! scaling factors: 
                  dr0i = (scale)/(ajzzz*dr(0)**2)
                  dr1i = (scale)/(ajzzz*dr(1)**2)
                  dr2i = (scale)/(ajzzz*dr(2)**2)
                  dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
                  dr0dr2 = (scale)/(ajzzz*4.*dr(0)*dr(2))
                  dr1dr2 = (scale)/(ajzzz*4.*dr(1)*dr(2))
                   au11ph=au11ph*dr0i
                   au11mh=au11mh*dr0i
                   au22ph=au22ph*dr1i
                   au22mh=au22mh*dr1i
                   au33ph=au33ph*dr2i
                   au33mh=au33mh*dr2i
                   au12pzz=au12pzz*dr0dr1
                   au12mzz=au12mzz*dr0dr1
                   au13pzz=au13pzz*dr0dr2
                   au13mzz=au13mzz*dr0dr2
                   au21zpz=au21zpz*dr0dr1
                   au21zmz=au21zmz*dr0dr1
                   au23zpz=au23zpz*dr1dr2
                   au23zmz=au23zmz*dr1dr2
                   au31zzp=au31zzp*dr0dr2
                   au31zzm=au31zzm*dr0dr2
                   au32zzp=au32zzp*dr1dr2
                   au32zzm=au32zzm*dr1dr2
                  ! 3D, order 2:
                  dsgT = ( ( au23zmz+au32zzm)*u(i1  ,i2-1,i3-1,qc) +( 
     & au13mzz+au31zzm)*u(i1-1,i2  ,i3-1,qc) +( au33mh            )*u(
     & i1  ,i2  ,i3-1,qc) +(-au13pzz-au31zzm)*u(i1+1,i2  ,i3-1,qc) +(-
     & au23zpz-au32zzm)*u(i1  ,i2+1,i3-1,qc) +( au12mzz+au21zmz)*u(i1-
     & 1,i2-1,i3  ,qc) +( au22mh            )*u(i1  ,i2-1,i3  ,qc) +(-
     & au12pzz-au21zmz)*u(i1+1,i2-1,i3  ,qc) +( au11mh            )*u(
     & i1-1,i2  ,i3  ,qc) +(-au11ph-au11mh -au22ph -au22mh -au33ph -
     & au33mh)*u(i1  ,i2  ,i3  ,qc) +( au11ph            )*u(i1+1,i2  
     & ,i3  ,qc) +(-au12mzz-au21zpz)*u(i1-1,i2+1,i3  ,qc) +( au22ph   
     &          )*u(i1  ,i2+1,i3  ,qc) +( au12pzz+au21zpz)*u(i1+1,i2+
     & 1,i3  ,qc) +(-au23zmz-au32zzp)*u(i1  ,i2-1,i3+1,qc) +(-au13mzz-
     & au31zzp)*u(i1-1,i2  ,i3+1,qc) +( au33ph            )*u(i1  ,i2 
     &  ,i3+1,qc) +( au13pzz+au31zzp)*u(i1+1,i2  ,i3+1,qc) +( au23zpz+
     & au32zzp)*u(i1  ,i2+1,i3+1,qc) )
                fi(i1,i2,i3,qc) = dsgT + adcBoussinesq*(u(i1-1,i2,i3,
     & qc)+u(i1,i2-1,i3,qc)+u(i1,i2,i3-1,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+
     & 1,i3,qc)+u(i1,i2,i3+1,qc)-6.*u(i1,i2,i3,qc))
               endif
               if( nonlinearTermsAreImplicit.eq.1 )then
                 fi(i1,i2,i3,qc) = fi(i1,i2,i3,qc) - aImp*( qlterm )
               end if
              end if
             end if
           end if
          end if
          if( evalResidual.eq.1 )then
            ! residual in 3D: (NOTE: currently ul is not available when evaluating the residual)
            fe(i1,i2,i3,uc) = fi(i1,i2,i3,uc) -ugv*u0x -vgv*u0y -wgv*
     & u0z - p0x + nu*(u0xx+u0yy+u0zz) + adCoeff*(u(i1-1,i2,i3,uc)+u(
     & i1,i2-1,i3,uc)+u(i1,i2,i3-1,uc)+u(i1+1,i2,i3,uc)+u(i1,i2+1,i3,
     & uc)+u(i1,i2,i3+1,uc)-6.*u(i1,i2,i3,uc))
            fe(i1,i2,i3,vc) = fi(i1,i2,i3,vc) -ugv*v0x -vgv*v0y -wgv*
     & v0z - p0y + nu*(v0xx+v0yy+v0zz) + adCoeff*(u(i1-1,i2,i3,vc)+u(
     & i1,i2-1,i3,vc)+u(i1,i2,i3-1,vc)+u(i1+1,i2,i3,vc)+u(i1,i2+1,i3,
     & vc)+u(i1,i2,i3+1,vc)-6.*u(i1,i2,i3,vc))
            fe(i1,i2,i3,wc) = fi(i1,i2,i3,wc) -ugv*w0x -vgv*w0y -wgv*
     & w0z - p0z + nu*(w0xx+w0yy+w0zz) + adCoeff*(u(i1-1,i2,i3,wc)+u(
     & i1,i2-1,i3,wc)+u(i1,i2,i3-1,wc)+u(i1+1,i2,i3,wc)+u(i1,i2+1,i3,
     & wc)+u(i1,i2,i3+1,wc)-6.*u(i1,i2,i3,wc))
            if( pdeModel.eq.BoussinesqModel )then
             fe(i1,i2,i3,uc) = fe(i1,i2,i3,uc) -thermalExpansivity*
     & gravity(0)*qq
             fe(i1,i2,i3,vc) = fe(i1,i2,i3,vc) -thermalExpansivity*
     & gravity(1)*qq
             fe(i1,i2,i3,wc) = fe(i1,i2,i3,wc) -thermalExpansivity*
     & gravity(2)*qq
             fe(i1,i2,i3,qc) = fi(i1,i2,i3,qc) -ugv*q0x -vgv*q0y -wgv*
     & q0z + adcBoussinesq*(u(i1-1,i2,i3,qc)+u(i1,i2-1,i3,qc)+u(i1,i2,
     & i3-1,qc)+u(i1+1,i2,i3,qc)+u(i1,i2+1,i3,qc)+u(i1,i2,i3+1,qc)-6.*
     & u(i1,i2,i3,qc))
             if( materialFormat.eq.constantMaterialProperties )then
               fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) +kThermal*(q0xx+q0yy+
     & q0zz)
             else
              ! -- variable material properties : 
              ! evaluate dsgT = div( K grad (T) )/(rho*Cp)
               ! ---------- 3D -----------
               ! Get coefficients at nearby points: 
               if( materialFormat.eq.constantMaterialProperties )then
                 ! const material properties 
                 stop 11199
               else if( 
     & materialFormat.eq.piecewiseConstantMaterialProperties )then
                 ! piecewise constant material properties
                 scale = (1.)/( rhopc(i1,i2,i3)*Cppc(i1,i2,i3) )
                 Kzzm=thermalKpc(i1  ,i2  ,i3-1)
                 Kzmz=thermalKpc(i1  ,i2-1,i3  )
                 Kmzz=thermalKpc(i1-1,i2  ,i3  )
                 Kzzz=thermalKpc(i1  ,i2  ,i3  )
                 Kpzz=thermalKpc(i1+1,i2  ,i3  )
                 Kzpz=thermalKpc(i1  ,i2+1,i3  )
                 Kzzp=thermalKpc(i1  ,i2  ,i3+1)
               else if( materialFormat.eq.variableMaterialProperties )
     & then
                 ! variable material properties
                 scale = (1.)/( rhov(i1,i2,i3)*Cpv(i1,i2,i3) )
                 Kzzm=thermalKv(i1  ,i2  ,i3-1)
                 Kzmz=thermalKv(i1  ,i2-1,i3  )
                 Kmzz=thermalKv(i1-1,i2  ,i3  )
                 Kzzz=thermalKv(i1  ,i2  ,i3  )
                 Kpzz=thermalKv(i1+1,i2  ,i3  )
                 Kzpz=thermalKv(i1  ,i2+1,i3  )
                 Kzzp=thermalKv(i1  ,i2  ,i3+1)
               end if
               !  ---- Dx( K*T.x ) + Dy( K*T.y ) + Dz( K*T.z ) ----
                ! evaluate the jacobian at nearby points:
                ajzzm = (1./((rx(i1,i2,i3-1)*sy(i1,i2,i3-1)-ry(i1,i2,
     & i3-1)*sx(i1,i2,i3-1))*tz(i1,i2,i3-1)+(ry(i1,i2,i3-1)*sz(i1,i2,
     & i3-1)-rz(i1,i2,i3-1)*sy(i1,i2,i3-1))*tx(i1,i2,i3-1)+(rz(i1,i2,
     & i3-1)*sx(i1,i2,i3-1)-rx(i1,i2,i3-1)*sz(i1,i2,i3-1))*ty(i1,i2,
     & i3-1)))
                ajzmz = (1./((rx(i1,i2-1,i3)*sy(i1,i2-1,i3)-ry(i1,i2-1,
     & i3)*sx(i1,i2-1,i3))*tz(i1,i2-1,i3)+(ry(i1,i2-1,i3)*sz(i1,i2-1,
     & i3)-rz(i1,i2-1,i3)*sy(i1,i2-1,i3))*tx(i1,i2-1,i3)+(rz(i1,i2-1,
     & i3)*sx(i1,i2-1,i3)-rx(i1,i2-1,i3)*sz(i1,i2-1,i3))*ty(i1,i2-1,
     & i3)))
                ajmzz = (1./((rx(i1-1,i2,i3)*sy(i1-1,i2,i3)-ry(i1-1,i2,
     & i3)*sx(i1-1,i2,i3))*tz(i1-1,i2,i3)+(ry(i1-1,i2,i3)*sz(i1-1,i2,
     & i3)-rz(i1-1,i2,i3)*sy(i1-1,i2,i3))*tx(i1-1,i2,i3)+(rz(i1-1,i2,
     & i3)*sx(i1-1,i2,i3)-rx(i1-1,i2,i3)*sz(i1-1,i2,i3))*ty(i1-1,i2,
     & i3)))
                ajzzz = (1./((rx(i1,i2,i3)*sy(i1,i2,i3)-ry(i1,i2,i3)*
     & sx(i1,i2,i3))*tz(i1,i2,i3)+(ry(i1,i2,i3)*sz(i1,i2,i3)-rz(i1,i2,
     & i3)*sy(i1,i2,i3))*tx(i1,i2,i3)+(rz(i1,i2,i3)*sx(i1,i2,i3)-rx(
     & i1,i2,i3)*sz(i1,i2,i3))*ty(i1,i2,i3)))
                ajpzz = (1./((rx(i1+1,i2,i3)*sy(i1+1,i2,i3)-ry(i1+1,i2,
     & i3)*sx(i1+1,i2,i3))*tz(i1+1,i2,i3)+(ry(i1+1,i2,i3)*sz(i1+1,i2,
     & i3)-rz(i1+1,i2,i3)*sy(i1+1,i2,i3))*tx(i1+1,i2,i3)+(rz(i1+1,i2,
     & i3)*sx(i1+1,i2,i3)-rx(i1+1,i2,i3)*sz(i1+1,i2,i3))*ty(i1+1,i2,
     & i3)))
                ajzpz = (1./((rx(i1,i2+1,i3)*sy(i1,i2+1,i3)-ry(i1,i2+1,
     & i3)*sx(i1,i2+1,i3))*tz(i1,i2+1,i3)+(ry(i1,i2+1,i3)*sz(i1,i2+1,
     & i3)-rz(i1,i2+1,i3)*sy(i1,i2+1,i3))*tx(i1,i2+1,i3)+(rz(i1,i2+1,
     & i3)*sx(i1,i2+1,i3)-rx(i1,i2+1,i3)*sz(i1,i2+1,i3))*ty(i1,i2+1,
     & i3)))
                ajzzp = (1./((rx(i1,i2,i3+1)*sy(i1,i2,i3+1)-ry(i1,i2,
     & i3+1)*sx(i1,i2,i3+1))*tz(i1,i2,i3+1)+(ry(i1,i2,i3+1)*sz(i1,i2,
     & i3+1)-rz(i1,i2,i3+1)*sy(i1,i2,i3+1))*tx(i1,i2,i3+1)+(rz(i1,i2,
     & i3+1)*sx(i1,i2,i3+1)-rx(i1,i2,i3+1)*sz(i1,i2,i3+1))*ty(i1,i2,
     & i3+1)))
                ! ------------------------------------------------------------------------------------------------------------
                ! au. Get coefficients au11ph, au11mh, au22ph, etc. for 
                !          Dx( K*u.x ) + Dy( K*u.y ) + Dz( K*u.z )  
                 au11mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*rx(i1-1,i2,i3)
     &  + (Kmzz)*ry(i1-1,i2,i3)*ry(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)
     & *rz(i1-1,i2,i3) )
                 au11zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*rx(i1  ,i2,i3)
     &  + (Kzzz)*ry(i1  ,i2,i3)*ry(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)
     & *rz(i1  ,i2,i3) )
                 au11pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*rx(i1+1,i2,i3)
     &  + (Kpzz)*ry(i1+1,i2,i3)*ry(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)
     & *rz(i1+1,i2,i3) )
                 au11ph = .5*( au11zzz+au11pzz )
                 au11mh = .5*( au11zzz+au11mzz )
                 au22zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*sx(i1,i2-1,i3)
     &  + (Kzmz)*sy(i1,i2-1,i3)*sy(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)
     & *sz(i1,i2-1,i3) )
                 au22zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*sx(i1,i2  ,i3)
     &  + (Kzzz)*sy(i1,i2  ,i3)*sy(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)
     & *sz(i1,i2  ,i3) )
                 au22zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*sx(i1,i2+1,i3)
     &  + (Kzpz)*sy(i1,i2+1,i3)*sy(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)
     & *sz(i1,i2+1,i3) )
                 au22ph = .5*( au22zzz+au22zpz )
                 au22mh = .5*( au22zzz+au22zmz )
                 au33zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*tx(i1,i2,i3-1)
     &  + (Kzzm)*ty(i1,i2,i3-1)*ty(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)
     & *tz(i1,i2,i3-1) )
                 au33zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*tx(i1,i2,i3  )
     &  + (Kzzz)*ty(i1,i2,i3  )*ty(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )
     & *tz(i1,i2,i3  ) )
                 au33zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*tx(i1,i2,i3+1)
     &  + (Kzzp)*ty(i1,i2,i3+1)*ty(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)
     & *tz(i1,i2,i3+1) )
                 au33ph = .5*( au33zzz+au33zzp )
                 au33mh = .5*( au33zzz+au33zzm )
                 au12mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*sx(i1-1,i2,i3)
     &  + (Kmzz)*ry(i1-1,i2,i3)*sy(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)
     & *sz(i1-1,i2,i3) )
                 au12zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*sx(i1  ,i2,i3)
     &  + (Kzzz)*ry(i1  ,i2,i3)*sy(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)
     & *sz(i1  ,i2,i3) )
                 au12pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*sx(i1+1,i2,i3)
     &  + (Kpzz)*ry(i1+1,i2,i3)*sy(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)
     & *sz(i1+1,i2,i3) )
                 au13mzz = ajmzz*( (Kmzz)*rx(i1-1,i2,i3)*tx(i1-1,i2,i3)
     &  + (Kmzz)*ry(i1-1,i2,i3)*ty(i1-1,i2,i3) + (Kmzz)*rz(i1-1,i2,i3)
     & *tz(i1-1,i2,i3) )
                 au13zzz = ajzzz*( (Kzzz)*rx(i1  ,i2,i3)*tx(i1  ,i2,i3)
     &  + (Kzzz)*ry(i1  ,i2,i3)*ty(i1  ,i2,i3) + (Kzzz)*rz(i1  ,i2,i3)
     & *tz(i1  ,i2,i3) )
                 au13pzz = ajpzz*( (Kpzz)*rx(i1+1,i2,i3)*tx(i1+1,i2,i3)
     &  + (Kpzz)*ry(i1+1,i2,i3)*ty(i1+1,i2,i3) + (Kpzz)*rz(i1+1,i2,i3)
     & *tz(i1+1,i2,i3) )
                 au21zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*rx(i1,i2-1,i3)
     &  + (Kzmz)*sy(i1,i2-1,i3)*ry(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)
     & *rz(i1,i2-1,i3) )
                 au21zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*rx(i1,i2  ,i3)
     &  + (Kzzz)*sy(i1,i2  ,i3)*ry(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)
     & *rz(i1,i2  ,i3) )
                 au21zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*rx(i1,i2+1,i3)
     &  + (Kzpz)*sy(i1,i2+1,i3)*ry(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)
     & *rz(i1,i2+1,i3) )
                 au23zmz = ajzmz*( (Kzmz)*sx(i1,i2-1,i3)*tx(i1,i2-1,i3)
     &  + (Kzmz)*sy(i1,i2-1,i3)*ty(i1,i2-1,i3) + (Kzmz)*sz(i1,i2-1,i3)
     & *tz(i1,i2-1,i3) )
                 au23zzz = ajzzz*( (Kzzz)*sx(i1,i2  ,i3)*tx(i1,i2  ,i3)
     &  + (Kzzz)*sy(i1,i2  ,i3)*ty(i1,i2  ,i3) + (Kzzz)*sz(i1,i2  ,i3)
     & *tz(i1,i2  ,i3) )
                 au23zpz = ajzpz*( (Kzpz)*sx(i1,i2+1,i3)*tx(i1,i2+1,i3)
     &  + (Kzpz)*sy(i1,i2+1,i3)*ty(i1,i2+1,i3) + (Kzpz)*sz(i1,i2+1,i3)
     & *tz(i1,i2+1,i3) )
                 au31zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*rx(i1,i2,i3-1)
     &  + (Kzzm)*ty(i1,i2,i3-1)*ry(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)
     & *rz(i1,i2,i3-1) )
                 au31zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*rx(i1,i2,i3  )
     &  + (Kzzz)*ty(i1,i2,i3  )*ry(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )
     & *rz(i1,i2,i3  ) )
                 au31zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*rx(i1,i2,i3+1)
     &  + (Kzzp)*ty(i1,i2,i3+1)*ry(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)
     & *rz(i1,i2,i3+1) )
                 au32zzm = ajzzm*( (Kzzm)*tx(i1,i2,i3-1)*sx(i1,i2,i3-1)
     &  + (Kzzm)*ty(i1,i2,i3-1)*sy(i1,i2,i3-1) + (Kzzm)*tz(i1,i2,i3-1)
     & *sz(i1,i2,i3-1) )
                 au32zzz = ajzzz*( (Kzzz)*tx(i1,i2,i3  )*sx(i1,i2,i3  )
     &  + (Kzzz)*ty(i1,i2,i3  )*sy(i1,i2,i3  ) + (Kzzz)*tz(i1,i2,i3  )
     & *sz(i1,i2,i3  ) )
                 au32zzp = ajzzp*( (Kzzp)*tx(i1,i2,i3+1)*sx(i1,i2,i3+1)
     &  + (Kzzp)*ty(i1,i2,i3+1)*sy(i1,i2,i3+1) + (Kzzp)*tz(i1,i2,i3+1)
     & *sz(i1,i2,i3+1) )
                ! scaling factors: 
                dr0i = (scale)/(ajzzz*dr(0)**2)
                dr1i = (scale)/(ajzzz*dr(1)**2)
                dr2i = (scale)/(ajzzz*dr(2)**2)
                dr0dr1 = (scale)/(ajzzz*4.*dr(0)*dr(1))
                dr0dr2 = (scale)/(ajzzz*4.*dr(0)*dr(2))
                dr1dr2 = (scale)/(ajzzz*4.*dr(1)*dr(2))
                 au11ph=au11ph*dr0i
                 au11mh=au11mh*dr0i
                 au22ph=au22ph*dr1i
                 au22mh=au22mh*dr1i
                 au33ph=au33ph*dr2i
                 au33mh=au33mh*dr2i
                 au12pzz=au12pzz*dr0dr1
                 au12mzz=au12mzz*dr0dr1
                 au13pzz=au13pzz*dr0dr2
                 au13mzz=au13mzz*dr0dr2
                 au21zpz=au21zpz*dr0dr1
                 au21zmz=au21zmz*dr0dr1
                 au23zpz=au23zpz*dr1dr2
                 au23zmz=au23zmz*dr1dr2
                 au31zzp=au31zzp*dr0dr2
                 au31zzm=au31zzm*dr0dr2
                 au32zzp=au32zzp*dr1dr2
                 au32zzm=au32zzm*dr1dr2
                ! 3D, order 2:
                dsgT = ( ( au23zmz+au32zzm)*u(i1  ,i2-1,i3-1,qc) +( 
     & au13mzz+au31zzm)*u(i1-1,i2  ,i3-1,qc) +( au33mh            )*u(
     & i1  ,i2  ,i3-1,qc) +(-au13pzz-au31zzm)*u(i1+1,i2  ,i3-1,qc) +(-
     & au23zpz-au32zzm)*u(i1  ,i2+1,i3-1,qc) +( au12mzz+au21zmz)*u(i1-
     & 1,i2-1,i3  ,qc) +( au22mh            )*u(i1  ,i2-1,i3  ,qc) +(-
     & au12pzz-au21zmz)*u(i1+1,i2-1,i3  ,qc) +( au11mh            )*u(
     & i1-1,i2  ,i3  ,qc) +(-au11ph-au11mh -au22ph -au22mh -au33ph -
     & au33mh)*u(i1  ,i2  ,i3  ,qc) +( au11ph            )*u(i1+1,i2  
     & ,i3  ,qc) +(-au12mzz-au21zpz)*u(i1-1,i2+1,i3  ,qc) +( au22ph   
     &          )*u(i1  ,i2+1,i3  ,qc) +( au12pzz+au21zpz)*u(i1+1,i2+
     & 1,i3  ,qc) +(-au23zmz-au32zzp)*u(i1  ,i2-1,i3+1,qc) +(-au13mzz-
     & au31zzp)*u(i1-1,i2  ,i3+1,qc) +( au33ph            )*u(i1  ,i2 
     &  ,i3+1,qc) +( au13pzz+au31zzp)*u(i1+1,i2  ,i3+1,qc) +( au23zpz+
     & au32zzp)*u(i1  ,i2+1,i3+1,qc) )
              fe(i1,i2,i3,qc) = fe(i1,i2,i3,qc) + dsgT
             endif
            end if
          end if
          end do
          end do
          end do
         end if
      else
        if( orderOfAccuracy.ne.2 )then
        write(*,'("insImpINS: ERROR - not implemented for 
     & orderOfAccuracy=",i4)') orderOfAccuracy
        end if
        stop 9425
      end if
      call flush(6)
      return
      end
